<!DOCTYPE html>
<html>
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
table {border-spacing:0; border-collapse:collapse;}
table, td, th {border: 1px solid black;}
td, th {background: white; margin: 0; padding: 2px 0.5em 2px 0.5em}
td {border-width: 0 1px 0 0;}
th {border-width: 1px 1px 1px 0;}
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: courier,monospace; font-size: 10pt;}
th {background: #CCCCCC;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: 100%;}
table.s tr td {padding: 0 0.25em 0 0.25em;}
table.s tr td:first-child {text-align: right; font-weight: bold;}
table.s tr.notcovered td {background: #DDDDFF;}
table.s tr.nocodegen td {background: #FFFFEE;}
table.s tr.covered td {background: #CCFFCC;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum tr td {border-width: 1px;}
table.sum tr th {text-align:right;}
table.sum tr th:first-child {text-align:center;}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
</style>
</head>
<body>
<p>Coverage report for <strong>DECCiphers (D:\Projekte\DECGitMaster\Source\DECCiphers.pas)</strong>.</p>
<p> Generated at 29.10.2021 18:49:29 by <a href="http://code.google.com/p/delphi-code-coverage/" title="Code Coverage for Delphi 5+">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p> Statistics for D:\Projekte\DECGitMaster\Source\DECCiphers.pas </p>
<table  class="o"><tr><td>Number of lines covered</td><td>3260</td></tr><tr><td>Number of lines with code gen</td><td>3370</td></tr><tr><td>Line coverage</td><td>96%</td></tr></table>
<br /><br />
<table  class="s">
<tr class="nocodegen"><td>1</td><td><pre style="display:inline;">{*****************************************************************************</pre></td></tr>
<tr class="nocodegen"><td>2</td><td><pre style="display:inline;"> &nbsp;The DEC team (see file NOTICE.txt) licenses this file</pre></td></tr>
<tr class="nocodegen"><td>3</td><td><pre style="display:inline;"> &nbsp;to you under the Apache License, Version 2.0 (the</pre></td></tr>
<tr class="nocodegen"><td>4</td><td><pre style="display:inline;"> &nbsp;&quot;License&quot;); you may not use this file except in compliance</pre></td></tr>
<tr class="nocodegen"><td>5</td><td><pre style="display:inline;"> &nbsp;with the License. A copy of this licence is found in the root directory</pre></td></tr>
<tr class="nocodegen"><td>6</td><td><pre style="display:inline;"> &nbsp;of this project in the file LICENCE.txt or alternatively at</pre></td></tr>
<tr class="nocodegen"><td>7</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>8</td><td><pre style="display:inline;"> &nbsp; &nbsp;http://www.apache.org/licenses/LICENSE-2.0</pre></td></tr>
<tr class="nocodegen"><td>9</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>10</td><td><pre style="display:inline;"> &nbsp;Unless required by applicable law or agreed to in writing,</pre></td></tr>
<tr class="nocodegen"><td>11</td><td><pre style="display:inline;"> &nbsp;software distributed under the License is distributed on an</pre></td></tr>
<tr class="nocodegen"><td>12</td><td><pre style="display:inline;"> &nbsp;&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</pre></td></tr>
<tr class="nocodegen"><td>13</td><td><pre style="display:inline;"> &nbsp;KIND, either express or implied. &nbsp;See the License for the</pre></td></tr>
<tr class="nocodegen"><td>14</td><td><pre style="display:inline;"> &nbsp;specific language governing permissions and limitations</pre></td></tr>
<tr class="nocodegen"><td>15</td><td><pre style="display:inline;"> &nbsp;under the License.</pre></td></tr>
<tr class="nocodegen"><td>16</td><td><pre style="display:inline;">*****************************************************************************}</pre></td></tr>
<tr class="nocodegen"><td>17</td><td><pre style="display:inline;">unit DECCiphers;</pre></td></tr>
<tr class="nocodegen"><td>18</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>19</td><td><pre style="display:inline;">interface</pre></td></tr>
<tr class="nocodegen"><td>20</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>21</td><td><pre style="display:inline;">{$INCLUDE DECOptions.inc}</pre></td></tr>
<tr class="nocodegen"><td>22</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>23</td><td><pre style="display:inline;">uses</pre></td></tr>
<tr class="nocodegen"><td>24</td><td><pre style="display:inline;"> &nbsp;DECCipherBase, DECCipherFormats, DECUtil, DECTypes;</pre></td></tr>
<tr class="nocodegen"><td>25</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>26</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>27</td><td><pre style="display:inline;"> &nbsp;// Cipher Classes</pre></td></tr>
<tr class="nocodegen"><td>28</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>29</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>30</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Null cipher, doesn&apos;t encrypt, only copy</pre></td></tr>
<tr class="nocodegen"><td>31</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>32</td><td><pre style="display:inline;"> &nbsp;TCipher_Null &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>33</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>34</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A block based encryption algorithm with 32 to 448 bit key length</pre></td></tr>
<tr class="nocodegen"><td>35</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>36</td><td><pre style="display:inline;"> &nbsp;TCipher_Blowfish &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>37</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>38</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; AES Round 2 Final Candidate</pre></td></tr>
<tr class="nocodegen"><td>39</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>40</td><td><pre style="display:inline;"> &nbsp;TCipher_Twofish &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>41</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>42</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; International Data Encryption Algorithm, formerly patentet,</pre></td></tr>
<tr class="nocodegen"><td>43</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; now patent free. The algorithm is no longer to be really recommended due</pre></td></tr>
<tr class="nocodegen"><td>44</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; to some classes of weak keys and other successfull attacks.</pre></td></tr>
<tr class="nocodegen"><td>45</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>46</td><td><pre style="display:inline;"> &nbsp;TCipher_IDEA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>47</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>48</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Carlisle Adams and Stafford Tavares, 256 bit key length</pre></td></tr>
<tr class="nocodegen"><td>49</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>50</td><td><pre style="display:inline;"> &nbsp;TCipher_Cast256 &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>51</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>52</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; AES Round 2 Final Candidate</pre></td></tr>
<tr class="nocodegen"><td>53</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>54</td><td><pre style="display:inline;"> &nbsp;TCipher_Mars &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>55</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>56</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Streamcipher in as Block Cipher</pre></td></tr>
<tr class="nocodegen"><td>57</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>58</td><td><pre style="display:inline;"> &nbsp;TCipher_RC4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>59</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>60</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; AES Round 2 Final Candidate</pre></td></tr>
<tr class="nocodegen"><td>61</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>62</td><td><pre style="display:inline;"> &nbsp;TCipher_RC6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>63</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>64</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; AES Round 2 Final Candidate</pre></td></tr>
<tr class="nocodegen"><td>65</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>66</td><td><pre style="display:inline;"> &nbsp;TCipher_Rijndael &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>67</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>68</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; AES winner = TCipher_Rijndael</pre></td></tr>
<tr class="nocodegen"><td>69</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>70</td><td><pre style="display:inline;"> &nbsp;TCipher_AES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>71</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>72</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A block cipher invented by Joan Daemen and Vincent Rijmen. The design,</pre></td></tr>
<tr class="nocodegen"><td>73</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; published in 1997, is a forerunner to Rijndael, which has been adopted</pre></td></tr>
<tr class="nocodegen"><td>74</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; as the Advanced Encryption Standard. Square was introduced together with</pre></td></tr>
<tr class="nocodegen"><td>75</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; a new form of cryptanalysis discovered by Lars Knudsen, called the</pre></td></tr>
<tr class="nocodegen"><td>76</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; &quot;Square attack&quot;.</pre></td></tr>
<tr class="nocodegen"><td>77</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The structure of Square is a substitution-permutation network with eight</pre></td></tr>
<tr class="nocodegen"><td>78</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; rounds, operating on 128-bit blocks and using a 128-bit key.</pre></td></tr>
<tr class="nocodegen"><td>79</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>80</td><td><pre style="display:inline;"> &nbsp;/// &lt;remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>81</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; If possible use TCipher_AES instead</pre></td></tr>
<tr class="nocodegen"><td>82</td><td><pre style="display:inline;"> &nbsp;/// &lt;/remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>83</td><td><pre style="display:inline;"> &nbsp;TCipher_Square &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>84</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>85</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Stream Cipher in Blockmode (on UInt32), very fast</pre></td></tr>
<tr class="nocodegen"><td>86</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>87</td><td><pre style="display:inline;"> &nbsp;TCipher_SCOP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>88</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>89</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Stream Cipher in Blockmode (on UInt32), very fast.</pre></td></tr>
<tr class="nocodegen"><td>90</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Wrong old version from DEC 5.2. Use only for backwards compatibility!</pre></td></tr>
<tr class="nocodegen"><td>91</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>92</td><td><pre style="display:inline;"> &nbsp;TCipher_SCOP_DEC52 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>93</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>94</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Stream Cipher, eq. design from German ENIGMA Machine</pre></td></tr>
<tr class="nocodegen"><td>95</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>96</td><td><pre style="display:inline;"> &nbsp;TCipher_Sapphire &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>97</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>98</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Single DES &nbsp;8 byte Blocksize, &nbsp;8 byte Keysize, &nbsp;56 bits relevant.</pre></td></tr>
<tr class="nocodegen"><td>99</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Considered to be too weak nowadays. Included for compatibility reasons.</pre></td></tr>
<tr class="nocodegen"><td>100</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>101</td><td><pre style="display:inline;"> &nbsp;TCipher_1DES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>102</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>103</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Double DES &nbsp;8 byte Blocksize, 16 byte Keysize, 112 bits relevant</pre></td></tr>
<tr class="nocodegen"><td>104</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>105</td><td><pre style="display:inline;"> &nbsp;TCipher_2DES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>106</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>107</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Triple DES &nbsp;8 byte Blocksize, 24 byte Keysize, 168 bits relevant</pre></td></tr>
<tr class="nocodegen"><td>108</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>109</td><td><pre style="display:inline;"> &nbsp;TCipher_3DES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>110</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>111</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Triple DES 16 byte Blocksize, 16 byte Keysize, 112 bits relevant</pre></td></tr>
<tr class="nocodegen"><td>112</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>113</td><td><pre style="display:inline;"> &nbsp;TCipher_2DDES &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>114</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>115</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Triple DES 16 byte Blocksize, 24 byte Keysize, 168 bits relevant</pre></td></tr>
<tr class="nocodegen"><td>116</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>117</td><td><pre style="display:inline;"> &nbsp;TCipher_3DDES &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>118</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>119</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Triple DES 24 byte Blocksize, 24 byte Keysize, 168 bits relevant</pre></td></tr>
<tr class="nocodegen"><td>120</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>121</td><td><pre style="display:inline;"> &nbsp;TCipher_3TDES &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>122</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>123</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A 1994 developed block cipher using a 96 bit key. 3-Way, is vulnerable</pre></td></tr>
<tr class="nocodegen"><td>124</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; to related key cryptanalysis.</pre></td></tr>
<tr class="nocodegen"><td>125</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>126</td><td><pre style="display:inline;"> &nbsp;TCipher_3Way &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>127</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>128</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Carlisle Adams and Stafford Tavares, 128 bit key length</pre></td></tr>
<tr class="nocodegen"><td>129</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>130</td><td><pre style="display:inline;"> &nbsp;TCipher_Cast128 &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>131</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>132</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Russian Cipher</pre></td></tr>
<tr class="nocodegen"><td>133</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>134</td><td><pre style="display:inline;"> &nbsp;TCipher_Gost &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>135</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>136</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Alias/new name for Gost cipher</pre></td></tr>
<tr class="nocodegen"><td>137</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>138</td><td><pre style="display:inline;"> &nbsp;TCipher_Magma &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>139</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>140</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Misty1 is a block cipher developed 1995 by Mitsubishi. It is free only for</pre></td></tr>
<tr class="nocodegen"><td>141</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; academical and non-profit works in RFC 2994. it is otherwise patented.</pre></td></tr>
<tr class="nocodegen"><td>142</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; In 2015 it got broken via integral cryptoanalysis.</pre></td></tr>
<tr class="nocodegen"><td>143</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>144</td><td><pre style="display:inline;"> &nbsp;TCipher_Misty &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>145</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>146</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A 1996 block cipher with a key length of 120 bit. It can be broken with</pre></td></tr>
<tr class="nocodegen"><td>147</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; a relatively low number of ciphertext/plaintext queries.</pre></td></tr>
<tr class="nocodegen"><td>148</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>149</td><td><pre style="display:inline;"> &nbsp;TCipher_NewDES &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>150</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>151</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Camelia, a 128 bit block cipher.</pre></td></tr>
<tr class="nocodegen"><td>152</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Specification: https://info.isl.ntt.co.jp/crypt/eng/camellia/dl/01espec.pdf</pre></td></tr>
<tr class="nocodegen"><td>153</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>154</td><td><pre style="display:inline;"> &nbsp;TCipher_Q128 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>155</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>156</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Rivest Cipher 2, a 1987 developed cipher with a default keysize of 64 bit</pre></td></tr>
<tr class="nocodegen"><td>157</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>158</td><td><pre style="display:inline;"> &nbsp;TCipher_RC2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>159</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>160</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Rivest Cipher 5, a 1994 developed cipher with emphasis on speed and low</pre></td></tr>
<tr class="nocodegen"><td>161</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; size in order to make it efficient on embedded hardware as well. Key sizes</pre></td></tr>
<tr class="nocodegen"><td>162</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; of up to 2048 bits are possible but 128 bits are suggested. The algorithm</pre></td></tr>
<tr class="nocodegen"><td>163</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; was patented in the US up to 2015.</pre></td></tr>
<tr class="nocodegen"><td>164</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>165</td><td><pre style="display:inline;"> &nbsp;TCipher_RC5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>166</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>167</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; SAFER = Secure And Fast Encryption Routine</pre></td></tr>
<tr class="nocodegen"><td>168</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>169</td><td><pre style="display:inline;"> &nbsp;TCipher_SAFER &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>170</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>171</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A 1996 published block cipher with a key size of 128 bits. It was</pre></td></tr>
<tr class="nocodegen"><td>172</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; identified as one of the predecessors of Rijndael</pre></td></tr>
<tr class="nocodegen"><td>173</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>174</td><td><pre style="display:inline;"> &nbsp;TCipher_Shark &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>175</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>176</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A 1996 published block cipher with a key size of 128 bits. It was</pre></td></tr>
<tr class="nocodegen"><td>177</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; identified as one of the predecessors of Rijndael</pre></td></tr>
<tr class="nocodegen"><td>178</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Wrong old version from DEC 5.2. Use only for backwards compatibility!</pre></td></tr>
<tr class="nocodegen"><td>179</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>180</td><td><pre style="display:inline;"> &nbsp;TCipher_Shark_DEC52 &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>181</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>182</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A NSA developed and 1998 published block cipher with a key length of</pre></td></tr>
<tr class="nocodegen"><td>183</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; 80 bit. Soon after publication various weaknesses have been identified.</pre></td></tr>
<tr class="nocodegen"><td>184</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>185</td><td><pre style="display:inline;"> &nbsp;TCipher_Skipjack &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>186</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>187</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Tiny Encryption Algorithm</pre></td></tr>
<tr class="nocodegen"><td>188</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>189</td><td><pre style="display:inline;"> &nbsp;TCipher_TEA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>190</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>191</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Tiny Encryption Algorithm, 1st extended Version</pre></td></tr>
<tr class="nocodegen"><td>192</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>193</td><td><pre style="display:inline;"> &nbsp;TCipher_XTEA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>194</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>195</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; = TCipher_XTEA (kept for backward compatibility)</pre></td></tr>
<tr class="nocodegen"><td>196</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>197</td><td><pre style="display:inline;"> &nbsp;TCipher_TEAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>198</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>199</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Tiny Encryption Algorithm, 1st extended Version.</pre></td></tr>
<tr class="nocodegen"><td>200</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Wrong old version from DEC 5.2. Use only for backwards compatibility!</pre></td></tr>
<tr class="nocodegen"><td>201</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>202</td><td><pre style="display:inline;"> &nbsp;TCipher_XTEA_DEC52 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>203</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>204</td><td><pre style="display:inline;"> &nbsp;// Definitions needed for Skipjack algorithm</pre></td></tr>
<tr class="nocodegen"><td>205</td><td><pre style="display:inline;"> &nbsp;PSkipjackTab = ^TSkipjackTab;</pre></td></tr>
<tr class="nocodegen"><td>206</td><td><pre style="display:inline;"> &nbsp;TSkipjackTab = array[0..255] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>207</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>208</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>209</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; A do nothing cipher, usefull for debugging and development purposes. Do</pre></td></tr>
<tr class="nocodegen"><td>210</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; not use it for actual encryption as it will not encrypt anything at all!</pre></td></tr>
<tr class="nocodegen"><td>211</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>212</td><td><pre style="display:inline;"> &nbsp;TCipher_Null = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>213</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>214</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>215</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>216</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>217</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>218</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>219</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Provides meta data about the cipher algorithm used like key size.</pre></td></tr>
<tr class="nocodegen"><td>220</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>221</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>222</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>223</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>224</td><td><pre style="display:inline;"> &nbsp;TCipher_Blowfish = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>225</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>226</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>227</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>228</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>229</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>230</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>231</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>232</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>233</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>234</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>235</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>236</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>237</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>238</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>239</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>240</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>241</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>242</td><td><pre style="display:inline;"> &nbsp;TCipher_Twofish = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>243</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>244</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>245</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>246</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>247</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>248</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>249</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>250</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>251</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>252</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>253</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>254</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>255</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>256</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>257</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>258</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>259</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>260</td><td><pre style="display:inline;"> &nbsp;TCipher_IDEA = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>261</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>262</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>263</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>264</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>265</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>266</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>267</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>268</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>269</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>270</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>271</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>272</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>273</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>274</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>275</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>276</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>277</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>278</td><td><pre style="display:inline;"> &nbsp;TCipher_Cast256 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>279</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>280</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>281</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>282</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>283</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>284</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>285</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>286</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>287</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>288</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>289</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>290</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>291</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>292</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>293</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>294</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>295</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>296</td><td><pre style="display:inline;"> &nbsp;TCipher_Mars = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>297</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>298</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>299</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>300</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>301</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>302</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>303</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>304</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>305</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>306</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>307</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>308</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>309</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>310</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>311</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>312</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>313</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>314</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>315</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This is a well known stream cipher. In February 2015 its use in context</pre></td></tr>
<tr class="nocodegen"><td>316</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; of TLS has been forbidden due to severe security issues.</pre></td></tr>
<tr class="nocodegen"><td>317</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>318</td><td><pre style="display:inline;"> &nbsp;TCipher_RC4 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>319</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>320</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>321</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>322</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>323</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>324</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>325</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>326</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>327</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>328</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>329</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>330</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>331</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>332</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>333</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>334</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>335</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>336</td><td><pre style="display:inline;"> &nbsp;TCipher_RC6 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>337</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>338</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: Integer;</pre></td></tr>
<tr class="nocodegen"><td>339</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetRounds(Value: Integer);</pre></td></tr>
<tr class="nocodegen"><td>340</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>341</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Limits the number of rounds used to a minimum or maximum value,</pre></td></tr>
<tr class="nocodegen"><td>342</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; depending on the current value. If FRounds is 0 it will be set to 20.</pre></td></tr>
<tr class="nocodegen"><td>343</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>344</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure LimitRounds; inline;</pre></td></tr>
<tr class="nocodegen"><td>345</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>346</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>347</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>348</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>349</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>350</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>351</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>352</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>353</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>354</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>355</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>356</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>357</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>358</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>359</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>360</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>361</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Sets the number of rounds/times the algorithm is being applied to the</pre></td></tr>
<tr class="nocodegen"><td>362</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; data. Range should be 16-24 and default is 20 rounds.</pre></td></tr>
<tr class="nocodegen"><td>363</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>364</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: Integer read FRounds write SetRounds;</pre></td></tr>
<tr class="nocodegen"><td>365</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>366</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>367</td><td><pre style="display:inline;"> &nbsp;TCipher_Rijndael = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>368</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>369</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: Integer;</pre></td></tr>
<tr class="nocodegen"><td>370</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>371</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>372</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>373</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>374</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>375</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>376</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>377</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>378</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>379</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>380</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>381</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>382</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>383</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>384</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>385</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>386</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Gets the number of rounds/times the algorithm is being applied to the</pre></td></tr>
<tr class="nocodegen"><td>387</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; data. The number of rounds depends on the key size.</pre></td></tr>
<tr class="nocodegen"><td>388</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>389</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: Integer read FRounds;</pre></td></tr>
<tr class="nocodegen"><td>390</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>391</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>392</td><td><pre style="display:inline;"> &nbsp;TCipher_AES = class(TCipher_Rijndael);</pre></td></tr>
<tr class="nocodegen"><td>393</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>394</td><td><pre style="display:inline;"> &nbsp;TCipher_Square = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>395</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>396</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>397</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>398</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>399</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>400</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>401</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>402</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>403</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>404</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>405</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>406</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>407</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>408</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>409</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>410</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>411</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>412</td><td><pre style="display:inline;"> &nbsp;TCipher_SCOP = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>413</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>414</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>415</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>416</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>417</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>418</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>419</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>420</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>421</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>422</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>423</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>424</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>425</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>426</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>427</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>428</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>429</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>430</td><td><pre style="display:inline;"> &nbsp;/// &lt;remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>431</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Do only use if backwards compatibility with old code is necessary as</pre></td></tr>
<tr class="nocodegen"><td>432</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; this implementation is faulty!</pre></td></tr>
<tr class="nocodegen"><td>433</td><td><pre style="display:inline;"> &nbsp;/// &lt;/remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>434</td><td><pre style="display:inline;"> &nbsp;TCipher_SCOP_DEC52 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>435</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>436</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>437</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>438</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>439</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>440</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>441</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>442</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>443</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>444</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>445</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>446</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>447</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>448</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>449</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>450</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>451</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>452</td><td><pre style="display:inline;"> &nbsp;TCipher_Sapphire = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>453</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>454</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>455</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>456</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>457</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>458</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>459</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>460</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>461</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>462</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>463</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>464</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>465</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>466</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>467</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>468</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>469</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>470</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>471</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Base class for all DES based ciphers to fix issues with calling</pre></td></tr>
<tr class="nocodegen"><td>472</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; inherited in DoInit, as all other DES based classes did inherit from</pre></td></tr>
<tr class="nocodegen"><td>473</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; TCipher_1DES and inherited called the DoInit of that as well...</pre></td></tr>
<tr class="nocodegen"><td>474</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>475</td><td><pre style="display:inline;"> &nbsp;TCipher_DESBase = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>476</td><td><pre style="display:inline;"> &nbsp;strict protected</pre></td></tr>
<tr class="nocodegen"><td>477</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>478</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>479</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>480</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Data&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>481</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Key for the current block to be encrypted/decrypted?</pre></td></tr>
<tr class="nocodegen"><td>482</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>483</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>484</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>485</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>486</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>487</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>488</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>489</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Reverse&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>490</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Defines whether some internal calculation needs to be based from the</pre></td></tr>
<tr class="nocodegen"><td>491</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; start index or the highest index &nbsp;(= reverse)</pre></td></tr>
<tr class="nocodegen"><td>492</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>493</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInitKey(const Data: array of Byte; Key: PUInt32Array; Reverse: Boolean);</pre></td></tr>
<tr class="nocodegen"><td>494</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>495</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>496</td><td><pre style="display:inline;"> &nbsp;TCipher_1DES = class(TCipher_DESBase)</pre></td></tr>
<tr class="nocodegen"><td>497</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>498</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>499</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>500</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>501</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>502</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>503</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>504</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>505</td><td><pre style="display:inline;"> &nbsp;TCipher_2DES = class(TCipher_DESBase)</pre></td></tr>
<tr class="nocodegen"><td>506</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>507</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>508</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>509</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>510</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>511</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>512</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>513</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>514</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>515</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>516</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>517</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>518</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>519</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>520</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>521</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>522</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>523</td><td><pre style="display:inline;"> &nbsp;TCipher_3DES = class(TCipher_DESBase)</pre></td></tr>
<tr class="nocodegen"><td>524</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>525</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>526</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>527</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>528</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>529</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>530</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>531</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>532</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>533</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>534</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>535</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>536</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>537</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>538</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>539</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>540</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>541</td><td><pre style="display:inline;"> &nbsp;TCipher_2DDES = class(TCipher_2DES)</pre></td></tr>
<tr class="nocodegen"><td>542</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>543</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>544</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>545</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>546</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>547</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>548</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>549</td><td><pre style="display:inline;"> &nbsp;TCipher_3DDES = class(TCipher_3DES)</pre></td></tr>
<tr class="nocodegen"><td>550</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>551</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>552</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>553</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>554</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>555</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>556</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>557</td><td><pre style="display:inline;"> &nbsp;TCipher_3TDES = class(TCipher_3DES)</pre></td></tr>
<tr class="nocodegen"><td>558</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>559</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>560</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>561</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>562</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>563</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>564</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>565</td><td><pre style="display:inline;"> &nbsp;TCipher_3Way = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>566</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>567</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>568</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>569</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>570</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>571</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>572</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>573</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>574</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>575</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>576</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>577</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>578</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>579</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>580</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>581</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>582</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>583</td><td><pre style="display:inline;"> &nbsp;TCipher_Cast128 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>584</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>585</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: Integer;</pre></td></tr>
<tr class="nocodegen"><td>586</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>587</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>588</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>589</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>590</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>591</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>592</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>593</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>594</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>595</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>596</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>597</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>598</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>599</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>600</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>601</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>602</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>603</td><td><pre style="display:inline;"> &nbsp;TCipher_Gost = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>604</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>605</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>606</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>607</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>608</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>609</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>610</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>611</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>612</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>613</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>614</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>615</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>616</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>617</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>618</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>619</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>620</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>621</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>622</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Alias for Gost</pre></td></tr>
<tr class="nocodegen"><td>623</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>624</td><td><pre style="display:inline;"> &nbsp;TCipher_Magma = class(TCipher_Gost);</pre></td></tr>
<tr class="nocodegen"><td>625</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>626</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>627</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Do no longer use this algorithm if possible, as it got broken in 2015</pre></td></tr>
<tr class="nocodegen"><td>628</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; by crypto analysis.</pre></td></tr>
<tr class="nocodegen"><td>629</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>630</td><td><pre style="display:inline;"> &nbsp;TCipher_Misty = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>631</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>632</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>633</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>634</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>635</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>636</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>637</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>638</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>639</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>640</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>641</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>642</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>643</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>644</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>645</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>646</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>647</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>648</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>649</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; While this algorithm resembles the Data Encryption Standard (DES),</pre></td></tr>
<tr class="nocodegen"><td>650</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; it is easier to implement in software and is supposed to be more secure.</pre></td></tr>
<tr class="nocodegen"><td>651</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; It is not to be confused with another algorithm - known by the same</pre></td></tr>
<tr class="nocodegen"><td>652</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; name - which is simply DES without the initial and final permutations.</pre></td></tr>
<tr class="nocodegen"><td>653</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The NewDES here is a completely different algorithm.</pre></td></tr>
<tr class="nocodegen"><td>654</td><td><pre style="display:inline;"> &nbsp;///</pre></td></tr>
<tr class="nocodegen"><td>655</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Be aware though that recent crypto analysis shows that this algorithm is</pre></td></tr>
<tr class="nocodegen"><td>656</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; less safe than DES and thus not to be recommended for use!</pre></td></tr>
<tr class="nocodegen"><td>657</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>658</td><td><pre style="display:inline;"> &nbsp;TCipher_NewDES = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>659</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>660</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>661</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>662</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>663</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>664</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>665</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>666</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>667</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>668</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>669</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>670</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>671</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>672</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>673</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>674</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>675</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>676</td><td><pre style="display:inline;"> &nbsp;TCipher_Q128 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>677</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>678</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>679</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>680</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>681</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>682</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>683</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>684</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>685</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>686</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>687</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>688</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>689</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>690</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>691</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>692</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>693</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>694</td><td><pre style="display:inline;"> &nbsp;TCipher_RC2 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>695</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>696</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>697</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>698</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>699</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>700</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>701</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>702</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>703</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>704</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>705</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>706</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>707</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>708</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>709</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>710</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>711</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>712</td><td><pre style="display:inline;"> &nbsp;TCipher_RC5 = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>713</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>714</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: Integer;</pre></td></tr>
<tr class="nocodegen"><td>715</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetRounds(Value: Integer);</pre></td></tr>
<tr class="nocodegen"><td>716</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>717</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>718</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>719</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>720</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>721</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>722</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>723</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>724</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>725</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>726</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>727</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>728</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>729</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>730</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>731</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>732</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>733</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Sets the number of rounds/times the algorithm is being applied to the</pre></td></tr>
<tr class="nocodegen"><td>734</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; data. Allowed range is 0-255, if you can choose we recommend a</pre></td></tr>
<tr class="nocodegen"><td>735</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; value &gt; 16.</pre></td></tr>
<tr class="nocodegen"><td>736</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>737</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: Integer read FRounds write SetRounds;</pre></td></tr>
<tr class="nocodegen"><td>738</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>739</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>740</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>741</td><td><pre style="display:inline;"> &nbsp;/// &nbsp;svK40 &nbsp; &nbsp; SAFER K-40 &nbsp; &nbsp;Keysize is 40bit &nbsp;-&gt; &nbsp;5 Byte</pre></td></tr>
<tr class="nocodegen"><td>742</td><td><pre style="display:inline;"> &nbsp;/// &nbsp;svK64 &nbsp; &nbsp; SAFER K-64 &nbsp; &nbsp;Keysize is 64bit &nbsp;-&gt; &nbsp;8 Byte</pre></td></tr>
<tr class="nocodegen"><td>743</td><td><pre style="display:inline;"> &nbsp;/// &nbsp;svK128 &nbsp; &nbsp;SAFER K-128 &nbsp; KeySize is 128bit -&gt; 16 Byte</pre></td></tr>
<tr class="nocodegen"><td>744</td><td><pre style="display:inline;"> &nbsp;/// &nbsp;svSK40 &nbsp; &nbsp;SAFER SK-40 &nbsp; Stronger Version from K-40 with better Key Scheduling</pre></td></tr>
<tr class="nocodegen"><td>745</td><td><pre style="display:inline;"> &nbsp;/// &nbsp;svSK64 &nbsp; &nbsp;SAFER SK-64 &nbsp; Stronger Version from K-64 with better Key Scheduling</pre></td></tr>
<tr class="nocodegen"><td>746</td><td><pre style="display:inline;"> &nbsp;/// &nbsp;svSK128 &nbsp; SAFER SK-128 &nbsp;Stronger Version from K-128 with better Key Scheduling</pre></td></tr>
<tr class="nocodegen"><td>747</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>748</td><td><pre style="display:inline;"> &nbsp;TSAFERVersion = (svSK128, svSK64, svSK40, svK128, svK64, svK40);</pre></td></tr>
<tr class="nocodegen"><td>749</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>750</td><td><pre style="display:inline;"> &nbsp;TCipher_SAFER = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>751</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>752</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: Integer;</pre></td></tr>
<tr class="nocodegen"><td>753</td><td><pre style="display:inline;"> &nbsp; &nbsp;FVersion: TSAFERVersion;</pre></td></tr>
<tr class="nocodegen"><td>754</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetRounds(Value: Integer);</pre></td></tr>
<tr class="nocodegen"><td>755</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetVersion(Value: TSAFERVersion);</pre></td></tr>
<tr class="nocodegen"><td>756</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>757</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>758</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>759</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>760</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>761</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>762</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>763</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>764</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>765</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>766</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>767</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>768</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>769</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>770</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>771</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>772</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>773</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Sets the number of rounds/times the algorithm is being applied to the</pre></td></tr>
<tr class="nocodegen"><td>774</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; data. Range should be 4-13 and default is 5, 6, 10 or 8 rounds</pre></td></tr>
<tr class="nocodegen"><td>775</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; depending on the version</pre></td></tr>
<tr class="nocodegen"><td>776</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>777</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: Integer read FRounds write SetRounds;</pre></td></tr>
<tr class="nocodegen"><td>778</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Version: TSAFERVersion read FVersion write SetVersion;</pre></td></tr>
<tr class="nocodegen"><td>779</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>780</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>781</td><td><pre style="display:inline;"> &nbsp;{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>782</td><td><pre style="display:inline;"> &nbsp;PLong64 = ^TLong64;</pre></td></tr>
<tr class="nocodegen"><td>783</td><td><pre style="display:inline;"> &nbsp;TLong64 &nbsp;= packed record</pre></td></tr>
<tr class="nocodegen"><td>784</td><td><pre style="display:inline;"> &nbsp; &nbsp;L, R: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>785</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>786</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>787</td><td><pre style="display:inline;"> &nbsp;PLong64Array = ^TLong64Array;</pre></td></tr>
<tr class="nocodegen"><td>788</td><td><pre style="display:inline;"> &nbsp;TLong64Array = array[0..1023] of TLong64;</pre></td></tr>
<tr class="nocodegen"><td>789</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>790</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>791</td><td><pre style="display:inline;"> &nbsp;TLogArray = array[0..255] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>792</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>793</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>794</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Base class for both Shark implementations</pre></td></tr>
<tr class="nocodegen"><td>795</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>796</td><td><pre style="display:inline;"> &nbsp;TCipher_SharkBase = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>797</td><td><pre style="display:inline;"> &nbsp;strict protected</pre></td></tr>
<tr class="nocodegen"><td>798</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>799</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Transform(A: TLong64; Log, ALog: TLogArray): TLong64;</pre></td></tr>
<tr class="nocodegen"><td>800</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Shark(D: TLong64; K: PLong64): TLong64;</pre></td></tr>
<tr class="nocodegen"><td>801</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>802</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Transform(A: UInt64; Log, ALog: TLogArray): UInt64;</pre></td></tr>
<tr class="nocodegen"><td>803</td><td><pre style="display:inline;"> &nbsp; &nbsp;function SharkEncode(D: UInt64; K: PUInt64): UInt64;</pre></td></tr>
<tr class="nocodegen"><td>804</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>805</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>806</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>807</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>808</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>809</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>810</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>811</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>812</td><td><pre style="display:inline;"> &nbsp;TCipher_Shark = class(TCipher_SharkBase)</pre></td></tr>
<tr class="nocodegen"><td>813</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>814</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>815</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>816</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>817</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>818</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>819</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>820</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>821</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>822</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>823</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>824</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>825</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>826</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>827</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>828</td><td><pre style="display:inline;"> &nbsp;/// &lt;remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>829</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Do only use if backwards compatibility with old code is necessary as</pre></td></tr>
<tr class="nocodegen"><td>830</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; this implementation is faulty!</pre></td></tr>
<tr class="nocodegen"><td>831</td><td><pre style="display:inline;"> &nbsp;/// &lt;/remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>832</td><td><pre style="display:inline;"> &nbsp;TCipher_Shark_DEC52 = class(TCipher_SharkBase)</pre></td></tr>
<tr class="nocodegen"><td>833</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>834</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>835</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>836</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>837</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>838</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>839</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>840</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>841</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>842</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>843</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>844</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>845</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>846</td><td><pre style="display:inline;"> &nbsp;TCipher_Skipjack = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>847</td><td><pre style="display:inline;"> &nbsp;strict private</pre></td></tr>
<tr class="nocodegen"><td>848</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SkipjackIncCheck(var ATab: PSkipjackTab; AMin: PSkipjackTab; AMax: PByte); inline;</pre></td></tr>
<tr class="nocodegen"><td>849</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SkipjackDecCheck(var ATab: PSkipjackTab; AMin: PByte; AMax: PSkipjackTab); inline;</pre></td></tr>
<tr class="nocodegen"><td>850</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>851</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>852</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>853</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>854</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>855</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>856</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>857</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>858</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>859</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>860</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>861</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>862</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>863</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>864</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>865</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>866</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>867</td><td><pre style="display:inline;"> &nbsp;TCipher_TEA = class(TDECFormattedCipher)</pre></td></tr>
<tr class="nocodegen"><td>868</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>869</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: Integer;</pre></td></tr>
<tr class="nocodegen"><td>870</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetRounds(Value: Integer);</pre></td></tr>
<tr class="nocodegen"><td>871</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>872</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>873</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initialize the key, based on the key passed in</pre></td></tr>
<tr class="nocodegen"><td>874</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>875</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Key&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>876</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Encryption/Decryption key to be used</pre></td></tr>
<tr class="nocodegen"><td>877</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>878</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Size&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>879</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the key passed in bytes.</pre></td></tr>
<tr class="nocodegen"><td>880</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>881</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit(const Key; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>882</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>883</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>884</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>885</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function Context: TCipherContext; override;</pre></td></tr>
<tr class="nocodegen"><td>886</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>887</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>888</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; 16 - 256 Rounds, 16 (default) is sufficient, 64 is the official</pre></td></tr>
<tr class="nocodegen"><td>889</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; recommendation. If a value outside the range of 16 to 256 is assigned</pre></td></tr>
<tr class="nocodegen"><td>890</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; it will be limited to that range.</pre></td></tr>
<tr class="nocodegen"><td>891</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>892</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: Integer read FRounds write SetRounds;</pre></td></tr>
<tr class="nocodegen"><td>893</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>894</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>895</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>896</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; XTEA is an improved version of the TEA algorithm.</pre></td></tr>
<tr class="nocodegen"><td>897</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>898</td><td><pre style="display:inline;"> &nbsp;/// &lt;remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>899</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; In DEC V5.2 at least and in former commits of DEC 6.0 development version</pre></td></tr>
<tr class="nocodegen"><td>900</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; this algorithm was broken due to differences in brackets and thus returned</pre></td></tr>
<tr class="nocodegen"><td>901</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; a different result. It is unclear why nobody reported this as bug yet</pre></td></tr>
<tr class="nocodegen"><td>902</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; but be aware that if you need the old variant for compatibility reasons</pre></td></tr>
<tr class="nocodegen"><td>903</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; you need a commit from before 3rd December 2020.</pre></td></tr>
<tr class="nocodegen"><td>904</td><td><pre style="display:inline;"> &nbsp;/// &lt;/remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>905</td><td><pre style="display:inline;"> &nbsp;TCipher_XTEA = class(TCipher_TEA)</pre></td></tr>
<tr class="nocodegen"><td>906</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>907</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>908</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>909</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>910</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>911</td><td><pre style="display:inline;"> &nbsp;TCipher_TEAN = class(TCipher_XTEA);</pre></td></tr>
<tr class="nocodegen"><td>912</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>913</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>914</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; XTEA is an improved version of the TEA algorithm. This version is the</pre></td></tr>
<tr class="nocodegen"><td>915</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; old faulty one from DEC 5.2. Use only if necessary for compatibility</pre></td></tr>
<tr class="nocodegen"><td>916</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; &nbsp;reasons!</pre></td></tr>
<tr class="nocodegen"><td>917</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>918</td><td><pre style="display:inline;"> &nbsp;/// &lt;remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>919</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; In DEC V5.2 at least and in former commits of DEC 6.0 development version</pre></td></tr>
<tr class="nocodegen"><td>920</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; this algorithm was broken due to differences in brackets and thus returned</pre></td></tr>
<tr class="nocodegen"><td>921</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; a different result. It is unclear why nobody reported this as bug yet</pre></td></tr>
<tr class="nocodegen"><td>922</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; but be aware that if you need the old variant for compatibility reasons</pre></td></tr>
<tr class="nocodegen"><td>923</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; you need a commit from before 3rd December 2020.</pre></td></tr>
<tr class="nocodegen"><td>924</td><td><pre style="display:inline;"> &nbsp;/// &lt;/remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>925</td><td><pre style="display:inline;"> &nbsp;TCipher_XTEA_DEC52 = class(TCipher_TEA)</pre></td></tr>
<tr class="nocodegen"><td>926</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>927</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>928</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>929</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>930</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>931</td><td><pre style="display:inline;">implementation</pre></td></tr>
<tr class="nocodegen"><td>932</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>933</td><td><pre style="display:inline;">{$IFOPT Q+}{$DEFINE RESTORE_OVERFLOWCHECKS}{$Q-}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>934</td><td><pre style="display:inline;">{$IFOPT R+}{$DEFINE RESTORE_RANGECHECKS}{$R-}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>935</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>936</td><td><pre style="display:inline;">uses</pre></td></tr>
<tr class="nocodegen"><td>937</td><td><pre style="display:inline;"> &nbsp;{$IFDEF FPC}</pre></td></tr>
<tr class="nocodegen"><td>938</td><td><pre style="display:inline;"> &nbsp;SysUtils,</pre></td></tr>
<tr class="nocodegen"><td>939</td><td><pre style="display:inline;"> &nbsp;{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>940</td><td><pre style="display:inline;"> &nbsp;System.SysUtils,</pre></td></tr>
<tr class="nocodegen"><td>941</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>942</td><td><pre style="display:inline;"> &nbsp;DECData, DECDataCipher;</pre></td></tr>
<tr class="nocodegen"><td>943</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>944</td><td><pre style="display:inline;">{ TCipher_Null }</pre></td></tr>
<tr class="nocodegen"><td>945</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>946</td><td><pre style="display:inline;">class function TCipher_Null.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>947</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>948</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 0;</pre></td></tr>
<tr class="covered"><td>949</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>950</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>951</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 0;</pre></td></tr>
<tr class="covered"><td>952</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>953</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>954</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>955</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctNull, ctSymmetric];</pre></td></tr>
<tr class="covered"><td>956</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>957</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>958</td><td><pre style="display:inline;">procedure TCipher_Null.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="covered"><td>959</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>960</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>961</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>962</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>963</td><td><pre style="display:inline;">procedure TCipher_Null.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>964</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>965</td><td><pre style="display:inline;"> &nbsp;if Source &lt;&gt; Dest then</pre></td></tr>
<tr class="covered"><td>966</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(Source^, Dest^, Size);</pre></td></tr>
<tr class="covered"><td>967</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>968</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>969</td><td><pre style="display:inline;">procedure TCipher_Null.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>970</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>971</td><td><pre style="display:inline;"> &nbsp;if Source &lt;&gt; Dest then</pre></td></tr>
<tr class="covered"><td>972</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(Source^, Dest^, Size);</pre></td></tr>
<tr class="covered"><td>973</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>974</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>975</td><td><pre style="display:inline;">{ TCipher_Blowfish }</pre></td></tr>
<tr class="nocodegen"><td>976</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>977</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>978</td><td><pre style="display:inline;"> &nbsp;PBlowfish = ^TBlowfish;</pre></td></tr>
<tr class="nocodegen"><td>979</td><td><pre style="display:inline;"> &nbsp;TBlowfish = array[0..3, 0..255] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>980</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>981</td><td><pre style="display:inline;">class function TCipher_Blowfish.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>982</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>983</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 56;</pre></td></tr>
<tr class="covered"><td>984</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>985</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>986</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= SizeOf(Blowfish_Data) + SizeOf(Blowfish_Key);</pre></td></tr>
<tr class="covered"><td>987</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>988</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>989</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>990</td><td><pre style="display:inline;"> &nbsp;Result.CipherType := [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>991</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>992</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>993</td><td><pre style="display:inline;">procedure TCipher_Blowfish.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>994</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>995</td><td><pre style="display:inline;"> &nbsp;I, J: Integer;</pre></td></tr>
<tr class="nocodegen"><td>996</td><td><pre style="display:inline;"> &nbsp;B: array[0..1] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>997</td><td><pre style="display:inline;"> &nbsp;K: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>998</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>999</td><td><pre style="display:inline;"> &nbsp;S: PBlowfish;</pre></td></tr>
<tr class="covered"><td>1000</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1001</td><td><pre style="display:inline;"> &nbsp;K := @Key;</pre></td></tr>
<tr class="covered"><td>1002</td><td><pre style="display:inline;"> &nbsp;S := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1003</td><td><pre style="display:inline;"> &nbsp;P := Pointer(PByte(FAdditionalBuffer) + SizeOf(Blowfish_Data)); // for Pointer Math</pre></td></tr>
<tr class="nocodegen"><td>1004</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1005</td><td><pre style="display:inline;"> &nbsp;Move(Blowfish_Data, S^, SizeOf(Blowfish_Data));</pre></td></tr>
<tr class="covered"><td>1006</td><td><pre style="display:inline;"> &nbsp;Move(Blowfish_Key, P^, Sizeof(Blowfish_Key));</pre></td></tr>
<tr class="covered"><td>1007</td><td><pre style="display:inline;"> &nbsp;J := 0;</pre></td></tr>
<tr class="covered"><td>1008</td><td><pre style="display:inline;"> &nbsp;if Size &gt; 0 then</pre></td></tr>
<tr class="covered"><td>1009</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 17 do</pre></td></tr>
<tr class="nocodegen"><td>1010</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1011</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;P[I] := P[I] xor (K[(J + 0) mod Size] shl 24 +</pre></td></tr>
<tr class="nocodegen"><td>1012</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[(J + 1) mod Size] shl 16 +</pre></td></tr>
<tr class="nocodegen"><td>1013</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[(J + 2) mod Size] shl &nbsp;8 +</pre></td></tr>
<tr class="nocodegen"><td>1014</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[(J + 3) mod Size] shl &nbsp;0);</pre></td></tr>
<tr class="covered"><td>1015</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;J := (J + 4) mod Size;</pre></td></tr>
<tr class="covered"><td>1016</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1017</td><td><pre style="display:inline;"> &nbsp;FillChar(B, SizeOf(B), 0);</pre></td></tr>
<tr class="nocodegen"><td>1018</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1019</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 8 do</pre></td></tr>
<tr class="nocodegen"><td>1020</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1021</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoEncode(@B, @B, SizeOf(B));</pre></td></tr>
<tr class="covered"><td>1022</td><td><pre style="display:inline;"> &nbsp; &nbsp;P[I * 2 + 0] := SwapUInt32(B[0]);</pre></td></tr>
<tr class="covered"><td>1023</td><td><pre style="display:inline;"> &nbsp; &nbsp;P[I * 2 + 1] := SwapUInt32(B[1]);</pre></td></tr>
<tr class="covered"><td>1024</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1025</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 3 do</pre></td></tr>
<tr class="covered"><td>1026</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 127 do</pre></td></tr>
<tr class="nocodegen"><td>1027</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1028</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;DoEncode(@B, @B, SizeOf(B));</pre></td></tr>
<tr class="covered"><td>1029</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S[I, J * 2 + 0] := SwapUInt32(B[0]);</pre></td></tr>
<tr class="covered"><td>1030</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S[I, J * 2 + 1] := SwapUInt32(B[1]);</pre></td></tr>
<tr class="covered"><td>1031</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1032</td><td><pre style="display:inline;"> &nbsp;FillChar(B, SizeOf(B), 0);</pre></td></tr>
<tr class="nocodegen"><td>1033</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1034</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>1035</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1036</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1037</td><td><pre style="display:inline;">procedure TCipher_Blowfish.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1038</td><td><pre style="display:inline;">{$IFDEF X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1039</td><td><pre style="display:inline;">// Source = EDX, Dest = ECX, Size on Stack</pre></td></tr>
<tr class="covered"><td>1040</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="covered"><td>1041</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; EDI</pre></td></tr>
<tr class="covered"><td>1042</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; ESI</pre></td></tr>
<tr class="covered"><td>1043</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; EBX</pre></td></tr>
<tr class="covered"><td>1044</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>1045</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; ECX</pre></td></tr>
<tr class="covered"><td>1046</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;ESI,[EAX].TCipher_Blowfish.FAdditionalBuffer</pre></td></tr>
<tr class="covered"><td>1047</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBX,[EDX + 0] &nbsp; &nbsp; // A</pre></td></tr>
<tr class="covered"><td>1048</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBP,[EDX + 4] &nbsp; &nbsp; // B</pre></td></tr>
<tr class="covered"><td>1049</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // CPU &gt;= 486</pre></td></tr>
<tr class="covered"><td>1050</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>1051</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBX,[ESI + 4 * 256 * 4]</pre></td></tr>
<tr class="covered"><td>1052</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EDI,EDI</pre></td></tr>
<tr class="covered"><td>1053</td><td><pre style="display:inline;">@@1: &nbsp; &nbsp;MOV &nbsp; &nbsp;EAX,EBX</pre></td></tr>
<tr class="covered"><td>1054</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;SHR &nbsp; &nbsp;EBX,16</pre></td></tr>
<tr class="covered"><td>1055</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOVZX &nbsp;ECX,BH</pre></td></tr>
<tr class="covered"><td>1056</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;AND &nbsp; &nbsp;EBX,0FFh</pre></td></tr>
<tr class="covered"><td>1057</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;ECX,[ESI + ECX * 4 + 1024 * 0]</pre></td></tr>
<tr class="covered"><td>1058</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBX,[ESI + EBX * 4 + 1024 * 1]</pre></td></tr>
<tr class="covered"><td>1059</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOVZX &nbsp;EDX,AH</pre></td></tr>
<tr class="covered"><td>1060</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;ADD &nbsp; &nbsp;EBX,ECX</pre></td></tr>
<tr class="covered"><td>1061</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOVZX &nbsp;ECX,AL</pre></td></tr>
<tr class="covered"><td>1062</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EDX,[ESI + EDX * 4 + 1024 * 2]</pre></td></tr>
<tr class="covered"><td>1063</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;ECX,[ESI + ECX * 4 + 1024 * 3]</pre></td></tr>
<tr class="covered"><td>1064</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBX,EDX</pre></td></tr>
<tr class="covered"><td>1065</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBP,[ESI + 4 * 256 * 4 + 4 + EDI * 4]</pre></td></tr>
<tr class="covered"><td>1066</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;ADD &nbsp; &nbsp;EBX,ECX</pre></td></tr>
<tr class="covered"><td>1067</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;INC &nbsp; &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>1068</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBX,EBP</pre></td></tr>
<tr class="covered"><td>1069</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;TEST &nbsp; EDI,010h</pre></td></tr>
<tr class="covered"><td>1070</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBP,EAX</pre></td></tr>
<tr class="covered"><td>1071</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;JZ &nbsp; &nbsp; @@1</pre></td></tr>
<tr class="covered"><td>1072</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EAX</pre></td></tr>
<tr class="covered"><td>1073</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBP,[ESI + 4 * 256 * 4 + 17 * 4]</pre></td></tr>
<tr class="covered"><td>1074</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>1075</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>1076</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;[EAX + 4],EBX</pre></td></tr>
<tr class="covered"><td>1077</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;[EAX + 0],EBP</pre></td></tr>
<tr class="covered"><td>1078</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>1079</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>1080</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;ESI</pre></td></tr>
<tr class="covered"><td>1081</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>1082</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1083</td><td><pre style="display:inline;">{$ELSE !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1084</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1085</td><td><pre style="display:inline;"> &nbsp;I, A, B: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1086</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>1087</td><td><pre style="display:inline;"> &nbsp;D: PBlowfish;</pre></td></tr>
<tr class="nocodegen"><td>1088</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1089</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize, &apos;Size of &apos; + IntToStr(Size) + &apos; does not equal &apos;+</pre></td></tr>
<tr class="nocodegen"><td>1090</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &apos;block size of &apos; + IntToStr(Context.BlockSize));</pre></td></tr>
<tr class="nocodegen"><td>1091</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1092</td><td><pre style="display:inline;"> &nbsp;D := Pointer(FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>1093</td><td><pre style="display:inline;"> &nbsp;P := Pointer(PByte(FAdditionalBuffer) + SizeOf(Blowfish_Data)); // for Pointer Math</pre></td></tr>
<tr class="nocodegen"><td>1094</td><td><pre style="display:inline;"> &nbsp;A := SwapUInt32(PUInt32Array(Source)[0]) xor P[0]; P := @P[1];</pre></td></tr>
<tr class="nocodegen"><td>1095</td><td><pre style="display:inline;"> &nbsp;B := SwapUInt32(PUInt32Array(Source)[1]);</pre></td></tr>
<tr class="nocodegen"><td>1096</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>1097</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1098</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor P[0] xor (D[0, A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] +</pre></td></tr>
<tr class="nocodegen"><td>1099</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[1, A shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1100</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[2, A shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1101</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[3, A &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>1102</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1103</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor P[1] xor (D[0, B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] +</pre></td></tr>
<tr class="nocodegen"><td>1104</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[1, B shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1105</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[2, B shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1106</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[3, B &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>1107</td><td><pre style="display:inline;"> &nbsp; &nbsp;P := @P[2];</pre></td></tr>
<tr class="nocodegen"><td>1108</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1109</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := SwapUInt32(B xor P[0]);</pre></td></tr>
<tr class="nocodegen"><td>1110</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := SwapUInt32(A);</pre></td></tr>
<tr class="nocodegen"><td>1111</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1112</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1113</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1114</td><td><pre style="display:inline;">procedure TCipher_Blowfish.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1115</td><td><pre style="display:inline;">{$IFDEF X86ASM}</pre></td></tr>
<tr class="covered"><td>1116</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="covered"><td>1117</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; EDI</pre></td></tr>
<tr class="covered"><td>1118</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; ESI</pre></td></tr>
<tr class="covered"><td>1119</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; EBX</pre></td></tr>
<tr class="covered"><td>1120</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>1121</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PUSH &nbsp; ECX</pre></td></tr>
<tr class="covered"><td>1122</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;ESI,[EAX].TCipher_Blowfish.FAdditionalBuffer</pre></td></tr>
<tr class="covered"><td>1123</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBX,[EDX + 0] &nbsp; &nbsp; // A</pre></td></tr>
<tr class="covered"><td>1124</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBP,[EDX + 4] &nbsp; &nbsp; // B</pre></td></tr>
<tr class="covered"><td>1125</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>1126</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>1127</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBX,[ESI + 4 * 256 * 4 + 17 * 4]</pre></td></tr>
<tr class="covered"><td>1128</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EDI,16</pre></td></tr>
<tr class="covered"><td>1129</td><td><pre style="display:inline;">@@1: &nbsp; &nbsp;MOV &nbsp; &nbsp;EAX,EBX</pre></td></tr>
<tr class="covered"><td>1130</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;SHR &nbsp; &nbsp;EBX,16</pre></td></tr>
<tr class="covered"><td>1131</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOVZX &nbsp;ECX,BH</pre></td></tr>
<tr class="covered"><td>1132</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOVZX &nbsp;EDX,BL</pre></td></tr>
<tr class="covered"><td>1133</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBX,[ESI + ECX * 4 + 1024 * 0]</pre></td></tr>
<tr class="covered"><td>1134</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EDX,[ESI + EDX * 4 + 1024 * 1]</pre></td></tr>
<tr class="covered"><td>1135</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOVZX &nbsp;ECX,AH</pre></td></tr>
<tr class="covered"><td>1136</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;LEA &nbsp; &nbsp;EBX,[EBX + EDX]</pre></td></tr>
<tr class="covered"><td>1137</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOVZX &nbsp;EDX,AL</pre></td></tr>
<tr class="covered"><td>1138</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;ECX,[ESI + ECX * 4 + 1024 * 2]</pre></td></tr>
<tr class="covered"><td>1139</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EDX,[ESI + EDX * 4 + 1024 * 3]</pre></td></tr>
<tr class="covered"><td>1140</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBX,ECX</pre></td></tr>
<tr class="covered"><td>1141</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBP,[ESI + 4 * 256 * 4 + EDI * 4]</pre></td></tr>
<tr class="covered"><td>1142</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;LEA &nbsp; &nbsp;EBX,[EBX + EDX]</pre></td></tr>
<tr class="covered"><td>1143</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBX,EBP</pre></td></tr>
<tr class="covered"><td>1144</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;DEC &nbsp; &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>1145</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;EBP,EAX</pre></td></tr>
<tr class="covered"><td>1146</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;JNZ &nbsp; &nbsp;@@1</pre></td></tr>
<tr class="covered"><td>1147</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EAX</pre></td></tr>
<tr class="covered"><td>1148</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp;EBP,[ESI + 4 * 256 * 4]</pre></td></tr>
<tr class="covered"><td>1149</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>1150</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;BSWAP &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>1151</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;[EAX + 0],EBP</pre></td></tr>
<tr class="covered"><td>1152</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp;[EAX + 4],EBX</pre></td></tr>
<tr class="covered"><td>1153</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>1154</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>1155</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;ESI</pre></td></tr>
<tr class="covered"><td>1156</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;POP &nbsp; &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>1157</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1158</td><td><pre style="display:inline;">{$ELSE !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1159</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1160</td><td><pre style="display:inline;"> &nbsp;I, A, B: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1161</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>1162</td><td><pre style="display:inline;"> &nbsp;D: PBlowfish;</pre></td></tr>
<tr class="nocodegen"><td>1163</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1164</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>1165</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1166</td><td><pre style="display:inline;"> &nbsp;D := Pointer(FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>1167</td><td><pre style="display:inline;"> &nbsp;P := Pointer(PByte(FAdditionalBuffer) + SizeOf(Blowfish_Data) + SizeOf(Blowfish_Key) - SizeOf(Int32));</pre></td></tr>
<tr class="nocodegen"><td>1168</td><td><pre style="display:inline;"> &nbsp;A := SwapUInt32(PUInt32Array(Source)[0]) xor P[0];</pre></td></tr>
<tr class="nocodegen"><td>1169</td><td><pre style="display:inline;"> &nbsp;B := SwapUInt32(PUInt32Array(Source)[1]);</pre></td></tr>
<tr class="nocodegen"><td>1170</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>1171</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1172</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(P), 2);</pre></td></tr>
<tr class="nocodegen"><td>1173</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor P[1] xor (D[0, A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] +</pre></td></tr>
<tr class="nocodegen"><td>1174</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[1, A shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1175</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[2, A shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1176</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[3, A &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>1177</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor P[0] xor (D[0, B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] +</pre></td></tr>
<tr class="nocodegen"><td>1178</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[1, B shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1179</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[2, B shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1180</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[3, B &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>1181</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1182</td><td><pre style="display:inline;"> &nbsp;Dec(PUInt32(P));</pre></td></tr>
<tr class="nocodegen"><td>1183</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := SwapUInt32(B xor P[0]);</pre></td></tr>
<tr class="nocodegen"><td>1184</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := SwapUInt32(A);</pre></td></tr>
<tr class="nocodegen"><td>1185</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1186</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1187</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1188</td><td><pre style="display:inline;">{ TCipher_Twofish }</pre></td></tr>
<tr class="nocodegen"><td>1189</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1190</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>1191</td><td><pre style="display:inline;"> &nbsp;PTwofishBox = ^TTwofishBox;</pre></td></tr>
<tr class="nocodegen"><td>1192</td><td><pre style="display:inline;"> &nbsp;TTwofishBox = array[0..3, 0..255] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1193</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1194</td><td><pre style="display:inline;"> &nbsp;TLongRec = record</pre></td></tr>
<tr class="nocodegen"><td>1195</td><td><pre style="display:inline;"> &nbsp; &nbsp;case Integer of</pre></td></tr>
<tr class="nocodegen"><td>1196</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;0: (L: UInt32);</pre></td></tr>
<tr class="nocodegen"><td>1197</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;1: (A, B, C, D: Byte);</pre></td></tr>
<tr class="nocodegen"><td>1198</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1199</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1200</td><td><pre style="display:inline;">class function TCipher_Twofish.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>1201</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1202</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 32;</pre></td></tr>
<tr class="covered"><td>1203</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>1204</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>1205</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 4256;</pre></td></tr>
<tr class="covered"><td>1206</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>1207</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1208</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1209</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>1210</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1211</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1212</td><td><pre style="display:inline;">procedure TCipher_Twofish.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1213</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1214</td><td><pre style="display:inline;"> &nbsp;BoxKey: array[0..3] of TLongRec;</pre></td></tr>
<tr class="nocodegen"><td>1215</td><td><pre style="display:inline;"> &nbsp;SubKey: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>1216</td><td><pre style="display:inline;"> &nbsp;Box: PTwofishBox;</pre></td></tr>
<tr class="nocodegen"><td>1217</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1218</td><td><pre style="display:inline;"> &nbsp;procedure SetupKey;</pre></td></tr>
<tr class="nocodegen"><td>1219</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1220</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Encode(K0, K1: Integer): Integer;</pre></td></tr>
<tr class="nocodegen"><td>1221</td><td><pre style="display:inline;"> &nbsp; &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1222</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;R, I, J, G2, G3: Integer;</pre></td></tr>
<tr class="nocodegen"><td>1223</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B: byte;</pre></td></tr>
<tr class="covered"><td>1224</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1225</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;R := 0;</pre></td></tr>
<tr class="covered"><td>1226</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for I := 0 to 1 do</pre></td></tr>
<tr class="nocodegen"><td>1227</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1228</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;if I &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>1229</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;R := R xor K0</pre></td></tr>
<tr class="nocodegen"><td>1230</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>1231</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;R := R xor K1;</pre></td></tr>
<tr class="covered"><td>1232</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;for J := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>1233</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1234</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;B := R shr 24;</pre></td></tr>
<tr class="covered"><td>1235</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if B and $80 &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>1236</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;G2 := (B shl 1 xor $014D) and $FF</pre></td></tr>
<tr class="nocodegen"><td>1237</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>1238</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;G2 := B shl 1 and $FF;</pre></td></tr>
<tr class="covered"><td>1239</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if B and 1 &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>1240</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;G3 := (B shr 1 and $7F) xor $014D shr 1 xor G2</pre></td></tr>
<tr class="nocodegen"><td>1241</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>1242</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;G3 := (B shr 1 and $7F) xor G2;</pre></td></tr>
<tr class="covered"><td>1243</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;R := R shl 8 xor G3 shl 24 xor G2 shl 16 xor G3 shl 8 xor B;</pre></td></tr>
<tr class="covered"><td>1244</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1245</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1246</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := R;</pre></td></tr>
<tr class="covered"><td>1247</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1248</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1249</td><td><pre style="display:inline;"> &nbsp; &nbsp;function F32(X: Integer; K: array of Integer): Integer;</pre></td></tr>
<tr class="nocodegen"><td>1250</td><td><pre style="display:inline;"> &nbsp; &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1251</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A, B, C, D: UInt32;</pre></td></tr>
<tr class="covered"><td>1252</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1253</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := X &nbsp; &nbsp; &nbsp; &nbsp;and $FF;</pre></td></tr>
<tr class="covered"><td>1254</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := X shr &nbsp;8 and $FF;</pre></td></tr>
<tr class="covered"><td>1255</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := X shr 16 and $FF;</pre></td></tr>
<tr class="covered"><td>1256</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := X shr 24;</pre></td></tr>
<tr class="covered"><td>1257</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if Size = 32 then</pre></td></tr>
<tr class="nocodegen"><td>1258</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>1259</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;A := Twofish_8x8[1, A] xor K[3] &nbsp; &nbsp; &nbsp; &nbsp;and $FF;</pre></td></tr>
<tr class="notcovered"><td>1260</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := Twofish_8x8[0, B] xor K[3] shr &nbsp;8 and $FF;</pre></td></tr>
<tr class="notcovered"><td>1261</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := Twofish_8x8[0, C] xor K[3] shr 16 and $FF;</pre></td></tr>
<tr class="notcovered"><td>1262</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;D := Twofish_8x8[1, D] xor K[3] shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1263</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1264</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if Size &gt;= 24 then</pre></td></tr>
<tr class="nocodegen"><td>1265</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>1266</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;A := Twofish_8x8[1, A] xor K[2] &nbsp; &nbsp; &nbsp; &nbsp;and $FF;</pre></td></tr>
<tr class="notcovered"><td>1267</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := Twofish_8x8[1, B] xor K[2] shr &nbsp;8 and $FF;</pre></td></tr>
<tr class="notcovered"><td>1268</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := Twofish_8x8[0, C] xor K[2] shr 16 and $FF;</pre></td></tr>
<tr class="notcovered"><td>1269</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;D := Twofish_8x8[0, D] xor K[2] shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1270</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1271</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := Twofish_8x8[0, A] xor K[1] &nbsp; &nbsp; &nbsp; &nbsp;and $FF;</pre></td></tr>
<tr class="covered"><td>1272</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := Twofish_8x8[1, B] xor K[1] shr &nbsp;8 and $FF;</pre></td></tr>
<tr class="covered"><td>1273</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := Twofish_8x8[0, C] xor K[1] shr 16 and $FF;</pre></td></tr>
<tr class="covered"><td>1274</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := Twofish_8x8[1, D] xor K[1] shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1275</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1276</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := Twofish_8x8[0, A] xor K[0] &nbsp; &nbsp; &nbsp; &nbsp;and $FF;</pre></td></tr>
<tr class="covered"><td>1277</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := Twofish_8x8[0, B] xor K[0] shr &nbsp;8 and $FF;</pre></td></tr>
<tr class="covered"><td>1278</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := Twofish_8x8[1, C] xor K[0] shr 16 and $FF;</pre></td></tr>
<tr class="covered"><td>1279</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := Twofish_8x8[1, D] xor K[0] shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1280</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1281</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := Twofish_Data[0, A] xor Twofish_Data[1, B] xor</pre></td></tr>
<tr class="nocodegen"><td>1282</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Twofish_Data[2, C] xor Twofish_Data[3, D];</pre></td></tr>
<tr class="covered"><td>1283</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1284</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1285</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1286</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, J, A, B: Integer;</pre></td></tr>
<tr class="nocodegen"><td>1287</td><td><pre style="display:inline;"> &nbsp; &nbsp;E, O: array[0..3] of Integer;</pre></td></tr>
<tr class="nocodegen"><td>1288</td><td><pre style="display:inline;"> &nbsp; &nbsp;K: array[0..7] of Integer;</pre></td></tr>
<tr class="covered"><td>1289</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1290</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>1291</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>1292</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Size &lt;= 16 then</pre></td></tr>
<tr class="covered"><td>1293</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Size := 16</pre></td></tr>
<tr class="nocodegen"><td>1294</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>1295</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Size &lt;= 24 then</pre></td></tr>
<tr class="notcovered"><td>1296</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Size := 24</pre></td></tr>
<tr class="nocodegen"><td>1297</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>1298</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Size := 32;</pre></td></tr>
<tr class="covered"><td>1299</td><td><pre style="display:inline;"> &nbsp; &nbsp;J := Size shr 3 - 1;</pre></td></tr>
<tr class="covered"><td>1300</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to J do</pre></td></tr>
<tr class="nocodegen"><td>1301</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1302</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;E[I] := K[I shl 1];</pre></td></tr>
<tr class="covered"><td>1303</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;O[I] := K[I shl 1 + 1];</pre></td></tr>
<tr class="covered"><td>1304</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;BoxKey[J].L := Encode(E[I], O[I]);</pre></td></tr>
<tr class="covered"><td>1305</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(J);</pre></td></tr>
<tr class="covered"><td>1306</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1307</td><td><pre style="display:inline;"> &nbsp; &nbsp;J := 0;</pre></td></tr>
<tr class="covered"><td>1308</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 19 do</pre></td></tr>
<tr class="nocodegen"><td>1309</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1310</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := F32(J, E);</pre></td></tr>
<tr class="covered"><td>1311</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := F32(J + $01010101, O);</pre></td></tr>
<tr class="covered"><td>1312</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B shl 8 or B shr 24;</pre></td></tr>
<tr class="covered"><td>1313</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SubKey[I shl 1] := A + B;</pre></td></tr>
<tr class="covered"><td>1314</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := A + B shl 1; &nbsp; &nbsp; // here buggy instead shr 1 it&apos;s correct shl 1</pre></td></tr>
<tr class="covered"><td>1315</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SubKey[I shl 1 + 1] := B shl 9 or B shr 23;</pre></td></tr>
<tr class="covered"><td>1316</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(J, $02020202);</pre></td></tr>
<tr class="covered"><td>1317</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1318</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1319</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1320</td><td><pre style="display:inline;"> &nbsp;procedure DoXOR(D, S: PUInt32Array; Value: UInt32);</pre></td></tr>
<tr class="nocodegen"><td>1321</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1322</td><td><pre style="display:inline;"> &nbsp; &nbsp;I: UInt32;</pre></td></tr>
<tr class="covered"><td>1323</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1324</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := (Value and $FF) * $01010101;</pre></td></tr>
<tr class="covered"><td>1325</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 63 do</pre></td></tr>
<tr class="covered"><td>1326</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D[I] := S[I] xor Value;</pre></td></tr>
<tr class="covered"><td>1327</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1328</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1329</td><td><pre style="display:inline;"> &nbsp;procedure SetupBox128;</pre></td></tr>
<tr class="nocodegen"><td>1330</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1331</td><td><pre style="display:inline;"> &nbsp; &nbsp;L: array[0..255] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>1332</td><td><pre style="display:inline;"> &nbsp; &nbsp;A, I: Integer;</pre></td></tr>
<tr class="covered"><td>1333</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1334</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @Twofish_8x8[0], BoxKey[1].L);</pre></td></tr>
<tr class="covered"><td>1335</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].A;</pre></td></tr>
<tr class="covered"><td>1336</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="covered"><td>1337</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[0, I] := Twofish_Data[0, Twofish_8x8[0, L[I]] xor A];</pre></td></tr>
<tr class="covered"><td>1338</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @Twofish_8x8[1], BoxKey[1].L shr 8);</pre></td></tr>
<tr class="covered"><td>1339</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].B;</pre></td></tr>
<tr class="covered"><td>1340</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="covered"><td>1341</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[1, I] := Twofish_Data[1, Twofish_8x8[0, L[I]] xor A];</pre></td></tr>
<tr class="covered"><td>1342</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @Twofish_8x8[0], BoxKey[1].L shr 16);</pre></td></tr>
<tr class="covered"><td>1343</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].C;</pre></td></tr>
<tr class="covered"><td>1344</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="covered"><td>1345</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[2, I] := Twofish_Data[2, Twofish_8x8[1, L[I]] xor A];</pre></td></tr>
<tr class="covered"><td>1346</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @Twofish_8x8[1], BoxKey[1].L shr 24);</pre></td></tr>
<tr class="covered"><td>1347</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].D;</pre></td></tr>
<tr class="covered"><td>1348</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="covered"><td>1349</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[3, I] := Twofish_Data[3, Twofish_8x8[1, L[I]] xor A];</pre></td></tr>
<tr class="covered"><td>1350</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1351</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1352</td><td><pre style="display:inline;"> &nbsp;procedure SetupBox192;</pre></td></tr>
<tr class="nocodegen"><td>1353</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1354</td><td><pre style="display:inline;"> &nbsp; &nbsp;L: array[0..255] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>1355</td><td><pre style="display:inline;"> &nbsp; &nbsp;A, B, I: Integer;</pre></td></tr>
<tr class="notcovered"><td>1356</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>1357</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @Twofish_8x8[1], BoxKey[2].L);</pre></td></tr>
<tr class="notcovered"><td>1358</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].A;</pre></td></tr>
<tr class="notcovered"><td>1359</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].A;</pre></td></tr>
<tr class="notcovered"><td>1360</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1361</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[0, I] := Twofish_Data[0, Twofish_8x8[0, Twofish_8x8[0, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1362</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @Twofish_8x8[1], BoxKey[2].L shr 8);</pre></td></tr>
<tr class="notcovered"><td>1363</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].B;</pre></td></tr>
<tr class="notcovered"><td>1364</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].B;</pre></td></tr>
<tr class="notcovered"><td>1365</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1366</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[1, I] := Twofish_Data[1, Twofish_8x8[0, Twofish_8x8[1, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1367</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @Twofish_8x8[0], BoxKey[2].L shr 16);</pre></td></tr>
<tr class="notcovered"><td>1368</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].C;</pre></td></tr>
<tr class="notcovered"><td>1369</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].C;</pre></td></tr>
<tr class="notcovered"><td>1370</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1371</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[2, I] := Twofish_Data[2, Twofish_8x8[1, Twofish_8x8[0, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1372</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L ,@Twofish_8x8[0], BoxKey[2].L shr 24);</pre></td></tr>
<tr class="notcovered"><td>1373</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].D;</pre></td></tr>
<tr class="notcovered"><td>1374</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].D;</pre></td></tr>
<tr class="notcovered"><td>1375</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1376</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[3, I] := Twofish_Data[3, Twofish_8x8[1, Twofish_8x8[1, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1377</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1378</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1379</td><td><pre style="display:inline;"> &nbsp;procedure SetupBox256;</pre></td></tr>
<tr class="nocodegen"><td>1380</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1381</td><td><pre style="display:inline;"> &nbsp; &nbsp;L: array[0..255] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>1382</td><td><pre style="display:inline;"> &nbsp; &nbsp;K: array[0..255] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>1383</td><td><pre style="display:inline;"> &nbsp; &nbsp;A, B, I: Integer;</pre></td></tr>
<tr class="notcovered"><td>1384</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>1385</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@K, @Twofish_8x8[1], BoxKey[3].L);</pre></td></tr>
<tr class="notcovered"><td>1386</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1387</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;L[I] := Twofish_8x8[1, K[I]];</pre></td></tr>
<tr class="notcovered"><td>1388</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @L, BoxKey[2].L);</pre></td></tr>
<tr class="notcovered"><td>1389</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].A;</pre></td></tr>
<tr class="notcovered"><td>1390</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].A;</pre></td></tr>
<tr class="notcovered"><td>1391</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1392</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[0, I] := Twofish_Data[0, Twofish_8x8[0, Twofish_8x8[0, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1393</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@K, @Twofish_8x8[0], BoxKey[3].L shr 8);</pre></td></tr>
<tr class="notcovered"><td>1394</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1395</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;L[I] := Twofish_8x8[1, K[I]];</pre></td></tr>
<tr class="notcovered"><td>1396</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @L, BoxKey[2].L shr 8);</pre></td></tr>
<tr class="notcovered"><td>1397</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].B;</pre></td></tr>
<tr class="notcovered"><td>1398</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].B;</pre></td></tr>
<tr class="notcovered"><td>1399</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1400</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[1, I] := Twofish_Data[1, Twofish_8x8[0, Twofish_8x8[1, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1401</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@K, @Twofish_8x8[0], BoxKey[3].L shr 16);</pre></td></tr>
<tr class="notcovered"><td>1402</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1403</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;L[I] := Twofish_8x8[0, K[I]];</pre></td></tr>
<tr class="notcovered"><td>1404</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @L, BoxKey[2].L shr 16);</pre></td></tr>
<tr class="notcovered"><td>1405</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].C;</pre></td></tr>
<tr class="notcovered"><td>1406</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].C;</pre></td></tr>
<tr class="notcovered"><td>1407</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1408</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[2, I] := Twofish_Data[2, Twofish_8x8[1, Twofish_8x8[0, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1409</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@K, @Twofish_8x8[1], BoxKey[3].L shr 24);</pre></td></tr>
<tr class="notcovered"><td>1410</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1411</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;L[I] := Twofish_8x8[0, K[I]];</pre></td></tr>
<tr class="notcovered"><td>1412</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoXOR(@L, @L, BoxKey[2].L shr 24);</pre></td></tr>
<tr class="notcovered"><td>1413</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := BoxKey[0].D;</pre></td></tr>
<tr class="notcovered"><td>1414</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := BoxKey[1].D;</pre></td></tr>
<tr class="notcovered"><td>1415</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>1416</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Box[3, I] := Twofish_Data[3, Twofish_8x8[1, Twofish_8x8[1, L[I]] xor B] xor A];</pre></td></tr>
<tr class="notcovered"><td>1417</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1418</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1419</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1420</td><td><pre style="display:inline;"> &nbsp;SubKey := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1421</td><td><pre style="display:inline;"> &nbsp;Box &nbsp; &nbsp;:= @SubKey[40];</pre></td></tr>
<tr class="covered"><td>1422</td><td><pre style="display:inline;"> &nbsp;SetupKey;</pre></td></tr>
<tr class="covered"><td>1423</td><td><pre style="display:inline;"> &nbsp;if Size = 16 then</pre></td></tr>
<tr class="covered"><td>1424</td><td><pre style="display:inline;"> &nbsp; &nbsp;SetupBox128</pre></td></tr>
<tr class="nocodegen"><td>1425</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>1426</td><td><pre style="display:inline;"> &nbsp;if Size = 24 then</pre></td></tr>
<tr class="notcovered"><td>1427</td><td><pre style="display:inline;"> &nbsp; &nbsp;SetupBox192</pre></td></tr>
<tr class="nocodegen"><td>1428</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>1429</td><td><pre style="display:inline;"> &nbsp; &nbsp;SetupBox256;</pre></td></tr>
<tr class="nocodegen"><td>1430</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1431</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>1432</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1433</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1434</td><td><pre style="display:inline;">procedure TCipher_Twofish.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1435</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1436</td><td><pre style="display:inline;"> &nbsp;S: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>1437</td><td><pre style="display:inline;"> &nbsp;Box: PTwofishBox;</pre></td></tr>
<tr class="nocodegen"><td>1438</td><td><pre style="display:inline;"> &nbsp;I, X, Y: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1439</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: TLongRec;</pre></td></tr>
<tr class="covered"><td>1440</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1441</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>1442</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1443</td><td><pre style="display:inline;"> &nbsp;S &nbsp; := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1444</td><td><pre style="display:inline;"> &nbsp;A.L := PUInt32Array(Source)[0] xor S[0];</pre></td></tr>
<tr class="covered"><td>1445</td><td><pre style="display:inline;"> &nbsp;B.L := PUInt32Array(Source)[1] xor S[1];</pre></td></tr>
<tr class="covered"><td>1446</td><td><pre style="display:inline;"> &nbsp;C.L := PUInt32Array(Source)[2] xor S[2];</pre></td></tr>
<tr class="covered"><td>1447</td><td><pre style="display:inline;"> &nbsp;D.L := PUInt32Array(Source)[3] xor S[3];</pre></td></tr>
<tr class="nocodegen"><td>1448</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1449</td><td><pre style="display:inline;"> &nbsp;Box := @S[40];</pre></td></tr>
<tr class="covered"><td>1450</td><td><pre style="display:inline;"> &nbsp;S &nbsp; := @S[8];</pre></td></tr>
<tr class="covered"><td>1451</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>1452</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1453</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := Box[0, A.A] xor Box[1, A.B] xor Box[2, A.C] xor Box[3, A.D];</pre></td></tr>
<tr class="covered"><td>1454</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := Box[1, B.A] xor Box[2, B.B] xor Box[3, B.C] xor Box[0, B.D];</pre></td></tr>
<tr class="covered"><td>1455</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.L := D.L shl 1 or D.L shr 31;</pre></td></tr>
<tr class="covered"><td>1456</td><td><pre style="display:inline;"> &nbsp; &nbsp;C.L := C.L xor (X + Y &nbsp; &nbsp; &nbsp; + S[0]);</pre></td></tr>
<tr class="covered"><td>1457</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.L := D.L xor (X + Y shl 1 + S[1]);</pre></td></tr>
<tr class="covered"><td>1458</td><td><pre style="display:inline;"> &nbsp; &nbsp;C.L := C.L shr 1 or C.L shl 31;</pre></td></tr>
<tr class="nocodegen"><td>1459</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1460</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := Box[0, C.A] xor Box[1, C.B] xor Box[2, C.C] xor Box[3, C.D];</pre></td></tr>
<tr class="covered"><td>1461</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := Box[1, D.A] xor Box[2, D.B] xor Box[3, D.C] xor Box[0, D.D];</pre></td></tr>
<tr class="covered"><td>1462</td><td><pre style="display:inline;"> &nbsp; &nbsp;B.L := B.L shl 1 or B.L shr 31;</pre></td></tr>
<tr class="covered"><td>1463</td><td><pre style="display:inline;"> &nbsp; &nbsp;A.L := A.L xor (X + Y &nbsp; &nbsp; &nbsp; + S[2]);</pre></td></tr>
<tr class="covered"><td>1464</td><td><pre style="display:inline;"> &nbsp; &nbsp;B.L := B.L xor (X + Y shl 1 + S[3]);</pre></td></tr>
<tr class="covered"><td>1465</td><td><pre style="display:inline;"> &nbsp; &nbsp;A.L := A.L shr 1 or A.L shl 31;</pre></td></tr>
<tr class="nocodegen"><td>1466</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1467</td><td><pre style="display:inline;"> &nbsp; &nbsp;S := @S[4];</pre></td></tr>
<tr class="covered"><td>1468</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1469</td><td><pre style="display:inline;"> &nbsp;S := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1470</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := C.L xor S[4];</pre></td></tr>
<tr class="covered"><td>1471</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := D.L xor S[5];</pre></td></tr>
<tr class="covered"><td>1472</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := A.L xor S[6];</pre></td></tr>
<tr class="covered"><td>1473</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := B.L xor S[7];</pre></td></tr>
<tr class="covered"><td>1474</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1475</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1476</td><td><pre style="display:inline;">procedure TCipher_Twofish.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1477</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1478</td><td><pre style="display:inline;"> &nbsp;S: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>1479</td><td><pre style="display:inline;"> &nbsp;Box: PTwofishBox;</pre></td></tr>
<tr class="nocodegen"><td>1480</td><td><pre style="display:inline;"> &nbsp;I, X, Y: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1481</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: TLongRec;</pre></td></tr>
<tr class="covered"><td>1482</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1483</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>1484</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1485</td><td><pre style="display:inline;"> &nbsp;S := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1486</td><td><pre style="display:inline;"> &nbsp;Box := @S[40];</pre></td></tr>
<tr class="covered"><td>1487</td><td><pre style="display:inline;"> &nbsp;C.L := PUInt32Array(Source)[0] xor S[4];</pre></td></tr>
<tr class="covered"><td>1488</td><td><pre style="display:inline;"> &nbsp;D.L := PUInt32Array(Source)[1] xor S[5];</pre></td></tr>
<tr class="covered"><td>1489</td><td><pre style="display:inline;"> &nbsp;A.L := PUInt32Array(Source)[2] xor S[6];</pre></td></tr>
<tr class="covered"><td>1490</td><td><pre style="display:inline;"> &nbsp;B.L := PUInt32Array(Source)[3] xor S[7];</pre></td></tr>
<tr class="covered"><td>1491</td><td><pre style="display:inline;"> &nbsp;S := @S[36];</pre></td></tr>
<tr class="covered"><td>1492</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>1493</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1494</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := Box[0, C.A] xor Box[1, C.B] xor Box[2, C.C] xor Box[3, C.D];</pre></td></tr>
<tr class="covered"><td>1495</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := Box[0, D.D] xor Box[1, D.A] xor Box[2, D.B] xor Box[3, D.C];</pre></td></tr>
<tr class="covered"><td>1496</td><td><pre style="display:inline;"> &nbsp; &nbsp;A.L := A.L shl 1 or A.L shr 31;</pre></td></tr>
<tr class="covered"><td>1497</td><td><pre style="display:inline;"> &nbsp; &nbsp;B.L := B.L xor (X + Y shl 1 + S[3]);</pre></td></tr>
<tr class="covered"><td>1498</td><td><pre style="display:inline;"> &nbsp; &nbsp;A.L := A.L xor (X + Y &nbsp; &nbsp; &nbsp; + S[2]);</pre></td></tr>
<tr class="covered"><td>1499</td><td><pre style="display:inline;"> &nbsp; &nbsp;B.L := B.L shr 1 or B.L shl 31;</pre></td></tr>
<tr class="nocodegen"><td>1500</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1501</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := Box[0, A.A] xor Box[1, A.B] xor Box[2, A.C] xor Box[3, A.D];</pre></td></tr>
<tr class="covered"><td>1502</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := Box[0, B.D] xor Box[1, B.A] xor Box[2, B.B] xor Box[3, B.C];</pre></td></tr>
<tr class="covered"><td>1503</td><td><pre style="display:inline;"> &nbsp; &nbsp;C.L := C.L shl 1 or C.L shr 31;</pre></td></tr>
<tr class="covered"><td>1504</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.L := D.L xor (X + Y shl 1 + S[1]);</pre></td></tr>
<tr class="covered"><td>1505</td><td><pre style="display:inline;"> &nbsp; &nbsp;C.L := C.L xor (X + Y &nbsp; &nbsp; &nbsp; + S[0]);</pre></td></tr>
<tr class="covered"><td>1506</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.L := D.L shr 1 or D.L shl 31;</pre></td></tr>
<tr class="nocodegen"><td>1507</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1508</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(S), 4);</pre></td></tr>
<tr class="covered"><td>1509</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1510</td><td><pre style="display:inline;"> &nbsp;S := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1511</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A.L xor S[0];</pre></td></tr>
<tr class="covered"><td>1512</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B.L xor S[1];</pre></td></tr>
<tr class="covered"><td>1513</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := C.L xor S[2];</pre></td></tr>
<tr class="covered"><td>1514</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := D.L xor S[3];</pre></td></tr>
<tr class="covered"><td>1515</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1516</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1517</td><td><pre style="display:inline;">{ TCipher_IDEA }</pre></td></tr>
<tr class="nocodegen"><td>1518</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1519</td><td><pre style="display:inline;">class function TCipher_IDEA.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>1520</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1521</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>1522</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>1523</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>1524</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 208;</pre></td></tr>
<tr class="covered"><td>1525</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>1526</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1527</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1528</td><td><pre style="display:inline;"> &nbsp;Result.CipherType := [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>1529</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1530</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1531</td><td><pre style="display:inline;">procedure TCipher_IDEA.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1532</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1533</td><td><pre style="display:inline;"> &nbsp;function IDEAInv(X: Word): Word;</pre></td></tr>
<tr class="nocodegen"><td>1534</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1535</td><td><pre style="display:inline;"> &nbsp; &nbsp;A, B, C, D: Word;</pre></td></tr>
<tr class="covered"><td>1536</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1537</td><td><pre style="display:inline;"> &nbsp; &nbsp;if X &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>1538</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1539</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := X;</pre></td></tr>
<tr class="covered"><td>1540</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Exit;</pre></td></tr>
<tr class="nocodegen"><td>1541</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1542</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := 1;</pre></td></tr>
<tr class="covered"><td>1543</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := $10001 div X;</pre></td></tr>
<tr class="covered"><td>1544</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := $10001 mod X;</pre></td></tr>
<tr class="covered"><td>1545</td><td><pre style="display:inline;"> &nbsp; &nbsp;while C &lt;&gt; 1 do</pre></td></tr>
<tr class="nocodegen"><td>1546</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1547</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := X div C;</pre></td></tr>
<tr class="covered"><td>1548</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X := X mod C;</pre></td></tr>
<tr class="covered"><td>1549</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(A, B * D);</pre></td></tr>
<tr class="covered"><td>1550</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if X = 1 then</pre></td></tr>
<tr class="nocodegen"><td>1551</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1552</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Result := A;</pre></td></tr>
<tr class="covered"><td>1553</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Exit;</pre></td></tr>
<tr class="nocodegen"><td>1554</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1555</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := C div X;</pre></td></tr>
<tr class="covered"><td>1556</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C mod X;</pre></td></tr>
<tr class="covered"><td>1557</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(B, A * D);</pre></td></tr>
<tr class="nocodegen"><td>1558</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1559</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := 1 - B;</pre></td></tr>
<tr class="covered"><td>1560</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1561</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1562</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1563</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>1564</td><td><pre style="display:inline;"> &nbsp;E: PWordArray;</pre></td></tr>
<tr class="nocodegen"><td>1565</td><td><pre style="display:inline;"> &nbsp;A, B, C: Word;</pre></td></tr>
<tr class="nocodegen"><td>1566</td><td><pre style="display:inline;"> &nbsp;K, D: PWordArray;</pre></td></tr>
<tr class="covered"><td>1567</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1568</td><td><pre style="display:inline;"> &nbsp;E := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1569</td><td><pre style="display:inline;"> &nbsp;Move(Key, E^, Size);</pre></td></tr>
<tr class="covered"><td>1570</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="covered"><td>1571</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[I] := Swap(E[I]);</pre></td></tr>
<tr class="covered"><td>1572</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 39 do</pre></td></tr>
<tr class="covered"><td>1573</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[I + 8] := E[I and not 7 + (I + 1) and 7] shl 9 or</pre></td></tr>
<tr class="covered"><td>1574</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;E[I and not 7 + (I + 2) and 7] shr 7;</pre></td></tr>
<tr class="covered"><td>1575</td><td><pre style="display:inline;"> &nbsp;for I := 41 to 44 do</pre></td></tr>
<tr class="covered"><td>1576</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[I + 7] := E[I] shl 9 or E[I + 1] shr 7;</pre></td></tr>
<tr class="covered"><td>1577</td><td><pre style="display:inline;"> &nbsp;K &nbsp;:= E;</pre></td></tr>
<tr class="covered"><td>1578</td><td><pre style="display:inline;"> &nbsp;D &nbsp;:= @E[100];</pre></td></tr>
<tr class="covered"><td>1579</td><td><pre style="display:inline;"> &nbsp;A &nbsp;:= IDEAInv(K[0]);</pre></td></tr>
<tr class="covered"><td>1580</td><td><pre style="display:inline;"> &nbsp;B &nbsp;:= 0 - K[1];</pre></td></tr>
<tr class="covered"><td>1581</td><td><pre style="display:inline;"> &nbsp;C &nbsp;:= 0 - K[2];</pre></td></tr>
<tr class="covered"><td>1582</td><td><pre style="display:inline;"> &nbsp;D[3] := IDEAInv(K[3]);</pre></td></tr>
<tr class="covered"><td>1583</td><td><pre style="display:inline;"> &nbsp;D[2] := C;</pre></td></tr>
<tr class="covered"><td>1584</td><td><pre style="display:inline;"> &nbsp;D[1] := B;</pre></td></tr>
<tr class="covered"><td>1585</td><td><pre style="display:inline;"> &nbsp;D[0] := A;</pre></td></tr>
<tr class="covered"><td>1586</td><td><pre style="display:inline;"> &nbsp;Inc(PWord(K), 4);</pre></td></tr>
<tr class="covered"><td>1587</td><td><pre style="display:inline;"> &nbsp;for I := 1 to 8 do</pre></td></tr>
<tr class="nocodegen"><td>1588</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1589</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PWord(D), 6);</pre></td></tr>
<tr class="covered"><td>1590</td><td><pre style="display:inline;"> &nbsp; &nbsp;A &nbsp; &nbsp;:= K[0];</pre></td></tr>
<tr class="covered"><td>1591</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[5] := K[1];</pre></td></tr>
<tr class="covered"><td>1592</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[4] := A;</pre></td></tr>
<tr class="covered"><td>1593</td><td><pre style="display:inline;"> &nbsp; &nbsp;A &nbsp; &nbsp;:= IDEAInv(K[2]);</pre></td></tr>
<tr class="covered"><td>1594</td><td><pre style="display:inline;"> &nbsp; &nbsp;B &nbsp; &nbsp;:= 0 - K[3];</pre></td></tr>
<tr class="covered"><td>1595</td><td><pre style="display:inline;"> &nbsp; &nbsp;C &nbsp; &nbsp;:= 0 - K[4];</pre></td></tr>
<tr class="covered"><td>1596</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[3] := IDEAInv(K[5]);</pre></td></tr>
<tr class="covered"><td>1597</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[2] := B;</pre></td></tr>
<tr class="covered"><td>1598</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[1] := C;</pre></td></tr>
<tr class="covered"><td>1599</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[0] := A;</pre></td></tr>
<tr class="covered"><td>1600</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(PWord(K), 6);</pre></td></tr>
<tr class="covered"><td>1601</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1602</td><td><pre style="display:inline;"> &nbsp;A &nbsp; &nbsp;:= D[2];</pre></td></tr>
<tr class="covered"><td>1603</td><td><pre style="display:inline;"> &nbsp;D[2] := D[1];</pre></td></tr>
<tr class="covered"><td>1604</td><td><pre style="display:inline;"> &nbsp;D[1] := A;</pre></td></tr>
<tr class="nocodegen"><td>1605</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1606</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>1607</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1608</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1609</td><td><pre style="display:inline;">function IDEAMul(X, Y: UInt32): UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1610</td><td><pre style="display:inline;">{$IF defined(X86ASM) or defined(X64ASM)}</pre></td></tr>
<tr class="nocodegen"><td>1611</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="nocodegen"><td>1612</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$IFDEF X64ASM}</pre></td></tr>
<tr class="nocodegen"><td>1613</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,ECX</pre></td></tr>
<tr class="nocodegen"><td>1614</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ENDIF X64ASM}</pre></td></tr>
<tr class="covered"><td>1615</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,0FFFFh</pre></td></tr>
<tr class="covered"><td>1616</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; JZ &nbsp; &nbsp; @@1</pre></td></tr>
<tr class="covered"><td>1617</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EDX,0FFFFh</pre></td></tr>
<tr class="covered"><td>1618</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; JZ &nbsp; &nbsp; @@1</pre></td></tr>
<tr class="covered"><td>1619</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MUL &nbsp; &nbsp;EDX</pre></td></tr>
<tr class="covered"><td>1620</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EDX,EAX</pre></td></tr>
<tr class="covered"><td>1621</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;ECX,EAX</pre></td></tr>
<tr class="covered"><td>1622</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; SHR &nbsp; &nbsp;EDX,16</pre></td></tr>
<tr class="covered"><td>1623</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; SUB &nbsp; &nbsp;EAX,EDX</pre></td></tr>
<tr class="covered"><td>1624</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; SUB &nbsp; &nbsp;CX,AX</pre></td></tr>
<tr class="covered"><td>1625</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADC &nbsp; &nbsp;EAX,0</pre></td></tr>
<tr class="covered"><td>1626</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; RET</pre></td></tr>
<tr class="covered"><td>1627</td><td><pre style="display:inline;">@@1: &nbsp; LEA &nbsp; &nbsp;EAX,[EAX + EDX - 1]</pre></td></tr>
<tr class="covered"><td>1628</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; NEG &nbsp; &nbsp;EAX</pre></td></tr>
<tr class="covered"><td>1629</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1630</td><td><pre style="display:inline;">{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>1631</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1632</td><td><pre style="display:inline;"> &nbsp;X := X and $FFFF;</pre></td></tr>
<tr class="nocodegen"><td>1633</td><td><pre style="display:inline;"> &nbsp;if X &lt;&gt; 0 then</pre></td></tr>
<tr class="nocodegen"><td>1634</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1635</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := Y and $FFFF;</pre></td></tr>
<tr class="nocodegen"><td>1636</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Y &lt;&gt; 0 then</pre></td></tr>
<tr class="nocodegen"><td>1637</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1638</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X := X * Y;</pre></td></tr>
<tr class="nocodegen"><td>1639</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := X - (X shr 16);</pre></td></tr>
<tr class="nocodegen"><td>1640</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if Word(X) &lt; Word(Result) then // carry flag check for &quot;sub cx,ax&quot;</pre></td></tr>
<tr class="nocodegen"><td>1641</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(Result);</pre></td></tr>
<tr class="nocodegen"><td>1642</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Exit;</pre></td></tr>
<tr class="nocodegen"><td>1643</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1644</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1645</td><td><pre style="display:inline;"> &nbsp;Result := -(X + Y - 1);</pre></td></tr>
<tr class="nocodegen"><td>1646</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1647</td><td><pre style="display:inline;">{$IFEND}</pre></td></tr>
<tr class="nocodegen"><td>1648</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1649</td><td><pre style="display:inline;">procedure IDEACipher(Source, Dest: PUInt32Array; Key: PWordArray);</pre></td></tr>
<tr class="nocodegen"><td>1650</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1651</td><td><pre style="display:inline;"> &nbsp;I: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1652</td><td><pre style="display:inline;"> &nbsp;X, Y, A, B, C, D: UInt32;</pre></td></tr>
<tr class="covered"><td>1653</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1654</td><td><pre style="display:inline;"> &nbsp;I := SwapUInt32(Source[0]);</pre></td></tr>
<tr class="covered"><td>1655</td><td><pre style="display:inline;"> &nbsp;A := I shr 16;</pre></td></tr>
<tr class="covered"><td>1656</td><td><pre style="display:inline;"> &nbsp;B := I and $FFFF;</pre></td></tr>
<tr class="covered"><td>1657</td><td><pre style="display:inline;"> &nbsp;I := SwapUInt32(Source[1]);</pre></td></tr>
<tr class="covered"><td>1658</td><td><pre style="display:inline;"> &nbsp;C := I shr 16;</pre></td></tr>
<tr class="covered"><td>1659</td><td><pre style="display:inline;"> &nbsp;D := I and $FFFF;</pre></td></tr>
<tr class="covered"><td>1660</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>1661</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1662</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := IDEAMul(A, Key[0]);</pre></td></tr>
<tr class="covered"><td>1663</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, Key[1]);</pre></td></tr>
<tr class="covered"><td>1664</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, Key[2]);</pre></td></tr>
<tr class="covered"><td>1665</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := IDEAMul(D, Key[3]);</pre></td></tr>
<tr class="covered"><td>1666</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := C xor A;</pre></td></tr>
<tr class="covered"><td>1667</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := IDEAMul(Y, Key[4]);</pre></td></tr>
<tr class="covered"><td>1668</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := B xor D + Y;</pre></td></tr>
<tr class="covered"><td>1669</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := IDEAMul(X, Key[5]);</pre></td></tr>
<tr class="covered"><td>1670</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Y, X);</pre></td></tr>
<tr class="covered"><td>1671</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor X;</pre></td></tr>
<tr class="covered"><td>1672</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Y;</pre></td></tr>
<tr class="covered"><td>1673</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := B xor Y;</pre></td></tr>
<tr class="covered"><td>1674</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := C xor X;</pre></td></tr>
<tr class="covered"><td>1675</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := Y;</pre></td></tr>
<tr class="covered"><td>1676</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key := @Key[6];</pre></td></tr>
<tr class="covered"><td>1677</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1678</td><td><pre style="display:inline;"> &nbsp;Dest[0] := SwapUInt32(IDEAMul(A, Key[0]) shl 16 or (C + Key[1]) and $FFFF);</pre></td></tr>
<tr class="covered"><td>1679</td><td><pre style="display:inline;"> &nbsp;Dest[1] := SwapUInt32((B + Key[2]) shl 16 or IDEAMul(D, Key[3]) and $FFFF);</pre></td></tr>
<tr class="covered"><td>1680</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1681</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1682</td><td><pre style="display:inline;">procedure TCipher_IDEA.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>1683</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1684</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>1685</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1686</td><td><pre style="display:inline;"> &nbsp;IDEACipher(Source, Dest, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>1687</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1688</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1689</td><td><pre style="display:inline;">procedure TCipher_IDEA.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>1690</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1691</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>1692</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1693</td><td><pre style="display:inline;"> &nbsp;IDEACipher(Source, Dest, @PUInt32Array(FAdditionalBuffer)[26]);</pre></td></tr>
<tr class="covered"><td>1694</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1695</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1696</td><td><pre style="display:inline;">{ TCipher_Cast256 }</pre></td></tr>
<tr class="nocodegen"><td>1697</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1698</td><td><pre style="display:inline;">class function TCipher_Cast256.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>1699</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1700</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 32;</pre></td></tr>
<tr class="covered"><td>1701</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>1702</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>1703</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 384;</pre></td></tr>
<tr class="covered"><td>1704</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>1705</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1706</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1707</td><td><pre style="display:inline;"> &nbsp;Result.CipherType := [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>1708</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1709</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1710</td><td><pre style="display:inline;">procedure TCipher_Cast256.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1711</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1712</td><td><pre style="display:inline;"> &nbsp;X: array[0..7] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1713</td><td><pre style="display:inline;"> &nbsp;M, R, I, J, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1714</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>1715</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1716</td><td><pre style="display:inline;"> &nbsp;FillChar(X, SizeOf(X), 0);</pre></td></tr>
<tr class="covered"><td>1717</td><td><pre style="display:inline;"> &nbsp;Move(Key, X, Size);</pre></td></tr>
<tr class="covered"><td>1718</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(X, X, 8);</pre></td></tr>
<tr class="covered"><td>1719</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1720</td><td><pre style="display:inline;"> &nbsp;M := $5A827999;</pre></td></tr>
<tr class="covered"><td>1721</td><td><pre style="display:inline;"> &nbsp;R := 19;</pre></td></tr>
<tr class="covered"><td>1722</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 11 do</pre></td></tr>
<tr class="nocodegen"><td>1723</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1724</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 1 do</pre></td></tr>
<tr class="nocodegen"><td>1725</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1726</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M + X[7];</pre></td></tr>
<tr class="covered"><td>1727</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1728</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[6] := X[6] xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1729</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1730</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1731</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1732</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1733</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1734</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M xor X[6];</pre></td></tr>
<tr class="covered"><td>1735</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1736</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[5] := X[5] xor (Cast256_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>1737</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1738</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1739</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1740</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1741</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1742</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M - X[5];</pre></td></tr>
<tr class="covered"><td>1743</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1744</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[4] := X[4] xor (Cast256_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>1745</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1746</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1747</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1748</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1749</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1750</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M + X[4];</pre></td></tr>
<tr class="covered"><td>1751</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1752</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[3] := X[3] xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1753</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1754</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1755</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1756</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1757</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1758</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M xor X[3];</pre></td></tr>
<tr class="covered"><td>1759</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1760</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[2] := X[2] xor (Cast256_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>1761</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1762</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1763</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1764</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1765</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1766</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M - X[2];</pre></td></tr>
<tr class="covered"><td>1767</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1768</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[1] := X[1] xor (Cast256_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>1769</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1770</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1771</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1772</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1773</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1774</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M + X[1];</pre></td></tr>
<tr class="covered"><td>1775</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1776</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[0] := X[0] xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1777</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1778</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1779</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1780</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1781</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1782</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := M xor X[0];</pre></td></tr>
<tr class="covered"><td>1783</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl R or T shr (32 - R);</pre></td></tr>
<tr class="covered"><td>1784</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[7] := X[7] xor (Cast256_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>1785</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1786</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1787</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1788</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(M, $6ED9EBA1);</pre></td></tr>
<tr class="covered"><td>1789</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(R, 17);</pre></td></tr>
<tr class="covered"><td>1790</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1791</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt; 6 then</pre></td></tr>
<tr class="nocodegen"><td>1792</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1793</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[48] := X[0] and $1F;</pre></td></tr>
<tr class="covered"><td>1794</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[49] := X[2] and $1F;</pre></td></tr>
<tr class="covered"><td>1795</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[50] := X[4] and $1F;</pre></td></tr>
<tr class="covered"><td>1796</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[51] := X[6] and $1F;</pre></td></tr>
<tr class="covered"><td>1797</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[0] := X[7];</pre></td></tr>
<tr class="covered"><td>1798</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[1] := X[5];</pre></td></tr>
<tr class="covered"><td>1799</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[2] := X[3];</pre></td></tr>
<tr class="covered"><td>1800</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[3] := X[1];</pre></td></tr>
<tr class="nocodegen"><td>1801</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>1802</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>1803</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1804</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[48] := X[6] and $1F;</pre></td></tr>
<tr class="covered"><td>1805</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[49] := X[4] and $1F;</pre></td></tr>
<tr class="covered"><td>1806</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[50] := X[2] and $1F;</pre></td></tr>
<tr class="covered"><td>1807</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[51] := X[0] and $1F;</pre></td></tr>
<tr class="covered"><td>1808</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[0] := X[1];</pre></td></tr>
<tr class="covered"><td>1809</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[1] := X[3];</pre></td></tr>
<tr class="covered"><td>1810</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[2] := X[5];</pre></td></tr>
<tr class="covered"><td>1811</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[3] := X[7];</pre></td></tr>
<tr class="nocodegen"><td>1812</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1813</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[4];</pre></td></tr>
<tr class="covered"><td>1814</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1815</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(X, SizeOf(X));</pre></td></tr>
<tr class="nocodegen"><td>1816</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1817</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>1818</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1819</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1820</td><td><pre style="display:inline;">procedure TCipher_Cast256.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1821</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1822</td><td><pre style="display:inline;"> &nbsp;I, T, A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1823</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>1824</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1825</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>1826</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1827</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>1828</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Source^, Dest^, 4);</pre></td></tr>
<tr class="covered"><td>1829</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Dest)[0];</pre></td></tr>
<tr class="covered"><td>1830</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>1831</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>1832</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Dest)[3];</pre></td></tr>
<tr class="covered"><td>1833</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 5 do</pre></td></tr>
<tr class="nocodegen"><td>1834</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1835</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[0] + D;</pre></td></tr>
<tr class="covered"><td>1836</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[48] or T shr (32 - K[48]);</pre></td></tr>
<tr class="covered"><td>1837</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1838</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1839</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1840</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1841</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[1] xor C;</pre></td></tr>
<tr class="covered"><td>1842</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[49] or T shr (32 - K[49]);</pre></td></tr>
<tr class="covered"><td>1843</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast256_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>1844</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1845</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1846</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1847</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[2] - B;</pre></td></tr>
<tr class="covered"><td>1848</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[50] or T shr (32 - K[50]);</pre></td></tr>
<tr class="covered"><td>1849</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast256_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>1850</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1851</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1852</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1853</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[3] + A;</pre></td></tr>
<tr class="covered"><td>1854</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[51] or T shr (32 - K[51]);</pre></td></tr>
<tr class="covered"><td>1855</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1856</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1857</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1858</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1859</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[4];</pre></td></tr>
<tr class="covered"><td>1860</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1861</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 5 do</pre></td></tr>
<tr class="nocodegen"><td>1862</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1863</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[0] + A;</pre></td></tr>
<tr class="covered"><td>1864</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[48] or T shr (32 - K[48]);</pre></td></tr>
<tr class="covered"><td>1865</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1866</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1867</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1868</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1869</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[1] - B;</pre></td></tr>
<tr class="covered"><td>1870</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[49] or T shr (32 - K[49]);</pre></td></tr>
<tr class="covered"><td>1871</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast256_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>1872</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1873</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1874</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1875</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[2] xor C;</pre></td></tr>
<tr class="covered"><td>1876</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[50] or T shr (32 - K[50]);</pre></td></tr>
<tr class="covered"><td>1877</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast256_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>1878</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1879</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1880</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1881</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[3] + D;</pre></td></tr>
<tr class="covered"><td>1882</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[51] or T shr (32 - K[51]);</pre></td></tr>
<tr class="covered"><td>1883</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1884</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1885</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1886</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1887</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[4];</pre></td></tr>
<tr class="covered"><td>1888</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1889</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A;</pre></td></tr>
<tr class="covered"><td>1890</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B;</pre></td></tr>
<tr class="covered"><td>1891</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := C;</pre></td></tr>
<tr class="covered"><td>1892</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := D;</pre></td></tr>
<tr class="covered"><td>1893</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Dest^, Dest^, 4);</pre></td></tr>
<tr class="covered"><td>1894</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1895</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1896</td><td><pre style="display:inline;">procedure TCipher_Cast256.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1897</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1898</td><td><pre style="display:inline;"> &nbsp;I, T, A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1899</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>1900</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1901</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>1902</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>1903</td><td><pre style="display:inline;"> &nbsp;K := @PUInt32Array(FAdditionalBuffer)[44];</pre></td></tr>
<tr class="covered"><td>1904</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Source^, Dest^, 4);</pre></td></tr>
<tr class="covered"><td>1905</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Dest)[0];</pre></td></tr>
<tr class="covered"><td>1906</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>1907</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>1908</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Dest)[3];</pre></td></tr>
<tr class="covered"><td>1909</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 5 do</pre></td></tr>
<tr class="nocodegen"><td>1910</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1911</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[3] + D;</pre></td></tr>
<tr class="covered"><td>1912</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[51] or T shr (32 - K[51]);</pre></td></tr>
<tr class="covered"><td>1913</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1914</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1915</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1916</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1917</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[2] xor C;</pre></td></tr>
<tr class="covered"><td>1918</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[50] or T shr (32 - K[50]);</pre></td></tr>
<tr class="covered"><td>1919</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast256_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>1920</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1921</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1922</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1923</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[1] - B;</pre></td></tr>
<tr class="covered"><td>1924</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[49] or T shr (32 - K[49]);</pre></td></tr>
<tr class="covered"><td>1925</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast256_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>1926</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1927</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1928</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1929</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[0] + A;</pre></td></tr>
<tr class="covered"><td>1930</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[48] or T shr (32 - K[48]);</pre></td></tr>
<tr class="covered"><td>1931</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1932</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1933</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1934</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1935</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 4);</pre></td></tr>
<tr class="covered"><td>1936</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1937</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 5 do</pre></td></tr>
<tr class="nocodegen"><td>1938</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1939</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[3] + A;</pre></td></tr>
<tr class="covered"><td>1940</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[51] or T shr (32 - K[51]);</pre></td></tr>
<tr class="covered"><td>1941</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1942</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1943</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1944</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1945</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[2] - B;</pre></td></tr>
<tr class="covered"><td>1946</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[50] or T shr (32 - K[50]);</pre></td></tr>
<tr class="covered"><td>1947</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast256_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>1948</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1949</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1950</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1951</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[1] xor C;</pre></td></tr>
<tr class="covered"><td>1952</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[49] or T shr (32 - K[49]);</pre></td></tr>
<tr class="covered"><td>1953</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast256_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>1954</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1955</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>1956</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1957</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[0] + D;</pre></td></tr>
<tr class="covered"><td>1958</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[48] or T shr (32 - K[48]);</pre></td></tr>
<tr class="covered"><td>1959</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor (Cast256_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>1960</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>1961</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>1962</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast256_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>1963</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 4);</pre></td></tr>
<tr class="covered"><td>1964</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1965</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A;</pre></td></tr>
<tr class="covered"><td>1966</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B;</pre></td></tr>
<tr class="covered"><td>1967</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := C;</pre></td></tr>
<tr class="covered"><td>1968</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := D;</pre></td></tr>
<tr class="covered"><td>1969</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Dest^, Dest^, 4);</pre></td></tr>
<tr class="covered"><td>1970</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1971</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1972</td><td><pre style="display:inline;">{ TCipher_Mars }</pre></td></tr>
<tr class="nocodegen"><td>1973</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1974</td><td><pre style="display:inline;">class function TCipher_Mars.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>1975</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1976</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 56;</pre></td></tr>
<tr class="covered"><td>1977</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>1978</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>1979</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 160;</pre></td></tr>
<tr class="covered"><td>1980</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>1981</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1982</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>1983</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>1984</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1985</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1986</td><td><pre style="display:inline;">procedure TCipher_Mars.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>1987</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1988</td><td><pre style="display:inline;"> &nbsp;B: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>1989</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1990</td><td><pre style="display:inline;"> &nbsp;function FixKey(K, R: UInt32): UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1991</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>1992</td><td><pre style="display:inline;"> &nbsp; &nbsp;M1, M2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1993</td><td><pre style="display:inline;"> &nbsp; &nbsp;I: UInt32;</pre></td></tr>
<tr class="covered"><td>1994</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1995</td><td><pre style="display:inline;"> &nbsp; &nbsp;I := K and 3;</pre></td></tr>
<tr class="covered"><td>1996</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := K or 3;</pre></td></tr>
<tr class="covered"><td>1997</td><td><pre style="display:inline;"> &nbsp; &nbsp;M1 := not K xor (K shl 1);</pre></td></tr>
<tr class="covered"><td>1998</td><td><pre style="display:inline;"> &nbsp; &nbsp;M2 := M1 and (M1 shl 1);</pre></td></tr>
<tr class="covered"><td>1999</td><td><pre style="display:inline;"> &nbsp; &nbsp;M2 := M2 and (M2 shl 2);</pre></td></tr>
<tr class="covered"><td>2000</td><td><pre style="display:inline;"> &nbsp; &nbsp;M2 := M2 and (M2 shl 4);</pre></td></tr>
<tr class="covered"><td>2001</td><td><pre style="display:inline;"> &nbsp; &nbsp;M2 := M2 and (M1 shl 8);</pre></td></tr>
<tr class="covered"><td>2002</td><td><pre style="display:inline;"> &nbsp; &nbsp;M2 := M2 and $FFFFFE00;</pre></td></tr>
<tr class="covered"><td>2003</td><td><pre style="display:inline;"> &nbsp; &nbsp;if M2 = 0 then</pre></td></tr>
<tr class="nocodegen"><td>2004</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2005</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := K;</pre></td></tr>
<tr class="covered"><td>2006</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Exit;</pre></td></tr>
<tr class="nocodegen"><td>2007</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2008</td><td><pre style="display:inline;"> &nbsp; &nbsp;M1 := M2 or (M2 shr 1);</pre></td></tr>
<tr class="covered"><td>2009</td><td><pre style="display:inline;"> &nbsp; &nbsp;M1 := M1 or (M1 shr 2);</pre></td></tr>
<tr class="covered"><td>2010</td><td><pre style="display:inline;"> &nbsp; &nbsp;M1 := M1 or (M2 shr 4);</pre></td></tr>
<tr class="covered"><td>2011</td><td><pre style="display:inline;"> &nbsp; &nbsp;M1 := M1 or (M1 shr 5);</pre></td></tr>
<tr class="covered"><td>2012</td><td><pre style="display:inline;"> &nbsp; &nbsp;M1 := M1 and ((not K xor (K shl 1)) and (not K xor (K shr 1)) and $7FFFFFFC);</pre></td></tr>
<tr class="covered"><td>2013</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := K xor ((B[265 + I] shl R or B[265 + I] shr (32 - R)) and M1);</pre></td></tr>
<tr class="covered"><td>2014</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2015</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2016</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2017</td><td><pre style="display:inline;"> &nbsp;T: array[0..14] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2018</td><td><pre style="display:inline;"> &nbsp;I, J, L: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2019</td><td><pre style="display:inline;"> &nbsp;U: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2020</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>2021</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2022</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>2023</td><td><pre style="display:inline;"> &nbsp;B := @Mars_Data;</pre></td></tr>
<tr class="covered"><td>2024</td><td><pre style="display:inline;"> &nbsp;FillChar(T, SizeOf(T), 0);</pre></td></tr>
<tr class="covered"><td>2025</td><td><pre style="display:inline;"> &nbsp;Move(Key, T, Size);</pre></td></tr>
<tr class="covered"><td>2026</td><td><pre style="display:inline;"> &nbsp;Size := Size div 4;</pre></td></tr>
<tr class="covered"><td>2027</td><td><pre style="display:inline;"> &nbsp;T[Size] := Size;</pre></td></tr>
<tr class="covered"><td>2028</td><td><pre style="display:inline;"> &nbsp;for J := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>2029</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2030</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 14 do</pre></td></tr>
<tr class="nocodegen"><td>2031</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2032</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;U := T[(I + 8) mod 15] xor T[(I + 13) mod 15];</pre></td></tr>
<tr class="covered"><td>2033</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[I] := T[I] xor (U shl 3 or U shr 29) xor (I * 4 + J);</pre></td></tr>
<tr class="covered"><td>2034</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2035</td><td><pre style="display:inline;"> &nbsp; &nbsp;for L := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>2036</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2037</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for I := 0 to 14 do</pre></td></tr>
<tr class="nocodegen"><td>2038</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2039</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(T[I], B[T[(I + 14) mod 15] and $1FF]);</pre></td></tr>
<tr class="covered"><td>2040</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T[I] := T[I] shl 9 or T[I] shr 23;</pre></td></tr>
<tr class="covered"><td>2041</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2042</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2043</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 9 do</pre></td></tr>
<tr class="covered"><td>2044</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[(J * 10) + I] := T[(I * 4) mod 15];</pre></td></tr>
<tr class="covered"><td>2045</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2046</td><td><pre style="display:inline;"> &nbsp;I := 5;</pre></td></tr>
<tr class="nocodegen"><td>2047</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>2048</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[I] := FixKey(K[I], K[I - 1]);</pre></td></tr>
<tr class="covered"><td>2049</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I, 2);</pre></td></tr>
<tr class="covered"><td>2050</td><td><pre style="display:inline;"> &nbsp;until I &gt;= 37;</pre></td></tr>
<tr class="nocodegen"><td>2051</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2052</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>2053</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2054</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2055</td><td><pre style="display:inline;">procedure TCipher_Mars.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2056</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2057</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>2058</td><td><pre style="display:inline;"> &nbsp;I, L, R, A, B, C, D: UInt32;</pre></td></tr>
<tr class="covered"><td>2059</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2060</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>2061</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2062</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>2063</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0] + K[0];</pre></td></tr>
<tr class="covered"><td>2064</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1] + K[1];</pre></td></tr>
<tr class="covered"><td>2065</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Source)[2] + K[2];</pre></td></tr>
<tr class="covered"><td>2066</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Source)[3] + K[3];</pre></td></tr>
<tr class="covered"><td>2067</td><td><pre style="display:inline;"> &nbsp;K := @K[4];</pre></td></tr>
<tr class="covered"><td>2068</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 1 do</pre></td></tr>
<tr class="nocodegen"><td>2069</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2070</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Mars_Data[A and $FF] + Mars_Data[A shr 8 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2071</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, Mars_Data[A shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2072</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Mars_Data[A shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2073</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := (A shr 24 or A shl 8) + D;</pre></td></tr>
<tr class="nocodegen"><td>2074</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2075</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor Mars_Data[B and $FF] + Mars_Data[B shr 8 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2076</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, Mars_Data[B shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2077</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Mars_Data[B shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2078</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := (B shr 24 or B shl 8) + C;</pre></td></tr>
<tr class="nocodegen"><td>2079</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2080</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Mars_Data[C and $FF] + Mars_Data[C shr 8 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2081</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(A, Mars_Data[C shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2082</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Mars_Data[C shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2083</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shr 24 or C shl 8;</pre></td></tr>
<tr class="nocodegen"><td>2084</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2085</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Mars_Data[D and $FF] + Mars_Data[D shr 8 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2086</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, Mars_Data[D shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2087</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor Mars_Data[D shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2088</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D shr 24 or D shl 8;</pre></td></tr>
<tr class="covered"><td>2089</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2090</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2091</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>2092</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2093</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := A + K[0];</pre></td></tr>
<tr class="covered"><td>2094</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shl 13 or A shr 19;</pre></td></tr>
<tr class="covered"><td>2095</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := A * K[1];</pre></td></tr>
<tr class="covered"><td>2096</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2097</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2098</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2099</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2100</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2101</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="nocodegen"><td>2102</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2103</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2104</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2105</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(B, L);</pre></td></tr>
<tr class="covered"><td>2106</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := D xor R;</pre></td></tr>
<tr class="nocodegen"><td>2107</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2108</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2109</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2110</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(D, L);</pre></td></tr>
<tr class="covered"><td>2111</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B xor R;</pre></td></tr>
<tr class="nocodegen"><td>2112</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2113</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := B + K[2];</pre></td></tr>
<tr class="covered"><td>2114</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shl 13 or B shr 19;</pre></td></tr>
<tr class="covered"><td>2115</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := B * K[3];</pre></td></tr>
<tr class="covered"><td>2116</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2117</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2118</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2119</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2120</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2121</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="covered"><td>2122</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2123</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2124</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(C, L);</pre></td></tr>
<tr class="covered"><td>2125</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := A xor R;</pre></td></tr>
<tr class="nocodegen"><td>2126</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2127</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2128</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2129</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(A, L);</pre></td></tr>
<tr class="covered"><td>2130</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C xor R;</pre></td></tr>
<tr class="nocodegen"><td>2131</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2132</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := C + K[4];</pre></td></tr>
<tr class="covered"><td>2133</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shl 13 or C shr 19;</pre></td></tr>
<tr class="covered"><td>2134</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := C * K[5];</pre></td></tr>
<tr class="covered"><td>2135</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2136</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(A, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2137</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2138</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2139</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2140</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="covered"><td>2141</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2142</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2143</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(D, L);</pre></td></tr>
<tr class="covered"><td>2144</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B xor R;</pre></td></tr>
<tr class="nocodegen"><td>2145</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2146</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2147</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2148</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(B, L);</pre></td></tr>
<tr class="covered"><td>2149</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := D xor R;</pre></td></tr>
<tr class="nocodegen"><td>2150</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2151</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := D + K[6];</pre></td></tr>
<tr class="covered"><td>2152</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D shl 13 or D shr 19;</pre></td></tr>
<tr class="covered"><td>2153</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := D * K[7];</pre></td></tr>
<tr class="covered"><td>2154</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2155</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2156</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2157</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2158</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2159</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="covered"><td>2160</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2161</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2162</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(A, L);</pre></td></tr>
<tr class="covered"><td>2163</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C xor R;</pre></td></tr>
<tr class="nocodegen"><td>2164</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2165</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2166</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2167</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(C, L);</pre></td></tr>
<tr class="covered"><td>2168</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := A xor R;</pre></td></tr>
<tr class="nocodegen"><td>2169</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2170</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[8];</pre></td></tr>
<tr class="covered"><td>2171</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2172</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 1 do</pre></td></tr>
<tr class="nocodegen"><td>2173</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2174</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Mars_Data[A and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2175</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, Mars_Data[A shr 24]);</pre></td></tr>
<tr class="covered"><td>2176</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D - Mars_Data[A shr 16 and $FF + 256] xor Mars_Data[A shr 8 and $FF];</pre></td></tr>
<tr class="covered"><td>2177</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shl 24 or A shr 8;</pre></td></tr>
<tr class="covered"><td>2178</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor Mars_Data[B and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2179</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(D, Mars_Data[B shr 24]);</pre></td></tr>
<tr class="covered"><td>2180</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A - Mars_Data[B shr 16 and $FF + 256] xor Mars_Data[B shr 8 and $FF];</pre></td></tr>
<tr class="covered"><td>2181</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shl 24 or B shr 8;</pre></td></tr>
<tr class="covered"><td>2182</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, B);</pre></td></tr>
<tr class="covered"><td>2183</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Mars_Data[C and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2184</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, Mars_Data[C shr 24]);</pre></td></tr>
<tr class="covered"><td>2185</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B - Mars_Data[C shr 16 and $FF + 256] xor Mars_Data[C shr 8 and $FF];</pre></td></tr>
<tr class="covered"><td>2186</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shl 24 or C shr 8;</pre></td></tr>
<tr class="covered"><td>2187</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(D, A);</pre></td></tr>
<tr class="covered"><td>2188</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Mars_Data[D and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2189</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, Mars_Data[D shr 24]);</pre></td></tr>
<tr class="covered"><td>2190</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C - Mars_Data[D shr 16 and $FF + 256] xor Mars_Data[D shr 8 and $FF];</pre></td></tr>
<tr class="covered"><td>2191</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D shl 24 or D shr 8;</pre></td></tr>
<tr class="covered"><td>2192</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2193</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A - K[0];</pre></td></tr>
<tr class="covered"><td>2194</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B - K[1];</pre></td></tr>
<tr class="covered"><td>2195</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := C - K[2];</pre></td></tr>
<tr class="covered"><td>2196</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := D - K[3];</pre></td></tr>
<tr class="covered"><td>2197</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2198</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2199</td><td><pre style="display:inline;">procedure TCipher_Mars.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2200</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2201</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>2202</td><td><pre style="display:inline;"> &nbsp;I, L, R, A, B, C, D: UInt32;</pre></td></tr>
<tr class="covered"><td>2203</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2204</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>2205</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2206</td><td><pre style="display:inline;"> &nbsp;K := @PUInt32Array(FAdditionalBuffer)[28];</pre></td></tr>
<tr class="covered"><td>2207</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0] + K[8];</pre></td></tr>
<tr class="covered"><td>2208</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1] + K[9];</pre></td></tr>
<tr class="covered"><td>2209</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Source)[2] + K[10];</pre></td></tr>
<tr class="covered"><td>2210</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Source)[3] + K[11];</pre></td></tr>
<tr class="covered"><td>2211</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 1 do</pre></td></tr>
<tr class="nocodegen"><td>2212</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2213</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D shr 24 or D shl 8;</pre></td></tr>
<tr class="covered"><td>2214</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor Mars_Data[D shr 8 and $FF] + Mars_Data[D shr 16 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2215</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, Mars_Data[D shr 24]);</pre></td></tr>
<tr class="covered"><td>2216</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Mars_Data[D and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2217</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, A);</pre></td></tr>
<tr class="covered"><td>2218</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shr 24 or C shl 8;</pre></td></tr>
<tr class="covered"><td>2219</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Mars_Data[C shr 8 and $FF] + Mars_Data[C shr 16 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2220</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(A, Mars_Data[C shr 24]);</pre></td></tr>
<tr class="covered"><td>2221</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Mars_Data[C and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2222</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, B);</pre></td></tr>
<tr class="covered"><td>2223</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shr 24 or B shl 8;</pre></td></tr>
<tr class="covered"><td>2224</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Mars_Data[B shr 8 and $FF] + Mars_Data[B shr 16 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2225</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, Mars_Data[B shr 24]);</pre></td></tr>
<tr class="covered"><td>2226</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor Mars_Data[B and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2227</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shr 24 or A shl 8;</pre></td></tr>
<tr class="covered"><td>2228</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Mars_Data[A shr 8 and $FF] + Mars_Data[A shr 16 and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2229</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, Mars_Data[A shr 24]);</pre></td></tr>
<tr class="covered"><td>2230</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Mars_Data[A and $FF + 256];</pre></td></tr>
<tr class="covered"><td>2231</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2232</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>2233</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2234</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := D * K[7];</pre></td></tr>
<tr class="covered"><td>2235</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2236</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D shr 13 or D shl 19;</pre></td></tr>
<tr class="covered"><td>2237</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := D + K[6];</pre></td></tr>
<tr class="covered"><td>2238</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2239</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2240</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2241</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2242</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="covered"><td>2243</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2244</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2245</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(C, L);</pre></td></tr>
<tr class="covered"><td>2246</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := A xor R;</pre></td></tr>
<tr class="nocodegen"><td>2247</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2248</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2249</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2250</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(A, L);</pre></td></tr>
<tr class="covered"><td>2251</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C xor R;</pre></td></tr>
<tr class="nocodegen"><td>2252</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2253</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := C * K[5];</pre></td></tr>
<tr class="covered"><td>2254</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2255</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shr 13 or C shl 19;</pre></td></tr>
<tr class="covered"><td>2256</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := C + K[4];</pre></td></tr>
<tr class="covered"><td>2257</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2258</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2259</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2260</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2261</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="covered"><td>2262</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2263</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2264</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(B, L);</pre></td></tr>
<tr class="covered"><td>2265</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := D xor R;</pre></td></tr>
<tr class="nocodegen"><td>2266</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2267</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2268</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2269</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(D, L);</pre></td></tr>
<tr class="covered"><td>2270</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B xor R;</pre></td></tr>
<tr class="nocodegen"><td>2271</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2272</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := B * K[3];</pre></td></tr>
<tr class="covered"><td>2273</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2274</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shr 13 or B shl 19;</pre></td></tr>
<tr class="covered"><td>2275</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := B + K[2];</pre></td></tr>
<tr class="covered"><td>2276</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(D, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2277</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2278</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2279</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2280</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="covered"><td>2281</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2282</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2283</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(A, L);</pre></td></tr>
<tr class="covered"><td>2284</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C xor R;</pre></td></tr>
<tr class="nocodegen"><td>2285</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2286</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2287</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2288</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(C, L);</pre></td></tr>
<tr class="covered"><td>2289</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := A xor R;</pre></td></tr>
<tr class="nocodegen"><td>2290</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2291</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := A * K[1];</pre></td></tr>
<tr class="covered"><td>2292</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2293</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shr 13 or A shl 19;</pre></td></tr>
<tr class="covered"><td>2294</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := A + K[0];</pre></td></tr>
<tr class="covered"><td>2295</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, L shl R or L shr (32 - R));</pre></td></tr>
<tr class="covered"><td>2296</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Mars_Data[L and $1FF] xor R;</pre></td></tr>
<tr class="covered"><td>2297</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R shl 5 or R shr 27;</pre></td></tr>
<tr class="covered"><td>2298</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor R;</pre></td></tr>
<tr class="covered"><td>2299</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L shl R or L shr (32 - R);</pre></td></tr>
<tr class="covered"><td>2300</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 1 then</pre></td></tr>
<tr class="nocodegen"><td>2301</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2302</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(D, L);</pre></td></tr>
<tr class="covered"><td>2303</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B xor R;</pre></td></tr>
<tr class="nocodegen"><td>2304</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2305</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2306</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2307</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(B, L);</pre></td></tr>
<tr class="covered"><td>2308</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := D xor R;</pre></td></tr>
<tr class="nocodegen"><td>2309</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2310</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 8);</pre></td></tr>
<tr class="covered"><td>2311</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2312</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 1 do</pre></td></tr>
<tr class="nocodegen"><td>2313</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2314</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D shl 24 or D shr 8;</pre></td></tr>
<tr class="covered"><td>2315</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor Mars_Data[D shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2316</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, Mars_Data[D shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2317</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A - Mars_Data[D shr 8 and $FF + 256] xor Mars_Data[D and $FF];</pre></td></tr>
<tr class="covered"><td>2318</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shl 24 or C shr 8;</pre></td></tr>
<tr class="covered"><td>2319</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Mars_Data[C shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2320</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, Mars_Data[C shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2321</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D - Mars_Data[C shr 8 and $FF + 256] xor Mars_Data[C and $FF];</pre></td></tr>
<tr class="covered"><td>2322</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, C);</pre></td></tr>
<tr class="covered"><td>2323</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shl 24 or B shr 8;</pre></td></tr>
<tr class="covered"><td>2324</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Mars_Data[B shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2325</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(D, Mars_Data[B shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2326</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C - Mars_Data[B shr 8 and $FF + 256] xor Mars_Data[B and $FF];</pre></td></tr>
<tr class="covered"><td>2327</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, D);</pre></td></tr>
<tr class="covered"><td>2328</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shl 24 or A shr 8;</pre></td></tr>
<tr class="covered"><td>2329</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Mars_Data[A shr 24 + 256];</pre></td></tr>
<tr class="covered"><td>2330</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, Mars_Data[A shr 16 and $FF]);</pre></td></tr>
<tr class="covered"><td>2331</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B - Mars_Data[A shr 8 and $FF + 256] xor Mars_Data[A and $FF];</pre></td></tr>
<tr class="covered"><td>2332</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2333</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A - K[4];</pre></td></tr>
<tr class="covered"><td>2334</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B - K[5];</pre></td></tr>
<tr class="covered"><td>2335</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := C - K[6];</pre></td></tr>
<tr class="covered"><td>2336</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := D - K[7];</pre></td></tr>
<tr class="covered"><td>2337</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2338</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2339</td><td><pre style="display:inline;">{ TCipher_RC4 }</pre></td></tr>
<tr class="nocodegen"><td>2340</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2341</td><td><pre style="display:inline;">class function TCipher_RC4.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>2342</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2343</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 256;</pre></td></tr>
<tr class="covered"><td>2344</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>2345</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>2346</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 256 + 2;</pre></td></tr>
<tr class="covered"><td>2347</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := true;</pre></td></tr>
<tr class="covered"><td>2348</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>2349</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>2350</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctStream];</pre></td></tr>
<tr class="covered"><td>2351</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2352</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2353</td><td><pre style="display:inline;">procedure TCipher_RC4.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2354</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2355</td><td><pre style="display:inline;"> &nbsp;K: array[0..255] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>2356</td><td><pre style="display:inline;"> &nbsp;D: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>2357</td><td><pre style="display:inline;"> &nbsp;I, J, T: Byte;</pre></td></tr>
<tr class="covered"><td>2358</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2359</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>2360</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="nocodegen"><td>2361</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2362</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := I;</pre></td></tr>
<tr class="covered"><td>2363</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Size &gt; 0 then</pre></td></tr>
<tr class="covered"><td>2364</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[I] := TByteArray(Key)[I mod Size];</pre></td></tr>
<tr class="covered"><td>2365</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2366</td><td><pre style="display:inline;"> &nbsp;J := 0;</pre></td></tr>
<tr class="covered"><td>2367</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="nocodegen"><td>2368</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2369</td><td><pre style="display:inline;"> &nbsp; &nbsp;J := J + D[I] + K[I];</pre></td></tr>
<tr class="covered"><td>2370</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := D[I];</pre></td></tr>
<tr class="covered"><td>2371</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := D[J];</pre></td></tr>
<tr class="covered"><td>2372</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[J] := T;</pre></td></tr>
<tr class="covered"><td>2373</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2374</td><td><pre style="display:inline;"> &nbsp;D[256] := 0;</pre></td></tr>
<tr class="covered"><td>2375</td><td><pre style="display:inline;"> &nbsp;D[257] := 0;</pre></td></tr>
<tr class="covered"><td>2376</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>2377</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2378</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>2379</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2380</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2381</td><td><pre style="display:inline;">procedure TCipher_RC4.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2382</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2383</td><td><pre style="display:inline;"> &nbsp;D: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>2384</td><td><pre style="display:inline;"> &nbsp;S: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2385</td><td><pre style="display:inline;"> &nbsp;T, I, J: Byte;</pre></td></tr>
<tr class="covered"><td>2386</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2387</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>2388</td><td><pre style="display:inline;"> &nbsp;I := D[256];</pre></td></tr>
<tr class="covered"><td>2389</td><td><pre style="display:inline;"> &nbsp;J := D[257];</pre></td></tr>
<tr class="covered"><td>2390</td><td><pre style="display:inline;"> &nbsp;for S := 0 to Size - 1 do</pre></td></tr>
<tr class="nocodegen"><td>2391</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2392</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>2393</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := D[I];</pre></td></tr>
<tr class="covered"><td>2394</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(J, T);</pre></td></tr>
<tr class="covered"><td>2395</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := D[J];</pre></td></tr>
<tr class="covered"><td>2396</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[J] := T;</pre></td></tr>
<tr class="covered"><td>2397</td><td><pre style="display:inline;"> &nbsp; &nbsp;PByteArray(Dest)[S] := PByteArray(Source)[S] xor D[Byte(D[I] + T)];</pre></td></tr>
<tr class="covered"><td>2398</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2399</td><td><pre style="display:inline;"> &nbsp;D[256] := I;</pre></td></tr>
<tr class="covered"><td>2400</td><td><pre style="display:inline;"> &nbsp;D[257] := J;</pre></td></tr>
<tr class="covered"><td>2401</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2402</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2403</td><td><pre style="display:inline;">procedure TCipher_RC4.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>2404</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2405</td><td><pre style="display:inline;"> &nbsp;DoEncode(Source, Dest, Size);</pre></td></tr>
<tr class="covered"><td>2406</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2407</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2408</td><td><pre style="display:inline;">{ TCipher_RC6 }</pre></td></tr>
<tr class="nocodegen"><td>2409</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2410</td><td><pre style="display:inline;">class function TCipher_RC6.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>2411</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2412</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 256;</pre></td></tr>
<tr class="covered"><td>2413</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>2414</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>2415</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 272;</pre></td></tr>
<tr class="covered"><td>2416</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>2417</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>2418</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 24;</pre></td></tr>
<tr class="covered"><td>2419</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>2420</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2421</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2422</td><td><pre style="display:inline;">procedure TCipher_RC6.SetRounds(Value: Integer);</pre></td></tr>
<tr class="covered"><td>2423</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2424</td><td><pre style="display:inline;"> &nbsp;if Value &lt; Context.MinRounds then</pre></td></tr>
<tr class="covered"><td>2425</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := Context.MinRounds</pre></td></tr>
<tr class="nocodegen"><td>2426</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>2427</td><td><pre style="display:inline;"> &nbsp;if Value &gt; Context.MaxRounds then</pre></td></tr>
<tr class="covered"><td>2428</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := Context.MaxRounds;</pre></td></tr>
<tr class="covered"><td>2429</td><td><pre style="display:inline;"> &nbsp;if Value &lt;&gt; FRounds then</pre></td></tr>
<tr class="nocodegen"><td>2430</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2431</td><td><pre style="display:inline;"> &nbsp; &nbsp;if not (FState in [csNew, csInitialized, csDone]) then</pre></td></tr>
<tr class="notcovered"><td>2432</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Done;</pre></td></tr>
<tr class="covered"><td>2433</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := Value;</pre></td></tr>
<tr class="nocodegen"><td>2434</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2435</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2436</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2437</td><td><pre style="display:inline;">procedure TCipher_RC6.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2438</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2439</td><td><pre style="display:inline;"> &nbsp;K: array[0..63] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2440</td><td><pre style="display:inline;"> &nbsp;D: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>2441</td><td><pre style="display:inline;"> &nbsp;I, J, L, A, B, Z, T: UInt32;</pre></td></tr>
<tr class="covered"><td>2442</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2443</td><td><pre style="display:inline;"> &nbsp;LimitRounds;</pre></td></tr>
<tr class="nocodegen"><td>2444</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2445</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>2446</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>2447</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>2448</td><td><pre style="display:inline;"> &nbsp;L := Size shr 2;</pre></td></tr>
<tr class="covered"><td>2449</td><td><pre style="display:inline;"> &nbsp;if Size and 3 &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>2450</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(L);</pre></td></tr>
<tr class="covered"><td>2451</td><td><pre style="display:inline;"> &nbsp;if L &lt;= 0 then</pre></td></tr>
<tr class="notcovered"><td>2452</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := 1;</pre></td></tr>
<tr class="covered"><td>2453</td><td><pre style="display:inline;"> &nbsp;J := $B7E15163;</pre></td></tr>
<tr class="covered"><td>2454</td><td><pre style="display:inline;"> &nbsp;for I := 0 to (FRounds + 2) * 2 do</pre></td></tr>
<tr class="nocodegen"><td>2455</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2456</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := J;</pre></td></tr>
<tr class="covered"><td>2457</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(J, $9E3779B9);</pre></td></tr>
<tr class="covered"><td>2458</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2459</td><td><pre style="display:inline;"> &nbsp;if L &gt; UInt32(FRounds + 2) * 2 then</pre></td></tr>
<tr class="notcovered"><td>2460</td><td><pre style="display:inline;"> &nbsp; &nbsp;Z := L * 3</pre></td></tr>
<tr class="nocodegen"><td>2461</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>2462</td><td><pre style="display:inline;"> &nbsp; &nbsp;Z := (FRounds + 2) * 6;</pre></td></tr>
<tr class="covered"><td>2463</td><td><pre style="display:inline;"> &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>2464</td><td><pre style="display:inline;"> &nbsp;J := 0;</pre></td></tr>
<tr class="covered"><td>2465</td><td><pre style="display:inline;"> &nbsp;A := 0;</pre></td></tr>
<tr class="covered"><td>2466</td><td><pre style="display:inline;"> &nbsp;B := 0;</pre></td></tr>
<tr class="covered"><td>2467</td><td><pre style="display:inline;"> &nbsp;for Z := Z downto 1 do</pre></td></tr>
<tr class="nocodegen"><td>2468</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2469</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A + B + D[I];</pre></td></tr>
<tr class="covered"><td>2470</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shl 3 or A shr 29;</pre></td></tr>
<tr class="covered"><td>2471</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := A;</pre></td></tr>
<tr class="covered"><td>2472</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A + B;</pre></td></tr>
<tr class="covered"><td>2473</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := T + K[J];</pre></td></tr>
<tr class="covered"><td>2474</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shl T or B shr (32 - T);</pre></td></tr>
<tr class="covered"><td>2475</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[J] := B;</pre></td></tr>
<tr class="covered"><td>2476</td><td><pre style="display:inline;"> &nbsp; &nbsp;I := (I + 1) mod (UInt32(FRounds + 2) * 2);</pre></td></tr>
<tr class="covered"><td>2477</td><td><pre style="display:inline;"> &nbsp; &nbsp;J := (J + 1) mod L;</pre></td></tr>
<tr class="covered"><td>2478</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2479</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>2480</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2481</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>2482</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2483</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2484</td><td><pre style="display:inline;">procedure TCipher_RC6.LimitRounds;</pre></td></tr>
<tr class="covered"><td>2485</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2486</td><td><pre style="display:inline;"> &nbsp;if FRounds = 0 then</pre></td></tr>
<tr class="covered"><td>2487</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 20</pre></td></tr>
<tr class="nocodegen"><td>2488</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>2489</td><td><pre style="display:inline;"> &nbsp;if FRounds &lt; 16 then</pre></td></tr>
<tr class="notcovered"><td>2490</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 16</pre></td></tr>
<tr class="nocodegen"><td>2491</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>2492</td><td><pre style="display:inline;"> &nbsp;if FRounds &gt; 24 then</pre></td></tr>
<tr class="notcovered"><td>2493</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 24;</pre></td></tr>
<tr class="notcovered"><td>2494</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2495</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2496</td><td><pre style="display:inline;">procedure TCipher_RC6.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2497</td><td><pre style="display:inline;">{$IFDEF X86ASM}</pre></td></tr>
<tr class="covered"><td>2498</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="covered"><td>2499</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>2500</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;ESI</pre></td></tr>
<tr class="covered"><td>2501</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>2502</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>2503</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;ECX</pre></td></tr>
<tr class="covered"><td>2504</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EBP,[EAX].TCipher_RC6.FRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Rounds</pre></td></tr>
<tr class="covered"><td>2505</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; ESI,[EAX].TCipher_RC6.FAdditionalBuffer // Key</pre></td></tr>
<tr class="covered"><td>2506</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EAX,[EDX + &nbsp;0] &nbsp; &nbsp;// A</pre></td></tr>
<tr class="covered"><td>2507</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EBX,[EDX + &nbsp;4] &nbsp; &nbsp;// B</pre></td></tr>
<tr class="covered"><td>2508</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDI,[EDX + &nbsp;8] &nbsp; &nbsp;// C</pre></td></tr>
<tr class="covered"><td>2509</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDX,[EDX + 12] &nbsp; &nbsp;// D</pre></td></tr>
<tr class="covered"><td>2510</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ADD &nbsp; EBX,[ESI + 0] &nbsp; &nbsp; // Inc(B, K[0])</pre></td></tr>
<tr class="covered"><td>2511</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ADD &nbsp; EDX,[ESI + 4] &nbsp; &nbsp; // Inc(D, K[1])</pre></td></tr>
<tr class="covered"><td>2512</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ADD &nbsp; ESI,8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Inc(PInteger(K), 2)</pre></td></tr>
<tr class="covered"><td>2513</td><td><pre style="display:inline;">@@1: &nbsp;LEA &nbsp; ECX,[EBX * 2 + 1] // ECX := B * 2 + 1</pre></td></tr>
<tr class="covered"><td>2514</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;IMUL &nbsp;ECX,EBX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ECX := ECX * B</pre></td></tr>
<tr class="covered"><td>2515</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROL &nbsp; ECX,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // T := ROL(B * (B * 2 + 1), 5)</pre></td></tr>
<tr class="covered"><td>2516</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // save T</pre></td></tr>
<tr class="covered"><td>2517</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;XOR &nbsp; EAX,ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // A := A xor T</pre></td></tr>
<tr class="covered"><td>2518</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;LEA &nbsp; ECX,[EDX * 2 + 1] // ECX := D * 2 + 1</pre></td></tr>
<tr class="covered"><td>2519</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;IMUL &nbsp;ECX,EDX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ECX := ECX * D</pre></td></tr>
<tr class="covered"><td>2520</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROL &nbsp; ECX,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // U := ROL(D * (D * 2 + 1), 5)</pre></td></tr>
<tr class="covered"><td>2521</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;XOR &nbsp; EDI,ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // C := C xor U</pre></td></tr>
<tr class="covered"><td>2522</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROL &nbsp; EAX,CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// A := ROL(A xor T, U)</pre></td></tr>
<tr class="covered"><td>2523</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // restore T</pre></td></tr>
<tr class="covered"><td>2524</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ADD &nbsp; EAX,[ESI + 0] &nbsp; &nbsp; // Inc(A, K[0])</pre></td></tr>
<tr class="covered"><td>2525</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROL &nbsp; EDI,CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// C := ROL(C xor U, T)</pre></td></tr>
<tr class="covered"><td>2526</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; ECX,EAX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // T := A</pre></td></tr>
<tr class="covered"><td>2527</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ADD &nbsp; EDI,[ESI + 4] &nbsp; &nbsp; // Inc(C, K[1])</pre></td></tr>
<tr class="covered"><td>2528</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EAX,EBX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // A := B</pre></td></tr>
<tr class="covered"><td>2529</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EBX,EDI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // B := C</pre></td></tr>
<tr class="covered"><td>2530</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDI,EDX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // C := D</pre></td></tr>
<tr class="covered"><td>2531</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;DEC &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>2532</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDX,ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // D := T;</pre></td></tr>
<tr class="covered"><td>2533</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;LEA &nbsp; ESI,[ESI + 8] &nbsp; &nbsp; // Inc(PInteger(K), 2)</pre></td></tr>
<tr class="covered"><td>2534</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;JNZ &nbsp; @@1</pre></td></tr>
<tr class="covered"><td>2535</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ADD &nbsp; EAX,[ESI + 0] &nbsp; &nbsp; // Inc(A, K[0])</pre></td></tr>
<tr class="covered"><td>2536</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ADD &nbsp; EDI,[ESI + 4] &nbsp; &nbsp; // Inc(C, K[1])</pre></td></tr>
<tr class="covered"><td>2537</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; ECX</pre></td></tr>
<tr class="covered"><td>2538</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + &nbsp;0],EAX &nbsp; &nbsp;// A</pre></td></tr>
<tr class="covered"><td>2539</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + &nbsp;4],EBX &nbsp; &nbsp;// B</pre></td></tr>
<tr class="covered"><td>2540</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + &nbsp;8],EDI &nbsp; &nbsp;// C</pre></td></tr>
<tr class="covered"><td>2541</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + 12],EDX &nbsp; &nbsp;// D</pre></td></tr>
<tr class="covered"><td>2542</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>2543</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; EDI</pre></td></tr>
<tr class="covered"><td>2544</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; ESI</pre></td></tr>
<tr class="covered"><td>2545</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; EBX</pre></td></tr>
<tr class="covered"><td>2546</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2547</td><td><pre style="display:inline;">{$ELSE !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>2548</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2549</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>2550</td><td><pre style="display:inline;"> &nbsp;I, T, U, A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2551</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2552</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>2553</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2554</td><td><pre style="display:inline;"> &nbsp;K := Pointer(FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>2555</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="nocodegen"><td>2556</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1] + K[0];</pre></td></tr>
<tr class="nocodegen"><td>2557</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Source)[2];</pre></td></tr>
<tr class="nocodegen"><td>2558</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Source)[3] + K[1];</pre></td></tr>
<tr class="nocodegen"><td>2559</td><td><pre style="display:inline;"> &nbsp;for I := 1 to FRounds do</pre></td></tr>
<tr class="nocodegen"><td>2560</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2561</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[2];</pre></td></tr>
<tr class="nocodegen"><td>2562</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B * (B + B + 1);</pre></td></tr>
<tr class="nocodegen"><td>2563</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl 5 or T shr 27;</pre></td></tr>
<tr class="nocodegen"><td>2564</td><td><pre style="display:inline;"> &nbsp; &nbsp;U := D * (D + D + 1);</pre></td></tr>
<tr class="nocodegen"><td>2565</td><td><pre style="display:inline;"> &nbsp; &nbsp;U := U shl 5 or U shr 27;</pre></td></tr>
<tr class="nocodegen"><td>2566</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor T;</pre></td></tr>
<tr class="nocodegen"><td>2567</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shl U or A shr (32 - U) + K[0];</pre></td></tr>
<tr class="nocodegen"><td>2568</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor U;</pre></td></tr>
<tr class="nocodegen"><td>2569</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shl T or C shr (32 - T) + K[1];</pre></td></tr>
<tr class="nocodegen"><td>2570</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A; A := B; B := C; C := D; D := T;</pre></td></tr>
<tr class="nocodegen"><td>2571</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2572</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A + K[2];</pre></td></tr>
<tr class="nocodegen"><td>2573</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B;</pre></td></tr>
<tr class="nocodegen"><td>2574</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := C + K[3];</pre></td></tr>
<tr class="nocodegen"><td>2575</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := D;</pre></td></tr>
<tr class="nocodegen"><td>2576</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2577</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>2578</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2579</td><td><pre style="display:inline;">procedure TCipher_RC6.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2580</td><td><pre style="display:inline;">{$IFDEF X86ASM}</pre></td></tr>
<tr class="covered"><td>2581</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="covered"><td>2582</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>2583</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;ESI</pre></td></tr>
<tr class="covered"><td>2584</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>2585</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>2586</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;ECX</pre></td></tr>
<tr class="covered"><td>2587</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EBP,[EAX].TCipher_RC6.FRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Rounds</pre></td></tr>
<tr class="covered"><td>2588</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; ESI,[EAX].TCipher_RC6.FAdditionalBuffer // Key</pre></td></tr>
<tr class="covered"><td>2589</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;LEA &nbsp; ESI,[ESI + EBP * 8] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Key[FRounds * 2]</pre></td></tr>
<tr class="covered"><td>2590</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EAX,[EDX + &nbsp;0] &nbsp; &nbsp;// A</pre></td></tr>
<tr class="covered"><td>2591</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EBX,[EDX + &nbsp;4] &nbsp; &nbsp;// B</pre></td></tr>
<tr class="covered"><td>2592</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDI,[EDX + &nbsp;8] &nbsp; &nbsp;// C</pre></td></tr>
<tr class="covered"><td>2593</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDX,[EDX + 12] &nbsp; &nbsp;// D</pre></td></tr>
<tr class="covered"><td>2594</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SUB &nbsp; EDI,[ESI + 12] &nbsp; &nbsp;// Dec(C, K[3])</pre></td></tr>
<tr class="covered"><td>2595</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SUB &nbsp; EAX,[ESI + &nbsp;8] &nbsp; &nbsp;// Dec(A, K[2])</pre></td></tr>
<tr class="covered"><td>2596</td><td><pre style="display:inline;">@@1: &nbsp;MOV &nbsp; ECX,EAX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // T := A</pre></td></tr>
<tr class="covered"><td>2597</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SUB &nbsp; EDX,[ESI + 0] &nbsp; &nbsp; // Dec(A, K[0])</pre></td></tr>
<tr class="covered"><td>2598</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EAX,EDX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // A := D</pre></td></tr>
<tr class="covered"><td>2599</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDX,EDI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // D := C</pre></td></tr>
<tr class="covered"><td>2600</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SUB &nbsp; EBX,[ESI + 4] &nbsp; &nbsp; // Dec(C, K[1])</pre></td></tr>
<tr class="covered"><td>2601</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EDI,EBX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // C := B</pre></td></tr>
<tr class="covered"><td>2602</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; EBX,ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // B := T;</pre></td></tr>
<tr class="covered"><td>2603</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;LEA &nbsp; ECX,[EDX * 2 + 1] // ECX := D * 2 + 1</pre></td></tr>
<tr class="covered"><td>2604</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;IMUL &nbsp;ECX,EDX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ECX := ECX * D</pre></td></tr>
<tr class="covered"><td>2605</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROL &nbsp; ECX,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // U := ROL(D * (D * 2 + 1), 5)</pre></td></tr>
<tr class="covered"><td>2606</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PUSH &nbsp;ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // save U</pre></td></tr>
<tr class="covered"><td>2607</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROR &nbsp; EAX,CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// A := ROR(A - K[0], U)</pre></td></tr>
<tr class="covered"><td>2608</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;LEA &nbsp; ECX,[EBX * 2 + 1] // ECX := B * 2 + 1</pre></td></tr>
<tr class="covered"><td>2609</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;IMUL &nbsp;ECX,EBX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ECX := ECX * B</pre></td></tr>
<tr class="covered"><td>2610</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROL &nbsp; ECX,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // T := ROL(B * (B * 2 + 1), 5)</pre></td></tr>
<tr class="covered"><td>2611</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;XOR &nbsp; EAX,ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // A := A xor T</pre></td></tr>
<tr class="covered"><td>2612</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ROR &nbsp; EDI,CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// C := ROR(C - K[1], T)</pre></td></tr>
<tr class="covered"><td>2613</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // restore U</pre></td></tr>
<tr class="covered"><td>2614</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;XOR &nbsp; EDI,ECX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // C := C xor U</pre></td></tr>
<tr class="covered"><td>2615</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;DEC &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>2616</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;LEA &nbsp; ESI,[ESI - 8] &nbsp; &nbsp; // Dec(PInteger(K), 2)</pre></td></tr>
<tr class="covered"><td>2617</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;JNZ &nbsp; @@1</pre></td></tr>
<tr class="covered"><td>2618</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SUB &nbsp; EBX,[ESI + 0] &nbsp; &nbsp; // Dec(B, K[0])</pre></td></tr>
<tr class="covered"><td>2619</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SUB &nbsp; EDX,[ESI + 4] &nbsp; &nbsp; // Inc(D, K[1])</pre></td></tr>
<tr class="covered"><td>2620</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; ECX</pre></td></tr>
<tr class="covered"><td>2621</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + &nbsp;0],EAX &nbsp; &nbsp;// A</pre></td></tr>
<tr class="covered"><td>2622</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + &nbsp;4],EBX &nbsp; &nbsp;// B</pre></td></tr>
<tr class="covered"><td>2623</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + &nbsp;8],EDI &nbsp; &nbsp;// C</pre></td></tr>
<tr class="covered"><td>2624</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;MOV &nbsp; [ECX + 12],EDX &nbsp; &nbsp;// D</pre></td></tr>
<tr class="covered"><td>2625</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>2626</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; EDI</pre></td></tr>
<tr class="covered"><td>2627</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; ESI</pre></td></tr>
<tr class="covered"><td>2628</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;POP &nbsp; EBX</pre></td></tr>
<tr class="covered"><td>2629</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2630</td><td><pre style="display:inline;">{$ELSE !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>2631</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2632</td><td><pre style="display:inline;"> &nbsp;I, U, T, A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2633</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>2634</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2635</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>2636</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2637</td><td><pre style="display:inline;"> &nbsp;K := @PUInt32Array(FAdditionalBuffer)[FRounds * 2];</pre></td></tr>
<tr class="nocodegen"><td>2638</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0] - K[2];</pre></td></tr>
<tr class="nocodegen"><td>2639</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="nocodegen"><td>2640</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Source)[2] - K[3];</pre></td></tr>
<tr class="nocodegen"><td>2641</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Source)[3];</pre></td></tr>
<tr class="nocodegen"><td>2642</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2643</td><td><pre style="display:inline;"> &nbsp;for I := 1 to FRounds do</pre></td></tr>
<tr class="nocodegen"><td>2644</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2645</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A; A := D; D := C; C := B; B := T;</pre></td></tr>
<tr class="nocodegen"><td>2646</td><td><pre style="display:inline;"> &nbsp; &nbsp;U := D * (D + D + 1);</pre></td></tr>
<tr class="nocodegen"><td>2647</td><td><pre style="display:inline;"> &nbsp; &nbsp;U := U shl 5 or U shr 27;</pre></td></tr>
<tr class="nocodegen"><td>2648</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B * (B + B + 1);</pre></td></tr>
<tr class="nocodegen"><td>2649</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl 5 or T shr 27;</pre></td></tr>
<tr class="nocodegen"><td>2650</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C - K[1];</pre></td></tr>
<tr class="nocodegen"><td>2651</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shr T or C shl (32 - T) xor U;</pre></td></tr>
<tr class="nocodegen"><td>2652</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A - K[0];</pre></td></tr>
<tr class="nocodegen"><td>2653</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shr U or A shl (32 - U) xor T;</pre></td></tr>
<tr class="nocodegen"><td>2654</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 2);</pre></td></tr>
<tr class="nocodegen"><td>2655</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2656</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2657</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A;</pre></td></tr>
<tr class="nocodegen"><td>2658</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B - K[0];</pre></td></tr>
<tr class="nocodegen"><td>2659</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := C;</pre></td></tr>
<tr class="nocodegen"><td>2660</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := D - K[1];</pre></td></tr>
<tr class="nocodegen"><td>2661</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2662</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>2663</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2664</td><td><pre style="display:inline;">{ TCipher_Rijndael }</pre></td></tr>
<tr class="nocodegen"><td>2665</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2666</td><td><pre style="display:inline;">class function TCipher_Rijndael.Context: TCipherContext;</pre></td></tr>
<tr class="nocodegen"><td>2667</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>2668</td><td><pre style="display:inline;"> &nbsp;// don&apos;t change this!</pre></td></tr>
<tr class="nocodegen"><td>2669</td><td><pre style="display:inline;"> &nbsp;Rijndael_Blocks = &nbsp;4;</pre></td></tr>
<tr class="nocodegen"><td>2670</td><td><pre style="display:inline;"> &nbsp;Rijndael_Rounds = 14;</pre></td></tr>
<tr class="covered"><td>2671</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2672</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 32;</pre></td></tr>
<tr class="covered"><td>2673</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := Rijndael_Blocks * 4;</pre></td></tr>
<tr class="covered"><td>2674</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= Rijndael_Blocks * 4;</pre></td></tr>
<tr class="covered"><td>2675</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(UInt32) * 2;</pre></td></tr>
<tr class="covered"><td>2676</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>2677</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>2678</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>2679</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>2680</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2681</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2682</td><td><pre style="display:inline;">procedure TCipher_Rijndael.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2683</td><td><pre style="display:inline;">{$REGION OldKeyShedule}</pre></td></tr>
<tr class="nocodegen"><td>2684</td><td><pre style="display:inline;">{</pre></td></tr>
<tr class="nocodegen"><td>2685</td><td><pre style="display:inline;"> &nbsp;// Old Rijndael Key Scheduling:</pre></td></tr>
<tr class="nocodegen"><td>2686</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2687</td><td><pre style="display:inline;"> &nbsp;procedure BuildEncodeKey;</pre></td></tr>
<tr class="nocodegen"><td>2688</td><td><pre style="display:inline;"> &nbsp;const</pre></td></tr>
<tr class="nocodegen"><td>2689</td><td><pre style="display:inline;"> &nbsp; &nbsp;RND_Data: array[0..29] of Byte = (</pre></td></tr>
<tr class="nocodegen"><td>2690</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;$01, $02, $04, $08, $10, $20, $40, $80, $1B, $36, $6C, $D8, $AB, $4D, $9A,</pre></td></tr>
<tr class="nocodegen"><td>2691</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;$2F, $5E, $BC, $63, $C6, $97, $35, $6A, $D4, $B3, $7D, $FA, $EF, $C5, $91</pre></td></tr>
<tr class="nocodegen"><td>2692</td><td><pre style="display:inline;"> &nbsp; &nbsp;);</pre></td></tr>
<tr class="nocodegen"><td>2693</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>2694</td><td><pre style="display:inline;"> &nbsp; &nbsp;T, R: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2695</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2696</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure NextRounds;</pre></td></tr>
<tr class="nocodegen"><td>2697</td><td><pre style="display:inline;"> &nbsp; &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>2698</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;J: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2699</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2700</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;J := 0;</pre></td></tr>
<tr class="nocodegen"><td>2701</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;while (J &lt; FRounds - 6) and (R &lt;= FRounds) do</pre></td></tr>
<tr class="nocodegen"><td>2702</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2703</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;while (J &lt; FRounds - 6) and (T &lt; Rijndael_Blocks) do</pre></td></tr>
<tr class="nocodegen"><td>2704</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2705</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PUInt32Array(FBuffer)[R * Rijndael_Blocks + T] := K[J];</pre></td></tr>
<tr class="nocodegen"><td>2706</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(J);</pre></td></tr>
<tr class="nocodegen"><td>2707</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(T);</pre></td></tr>
<tr class="nocodegen"><td>2708</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2709</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;if T = Rijndael_Blocks then</pre></td></tr>
<tr class="nocodegen"><td>2710</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2711</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T := 0;</pre></td></tr>
<tr class="nocodegen"><td>2712</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(R);</pre></td></tr>
<tr class="nocodegen"><td>2713</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2714</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2715</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2716</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2717</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>2718</td><td><pre style="display:inline;"> &nbsp; &nbsp;RND: PByte;</pre></td></tr>
<tr class="nocodegen"><td>2719</td><td><pre style="display:inline;"> &nbsp; &nbsp;B: PByte;</pre></td></tr>
<tr class="nocodegen"><td>2720</td><td><pre style="display:inline;"> &nbsp; &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2721</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2722</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := 0;</pre></td></tr>
<tr class="nocodegen"><td>2723</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := 0;</pre></td></tr>
<tr class="nocodegen"><td>2724</td><td><pre style="display:inline;"> &nbsp; &nbsp;RND := @RND_Data;</pre></td></tr>
<tr class="nocodegen"><td>2725</td><td><pre style="display:inline;"> &nbsp; &nbsp;NextRounds;</pre></td></tr>
<tr class="nocodegen"><td>2726</td><td><pre style="display:inline;"> &nbsp; &nbsp;while R &lt;= FRounds do</pre></td></tr>
<tr class="nocodegen"><td>2727</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2728</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B &nbsp;:= @K;</pre></td></tr>
<tr class="nocodegen"><td>2729</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[FRounds - 7] shr &nbsp;8 and $FF] xor RND^; Inc(B);</pre></td></tr>
<tr class="nocodegen"><td>2730</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[FRounds - 7] shr 16 and $FF]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(B);</pre></td></tr>
<tr class="nocodegen"><td>2731</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[FRounds - 7] shr 24]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(B);</pre></td></tr>
<tr class="nocodegen"><td>2732</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[FRounds - 7] and $FF];</pre></td></tr>
<tr class="nocodegen"><td>2733</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(RND);</pre></td></tr>
<tr class="nocodegen"><td>2734</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if FRounds = 14 then</pre></td></tr>
<tr class="nocodegen"><td>2735</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2736</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;for I := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>2737</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I] := K[I] xor K[I - 1];</pre></td></tr>
<tr class="nocodegen"><td>2738</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B &nbsp;:= @K[4];</pre></td></tr>
<tr class="nocodegen"><td>2739</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[3] and $FF]; &nbsp; &nbsp; &nbsp; &nbsp; Inc(B);</pre></td></tr>
<tr class="nocodegen"><td>2740</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[3] shr &nbsp;8 and $FF]; &nbsp;Inc(B);</pre></td></tr>
<tr class="nocodegen"><td>2741</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[3] shr 16 and $FF]; &nbsp;Inc(B);</pre></td></tr>
<tr class="nocodegen"><td>2742</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B^ := B^ xor Rijndael_S[0, K[3] shr 24];</pre></td></tr>
<tr class="nocodegen"><td>2743</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;for I := 5 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>2744</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I] := K[I] xor K[I - 1];</pre></td></tr>
<tr class="nocodegen"><td>2745</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2746</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2747</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;for I := 1 to FRounds - 7 do</pre></td></tr>
<tr class="nocodegen"><td>2748</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I] := K[I] xor K[I - 1];</pre></td></tr>
<tr class="nocodegen"><td>2749</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;NextRounds;</pre></td></tr>
<tr class="nocodegen"><td>2750</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2751</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2752</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2753</td><td><pre style="display:inline;"> &nbsp;procedure BuildDecodeKey;</pre></td></tr>
<tr class="nocodegen"><td>2754</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>2755</td><td><pre style="display:inline;"> &nbsp; &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2756</td><td><pre style="display:inline;"> &nbsp; &nbsp;D: PUInt32;</pre></td></tr>
<tr class="nocodegen"><td>2757</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2758</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := Pointer(PAnsiChar(FBuffer) + FBufferSize shr 1); // for Pointer Math</pre></td></tr>
<tr class="nocodegen"><td>2759</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(FBuffer^, D^, FBufferSize shr 1);</pre></td></tr>
<tr class="nocodegen"><td>2760</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, 4);</pre></td></tr>
<tr class="nocodegen"><td>2761</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to FRounds * 4 - 5 do</pre></td></tr>
<tr class="nocodegen"><td>2762</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2763</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D^ := &nbsp;Rijndael_Key[D^ and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2764</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Rijndael_Key[D^ shr &nbsp;8 and $FF] shl &nbsp;8 or Rijndael_Key[D^ shr &nbsp;8 and $FF] shr 24) xor</pre></td></tr>
<tr class="nocodegen"><td>2765</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Rijndael_Key[D^ shr 16 and $FF] shl 16 or Rijndael_Key[D^ shr 16 and $FF] shr 16) xor</pre></td></tr>
<tr class="nocodegen"><td>2766</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Rijndael_Key[D^ shr 24] &nbsp; &nbsp; &nbsp; &nbsp; shl 24 or Rijndael_Key[D^ shr 24] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr 8);</pre></td></tr>
<tr class="nocodegen"><td>2767</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(D);</pre></td></tr>
<tr class="nocodegen"><td>2768</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2769</td><td><pre style="display:inline;"> &nbsp;end; }</pre></td></tr>
<tr class="nocodegen"><td>2770</td><td><pre style="display:inline;">{$ENDREGION}</pre></td></tr>
<tr class="nocodegen"><td>2771</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2772</td><td><pre style="display:inline;"> &nbsp;// New AES conform Key Scheduling</pre></td></tr>
<tr class="nocodegen"><td>2773</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2774</td><td><pre style="display:inline;"> &nbsp;procedure BuildEncodeKey;</pre></td></tr>
<tr class="nocodegen"><td>2775</td><td><pre style="display:inline;"> &nbsp;const</pre></td></tr>
<tr class="nocodegen"><td>2776</td><td><pre style="display:inline;"> &nbsp; &nbsp;RCon: array[0..9] of UInt32 = ($01, $02, $04, $08, $10, $20, $40, $80, $1b, $36);</pre></td></tr>
<tr class="nocodegen"><td>2777</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>2778</td><td><pre style="display:inline;"> &nbsp; &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2779</td><td><pre style="display:inline;"> &nbsp; &nbsp;T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2780</td><td><pre style="display:inline;"> &nbsp; &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>2781</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2782</td><td><pre style="display:inline;"> &nbsp; &nbsp;P := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>2783</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Size &lt;= 16 then</pre></td></tr>
<tr class="nocodegen"><td>2784</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2785</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for I := 0 to 9 do</pre></td></tr>
<tr class="nocodegen"><td>2786</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2787</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := P[3];</pre></td></tr>
<tr class="covered"><td>2788</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P[4] := Rijndael_S[0, T shr &nbsp;8 and $FF] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>2789</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T shr 16 and $FF] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>2790</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>2791</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] shl 24 xor P[0] xor RCon[I];</pre></td></tr>
<tr class="covered"><td>2792</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P[5] := P[1] xor P[4];</pre></td></tr>
<tr class="covered"><td>2793</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P[6] := P[2] xor P[5];</pre></td></tr>
<tr class="covered"><td>2794</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P[7] := P[3] xor P[6];</pre></td></tr>
<tr class="covered"><td>2795</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P &nbsp; &nbsp;:= @P[4];</pre></td></tr>
<tr class="covered"><td>2796</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2797</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2798</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>2799</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if Size &lt;= 24 then</pre></td></tr>
<tr class="nocodegen"><td>2800</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2801</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>2802</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2803</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T := P[5];</pre></td></tr>
<tr class="covered"><td>2804</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[6] := Rijndael_S[0, T shr &nbsp;8 and $FF] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>2805</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T shr 16 and $FF] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>2806</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>2807</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] shl 24 xor P[0] xor RCon[I];</pre></td></tr>
<tr class="covered"><td>2808</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[7] := P[1] xor P[6];</pre></td></tr>
<tr class="covered"><td>2809</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[8] := P[2] xor P[7];</pre></td></tr>
<tr class="covered"><td>2810</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[9] := P[3] xor P[8];</pre></td></tr>
<tr class="covered"><td>2811</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if I = 7 then</pre></td></tr>
<tr class="nocodegen"><td>2812</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Break;</pre></td></tr>
<tr class="covered"><td>2813</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[10] := P[4] xor P[9];</pre></td></tr>
<tr class="covered"><td>2814</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[11] := P[5] xor P[10];</pre></td></tr>
<tr class="covered"><td>2815</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P &nbsp; &nbsp; := @P[6];</pre></td></tr>
<tr class="covered"><td>2816</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2817</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2818</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2819</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2820</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;for I :=0 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>2821</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2822</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T := P[7];</pre></td></tr>
<tr class="covered"><td>2823</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[8] := Rijndael_S[0, T shr &nbsp;8 and $FF] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>2824</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T shr 16 and $FF] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>2825</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>2826</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] shl 24 xor P[0] xor RCon[I];</pre></td></tr>
<tr class="covered"><td>2827</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[9] := P[1] xor P[8];</pre></td></tr>
<tr class="covered"><td>2828</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[10] := P[2] xor P[9];</pre></td></tr>
<tr class="covered"><td>2829</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[11] := P[3] xor P[10];</pre></td></tr>
<tr class="covered"><td>2830</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if I = 6 then</pre></td></tr>
<tr class="nocodegen"><td>2831</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Break;</pre></td></tr>
<tr class="covered"><td>2832</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T := P[11];</pre></td></tr>
<tr class="covered"><td>2833</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[12] := Rijndael_S[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>2834</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rijndael_S[0, T shr &nbsp;8 and $FF] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>2835</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rijndael_S[0, T shr 16 and $FF] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>2836</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rijndael_S[0, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 24 xor P[4];</pre></td></tr>
<tr class="covered"><td>2837</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[13] := P[5] xor P[12];</pre></td></tr>
<tr class="covered"><td>2838</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[14] := P[6] xor P[13];</pre></td></tr>
<tr class="covered"><td>2839</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P[15] := P[7] xor P[14];</pre></td></tr>
<tr class="covered"><td>2840</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P &nbsp; &nbsp; := @P[8];</pre></td></tr>
<tr class="covered"><td>2841</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2842</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2843</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2844</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2845</td><td><pre style="display:inline;"> &nbsp;procedure BuildDecodeKey;</pre></td></tr>
<tr class="nocodegen"><td>2846</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>2847</td><td><pre style="display:inline;"> &nbsp; &nbsp;P: PUInt32;</pre></td></tr>
<tr class="nocodegen"><td>2848</td><td><pre style="display:inline;"> &nbsp; &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>2849</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2850</td><td><pre style="display:inline;"> &nbsp; &nbsp;P := Pointer(PByte(FAdditionalBuffer) + FAdditionalBufferSize shr 1); // for Pointer Math</pre></td></tr>
<tr class="covered"><td>2851</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(FAdditionalBuffer^, P^, FAdditionalBufferSize shr 1);</pre></td></tr>
<tr class="covered"><td>2852</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(P, 4);</pre></td></tr>
<tr class="covered"><td>2853</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to FRounds * 4 - 5 do</pre></td></tr>
<tr class="nocodegen"><td>2854</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2855</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;P^ := Rijndael_T[4, Rijndael_S[0, P^ &nbsp; &nbsp; &nbsp; &nbsp;and $FF]] xor</pre></td></tr>
<tr class="nocodegen"><td>2856</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[5, Rijndael_S[0, P^ shr &nbsp;8 and $FF]] xor</pre></td></tr>
<tr class="nocodegen"><td>2857</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[6, Rijndael_S[0, P^ shr 16 and $FF]] xor</pre></td></tr>
<tr class="nocodegen"><td>2858</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[7, Rijndael_S[0, P^ shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]];</pre></td></tr>
<tr class="covered"><td>2859</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(P);</pre></td></tr>
<tr class="covered"><td>2860</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2861</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2862</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2863</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2864</td><td><pre style="display:inline;"> &nbsp;if Size &lt;= 16 then</pre></td></tr>
<tr class="covered"><td>2865</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 10</pre></td></tr>
<tr class="nocodegen"><td>2866</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>2867</td><td><pre style="display:inline;"> &nbsp;if Size &lt;= 24 then</pre></td></tr>
<tr class="covered"><td>2868</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 12</pre></td></tr>
<tr class="nocodegen"><td>2869</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>2870</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 14;</pre></td></tr>
<tr class="covered"><td>2871</td><td><pre style="display:inline;"> &nbsp;FillChar(FAdditionalBuffer^, 32, 0);</pre></td></tr>
<tr class="covered"><td>2872</td><td><pre style="display:inline;"> &nbsp;Move(Key, FAdditionalBuffer^, Size);</pre></td></tr>
<tr class="covered"><td>2873</td><td><pre style="display:inline;"> &nbsp;BuildEncodeKey;</pre></td></tr>
<tr class="covered"><td>2874</td><td><pre style="display:inline;"> &nbsp;BuildDecodeKey;</pre></td></tr>
<tr class="nocodegen"><td>2875</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2876</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>2877</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2878</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2879</td><td><pre style="display:inline;">procedure TCipher_Rijndael.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2880</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2881</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>2882</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2883</td><td><pre style="display:inline;"> &nbsp;A2, B2, C2, D2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2884</td><td><pre style="display:inline;"> &nbsp;A1, B1, C1, D1: UInt32;</pre></td></tr>
<tr class="covered"><td>2885</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2886</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>2887</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2888</td><td><pre style="display:inline;"> &nbsp;P &nbsp;:= FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>2889</td><td><pre style="display:inline;"> &nbsp;A1 := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>2890</td><td><pre style="display:inline;"> &nbsp;B1 := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>2891</td><td><pre style="display:inline;"> &nbsp;C1 := PUInt32Array(Source)[2];</pre></td></tr>
<tr class="covered"><td>2892</td><td><pre style="display:inline;"> &nbsp;D1 := PUInt32Array(Source)[3];</pre></td></tr>
<tr class="nocodegen"><td>2893</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2894</td><td><pre style="display:inline;"> &nbsp;for I := 2 to FRounds do</pre></td></tr>
<tr class="nocodegen"><td>2895</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2896</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := A1 xor P[0];</pre></td></tr>
<tr class="covered"><td>2897</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := B1 xor P[1];</pre></td></tr>
<tr class="covered"><td>2898</td><td><pre style="display:inline;"> &nbsp; &nbsp;C2 := C1 xor P[2];</pre></td></tr>
<tr class="covered"><td>2899</td><td><pre style="display:inline;"> &nbsp; &nbsp;D2 := D1 xor P[3];</pre></td></tr>
<tr class="nocodegen"><td>2900</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2901</td><td><pre style="display:inline;"> &nbsp; &nbsp;A1 := Rijndael_T[0, A2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2902</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[1, B2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2903</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[2, C2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2904</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[3, D2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>2905</td><td><pre style="display:inline;"> &nbsp; &nbsp;B1 := Rijndael_T[0, B2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2906</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[1, C2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2907</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[2, D2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2908</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[3, A2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>2909</td><td><pre style="display:inline;"> &nbsp; &nbsp;C1 := Rijndael_T[0, C2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2910</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[1, D2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2911</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[2, A2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2912</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[3, B2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>2913</td><td><pre style="display:inline;"> &nbsp; &nbsp;D1 := Rijndael_T[0, D2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2914</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[1, A2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2915</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[2, B2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2916</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[3, C2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="nocodegen"><td>2917</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2918</td><td><pre style="display:inline;"> &nbsp; &nbsp;P := @P[4];</pre></td></tr>
<tr class="covered"><td>2919</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2920</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2921</td><td><pre style="display:inline;"> &nbsp;A2 := A1 xor P[0];</pre></td></tr>
<tr class="covered"><td>2922</td><td><pre style="display:inline;"> &nbsp;B2 := B1 xor P[1];</pre></td></tr>
<tr class="covered"><td>2923</td><td><pre style="display:inline;"> &nbsp;C2 := C1 xor P[2];</pre></td></tr>
<tr class="covered"><td>2924</td><td><pre style="display:inline;"> &nbsp;D2 := D1 xor P[3];</pre></td></tr>
<tr class="nocodegen"><td>2925</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2926</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := (Rijndael_S[0, A2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>2927</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, B2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>2928</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, C2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>2929</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, D2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 24) &nbsp; &nbsp; xor P[4];</pre></td></tr>
<tr class="covered"><td>2930</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := (Rijndael_S[0, B2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>2931</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, C2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>2932</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, D2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>2933</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, A2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 24) &nbsp; &nbsp; xor P[5];</pre></td></tr>
<tr class="covered"><td>2934</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := (Rijndael_S[0, C2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>2935</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, D2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>2936</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, A2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>2937</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, B2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 24) &nbsp; &nbsp; xor P[6];</pre></td></tr>
<tr class="covered"><td>2938</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := (Rijndael_S[0, D2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>2939</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, A2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>2940</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, B2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>2941</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[0, C2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 24) &nbsp; &nbsp; xor P[7];</pre></td></tr>
<tr class="covered"><td>2942</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2943</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2944</td><td><pre style="display:inline;">procedure TCipher_Rijndael.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>2945</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2946</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>2947</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2948</td><td><pre style="display:inline;"> &nbsp;A2, B2, C2, D2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2949</td><td><pre style="display:inline;"> &nbsp;A1, B1, C1, D1: UInt32;</pre></td></tr>
<tr class="covered"><td>2950</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2951</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>2952</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2953</td><td><pre style="display:inline;"> &nbsp;P &nbsp;:= Pointer(PByte(FAdditionalBuffer) + FAdditionalBufferSize shr 1 + FRounds * 16); // for Pointer Math</pre></td></tr>
<tr class="covered"><td>2954</td><td><pre style="display:inline;"> &nbsp;A1 := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>2955</td><td><pre style="display:inline;"> &nbsp;B1 := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>2956</td><td><pre style="display:inline;"> &nbsp;C1 := PUInt32Array(Source)[2];</pre></td></tr>
<tr class="covered"><td>2957</td><td><pre style="display:inline;"> &nbsp;D1 := PUInt32Array(Source)[3];</pre></td></tr>
<tr class="nocodegen"><td>2958</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2959</td><td><pre style="display:inline;"> &nbsp;for I := 2 to FRounds do</pre></td></tr>
<tr class="nocodegen"><td>2960</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2961</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := A1 xor P[0];</pre></td></tr>
<tr class="covered"><td>2962</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := B1 xor P[1];</pre></td></tr>
<tr class="covered"><td>2963</td><td><pre style="display:inline;"> &nbsp; &nbsp;C2 := C1 xor P[2];</pre></td></tr>
<tr class="covered"><td>2964</td><td><pre style="display:inline;"> &nbsp; &nbsp;D2 := D1 xor P[3];</pre></td></tr>
<tr class="nocodegen"><td>2965</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2966</td><td><pre style="display:inline;"> &nbsp; &nbsp;A1 := Rijndael_T[4, A2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2967</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[5, D2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2968</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[6, C2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2969</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[7, B2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>2970</td><td><pre style="display:inline;"> &nbsp; &nbsp;B1 := Rijndael_T[4, B2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2971</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[5, A2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2972</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[6, D2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2973</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[7, C2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>2974</td><td><pre style="display:inline;"> &nbsp; &nbsp;C1 := Rijndael_T[4, C2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2975</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[5, B2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2976</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[6, A2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2977</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[7, D2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>2978</td><td><pre style="display:inline;"> &nbsp; &nbsp;D1 := Rijndael_T[4, D2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2979</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[5, C2 shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2980</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[6, B2 shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>2981</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_T[7, A2 shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="nocodegen"><td>2982</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2983</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(P), 4);</pre></td></tr>
<tr class="covered"><td>2984</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2985</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2986</td><td><pre style="display:inline;"> &nbsp;A2 := A1 xor P[0];</pre></td></tr>
<tr class="covered"><td>2987</td><td><pre style="display:inline;"> &nbsp;B2 := B1 xor P[1];</pre></td></tr>
<tr class="covered"><td>2988</td><td><pre style="display:inline;"> &nbsp;C2 := C1 xor P[2];</pre></td></tr>
<tr class="covered"><td>2989</td><td><pre style="display:inline;"> &nbsp;D2 := D1 xor P[3];</pre></td></tr>
<tr class="nocodegen"><td>2990</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2991</td><td><pre style="display:inline;"> &nbsp;Dec(PUInt32(P), 4);</pre></td></tr>
<tr class="nocodegen"><td>2992</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2993</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := (Rijndael_S[1, A2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>2994</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, D2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>2995</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, C2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>2996</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, B2 shr 24] &nbsp; &nbsp; &nbsp; &nbsp; shl 24) &nbsp; &nbsp;xor P[0];</pre></td></tr>
<tr class="covered"><td>2997</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := (Rijndael_S[1, B2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>2998</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, A2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>2999</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, D2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>3000</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, C2 shr 24] &nbsp; &nbsp; &nbsp; &nbsp; shl 24) &nbsp; &nbsp;xor P[1];</pre></td></tr>
<tr class="covered"><td>3001</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := (Rijndael_S[1, C2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>3002</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, B2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>3003</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, A2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>3004</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, D2 shr 24] &nbsp; &nbsp; &nbsp; &nbsp; shl 24) &nbsp; &nbsp;xor P[2];</pre></td></tr>
<tr class="covered"><td>3005</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := (Rijndael_S[1, D2 &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;or</pre></td></tr>
<tr class="nocodegen"><td>3006</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, C2 shr &nbsp;8 and $FF] shl &nbsp;8 or</pre></td></tr>
<tr class="nocodegen"><td>3007</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, B2 shr 16 and $FF] shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>3008</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rijndael_S[1, A2 shr 24] &nbsp; &nbsp; &nbsp; &nbsp; shl 24) &nbsp; &nbsp;xor P[3];</pre></td></tr>
<tr class="covered"><td>3009</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3010</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3011</td><td><pre style="display:inline;">{ TCipher_Square }</pre></td></tr>
<tr class="nocodegen"><td>3012</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3013</td><td><pre style="display:inline;">class function TCipher_Square.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3014</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3015</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>3016</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>3017</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>3018</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 9 * 4 * 2 * SizeOf(UInt32);</pre></td></tr>
<tr class="covered"><td>3019</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>3020</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3021</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3022</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>3023</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3024</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3025</td><td><pre style="display:inline;">procedure TCipher_Square.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3026</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>3027</td><td><pre style="display:inline;"> &nbsp;PSquare_Key = ^TSquare_Key;</pre></td></tr>
<tr class="nocodegen"><td>3028</td><td><pre style="display:inline;"> &nbsp;TSquare_Key = array[0..8, 0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3029</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3030</td><td><pre style="display:inline;"> &nbsp;E, D: PSquare_Key;</pre></td></tr>
<tr class="nocodegen"><td>3031</td><td><pre style="display:inline;"> &nbsp;S, T, R: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3032</td><td><pre style="display:inline;"> &nbsp;I, J: Integer;</pre></td></tr>
<tr class="covered"><td>3033</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3034</td><td><pre style="display:inline;"> &nbsp;E := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3035</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer; Inc(D);</pre></td></tr>
<tr class="covered"><td>3036</td><td><pre style="display:inline;"> &nbsp;Move(Key, E^, Size);</pre></td></tr>
<tr class="nocodegen"><td>3037</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3038</td><td><pre style="display:inline;"> &nbsp;for I := 1 to 8 do</pre></td></tr>
<tr class="nocodegen"><td>3039</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3040</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := E[I - 1, 3];</pre></td></tr>
<tr class="covered"><td>3041</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shr 8 or T shl 24;</pre></td></tr>
<tr class="covered"><td>3042</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[I, 0] := E[I - 1, 0] xor T xor 1 shl (I - 1);</pre></td></tr>
<tr class="covered"><td>3043</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[I, 1] := E[I - 1, 1] xor E[I, 0];</pre></td></tr>
<tr class="covered"><td>3044</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[I, 2] := E[I - 1, 2] xor E[I, 1];</pre></td></tr>
<tr class="covered"><td>3045</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[I, 3] := E[I - 1, 3] xor E[I, 2];</pre></td></tr>
<tr class="nocodegen"><td>3046</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3047</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[8 - I, 0] := E[I, 0];</pre></td></tr>
<tr class="covered"><td>3048</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[8 - I, 1] := E[I, 1];</pre></td></tr>
<tr class="covered"><td>3049</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[8 - I, 2] := E[I, 2];</pre></td></tr>
<tr class="covered"><td>3050</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[8 - I, 3] := E[I, 3];</pre></td></tr>
<tr class="nocodegen"><td>3051</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3052</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>3053</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3054</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;R := E[I - 1, J];</pre></td></tr>
<tr class="covered"><td>3055</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S := Square_PHI[R and $FF];</pre></td></tr>
<tr class="covered"><td>3056</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := Square_PHI[R shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>3057</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl 8 or T shr 24;</pre></td></tr>
<tr class="covered"><td>3058</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S := S xor T;</pre></td></tr>
<tr class="covered"><td>3059</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := Square_PHI[R shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>3060</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl 16 or T shr 16;</pre></td></tr>
<tr class="covered"><td>3061</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S := S xor T;</pre></td></tr>
<tr class="covered"><td>3062</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := Square_PHI[R shr 24];</pre></td></tr>
<tr class="covered"><td>3063</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl 24 or T shr 8;</pre></td></tr>
<tr class="covered"><td>3064</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S := S xor T;</pre></td></tr>
<tr class="covered"><td>3065</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;E[I - 1, J] := S;</pre></td></tr>
<tr class="covered"><td>3066</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3067</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3068</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3069</td><td><pre style="display:inline;"> &nbsp;D[8] := E[0];</pre></td></tr>
<tr class="nocodegen"><td>3070</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3071</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>3072</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3073</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3074</td><td><pre style="display:inline;">procedure TCipher_Square.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3075</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3076</td><td><pre style="display:inline;"> &nbsp;Key: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3077</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3078</td><td><pre style="display:inline;"> &nbsp;AA, BB, CC: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3079</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>3080</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3081</td><td><pre style="display:inline;"> &nbsp;Key := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3082</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0] xor Key[0];</pre></td></tr>
<tr class="covered"><td>3083</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1] xor Key[1];</pre></td></tr>
<tr class="covered"><td>3084</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Source)[2] xor Key[2];</pre></td></tr>
<tr class="covered"><td>3085</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Source)[3] xor Key[3];</pre></td></tr>
<tr class="covered"><td>3086</td><td><pre style="display:inline;"> &nbsp;Key := @Key[4];</pre></td></tr>
<tr class="nocodegen"><td>3087</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3088</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>3089</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3090</td><td><pre style="display:inline;"> &nbsp; &nbsp;AA := Square_TE[0, A &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3091</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3092</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3093</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor Key[0];</pre></td></tr>
<tr class="covered"><td>3094</td><td><pre style="display:inline;"> &nbsp; &nbsp;BB := Square_TE[0, A shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3095</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3096</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3097</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D shr &nbsp;8 and $FF] xor Key[1];</pre></td></tr>
<tr class="covered"><td>3098</td><td><pre style="display:inline;"> &nbsp; &nbsp;CC := Square_TE[0, A shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3099</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3100</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3101</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D shr 16 and $FF] xor Key[2];</pre></td></tr>
<tr class="covered"><td>3102</td><td><pre style="display:inline;"> &nbsp; &nbsp;D &nbsp;:= Square_TE[0, A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3103</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3104</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3105</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor Key[3];</pre></td></tr>
<tr class="nocodegen"><td>3106</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3107</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := AA; B := BB; C := CC;</pre></td></tr>
<tr class="nocodegen"><td>3108</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3109</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key := @Key[4];</pre></td></tr>
<tr class="covered"><td>3110</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3111</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3112</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := UInt32(Square_SE[A &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3113</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[B &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3114</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[C &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3115</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[D &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) shl 24 xor Key[0];</pre></td></tr>
<tr class="covered"><td>3116</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := UInt32(Square_SE[A shr &nbsp;8 and $FF]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3117</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[B shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3118</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[C shr &nbsp;8 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3119</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[D shr &nbsp;8 and $FF]) shl 24 xor Key[1];</pre></td></tr>
<tr class="covered"><td>3120</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := UInt32(Square_SE[A shr 16 and $FF]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3121</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[B shr 16 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3122</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[C shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3123</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[D shr 16 and $FF]) shl 24 xor Key[2];</pre></td></tr>
<tr class="covered"><td>3124</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := UInt32(Square_SE[A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3125</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3126</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[C shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3127</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SE[D shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 24 xor Key[3];</pre></td></tr>
<tr class="covered"><td>3128</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3129</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3130</td><td><pre style="display:inline;">procedure TCipher_Square.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3131</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3132</td><td><pre style="display:inline;"> &nbsp;Key: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3133</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3134</td><td><pre style="display:inline;"> &nbsp;AA, BB, CC: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3135</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>3136</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3137</td><td><pre style="display:inline;"> &nbsp;Key := @PUInt32Array(FAdditionalBuffer)[9 * 4];</pre></td></tr>
<tr class="covered"><td>3138</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0] xor Key[0];</pre></td></tr>
<tr class="covered"><td>3139</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1] xor Key[1];</pre></td></tr>
<tr class="covered"><td>3140</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(Source)[2] xor Key[2];</pre></td></tr>
<tr class="covered"><td>3141</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(Source)[3] xor Key[3];</pre></td></tr>
<tr class="covered"><td>3142</td><td><pre style="display:inline;"> &nbsp;Key := @Key[4];</pre></td></tr>
<tr class="nocodegen"><td>3143</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3144</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>3145</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3146</td><td><pre style="display:inline;"> &nbsp; &nbsp;AA := Square_TD[0, A &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3147</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[1, B &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3148</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[2, C &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3149</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[3, D &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor Key[0];</pre></td></tr>
<tr class="covered"><td>3150</td><td><pre style="display:inline;"> &nbsp; &nbsp;BB := Square_TD[0, A shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3151</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[1, B shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3152</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[2, C shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3153</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[3, D shr &nbsp;8 and $FF] xor Key[1];</pre></td></tr>
<tr class="covered"><td>3154</td><td><pre style="display:inline;"> &nbsp; &nbsp;CC := Square_TD[0, A shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3155</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[1, B shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3156</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[2, C shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3157</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[3, D shr 16 and $FF] xor Key[2];</pre></td></tr>
<tr class="covered"><td>3158</td><td><pre style="display:inline;"> &nbsp; &nbsp;D &nbsp;:= Square_TD[0, A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3159</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[1, B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3160</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[2, C shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3161</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TD[3, D shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor Key[3];</pre></td></tr>
<tr class="nocodegen"><td>3162</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3163</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := AA; B := BB; C := CC;</pre></td></tr>
<tr class="covered"><td>3164</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key := @Key[4];</pre></td></tr>
<tr class="covered"><td>3165</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3166</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3167</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := UInt32(Square_SD[A &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3168</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[B &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3169</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[C &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3170</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[D &nbsp; &nbsp; &nbsp; &nbsp;and $FF]) shl 24 xor Key[0];</pre></td></tr>
<tr class="covered"><td>3171</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := UInt32(Square_SD[A shr &nbsp;8 and $FF]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3172</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[B shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3173</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[C shr &nbsp;8 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3174</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[D shr &nbsp;8 and $FF]) shl 24 xor Key[1];</pre></td></tr>
<tr class="covered"><td>3175</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := UInt32(Square_SD[A shr 16 and $FF]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3176</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[B shr 16 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3177</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[C shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3178</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[D shr 16 and $FF]) shl 24 xor Key[2];</pre></td></tr>
<tr class="covered"><td>3179</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := UInt32(Square_SD[A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3180</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3181</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[C shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3182</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Square_SD[D shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 24 xor Key[3];</pre></td></tr>
<tr class="covered"><td>3183</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3184</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3185</td><td><pre style="display:inline;">{ TCipher_SCOP }</pre></td></tr>
<tr class="nocodegen"><td>3186</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3187</td><td><pre style="display:inline;">class function TCipher_SCOP.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3188</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3189</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 48;</pre></td></tr>
<tr class="covered"><td>3190</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 4;</pre></td></tr>
<tr class="covered"><td>3191</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 32;</pre></td></tr>
<tr class="covered"><td>3192</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 384 * 4 + 3 * SizeOf(UInt32);</pre></td></tr>
<tr class="covered"><td>3193</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := True;</pre></td></tr>
<tr class="covered"><td>3194</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3195</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3196</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctStream];</pre></td></tr>
<tr class="covered"><td>3197</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3198</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3199</td><td><pre style="display:inline;">procedure TCipher_SCOP.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3200</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3201</td><td><pre style="display:inline;"> &nbsp;Init_State: packed record</pre></td></tr>
<tr class="nocodegen"><td>3202</td><td><pre style="display:inline;"> &nbsp; &nbsp;Coef: array[0..7, 0..3] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>3203</td><td><pre style="display:inline;"> &nbsp; &nbsp;X: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3204</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3205</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3206</td><td><pre style="display:inline;"> &nbsp;procedure ExpandKey;</pre></td></tr>
<tr class="nocodegen"><td>3207</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>3208</td><td><pre style="display:inline;"> &nbsp; &nbsp;P: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>3209</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, C: Integer;</pre></td></tr>
<tr class="covered"><td>3210</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3211</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := 1;</pre></td></tr>
<tr class="covered"><td>3212</td><td><pre style="display:inline;"> &nbsp; &nbsp;P := @Init_State;</pre></td></tr>
<tr class="covered"><td>3213</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(Key, P^, Size);</pre></td></tr>
<tr class="covered"><td>3214</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := Size to 47 do</pre></td></tr>
<tr class="covered"><td>3215</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;P[I] := P[I - Size] + P[I - Size + 1];</pre></td></tr>
<tr class="covered"><td>3216</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="covered"><td>3217</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if P[I] = 0 then</pre></td></tr>
<tr class="nocodegen"><td>3218</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3219</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P[I] := C;</pre></td></tr>
<tr class="covered"><td>3220</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(C);</pre></td></tr>
<tr class="covered"><td>3221</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3222</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3223</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3224</td><td><pre style="display:inline;"> &nbsp;procedure GP8(Data: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3225</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>3226</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, I2: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3227</td><td><pre style="display:inline;"> &nbsp; &nbsp;NewX: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3228</td><td><pre style="display:inline;"> &nbsp; &nbsp;X1, X2, X3, X4: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3229</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y1, Y2: UInt32;</pre></td></tr>
<tr class="covered"><td>3230</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3231</td><td><pre style="display:inline;"> &nbsp; &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>3232</td><td><pre style="display:inline;"> &nbsp; &nbsp;I2 := 0;</pre></td></tr>
<tr class="covered"><td>3233</td><td><pre style="display:inline;"> &nbsp; &nbsp;while I &lt; 8 do</pre></td></tr>
<tr class="nocodegen"><td>3234</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3235</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X1 := Init_State.X[I2] shr 16;</pre></td></tr>
<tr class="covered"><td>3236</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X2 := X1 * X1;</pre></td></tr>
<tr class="covered"><td>3237</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X3 := X2 * X1;</pre></td></tr>
<tr class="covered"><td>3238</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X4 := X3 * X1;</pre></td></tr>
<tr class="covered"><td>3239</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Y1 := Init_State.Coef[I][0] * X4 +</pre></td></tr>
<tr class="nocodegen"><td>3240</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I][1] * X3 +</pre></td></tr>
<tr class="nocodegen"><td>3241</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I][2] * X2 +</pre></td></tr>
<tr class="nocodegen"><td>3242</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I][3] * X1 + 1;</pre></td></tr>
<tr class="covered"><td>3243</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X1 := Init_State.X[I2] and $FFFF;</pre></td></tr>
<tr class="covered"><td>3244</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X2 := X1 * X1;</pre></td></tr>
<tr class="covered"><td>3245</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X3 := X2 * X1;</pre></td></tr>
<tr class="covered"><td>3246</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X4 := X3 * X1;</pre></td></tr>
<tr class="covered"><td>3247</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Y2 := Init_State.Coef[I + 1][0] * X4 +</pre></td></tr>
<tr class="nocodegen"><td>3248</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I + 1][1] * X3 +</pre></td></tr>
<tr class="nocodegen"><td>3249</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I + 1][2] * X2 +</pre></td></tr>
<tr class="nocodegen"><td>3250</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I + 1][3] * X1 + 1;</pre></td></tr>
<tr class="covered"><td>3251</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Data[I2] := Y1 shl 16 or Y2 and $FFFF;</pre></td></tr>
<tr class="covered"><td>3252</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;NewX[I2] := Y1 and $FFFF0000 or Y2 shr 16;</pre></td></tr>
<tr class="covered"><td>3253</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I2);</pre></td></tr>
<tr class="covered"><td>3254</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I, 2);</pre></td></tr>
<tr class="nocodegen"><td>3255</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3256</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[0] := NewX[0] shr 16 or NewX[3] shl 16;</pre></td></tr>
<tr class="covered"><td>3257</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[1] := NewX[0] shl 16 or NewX[1] shr 16;</pre></td></tr>
<tr class="covered"><td>3258</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[2] := NewX[1] shl 16 or NewX[2] shr 16;</pre></td></tr>
<tr class="covered"><td>3259</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[3] := NewX[2] shl 16 or NewX[3] shr 16;</pre></td></tr>
<tr class="covered"><td>3260</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3261</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3262</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3263</td><td><pre style="display:inline;"> &nbsp;I, J: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3264</td><td><pre style="display:inline;"> &nbsp;T: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3265</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>3266</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3267</td><td><pre style="display:inline;"> &nbsp;FillChar(Init_State, SizeOf(Init_State), 0);</pre></td></tr>
<tr class="covered"><td>3268</td><td><pre style="display:inline;"> &nbsp;FillChar(T, SizeOf(T), 0);</pre></td></tr>
<tr class="covered"><td>3269</td><td><pre style="display:inline;"> &nbsp;P := Pointer(PByte(FAdditionalBuffer) + 12); // for Pointer Math</pre></td></tr>
<tr class="covered"><td>3270</td><td><pre style="display:inline;"> &nbsp;ExpandKey;</pre></td></tr>
<tr class="covered"><td>3271</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="covered"><td>3272</td><td><pre style="display:inline;"> &nbsp; &nbsp;GP8(@T);</pre></td></tr>
<tr class="covered"><td>3273</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 11 do</pre></td></tr>
<tr class="nocodegen"><td>3274</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3275</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 7 do</pre></td></tr>
<tr class="covered"><td>3276</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;GP8(@P[I * 32 + J * 4]);</pre></td></tr>
<tr class="covered"><td>3277</td><td><pre style="display:inline;"> &nbsp; &nbsp;GP8(@T);</pre></td></tr>
<tr class="covered"><td>3278</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3279</td><td><pre style="display:inline;"> &nbsp;GP8(@T);</pre></td></tr>
<tr class="covered"><td>3280</td><td><pre style="display:inline;"> &nbsp;I := T[3] and $7F;</pre></td></tr>
<tr class="covered"><td>3281</td><td><pre style="display:inline;"> &nbsp;P[I] := P[I] or 1;</pre></td></tr>
<tr class="covered"><td>3282</td><td><pre style="display:inline;"> &nbsp;P := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3283</td><td><pre style="display:inline;"> &nbsp;P[0] := T[3] shr 24 and $FF;</pre></td></tr>
<tr class="covered"><td>3284</td><td><pre style="display:inline;"> &nbsp;P[1] := T[3] shr 16 and $FF;</pre></td></tr>
<tr class="covered"><td>3285</td><td><pre style="display:inline;"> &nbsp;P[2] := T[3] shr &nbsp;8 and $FF;</pre></td></tr>
<tr class="covered"><td>3286</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(Init_State, SizeOf(Init_State));</pre></td></tr>
<tr class="nocodegen"><td>3287</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3288</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>3289</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3290</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3291</td><td><pre style="display:inline;">procedure TCipher_SCOP.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3292</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3293</td><td><pre style="display:inline;"> &nbsp;I, J: Byte;</pre></td></tr>
<tr class="nocodegen"><td>3294</td><td><pre style="display:inline;"> &nbsp;T2, T3, T1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3295</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3296</td><td><pre style="display:inline;"> &nbsp;W: Integer;</pre></td></tr>
<tr class="covered"><td>3297</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3298</td><td><pre style="display:inline;"> &nbsp;P &nbsp;:= FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3299</td><td><pre style="display:inline;"> &nbsp;I &nbsp;:= P[0];</pre></td></tr>
<tr class="covered"><td>3300</td><td><pre style="display:inline;"> &nbsp;J &nbsp;:= P[1];</pre></td></tr>
<tr class="covered"><td>3301</td><td><pre style="display:inline;"> &nbsp;T3 := P[2];</pre></td></tr>
<tr class="covered"><td>3302</td><td><pre style="display:inline;"> &nbsp;for W := 0 to Size div 4 - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3303</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3304</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := P[J + 3 + 128]; Inc(J, T3);</pre></td></tr>
<tr class="covered"><td>3305</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := P[J + 3 + 128];</pre></td></tr>
<tr class="covered"><td>3306</td><td><pre style="display:inline;"> &nbsp; &nbsp;PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] + T1 + T2;</pre></td></tr>
<tr class="covered"><td>3307</td><td><pre style="display:inline;"> &nbsp; &nbsp;T3 := T2 + P[I + 3]; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>3308</td><td><pre style="display:inline;"> &nbsp; &nbsp;P[J + 3 + 128] := T3;</pre></td></tr>
<tr class="covered"><td>3309</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(J, T2);</pre></td></tr>
<tr class="covered"><td>3310</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3311</td><td><pre style="display:inline;"> &nbsp;P[0] := I;</pre></td></tr>
<tr class="covered"><td>3312</td><td><pre style="display:inline;"> &nbsp;P[1] := J;</pre></td></tr>
<tr class="covered"><td>3313</td><td><pre style="display:inline;"> &nbsp;P[2] := T3;</pre></td></tr>
<tr class="covered"><td>3314</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3315</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3316</td><td><pre style="display:inline;">procedure TCipher_SCOP.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3317</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3318</td><td><pre style="display:inline;"> &nbsp;I, J: Byte;</pre></td></tr>
<tr class="nocodegen"><td>3319</td><td><pre style="display:inline;"> &nbsp;T1, T2, T3: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3320</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3321</td><td><pre style="display:inline;"> &nbsp;W: Integer;</pre></td></tr>
<tr class="covered"><td>3322</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3323</td><td><pre style="display:inline;"> &nbsp;P &nbsp;:= FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3324</td><td><pre style="display:inline;"> &nbsp;I &nbsp;:= P[0];</pre></td></tr>
<tr class="covered"><td>3325</td><td><pre style="display:inline;"> &nbsp;J &nbsp;:= P[1];</pre></td></tr>
<tr class="covered"><td>3326</td><td><pre style="display:inline;"> &nbsp;T3 := P[2];</pre></td></tr>
<tr class="covered"><td>3327</td><td><pre style="display:inline;"> &nbsp;for W := 0 to Size div 4 - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3328</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3329</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := P[J + 3 + 128]; Inc(J, T3);</pre></td></tr>
<tr class="covered"><td>3330</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := P[J + 3 + 128];</pre></td></tr>
<tr class="covered"><td>3331</td><td><pre style="display:inline;"> &nbsp; &nbsp;PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] - T1 - T2;</pre></td></tr>
<tr class="covered"><td>3332</td><td><pre style="display:inline;"> &nbsp; &nbsp;T3 := T2 + P[I + 3];</pre></td></tr>
<tr class="covered"><td>3333</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>3334</td><td><pre style="display:inline;"> &nbsp; &nbsp;P[J + 3 + 128] := T3;</pre></td></tr>
<tr class="covered"><td>3335</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(J, T2);</pre></td></tr>
<tr class="covered"><td>3336</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3337</td><td><pre style="display:inline;"> &nbsp;P[0] := I;</pre></td></tr>
<tr class="covered"><td>3338</td><td><pre style="display:inline;"> &nbsp;P[1] := J;</pre></td></tr>
<tr class="covered"><td>3339</td><td><pre style="display:inline;"> &nbsp;P[2] := T3;</pre></td></tr>
<tr class="covered"><td>3340</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3341</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3342</td><td><pre style="display:inline;">{ TCipher_SCOP_DEC52 }</pre></td></tr>
<tr class="nocodegen"><td>3343</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3344</td><td><pre style="display:inline;">class function TCipher_SCOP_DEC52.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3345</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3346</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 48;</pre></td></tr>
<tr class="covered"><td>3347</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 4;</pre></td></tr>
<tr class="covered"><td>3348</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 32;</pre></td></tr>
<tr class="covered"><td>3349</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 384 * 4 + 3 * SizeOf(UInt32);</pre></td></tr>
<tr class="covered"><td>3350</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := True;</pre></td></tr>
<tr class="covered"><td>3351</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3352</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3353</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctStream];</pre></td></tr>
<tr class="covered"><td>3354</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3355</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3356</td><td><pre style="display:inline;">procedure TCipher_SCOP_DEC52.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3357</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3358</td><td><pre style="display:inline;"> &nbsp;Init_State: packed record</pre></td></tr>
<tr class="nocodegen"><td>3359</td><td><pre style="display:inline;"> &nbsp; &nbsp;Coef: array[0..7, 0..3] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>3360</td><td><pre style="display:inline;"> &nbsp; &nbsp;X: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3361</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3362</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3363</td><td><pre style="display:inline;"> &nbsp;procedure ExpandKey;</pre></td></tr>
<tr class="nocodegen"><td>3364</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>3365</td><td><pre style="display:inline;"> &nbsp; &nbsp;P: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>3366</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, C: Integer;</pre></td></tr>
<tr class="covered"><td>3367</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3368</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := 1;</pre></td></tr>
<tr class="covered"><td>3369</td><td><pre style="display:inline;"> &nbsp; &nbsp;P := @Init_State;</pre></td></tr>
<tr class="covered"><td>3370</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(Key, P^, Size);</pre></td></tr>
<tr class="covered"><td>3371</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := Size to 47 do</pre></td></tr>
<tr class="covered"><td>3372</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;P[I] := P[I - Size] + P[I - Size + 1];</pre></td></tr>
<tr class="covered"><td>3373</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="covered"><td>3374</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if P[I] = 0 then</pre></td></tr>
<tr class="nocodegen"><td>3375</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>3376</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P[I] := C;</pre></td></tr>
<tr class="notcovered"><td>3377</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(C);</pre></td></tr>
<tr class="covered"><td>3378</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3379</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3380</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3381</td><td><pre style="display:inline;"> &nbsp;procedure GP8(Data: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3382</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>3383</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, I2: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3384</td><td><pre style="display:inline;"> &nbsp; &nbsp;NewX: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3385</td><td><pre style="display:inline;"> &nbsp; &nbsp;X1, X2, X3, X4: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3386</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y1, Y2: UInt32;</pre></td></tr>
<tr class="covered"><td>3387</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3388</td><td><pre style="display:inline;"> &nbsp; &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>3389</td><td><pre style="display:inline;"> &nbsp; &nbsp;I2 := 0;</pre></td></tr>
<tr class="covered"><td>3390</td><td><pre style="display:inline;"> &nbsp; &nbsp;while I &lt; 8 do</pre></td></tr>
<tr class="nocodegen"><td>3391</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3392</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X1 := Init_State.X[I2] shr 16;</pre></td></tr>
<tr class="covered"><td>3393</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X2 := X1 * X1;</pre></td></tr>
<tr class="covered"><td>3394</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X3 := X2 * X1;</pre></td></tr>
<tr class="covered"><td>3395</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X4 := X3 * X1;</pre></td></tr>
<tr class="covered"><td>3396</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Y1 := Init_State.Coef[I][0] * X4 +</pre></td></tr>
<tr class="nocodegen"><td>3397</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I][1] * X3 +</pre></td></tr>
<tr class="nocodegen"><td>3398</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I][2] * X2 +</pre></td></tr>
<tr class="nocodegen"><td>3399</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I][3] * X1 + 1;</pre></td></tr>
<tr class="covered"><td>3400</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X1 := Init_State.X[I2] and $FFFF;</pre></td></tr>
<tr class="covered"><td>3401</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X2 := X1 * X1;</pre></td></tr>
<tr class="covered"><td>3402</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X3 := X2 * X1;</pre></td></tr>
<tr class="covered"><td>3403</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X4 := X3 * X1;</pre></td></tr>
<tr class="covered"><td>3404</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Y2 := Init_State.Coef[I + 1][0] * X4 +</pre></td></tr>
<tr class="nocodegen"><td>3405</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I + 2][1] * X3 +</pre></td></tr>
<tr class="nocodegen"><td>3406</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I + 3][2] * X2 +</pre></td></tr>
<tr class="nocodegen"><td>3407</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Init_State.Coef[I + 4][3] * X1 + 1;</pre></td></tr>
<tr class="covered"><td>3408</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Data[I2] := Y1 shl 16 or Y2 and $FFFF;</pre></td></tr>
<tr class="covered"><td>3409</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;NewX[I2] := Y1 and $FFFF0000 or Y2 shr 16;</pre></td></tr>
<tr class="covered"><td>3410</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I2);</pre></td></tr>
<tr class="covered"><td>3411</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I, 2);</pre></td></tr>
<tr class="nocodegen"><td>3412</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3413</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[0] := NewX[0] shr 16 or NewX[3] shl 16;</pre></td></tr>
<tr class="covered"><td>3414</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[1] := NewX[0] shl 16 or NewX[1] shr 16;</pre></td></tr>
<tr class="covered"><td>3415</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[2] := NewX[1] shl 16 or NewX[2] shr 16;</pre></td></tr>
<tr class="covered"><td>3416</td><td><pre style="display:inline;"> &nbsp; &nbsp;Init_State.X[3] := NewX[2] shl 16 or NewX[3] shr 16;</pre></td></tr>
<tr class="covered"><td>3417</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3418</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3419</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3420</td><td><pre style="display:inline;"> &nbsp;I, J: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3421</td><td><pre style="display:inline;"> &nbsp;T: array[0..3] of Integer;</pre></td></tr>
<tr class="nocodegen"><td>3422</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>3423</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3424</td><td><pre style="display:inline;"> &nbsp;FillChar(Init_State, SizeOf(Init_State), 0);</pre></td></tr>
<tr class="covered"><td>3425</td><td><pre style="display:inline;"> &nbsp;FillChar(T, SizeOf(T), 0);</pre></td></tr>
<tr class="covered"><td>3426</td><td><pre style="display:inline;"> &nbsp;P := Pointer(PByte(FAdditionalBuffer) + 12); // for Pointer Math</pre></td></tr>
<tr class="covered"><td>3427</td><td><pre style="display:inline;"> &nbsp;ExpandKey;</pre></td></tr>
<tr class="covered"><td>3428</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="covered"><td>3429</td><td><pre style="display:inline;"> &nbsp; &nbsp;GP8(@T);</pre></td></tr>
<tr class="covered"><td>3430</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 11 do</pre></td></tr>
<tr class="nocodegen"><td>3431</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3432</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 7 do</pre></td></tr>
<tr class="covered"><td>3433</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;GP8(@P[I * 32 + J * 4]);</pre></td></tr>
<tr class="covered"><td>3434</td><td><pre style="display:inline;"> &nbsp; &nbsp;GP8(@T);</pre></td></tr>
<tr class="covered"><td>3435</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3436</td><td><pre style="display:inline;"> &nbsp;GP8(@T);</pre></td></tr>
<tr class="covered"><td>3437</td><td><pre style="display:inline;"> &nbsp;I := T[3] and $7F;</pre></td></tr>
<tr class="covered"><td>3438</td><td><pre style="display:inline;"> &nbsp;P[I + 3] := P[I + 3] or 1;</pre></td></tr>
<tr class="covered"><td>3439</td><td><pre style="display:inline;"> &nbsp;P := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3440</td><td><pre style="display:inline;"> &nbsp;P[0] := T[3] shr 24 and $FF;</pre></td></tr>
<tr class="covered"><td>3441</td><td><pre style="display:inline;"> &nbsp;P[1] := T[3] shr 16 and $FF;</pre></td></tr>
<tr class="covered"><td>3442</td><td><pre style="display:inline;"> &nbsp;P[2] := T[3] shr &nbsp;8 and $FF;</pre></td></tr>
<tr class="covered"><td>3443</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(Init_State, SizeOf(Init_State));</pre></td></tr>
<tr class="nocodegen"><td>3444</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3445</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>3446</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3447</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3448</td><td><pre style="display:inline;">procedure TCipher_SCOP_DEC52.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3449</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3450</td><td><pre style="display:inline;"> &nbsp;I, J: Byte;</pre></td></tr>
<tr class="nocodegen"><td>3451</td><td><pre style="display:inline;"> &nbsp;T2, T3, T1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3452</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3453</td><td><pre style="display:inline;"> &nbsp;W: Integer;</pre></td></tr>
<tr class="covered"><td>3454</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3455</td><td><pre style="display:inline;"> &nbsp;P &nbsp;:= FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3456</td><td><pre style="display:inline;"> &nbsp;I &nbsp;:= P[0];</pre></td></tr>
<tr class="covered"><td>3457</td><td><pre style="display:inline;"> &nbsp;J &nbsp;:= P[1];</pre></td></tr>
<tr class="covered"><td>3458</td><td><pre style="display:inline;"> &nbsp;T3 := P[2];</pre></td></tr>
<tr class="covered"><td>3459</td><td><pre style="display:inline;"> &nbsp;for W := 0 to Size div 4 - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3460</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3461</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := P[J + 3 + 128]; Inc(J, T3);</pre></td></tr>
<tr class="covered"><td>3462</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := P[J + 3 + 128];</pre></td></tr>
<tr class="covered"><td>3463</td><td><pre style="display:inline;"> &nbsp; &nbsp;PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] + T1 + T2;</pre></td></tr>
<tr class="covered"><td>3464</td><td><pre style="display:inline;"> &nbsp; &nbsp;T3 := T2 + P[I + 3]; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>3465</td><td><pre style="display:inline;"> &nbsp; &nbsp;P[J + 3 + 128] := T3;</pre></td></tr>
<tr class="covered"><td>3466</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(J, T2);</pre></td></tr>
<tr class="covered"><td>3467</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3468</td><td><pre style="display:inline;"> &nbsp;P[0] := I;</pre></td></tr>
<tr class="covered"><td>3469</td><td><pre style="display:inline;"> &nbsp;P[1] := J;</pre></td></tr>
<tr class="covered"><td>3470</td><td><pre style="display:inline;"> &nbsp;P[2] := T3;</pre></td></tr>
<tr class="covered"><td>3471</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3472</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3473</td><td><pre style="display:inline;">procedure TCipher_SCOP_DEC52.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3474</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3475</td><td><pre style="display:inline;"> &nbsp;I, J: Byte;</pre></td></tr>
<tr class="nocodegen"><td>3476</td><td><pre style="display:inline;"> &nbsp;T1, T2, T3: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3477</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3478</td><td><pre style="display:inline;"> &nbsp;W: Integer;</pre></td></tr>
<tr class="covered"><td>3479</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3480</td><td><pre style="display:inline;"> &nbsp;P &nbsp;:= FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3481</td><td><pre style="display:inline;"> &nbsp;I &nbsp;:= P[0];</pre></td></tr>
<tr class="covered"><td>3482</td><td><pre style="display:inline;"> &nbsp;J &nbsp;:= P[1];</pre></td></tr>
<tr class="covered"><td>3483</td><td><pre style="display:inline;"> &nbsp;T3 := P[2];</pre></td></tr>
<tr class="covered"><td>3484</td><td><pre style="display:inline;"> &nbsp;for W := 0 to Size div 4 - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3485</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3486</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := P[J + 3 + 128]; Inc(J, T3);</pre></td></tr>
<tr class="covered"><td>3487</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := P[J + 3 + 128];</pre></td></tr>
<tr class="covered"><td>3488</td><td><pre style="display:inline;"> &nbsp; &nbsp;PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] - T1 - T2;</pre></td></tr>
<tr class="covered"><td>3489</td><td><pre style="display:inline;"> &nbsp; &nbsp;T3 := T2 + P[I + 3];</pre></td></tr>
<tr class="covered"><td>3490</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>3491</td><td><pre style="display:inline;"> &nbsp; &nbsp;P[J + 3 + 128] := T3;</pre></td></tr>
<tr class="covered"><td>3492</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(J, T2);</pre></td></tr>
<tr class="covered"><td>3493</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3494</td><td><pre style="display:inline;"> &nbsp;P[0] := I;</pre></td></tr>
<tr class="covered"><td>3495</td><td><pre style="display:inline;"> &nbsp;P[1] := J;</pre></td></tr>
<tr class="covered"><td>3496</td><td><pre style="display:inline;"> &nbsp;P[2] := T3;</pre></td></tr>
<tr class="covered"><td>3497</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3498</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3499</td><td><pre style="display:inline;">{ TCipher_Sapphire }</pre></td></tr>
<tr class="nocodegen"><td>3500</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3501</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>3502</td><td><pre style="display:inline;"> &nbsp;PSapphireKey = ^TSapphireKey;</pre></td></tr>
<tr class="nocodegen"><td>3503</td><td><pre style="display:inline;"> &nbsp;TSapphireKey = packed record</pre></td></tr>
<tr class="nocodegen"><td>3504</td><td><pre style="display:inline;"> &nbsp; &nbsp;Cards: array[0..255] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3505</td><td><pre style="display:inline;"> &nbsp; &nbsp;Rotor: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3506</td><td><pre style="display:inline;"> &nbsp; &nbsp;Ratchet: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3507</td><td><pre style="display:inline;"> &nbsp; &nbsp;Avalanche: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3508</td><td><pre style="display:inline;"> &nbsp; &nbsp;Plain: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3509</td><td><pre style="display:inline;"> &nbsp; &nbsp;Cipher: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3510</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3511</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3512</td><td><pre style="display:inline;">class function TCipher_Sapphire.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3513</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3514</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1024;</pre></td></tr>
<tr class="covered"><td>3515</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3516</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 32;</pre></td></tr>
<tr class="covered"><td>3517</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= SizeOf(TSapphireKey);</pre></td></tr>
<tr class="covered"><td>3518</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := True;</pre></td></tr>
<tr class="covered"><td>3519</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3520</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3521</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctStream];</pre></td></tr>
<tr class="covered"><td>3522</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3523</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3524</td><td><pre style="display:inline;">procedure TCipher_Sapphire.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3525</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3526</td><td><pre style="display:inline;"> &nbsp;Sum: Byte;</pre></td></tr>
<tr class="nocodegen"><td>3527</td><td><pre style="display:inline;"> &nbsp;P: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3528</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3529</td><td><pre style="display:inline;"> &nbsp;function KeyRand(Max: UInt32): Byte;</pre></td></tr>
<tr class="nocodegen"><td>3530</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>3531</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, M: UInt32;</pre></td></tr>
<tr class="covered"><td>3532</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3533</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := 0;</pre></td></tr>
<tr class="covered"><td>3534</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Max = 0 then</pre></td></tr>
<tr class="nocodegen"><td>3535</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Exit;</pre></td></tr>
<tr class="covered"><td>3536</td><td><pre style="display:inline;"> &nbsp; &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>3537</td><td><pre style="display:inline;"> &nbsp; &nbsp;M := 1;</pre></td></tr>
<tr class="nocodegen"><td>3538</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3539</td><td><pre style="display:inline;"> &nbsp; &nbsp;while M &lt; Max do</pre></td></tr>
<tr class="covered"><td>3540</td><td><pre style="display:inline;"> &nbsp; &nbsp; Inc(M, M or 1);</pre></td></tr>
<tr class="nocodegen"><td>3541</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3542</td><td><pre style="display:inline;"> &nbsp; &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>3543</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(Sum, TByteArray(Key)[P]);</pre></td></tr>
<tr class="covered"><td>3544</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(P);</pre></td></tr>
<tr class="covered"><td>3545</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if P &gt;= Size then</pre></td></tr>
<tr class="nocodegen"><td>3546</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3547</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;P := 0;</pre></td></tr>
<tr class="covered"><td>3548</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(Sum, Size);</pre></td></tr>
<tr class="nocodegen"><td>3549</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3550</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := M and Sum;</pre></td></tr>
<tr class="covered"><td>3551</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>3552</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I &gt; 11 then</pre></td></tr>
<tr class="notcovered"><td>3553</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Result := Result mod Max;</pre></td></tr>
<tr class="covered"><td>3554</td><td><pre style="display:inline;"> &nbsp; &nbsp;until Result &lt;= Max;</pre></td></tr>
<tr class="covered"><td>3555</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3556</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3557</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3558</td><td><pre style="display:inline;"> &nbsp;I, S, T: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3559</td><td><pre style="display:inline;"> &nbsp;SKey : PSapphireKey;</pre></td></tr>
<tr class="covered"><td>3560</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3561</td><td><pre style="display:inline;"> &nbsp;SKey := PSapphireKey(FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3562</td><td><pre style="display:inline;"> &nbsp;if Size &lt;= 0 then</pre></td></tr>
<tr class="nocodegen"><td>3563</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>3564</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Rotor &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="notcovered"><td>3565</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Ratchet &nbsp; := 3;</pre></td></tr>
<tr class="notcovered"><td>3566</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Avalanche := 5;</pre></td></tr>
<tr class="notcovered"><td>3567</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Plain &nbsp; &nbsp; := 7;</pre></td></tr>
<tr class="notcovered"><td>3568</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cipher &nbsp; &nbsp;:= 11;</pre></td></tr>
<tr class="notcovered"><td>3569</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="notcovered"><td>3570</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SKey.Cards[I] := 255 - I;</pre></td></tr>
<tr class="nocodegen"><td>3571</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>3572</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3573</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3574</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="covered"><td>3575</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SKey.Cards[I] := I;</pre></td></tr>
<tr class="covered"><td>3576</td><td><pre style="display:inline;"> &nbsp; &nbsp;P &nbsp; := 0;</pre></td></tr>
<tr class="covered"><td>3577</td><td><pre style="display:inline;"> &nbsp; &nbsp;Sum := 0;</pre></td></tr>
<tr class="covered"><td>3578</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 255 downto 1 do</pre></td></tr>
<tr class="nocodegen"><td>3579</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3580</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S := KeyRand(I);</pre></td></tr>
<tr class="covered"><td>3581</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := SKey.Cards[I];</pre></td></tr>
<tr class="covered"><td>3582</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SKey.Cards[I] := SKey.Cards[S];</pre></td></tr>
<tr class="covered"><td>3583</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;SKey.Cards[S] := T;</pre></td></tr>
<tr class="covered"><td>3584</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3585</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Rotor &nbsp; &nbsp; := SKey.Cards[1];</pre></td></tr>
<tr class="covered"><td>3586</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Ratchet &nbsp; := SKey.Cards[3];</pre></td></tr>
<tr class="covered"><td>3587</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Avalanche := SKey.Cards[5];</pre></td></tr>
<tr class="covered"><td>3588</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Plain &nbsp; &nbsp; := SKey.Cards[7];</pre></td></tr>
<tr class="covered"><td>3589</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cipher &nbsp; &nbsp;:= SKey.Cards[Sum];</pre></td></tr>
<tr class="nocodegen"><td>3590</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3591</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3592</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>3593</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3594</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3595</td><td><pre style="display:inline;">procedure TCipher_Sapphire.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3596</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3597</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3598</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3599</td><td><pre style="display:inline;"> &nbsp;SKey: PSapphireKey;</pre></td></tr>
<tr class="covered"><td>3600</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3601</td><td><pre style="display:inline;"> &nbsp;SKey := PSapphireKey(FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3602</td><td><pre style="display:inline;"> &nbsp;for I := 0 to Size - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3603</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3604</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Ratchet := (SKey.Ratchet + SKey.Cards[SKey.Rotor]) and $FF;</pre></td></tr>
<tr class="covered"><td>3605</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Rotor := (SKey.Rotor + 1) and $FF;</pre></td></tr>
<tr class="covered"><td>3606</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := SKey.Cards[SKey.Cipher];</pre></td></tr>
<tr class="covered"><td>3607</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Cipher] &nbsp;:= SKey.Cards[SKey.Ratchet];</pre></td></tr>
<tr class="covered"><td>3608</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Ratchet] := SKey.Cards[SKey.Plain];</pre></td></tr>
<tr class="covered"><td>3609</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Plain] &nbsp; := SKey.Cards[SKey.Rotor];</pre></td></tr>
<tr class="covered"><td>3610</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Rotor] &nbsp; := T;</pre></td></tr>
<tr class="covered"><td>3611</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Avalanche := (SKey.Avalanche + SKey.Cards[T]) and $FF;</pre></td></tr>
<tr class="covered"><td>3612</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (SKey.Cards[SKey.Plain] + SKey.Cards[SKey.Cipher] + SKey.Cards[SKey.Avalanche]) and $FF;</pre></td></tr>
<tr class="covered"><td>3613</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Plain := PByteArray(Source)[I];</pre></td></tr>
<tr class="covered"><td>3614</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cipher := SKey.Plain xor SKey.Cards[SKey.Cards[T]] xor</pre></td></tr>
<tr class="nocodegen"><td>3615</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SKey.Cards[(SKey.Cards[SKey.Ratchet] +</pre></td></tr>
<tr class="nocodegen"><td>3616</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SKey.Cards[SKey.Rotor]) and $FF];</pre></td></tr>
<tr class="covered"><td>3617</td><td><pre style="display:inline;"> &nbsp; &nbsp;PByteArray(Dest)[I] := SKey.Cipher;</pre></td></tr>
<tr class="covered"><td>3618</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3619</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3620</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3621</td><td><pre style="display:inline;">procedure TCipher_Sapphire.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3622</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3623</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3624</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3625</td><td><pre style="display:inline;"> &nbsp;SKey: PSapphireKey;</pre></td></tr>
<tr class="covered"><td>3626</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3627</td><td><pre style="display:inline;"> &nbsp;SKey := PSapphireKey(FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3628</td><td><pre style="display:inline;"> &nbsp;for I := 0 to Size - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3629</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3630</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Ratchet := (SKey.Ratchet + SKey.Cards[SKey.Rotor]) and $FF;</pre></td></tr>
<tr class="covered"><td>3631</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Rotor := (SKey.Rotor + 1) and $FF;</pre></td></tr>
<tr class="covered"><td>3632</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := SKey.Cards[SKey.Cipher];</pre></td></tr>
<tr class="covered"><td>3633</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Cipher] &nbsp;:= SKey.Cards[SKey.Ratchet];</pre></td></tr>
<tr class="covered"><td>3634</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Ratchet] := SKey.Cards[SKey.Plain];</pre></td></tr>
<tr class="covered"><td>3635</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Plain] &nbsp; := SKey.Cards[SKey.Rotor];</pre></td></tr>
<tr class="covered"><td>3636</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cards[SKey.Rotor] &nbsp; := T;</pre></td></tr>
<tr class="covered"><td>3637</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Avalanche := (SKey.Avalanche + SKey.Cards[T]) and $FF;</pre></td></tr>
<tr class="covered"><td>3638</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (SKey.Cards[SKey.Plain] + SKey.Cards[SKey.Cipher] + SKey.Cards[SKey.Avalanche]) and $FF;</pre></td></tr>
<tr class="covered"><td>3639</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Cipher := PByteArray(Source)[I];</pre></td></tr>
<tr class="covered"><td>3640</td><td><pre style="display:inline;"> &nbsp; &nbsp;SKey.Plain := SKey.Cipher xor SKey.Cards[SKey.Cards[T]] xor</pre></td></tr>
<tr class="nocodegen"><td>3641</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SKey.Cards[(SKey.Cards[SKey.Ratchet] +</pre></td></tr>
<tr class="nocodegen"><td>3642</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SKey.Cards[SKey.Rotor]) and $FF];</pre></td></tr>
<tr class="covered"><td>3643</td><td><pre style="display:inline;"> &nbsp; &nbsp;PByteArray(Dest)[I] := SKey.Plain;</pre></td></tr>
<tr class="covered"><td>3644</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3645</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3646</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3647</td><td><pre style="display:inline;">{ DES basics }</pre></td></tr>
<tr class="nocodegen"><td>3648</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3649</td><td><pre style="display:inline;">procedure DES_Func(Source, Dest, Key: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3650</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3651</td><td><pre style="display:inline;"> &nbsp;L, R, X, Y, I: UInt32;</pre></td></tr>
<tr class="covered"><td>3652</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3653</td><td><pre style="display:inline;"> &nbsp;L := SwapUInt32(Source[0]);</pre></td></tr>
<tr class="covered"><td>3654</td><td><pre style="display:inline;"> &nbsp;R := SwapUInt32(Source[1]);</pre></td></tr>
<tr class="nocodegen"><td>3655</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3656</td><td><pre style="display:inline;"> &nbsp;X := (L shr &nbsp;4 xor R) and $0F0F0F0F; R := R xor X; L := L xor X shl &nbsp;4;</pre></td></tr>
<tr class="covered"><td>3657</td><td><pre style="display:inline;"> &nbsp;X := (L shr 16 xor R) and $0000FFFF; R := R xor X; L := L xor X shl 16;</pre></td></tr>
<tr class="covered"><td>3658</td><td><pre style="display:inline;"> &nbsp;X := (R shr &nbsp;2 xor L) and $33333333; L := L xor X; R := R xor X shl &nbsp;2;</pre></td></tr>
<tr class="covered"><td>3659</td><td><pre style="display:inline;"> &nbsp;X := (R shr &nbsp;8 xor L) and $00FF00FF; L := L xor X; R := R xor X shl &nbsp;8;</pre></td></tr>
<tr class="nocodegen"><td>3660</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3661</td><td><pre style="display:inline;"> &nbsp;R := R shl 1 or R shr 31;</pre></td></tr>
<tr class="covered"><td>3662</td><td><pre style="display:inline;"> &nbsp;X := (L xor R) and $AAAAAAAA;</pre></td></tr>
<tr class="covered"><td>3663</td><td><pre style="display:inline;"> &nbsp;R := R xor X;</pre></td></tr>
<tr class="covered"><td>3664</td><td><pre style="display:inline;"> &nbsp;L := L xor X;</pre></td></tr>
<tr class="covered"><td>3665</td><td><pre style="display:inline;"> &nbsp;L := L shl 1 or L shr 31;</pre></td></tr>
<tr class="nocodegen"><td>3666</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3667</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>3668</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3669</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := (R shl 28 or R shr 4) xor Key[0];</pre></td></tr>
<tr class="covered"><td>3670</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := R xor Key[1];</pre></td></tr>
<tr class="covered"><td>3671</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor (DES_Data[0, X &nbsp; &nbsp; &nbsp; &nbsp;and $3F] or DES_Data[1, X shr &nbsp;8 and $3F] or</pre></td></tr>
<tr class="nocodegen"><td>3672</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DES_Data[2, X shr 16 and $3F] or DES_Data[3, X shr 24 and $3F] or</pre></td></tr>
<tr class="nocodegen"><td>3673</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DES_Data[4, Y &nbsp; &nbsp; &nbsp; &nbsp;and $3F] or DES_Data[5, Y shr &nbsp;8 and $3F] or</pre></td></tr>
<tr class="nocodegen"><td>3674</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DES_Data[6, Y shr 16 and $3F] or DES_Data[7, Y shr 24 and $3F]);</pre></td></tr>
<tr class="nocodegen"><td>3675</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3676</td><td><pre style="display:inline;"> &nbsp; &nbsp;X := (L shl 28 or L shr 4) xor Key[2];</pre></td></tr>
<tr class="covered"><td>3677</td><td><pre style="display:inline;"> &nbsp; &nbsp;Y := L xor Key[3];</pre></td></tr>
<tr class="covered"><td>3678</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R xor (DES_Data[0, X &nbsp; &nbsp; &nbsp; &nbsp;and $3F] or DES_Data[1, X shr &nbsp;8 and $3F] or</pre></td></tr>
<tr class="nocodegen"><td>3679</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DES_Data[2, X shr 16 and $3F] or DES_Data[3, X shr 24 and $3F] or</pre></td></tr>
<tr class="nocodegen"><td>3680</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DES_Data[4, Y &nbsp; &nbsp; &nbsp; &nbsp;and $3F] or DES_Data[5, Y shr &nbsp;8 and $3F] or</pre></td></tr>
<tr class="nocodegen"><td>3681</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DES_Data[6, Y shr 16 and $3F] or DES_Data[7, Y shr 24 and $3F]);</pre></td></tr>
<tr class="covered"><td>3682</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key := @Key[4];</pre></td></tr>
<tr class="covered"><td>3683</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3684</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3685</td><td><pre style="display:inline;"> &nbsp;R := R shl 31 or R shr 1;</pre></td></tr>
<tr class="covered"><td>3686</td><td><pre style="display:inline;"> &nbsp;X := (L xor R) and $AAAAAAAA;</pre></td></tr>
<tr class="covered"><td>3687</td><td><pre style="display:inline;"> &nbsp;R := R xor X;</pre></td></tr>
<tr class="covered"><td>3688</td><td><pre style="display:inline;"> &nbsp;L := L xor X;</pre></td></tr>
<tr class="covered"><td>3689</td><td><pre style="display:inline;"> &nbsp;L := L shl 31 or L shr 1;</pre></td></tr>
<tr class="nocodegen"><td>3690</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3691</td><td><pre style="display:inline;"> &nbsp;X := (L shr &nbsp;8 xor R) and $00FF00FF; R := R xor X; L := L xor X shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>3692</td><td><pre style="display:inline;"> &nbsp;X := (L shr &nbsp;2 xor R) and $33333333; R := R xor X; L := L xor X shl &nbsp;2;</pre></td></tr>
<tr class="covered"><td>3693</td><td><pre style="display:inline;"> &nbsp;X := (R shr 16 xor L) and $0000FFFF; L := L xor X; R := R xor X shl 16;</pre></td></tr>
<tr class="covered"><td>3694</td><td><pre style="display:inline;"> &nbsp;X := (R shr &nbsp;4 xor L) and $0F0F0F0F; L := L xor X; R := R xor X shl &nbsp;4;</pre></td></tr>
<tr class="nocodegen"><td>3695</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3696</td><td><pre style="display:inline;"> &nbsp;Dest[0] := SwapUInt32(R);</pre></td></tr>
<tr class="covered"><td>3697</td><td><pre style="display:inline;"> &nbsp;Dest[1] := SwapUInt32(L);</pre></td></tr>
<tr class="covered"><td>3698</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3699</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3700</td><td><pre style="display:inline;">procedure TCipher_DESBase.DoInitKey(const Data: array of Byte; Key: PUInt32Array; Reverse: Boolean);</pre></td></tr>
<tr class="nocodegen"><td>3701</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>3702</td><td><pre style="display:inline;"> &nbsp;ROT: array[0..15] of Byte = (1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28);</pre></td></tr>
<tr class="nocodegen"><td>3703</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3704</td><td><pre style="display:inline;"> &nbsp;I, J, L, M, N: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3705</td><td><pre style="display:inline;"> &nbsp;PC_M, PC_R: array[0..55] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>3706</td><td><pre style="display:inline;"> &nbsp;K: array[0..31] of UInt32;</pre></td></tr>
<tr class="covered"><td>3707</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3708</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>3709</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 55 do</pre></td></tr>
<tr class="covered"><td>3710</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Data[DES_PC1[I] shr 3] and ($80 shr (DES_PC1[I] and $07)) &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>3711</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PC_M[I] := 1</pre></td></tr>
<tr class="nocodegen"><td>3712</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>3713</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PC_M[I] := 0;</pre></td></tr>
<tr class="covered"><td>3714</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>3715</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3716</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Reverse then</pre></td></tr>
<tr class="covered"><td>3717</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;M := (15 - I) shl 1</pre></td></tr>
<tr class="nocodegen"><td>3718</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>3719</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;M := I shl 1;</pre></td></tr>
<tr class="covered"><td>3720</td><td><pre style="display:inline;"> &nbsp; &nbsp;N := M + 1;</pre></td></tr>
<tr class="covered"><td>3721</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 27 do</pre></td></tr>
<tr class="nocodegen"><td>3722</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3723</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;L := J + ROT[I];</pre></td></tr>
<tr class="covered"><td>3724</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if L &lt; 28 then</pre></td></tr>
<tr class="covered"><td>3725</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PC_R[J] := PC_M[L]</pre></td></tr>
<tr class="nocodegen"><td>3726</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>3727</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PC_R[J] := PC_M[L - 28];</pre></td></tr>
<tr class="covered"><td>3728</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3729</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 28 to 55 do</pre></td></tr>
<tr class="nocodegen"><td>3730</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3731</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;L := J + ROT[I];</pre></td></tr>
<tr class="covered"><td>3732</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if L &lt; 56 then</pre></td></tr>
<tr class="covered"><td>3733</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PC_R[J] := PC_M[L]</pre></td></tr>
<tr class="nocodegen"><td>3734</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>3735</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;PC_R[J] := PC_M[L - 28];</pre></td></tr>
<tr class="covered"><td>3736</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3737</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := $1000000;</pre></td></tr>
<tr class="covered"><td>3738</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 23 do</pre></td></tr>
<tr class="nocodegen"><td>3739</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3740</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;L := L shr 1;</pre></td></tr>
<tr class="covered"><td>3741</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if PC_R[DES_PC2[J &nbsp; &nbsp; ]] &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>3742</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;K[M] := K[M] or L;</pre></td></tr>
<tr class="covered"><td>3743</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if PC_R[DES_PC2[J + 24]] &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>3744</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;K[N] := K[N] or L;</pre></td></tr>
<tr class="covered"><td>3745</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3746</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3747</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>3748</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3749</td><td><pre style="display:inline;"> &nbsp; &nbsp;M := I shl 1;</pre></td></tr>
<tr class="covered"><td>3750</td><td><pre style="display:inline;"> &nbsp; &nbsp;N := M + 1;</pre></td></tr>
<tr class="covered"><td>3751</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[0] := K[M] and $00FC0000 shl &nbsp;6 or</pre></td></tr>
<tr class="nocodegen"><td>3752</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[M] and $00000FC0 shl 10 or</pre></td></tr>
<tr class="nocodegen"><td>3753</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[N] and $00FC0000 shr 10 or</pre></td></tr>
<tr class="nocodegen"><td>3754</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[N] and $00000FC0 shr &nbsp;6;</pre></td></tr>
<tr class="covered"><td>3755</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[1] := K[M] and $0003F000 shl 12 or</pre></td></tr>
<tr class="nocodegen"><td>3756</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[M] and $0000003F shl 16 or</pre></td></tr>
<tr class="nocodegen"><td>3757</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[N] and $0003F000 shr &nbsp;4 or</pre></td></tr>
<tr class="nocodegen"><td>3758</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[N] and $0000003F;</pre></td></tr>
<tr class="covered"><td>3759</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key := @Key[2];</pre></td></tr>
<tr class="covered"><td>3760</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3761</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="covered"><td>3762</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(PC_M, SizeOf(PC_M));</pre></td></tr>
<tr class="covered"><td>3763</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(PC_R, SizeOf(PC_R));</pre></td></tr>
<tr class="covered"><td>3764</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3765</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3766</td><td><pre style="display:inline;">{ TCipher_1DES }</pre></td></tr>
<tr class="nocodegen"><td>3767</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3768</td><td><pre style="display:inline;">class function TCipher_1DES.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3769</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3770</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>3771</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>3772</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>3773</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 32 * 4 * 2;</pre></td></tr>
<tr class="covered"><td>3774</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>3775</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3776</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3777</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>3778</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3779</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3780</td><td><pre style="display:inline;">procedure TCipher_1DES.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3781</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3782</td><td><pre style="display:inline;"> &nbsp;K: array[0..7] of Byte;</pre></td></tr>
<tr class="covered"><td>3783</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3784</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>3785</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>3786</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K, FAdditionalBuffer, False);</pre></td></tr>
<tr class="covered"><td>3787</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K, @PUInt32Array(FAdditionalBuffer)[32], True);</pre></td></tr>
<tr class="covered"><td>3788</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>3789</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3790</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>3791</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3792</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3793</td><td><pre style="display:inline;">procedure TCipher_1DES.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>3794</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3795</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>3796</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3797</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3798</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3799</td><td><pre style="display:inline;">procedure TCipher_1DES.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>3800</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3801</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>3802</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>3803</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3804</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3805</td><td><pre style="display:inline;">{ TCipher_2DES }</pre></td></tr>
<tr class="nocodegen"><td>3806</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3807</td><td><pre style="display:inline;">class function TCipher_2DES.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3808</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3809</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>3810</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>3811</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>3812</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 32 * 4 * 2 * 2;</pre></td></tr>
<tr class="covered"><td>3813</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>3814</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3815</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3816</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>3817</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3818</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3819</td><td><pre style="display:inline;">procedure TCipher_2DES.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3820</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3821</td><td><pre style="display:inline;"> &nbsp;K: array[0..15] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>3822</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>3823</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3824</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>3825</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>3826</td><td><pre style="display:inline;"> &nbsp;P := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3827</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[0], @P[ 0], False);</pre></td></tr>
<tr class="covered"><td>3828</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[8], @P[32], True);</pre></td></tr>
<tr class="covered"><td>3829</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[0], @P[64], True);</pre></td></tr>
<tr class="covered"><td>3830</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[8], @P[96], False);</pre></td></tr>
<tr class="covered"><td>3831</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>3832</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3833</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>3834</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3835</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3836</td><td><pre style="display:inline;">procedure TCipher_2DES.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>3837</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3838</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>3839</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3840</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>3841</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3842</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3843</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3844</td><td><pre style="display:inline;">procedure TCipher_2DES.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>3845</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3846</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>3847</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3848</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>3849</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3850</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3851</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3852</td><td><pre style="display:inline;">{ TCipher_3DES }</pre></td></tr>
<tr class="nocodegen"><td>3853</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3854</td><td><pre style="display:inline;">class function TCipher_3DES.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3855</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3856</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 24;</pre></td></tr>
<tr class="covered"><td>3857</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>3858</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>3859</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 32 * 4 * 2 * 3;</pre></td></tr>
<tr class="covered"><td>3860</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>3861</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3862</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>3863</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>3864</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3865</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3866</td><td><pre style="display:inline;">procedure TCipher_3DES.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3867</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3868</td><td><pre style="display:inline;"> &nbsp;K: array[0..23] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>3869</td><td><pre style="display:inline;"> &nbsp;P: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>3870</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3871</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>3872</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>3873</td><td><pre style="display:inline;"> &nbsp;P := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>3874</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[ 0], @P[ &nbsp;0], False);</pre></td></tr>
<tr class="covered"><td>3875</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[ 8], @P[ 32], True);</pre></td></tr>
<tr class="covered"><td>3876</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[16], @P[ 64], False);</pre></td></tr>
<tr class="covered"><td>3877</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[16], @P[ 96], True);</pre></td></tr>
<tr class="covered"><td>3878</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[ 8], @P[128], False);</pre></td></tr>
<tr class="covered"><td>3879</td><td><pre style="display:inline;"> &nbsp;DoInitKey(K[ 0], @P[160], True);</pre></td></tr>
<tr class="covered"><td>3880</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>3881</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3882</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>3883</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3884</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3885</td><td><pre style="display:inline;">procedure TCipher_3DES.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>3886</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3887</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>3888</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[ 0]);</pre></td></tr>
<tr class="covered"><td>3889</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>3890</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3891</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3892</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3893</td><td><pre style="display:inline;">procedure TCipher_3DES.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>3894</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3895</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>3896</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>3897</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[128]);</pre></td></tr>
<tr class="covered"><td>3898</td><td><pre style="display:inline;"> &nbsp;DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[160]);</pre></td></tr>
<tr class="covered"><td>3899</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3900</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3901</td><td><pre style="display:inline;">{ TCipher_2DDES }</pre></td></tr>
<tr class="nocodegen"><td>3902</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3903</td><td><pre style="display:inline;">class function TCipher_2DDES.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3904</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3905</td><td><pre style="display:inline;"> &nbsp;Result &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= inherited Context;</pre></td></tr>
<tr class="covered"><td>3906</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>3907</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize := 16;</pre></td></tr>
<tr class="covered"><td>3908</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp;:= 1;</pre></td></tr>
<tr class="covered"><td>3909</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp;:= 1;</pre></td></tr>
<tr class="covered"><td>3910</td><td><pre style="display:inline;"> &nbsp;Result.CipherType := [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>3911</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3912</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3913</td><td><pre style="display:inline;">procedure TCipher_2DDES.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3914</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3915</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="covered"><td>3916</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3917</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>3918</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3919</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3920</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3921</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3922</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>3923</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>3924</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>3925</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>3926</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3927</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>3928</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>3929</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3930</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3931</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3932</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3933</td><td><pre style="display:inline;">procedure TCipher_2DDES.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3934</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3935</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="covered"><td>3936</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3937</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>3938</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3939</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3940</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3941</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3942</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>3943</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>3944</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>3945</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>3946</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3947</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>3948</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>3949</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3950</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3951</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3952</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3953</td><td><pre style="display:inline;">{ TCipher_3DDES }</pre></td></tr>
<tr class="nocodegen"><td>3954</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3955</td><td><pre style="display:inline;">class function TCipher_3DDES.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>3956</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3957</td><td><pre style="display:inline;"> &nbsp;Result &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= inherited Context;</pre></td></tr>
<tr class="covered"><td>3958</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>3959</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize := 16;</pre></td></tr>
<tr class="covered"><td>3960</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp;:= 1;</pre></td></tr>
<tr class="covered"><td>3961</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp;:= 1;</pre></td></tr>
<tr class="covered"><td>3962</td><td><pre style="display:inline;"> &nbsp;Result.CipherType := [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>3963</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3964</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3965</td><td><pre style="display:inline;">procedure TCipher_3DDES.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3966</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3967</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="covered"><td>3968</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3969</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>3970</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3971</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3972</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>3973</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3974</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>3975</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>3976</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>3977</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>3978</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3979</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>3980</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>3981</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3982</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>3983</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3984</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3985</td><td><pre style="display:inline;">procedure TCipher_3DDES.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>3986</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3987</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="covered"><td>3988</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3989</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>3990</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3991</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>3992</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>3993</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3994</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>3995</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>3996</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[128]);</pre></td></tr>
<tr class="covered"><td>3997</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[128]);</pre></td></tr>
<tr class="covered"><td>3998</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>3999</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>4000</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>4001</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[160]);</pre></td></tr>
<tr class="covered"><td>4002</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[160]);</pre></td></tr>
<tr class="covered"><td>4003</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4004</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4005</td><td><pre style="display:inline;">{ TCipher_3TDES }</pre></td></tr>
<tr class="nocodegen"><td>4006</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4007</td><td><pre style="display:inline;">class function TCipher_3TDES.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>4008</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4009</td><td><pre style="display:inline;"> &nbsp;Result &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= inherited Context;</pre></td></tr>
<tr class="covered"><td>4010</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp;:= 24;</pre></td></tr>
<tr class="covered"><td>4011</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize := 24;</pre></td></tr>
<tr class="covered"><td>4012</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp;:= 1;</pre></td></tr>
<tr class="covered"><td>4013</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp;:= 1;</pre></td></tr>
<tr class="covered"><td>4014</td><td><pre style="display:inline;"> &nbsp;Result.CipherType := [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>4015</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4016</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4017</td><td><pre style="display:inline;">procedure TCipher_3TDES.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4018</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4019</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="covered"><td>4020</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4021</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>4022</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4023</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4024</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4025</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[4], @PUInt32Array(Dest)[4], FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4026</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>4027</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>4028</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>4029</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[3];</pre></td></tr>
<tr class="covered"><td>4030</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];</pre></td></tr>
<tr class="covered"><td>4031</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[4] := T;</pre></td></tr>
<tr class="covered"><td>4032</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>4033</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>4034</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[32]);</pre></td></tr>
<tr class="covered"><td>4035</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>4036</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>4037</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>4038</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[3];</pre></td></tr>
<tr class="covered"><td>4039</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];</pre></td></tr>
<tr class="covered"><td>4040</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[4] := T;</pre></td></tr>
<tr class="covered"><td>4041</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>4042</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>4043</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[64]);</pre></td></tr>
<tr class="covered"><td>4044</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4045</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4046</td><td><pre style="display:inline;">procedure TCipher_3TDES.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4047</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4048</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="covered"><td>4049</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4050</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>4051</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4052</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>4053</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>4054</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Source)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[96]);</pre></td></tr>
<tr class="covered"><td>4055</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>4056</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>4057</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>4058</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[3];</pre></td></tr>
<tr class="covered"><td>4059</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];</pre></td></tr>
<tr class="covered"><td>4060</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[4] := T;</pre></td></tr>
<tr class="covered"><td>4061</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[128]);</pre></td></tr>
<tr class="covered"><td>4062</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[128]);</pre></td></tr>
<tr class="covered"><td>4063</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[128]);</pre></td></tr>
<tr class="covered"><td>4064</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[1];</pre></td></tr>
<tr class="covered"><td>4065</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];</pre></td></tr>
<tr class="covered"><td>4066</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := T;</pre></td></tr>
<tr class="covered"><td>4067</td><td><pre style="display:inline;"> &nbsp;T := PUInt32Array(Dest)[3];</pre></td></tr>
<tr class="covered"><td>4068</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];</pre></td></tr>
<tr class="covered"><td>4069</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[4] := T;</pre></td></tr>
<tr class="covered"><td>4070</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[160]);</pre></td></tr>
<tr class="covered"><td>4071</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[160]);</pre></td></tr>
<tr class="covered"><td>4072</td><td><pre style="display:inline;"> &nbsp;DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[160]);</pre></td></tr>
<tr class="covered"><td>4073</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4074</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4075</td><td><pre style="display:inline;">{ TCipher_3Way }</pre></td></tr>
<tr class="nocodegen"><td>4076</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4077</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>4078</td><td><pre style="display:inline;"> &nbsp;P3Way_Key = ^T3Way_Key;</pre></td></tr>
<tr class="nocodegen"><td>4079</td><td><pre style="display:inline;"> &nbsp;T3Way_Key = packed record</pre></td></tr>
<tr class="nocodegen"><td>4080</td><td><pre style="display:inline;"> &nbsp; &nbsp;E_Key: array[0..2] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4081</td><td><pre style="display:inline;"> &nbsp; &nbsp;E_Data: array[0..11] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4082</td><td><pre style="display:inline;"> &nbsp; &nbsp;D_Key: array[0..2] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4083</td><td><pre style="display:inline;"> &nbsp; &nbsp;D_Data: array[0..11] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4084</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4085</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4086</td><td><pre style="display:inline;">class function TCipher_3Way.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>4087</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4088</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 12;</pre></td></tr>
<tr class="covered"><td>4089</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 12;</pre></td></tr>
<tr class="covered"><td>4090</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 12;</pre></td></tr>
<tr class="covered"><td>4091</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= SizeOf(T3Way_Key);</pre></td></tr>
<tr class="covered"><td>4092</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>4093</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4094</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4095</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>4096</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4097</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4098</td><td><pre style="display:inline;">procedure TCipher_3Way.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4099</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4100</td><td><pre style="display:inline;"> &nbsp;procedure RANDGenerate(Start: UInt32; var P: array of UInt32);</pre></td></tr>
<tr class="nocodegen"><td>4101</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>4102</td><td><pre style="display:inline;"> &nbsp; &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>4103</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4104</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 11 do</pre></td></tr>
<tr class="nocodegen"><td>4105</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4106</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;P[I] := Start;</pre></td></tr>
<tr class="covered"><td>4107</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Start := Start shl 1;</pre></td></tr>
<tr class="covered"><td>4108</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if Start and $10000 &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>4109</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Start := Start xor $11011;</pre></td></tr>
<tr class="covered"><td>4110</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4111</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4112</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4113</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4114</td><td><pre style="display:inline;"> &nbsp;A0, A1, A2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4115</td><td><pre style="display:inline;"> &nbsp;B0, B1, B2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4116</td><td><pre style="display:inline;"> &nbsp;P3WayKey: P3Way_Key;</pre></td></tr>
<tr class="covered"><td>4117</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4118</td><td><pre style="display:inline;"> &nbsp;P3WayKey := P3Way_Key(FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>4119</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4120</td><td><pre style="display:inline;"> &nbsp;Move(Key, P3WayKey.E_Key, Size);</pre></td></tr>
<tr class="covered"><td>4121</td><td><pre style="display:inline;"> &nbsp;Move(Key, P3WayKey.D_Key, Size);</pre></td></tr>
<tr class="covered"><td>4122</td><td><pre style="display:inline;"> &nbsp;RANDGenerate($0B0B, P3WayKey.E_Data);</pre></td></tr>
<tr class="covered"><td>4123</td><td><pre style="display:inline;"> &nbsp;RANDGenerate($B1B1, P3WayKey.D_Data);</pre></td></tr>
<tr class="covered"><td>4124</td><td><pre style="display:inline;"> &nbsp;A0 := P3WayKey.D_Key[0];</pre></td></tr>
<tr class="covered"><td>4125</td><td><pre style="display:inline;"> &nbsp;A1 := P3WayKey.D_Key[1];</pre></td></tr>
<tr class="covered"><td>4126</td><td><pre style="display:inline;"> &nbsp;A2 := P3WayKey.D_Key[2];</pre></td></tr>
<tr class="covered"><td>4127</td><td><pre style="display:inline;"> &nbsp;B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4128</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 24 xor A2 shl &nbsp;8 xor A2 shr &nbsp;8 xor A0 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4129</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4130</td><td><pre style="display:inline;"> &nbsp;B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4131</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 24 xor A0 shl &nbsp;8 xor A0 shr &nbsp;8 xor A1 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4132</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4133</td><td><pre style="display:inline;"> &nbsp;B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4134</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 24 xor A1 shl &nbsp;8 xor A1 shr &nbsp;8 xor A2 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4135</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4136</td><td><pre style="display:inline;"> &nbsp;P3WayKey.D_Key[2] := ReverseBits(B0);</pre></td></tr>
<tr class="covered"><td>4137</td><td><pre style="display:inline;"> &nbsp;P3WayKey.D_Key[1] := ReverseBits(B1);</pre></td></tr>
<tr class="covered"><td>4138</td><td><pre style="display:inline;"> &nbsp;P3WayKey.D_Key[0] := ReverseBits(B2);</pre></td></tr>
<tr class="nocodegen"><td>4139</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4140</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>4141</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4142</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4143</td><td><pre style="display:inline;">procedure TCipher_3Way.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4144</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4145</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>4146</td><td><pre style="display:inline;"> &nbsp;A0, A1, A2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4147</td><td><pre style="display:inline;"> &nbsp;B0, B1, B2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4148</td><td><pre style="display:inline;"> &nbsp;K0, K1, K2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4149</td><td><pre style="display:inline;"> &nbsp;E: PUInt32;</pre></td></tr>
<tr class="nocodegen"><td>4150</td><td><pre style="display:inline;"> &nbsp;P3WayKey: P3Way_Key;</pre></td></tr>
<tr class="covered"><td>4151</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4152</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>4153</td><td><pre style="display:inline;"> &nbsp;P3WayKey := P3Way_Key(FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>4154</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4155</td><td><pre style="display:inline;"> &nbsp;K0 := P3WayKey.E_Key[0];</pre></td></tr>
<tr class="covered"><td>4156</td><td><pre style="display:inline;"> &nbsp;K1 := P3WayKey.E_Key[1];</pre></td></tr>
<tr class="covered"><td>4157</td><td><pre style="display:inline;"> &nbsp;K2 := P3WayKey.E_Key[2];</pre></td></tr>
<tr class="covered"><td>4158</td><td><pre style="display:inline;"> &nbsp;E &nbsp;:= @P3WayKey.E_Data;</pre></td></tr>
<tr class="nocodegen"><td>4159</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4160</td><td><pre style="display:inline;"> &nbsp;A0 := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>4161</td><td><pre style="display:inline;"> &nbsp;A1 := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>4162</td><td><pre style="display:inline;"> &nbsp;A2 := PUInt32Array(Source)[2];</pre></td></tr>
<tr class="covered"><td>4163</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 10 do</pre></td></tr>
<tr class="nocodegen"><td>4164</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4165</td><td><pre style="display:inline;"> &nbsp; &nbsp;A0 := A0 xor K0 xor E^ shl 16;</pre></td></tr>
<tr class="covered"><td>4166</td><td><pre style="display:inline;"> &nbsp; &nbsp;A1 := A1 xor K1;</pre></td></tr>
<tr class="covered"><td>4167</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := A2 xor K2 xor E^;</pre></td></tr>
<tr class="covered"><td>4168</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(E);</pre></td></tr>
<tr class="nocodegen"><td>4169</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4170</td><td><pre style="display:inline;"> &nbsp; &nbsp;B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4171</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 24 xor A2 shl &nbsp;8 xor A2 shr &nbsp;8 xor A0 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4172</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4173</td><td><pre style="display:inline;"> &nbsp; &nbsp;B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4174</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 24 xor A0 shl &nbsp;8 xor A0 shr &nbsp;8 xor A1 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4175</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4176</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4177</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 24 xor A1 shl &nbsp;8 xor A1 shr &nbsp;8 xor A2 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4178</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4179</td><td><pre style="display:inline;"> &nbsp; &nbsp;B0 := B0 shr 10 or B0 shl 22;</pre></td></tr>
<tr class="covered"><td>4180</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := B2 shl &nbsp;1 or B2 shr 31;</pre></td></tr>
<tr class="covered"><td>4181</td><td><pre style="display:inline;"> &nbsp; &nbsp;A0 := B0 xor (B1 or not B2);</pre></td></tr>
<tr class="covered"><td>4182</td><td><pre style="display:inline;"> &nbsp; &nbsp;A1 := B1 xor (B2 or not B0);</pre></td></tr>
<tr class="covered"><td>4183</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := B2 xor (B0 or not B1);</pre></td></tr>
<tr class="covered"><td>4184</td><td><pre style="display:inline;"> &nbsp; &nbsp;A0 := A0 shl &nbsp;1 or A0 shr 31;</pre></td></tr>
<tr class="covered"><td>4185</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := A2 shr 10 or A2 shl 22;</pre></td></tr>
<tr class="covered"><td>4186</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4187</td><td><pre style="display:inline;"> &nbsp;A0 := A0 xor K0 xor E^ shl 16;</pre></td></tr>
<tr class="covered"><td>4188</td><td><pre style="display:inline;"> &nbsp;A1 := A1 xor K1;</pre></td></tr>
<tr class="covered"><td>4189</td><td><pre style="display:inline;"> &nbsp;A2 := A2 xor K2 xor E^;</pre></td></tr>
<tr class="covered"><td>4190</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4191</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A1 shr 24 xor A2 shl &nbsp;8 xor A2 shr &nbsp;8 xor A0 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4192</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4193</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4194</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A2 shr 24 xor A0 shl &nbsp;8 xor A0 shr &nbsp;8 xor A1 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4195</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4196</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4197</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A0 shr 24 xor A1 shl &nbsp;8 xor A1 shr &nbsp;8 xor A2 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4198</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4199</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4200</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4201</td><td><pre style="display:inline;">procedure TCipher_3Way.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4202</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4203</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>4204</td><td><pre style="display:inline;"> &nbsp;A0, A1, A2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4205</td><td><pre style="display:inline;"> &nbsp;B0, B1, B2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4206</td><td><pre style="display:inline;"> &nbsp;K0, K1, K2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4207</td><td><pre style="display:inline;"> &nbsp;E: PUInt32;</pre></td></tr>
<tr class="nocodegen"><td>4208</td><td><pre style="display:inline;"> &nbsp;P3WayKey: P3Way_Key;</pre></td></tr>
<tr class="covered"><td>4209</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4210</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>4211</td><td><pre style="display:inline;"> &nbsp;P3WayKey := P3Way_Key(FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>4212</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4213</td><td><pre style="display:inline;"> &nbsp;K0 := P3WayKey.D_Key[0];</pre></td></tr>
<tr class="covered"><td>4214</td><td><pre style="display:inline;"> &nbsp;K1 := P3WayKey.D_Key[1];</pre></td></tr>
<tr class="covered"><td>4215</td><td><pre style="display:inline;"> &nbsp;K2 := P3WayKey.D_Key[2];</pre></td></tr>
<tr class="covered"><td>4216</td><td><pre style="display:inline;"> &nbsp;E &nbsp;:= @P3WayKey.D_Data;</pre></td></tr>
<tr class="nocodegen"><td>4217</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4218</td><td><pre style="display:inline;"> &nbsp;A0 := ReverseBits(PUInt32Array(Source)[2]);</pre></td></tr>
<tr class="covered"><td>4219</td><td><pre style="display:inline;"> &nbsp;A1 := ReverseBits(PUInt32Array(Source)[1]);</pre></td></tr>
<tr class="covered"><td>4220</td><td><pre style="display:inline;"> &nbsp;A2 := ReverseBits(PUInt32Array(Source)[0]);</pre></td></tr>
<tr class="covered"><td>4221</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 10 do</pre></td></tr>
<tr class="nocodegen"><td>4222</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4223</td><td><pre style="display:inline;"> &nbsp; &nbsp;A0 := A0 xor K0 xor E^ shl 16;</pre></td></tr>
<tr class="covered"><td>4224</td><td><pre style="display:inline;"> &nbsp; &nbsp;A1 := A1 xor K1;</pre></td></tr>
<tr class="covered"><td>4225</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := A2 xor K2 xor E^;</pre></td></tr>
<tr class="covered"><td>4226</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(E);</pre></td></tr>
<tr class="nocodegen"><td>4227</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4228</td><td><pre style="display:inline;"> &nbsp; &nbsp;B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4229</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 24 xor A2 shl &nbsp;8 xor A2 shr &nbsp;8 xor A0 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4230</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4231</td><td><pre style="display:inline;"> &nbsp; &nbsp;B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4232</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 24 xor A0 shl &nbsp;8 xor A0 shr &nbsp;8 xor A1 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4233</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4234</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4235</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 24 xor A1 shl &nbsp;8 xor A1 shr &nbsp;8 xor A2 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4236</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4237</td><td><pre style="display:inline;"> &nbsp; &nbsp;B0 := B0 shr 10 or B0 shl 22;</pre></td></tr>
<tr class="covered"><td>4238</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := B2 shl &nbsp;1 or B2 shr 31;</pre></td></tr>
<tr class="covered"><td>4239</td><td><pre style="display:inline;"> &nbsp; &nbsp;A0 := B0 xor (B1 or not B2);</pre></td></tr>
<tr class="covered"><td>4240</td><td><pre style="display:inline;"> &nbsp; &nbsp;A1 := B1 xor (B2 or not B0);</pre></td></tr>
<tr class="covered"><td>4241</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := B2 xor (B0 or not B1);</pre></td></tr>
<tr class="covered"><td>4242</td><td><pre style="display:inline;"> &nbsp; &nbsp;A0 := A0 shl &nbsp;1 or A0 shr 31;</pre></td></tr>
<tr class="covered"><td>4243</td><td><pre style="display:inline;"> &nbsp; &nbsp;A2 := A2 shr 10 or A2 shl 22;</pre></td></tr>
<tr class="covered"><td>4244</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4245</td><td><pre style="display:inline;"> &nbsp;A0 := A0 xor K0 xor E^ shl 16;</pre></td></tr>
<tr class="covered"><td>4246</td><td><pre style="display:inline;"> &nbsp;A1 := A1 xor K1;</pre></td></tr>
<tr class="covered"><td>4247</td><td><pre style="display:inline;"> &nbsp;A2 := A2 xor K2 xor E^;</pre></td></tr>
<tr class="covered"><td>4248</td><td><pre style="display:inline;"> &nbsp;B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4249</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 24 xor A2 shl &nbsp;8 xor A2 shr &nbsp;8 xor A0 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4250</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4251</td><td><pre style="display:inline;"> &nbsp;B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4252</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 shr 24 xor A0 shl &nbsp;8 xor A0 shr &nbsp;8 xor A1 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4253</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl &nbsp;8;</pre></td></tr>
<tr class="covered"><td>4254</td><td><pre style="display:inline;"> &nbsp;B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>4255</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A0 shr 24 xor A1 shl &nbsp;8 xor A1 shr &nbsp;8 xor A2 shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>4256</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl &nbsp;8;</pre></td></tr>
<tr class="nocodegen"><td>4257</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4258</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := ReverseBits(B0);</pre></td></tr>
<tr class="covered"><td>4259</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := ReverseBits(B1);</pre></td></tr>
<tr class="covered"><td>4260</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := ReverseBits(B2);</pre></td></tr>
<tr class="covered"><td>4261</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4262</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4263</td><td><pre style="display:inline;">{ TCipher_Cast128 }</pre></td></tr>
<tr class="nocodegen"><td>4264</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4265</td><td><pre style="display:inline;">class function TCipher_Cast128.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>4266</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4267</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>4268</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>4269</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>4270</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 128;</pre></td></tr>
<tr class="covered"><td>4271</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := false;</pre></td></tr>
<tr class="covered"><td>4272</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 12;</pre></td></tr>
<tr class="covered"><td>4273</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>4274</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>4275</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4276</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4277</td><td><pre style="display:inline;">procedure TCipher_Cast128.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4278</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4279</td><td><pre style="display:inline;"> &nbsp;Z, X, T: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4280</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>4281</td><td><pre style="display:inline;"> &nbsp;I: UInt32;</pre></td></tr>
<tr class="covered"><td>4282</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4283</td><td><pre style="display:inline;"> &nbsp;// as per rfc2144 the number of rounds is 12 for key sizes &lt;= 80 bit,</pre></td></tr>
<tr class="nocodegen"><td>4284</td><td><pre style="display:inline;"> &nbsp;// otherwise 16</pre></td></tr>
<tr class="covered"><td>4285</td><td><pre style="display:inline;"> &nbsp;if Size &lt;= 10 then</pre></td></tr>
<tr class="notcovered"><td>4286</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 12</pre></td></tr>
<tr class="nocodegen"><td>4287</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>4288</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 16;</pre></td></tr>
<tr class="nocodegen"><td>4289</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4290</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>4291</td><td><pre style="display:inline;"> &nbsp;FillChar(X, SizeOf(X), 0);</pre></td></tr>
<tr class="covered"><td>4292</td><td><pre style="display:inline;"> &nbsp;Move(Key, X, Size);</pre></td></tr>
<tr class="covered"><td>4293</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(X, X, 4);</pre></td></tr>
<tr class="covered"><td>4294</td><td><pre style="display:inline;"> &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>4295</td><td><pre style="display:inline;"> &nbsp;while I &lt; 32 do</pre></td></tr>
<tr class="nocodegen"><td>4296</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4297</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I and 4 = 0 then</pre></td></tr>
<tr class="nocodegen"><td>4298</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4299</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Z[0] := X[0] xor Cast128_Key[0, X[3] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4300</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, X[3] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4301</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, X[3] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4302</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, X[3] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4303</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, X[2] shr 24];</pre></td></tr>
<tr class="covered"><td>4304</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[0] := Z[0];</pre></td></tr>
<tr class="covered"><td>4305</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Z[1] := X[2] xor Cast128_Key[0, Z[0] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4306</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, Z[0] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4307</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, Z[0] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4308</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, Z[0] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4309</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, X[2] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>4310</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[1] := Z[1];</pre></td></tr>
<tr class="covered"><td>4311</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Z[2] := X[3] xor Cast128_Key[0, Z[1] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4312</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, Z[1] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4313</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, Z[1] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4314</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, Z[1] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4315</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[0, X[2] shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>4316</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[2] := Z[2];</pre></td></tr>
<tr class="covered"><td>4317</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Z[3] := X[1] xor Cast128_Key[0, Z[2] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4318</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, Z[2] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4319</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, Z[2] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4320</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, Z[2] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4321</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, X[2] and $FF];</pre></td></tr>
<tr class="covered"><td>4322</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[3] := Z[3];</pre></td></tr>
<tr class="nocodegen"><td>4323</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>4324</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4325</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4326</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[0] := Z[2] xor Cast128_Key[0, Z[1] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4327</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, Z[1] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4328</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, Z[1] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4329</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, Z[1] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4330</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, Z[0] shr 24];</pre></td></tr>
<tr class="covered"><td>4331</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[0] := X[0];</pre></td></tr>
<tr class="covered"><td>4332</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[1] := Z[0] xor Cast128_Key[0, X[0] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4333</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, X[0] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4334</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, X[0] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4335</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, X[0] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4336</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, Z[0] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>4337</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[1] := X[1];</pre></td></tr>
<tr class="covered"><td>4338</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[2] := Z[1] xor Cast128_Key[0, X[1] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4339</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, X[1] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4340</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, X[1] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4341</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, X[1] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4342</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[0, Z[0] shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>4343</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[2] := X[2];</pre></td></tr>
<tr class="covered"><td>4344</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;X[3] := Z[3] xor Cast128_Key[0, X[2] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4345</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, X[2] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4346</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[2, X[2] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4347</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[3, X[2] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4348</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cast128_Key[1, Z[0] and $FF];</pre></td></tr>
<tr class="covered"><td>4349</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[3] := X[3];</pre></td></tr>
<tr class="nocodegen"><td>4350</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4351</td><td><pre style="display:inline;"> &nbsp; &nbsp;case I and 12 of</pre></td></tr>
<tr class="nocodegen"><td>4352</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;0,12:</pre></td></tr>
<tr class="nocodegen"><td>4353</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4354</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 0] := Cast128_Key[0, T[2] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4355</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[2] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4356</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[1] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4357</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[1] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>4358</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 1] := Cast128_Key[0, T[2] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4359</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[2] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4360</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[1] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4361</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[1] shr 24];</pre></td></tr>
<tr class="covered"><td>4362</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 2] := Cast128_Key[0, T[3] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4363</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[3] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4364</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[0] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4365</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[0] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>4366</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 3] := Cast128_Key[0, T[3] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4367</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[3] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4368</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[0] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4369</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[0] shr 24];</pre></td></tr>
<tr class="nocodegen"><td>4370</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4371</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;4,8:</pre></td></tr>
<tr class="nocodegen"><td>4372</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4373</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 0] := Cast128_Key[0, T[0] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4374</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[0] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4375</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[3] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4376</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[3] shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>4377</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 1] := Cast128_Key[0, T[0] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4378</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[0] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4379</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[3] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4380</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[3] and $FF];</pre></td></tr>
<tr class="covered"><td>4381</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 2] := Cast128_Key[0, T[1] and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4382</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[1] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4383</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[2] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4384</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[2] shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>4385</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 3] := Cast128_Key[0, T[1] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4386</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[1, T[1] shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4387</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[2, T[2] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4388</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Key[3, T[2] and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4389</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4390</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4391</td><td><pre style="display:inline;"> &nbsp; &nbsp;case I and 12 of</pre></td></tr>
<tr class="nocodegen"><td>4392</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;0: begin</pre></td></tr>
<tr class="covered"><td>4393</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 0] := K[I + 0] xor Cast128_Key[0, Z[0] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>4394</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 1] := K[I + 1] xor Cast128_Key[1, Z[1] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>4395</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 2] := K[I + 2] xor Cast128_Key[2, Z[2] shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>4396</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 3] := K[I + 3] xor Cast128_Key[3, Z[3] shr 24];</pre></td></tr>
<tr class="nocodegen"><td>4397</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>4398</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;4: begin</pre></td></tr>
<tr class="covered"><td>4399</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 0] := K[I + 0] xor Cast128_Key[0, X[2] shr 24];</pre></td></tr>
<tr class="covered"><td>4400</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 1] := K[I + 1] xor Cast128_Key[1, X[3] shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>4401</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 2] := K[I + 2] xor Cast128_Key[2, X[0] and $FF];</pre></td></tr>
<tr class="covered"><td>4402</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 3] := K[I + 3] xor Cast128_Key[3, X[1] and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4403</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>4404</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;8: begin</pre></td></tr>
<tr class="covered"><td>4405</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 0] := K[I + 0] xor Cast128_Key[0, Z[2] shr 16 and $FF];</pre></td></tr>
<tr class="covered"><td>4406</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 1] := K[I + 1] xor Cast128_Key[1, Z[3] shr 24];</pre></td></tr>
<tr class="covered"><td>4407</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 2] := K[I + 2] xor Cast128_Key[2, Z[0] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="covered"><td>4408</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K[I + 3] := K[I + 3] xor Cast128_Key[3, Z[1] shr &nbsp;8 and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4409</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>4410</td><td><pre style="display:inline;"> &nbsp; &nbsp; 12: begin</pre></td></tr>
<tr class="covered"><td>4411</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 0] := K[I + 0] xor Cast128_Key[0, X[0] and $FF];</pre></td></tr>
<tr class="covered"><td>4412</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 1] := K[I + 1] xor Cast128_Key[1, X[1] and $FF];</pre></td></tr>
<tr class="covered"><td>4413</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 2] := K[I + 2] xor Cast128_Key[2, X[2] shr 24];</pre></td></tr>
<tr class="covered"><td>4414</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K[I + 3] := K[I + 3] xor Cast128_Key[3, X[3] shr 16 and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4415</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4416</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4417</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &gt;= 16 then</pre></td></tr>
<tr class="nocodegen"><td>4418</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4419</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[I + 0] := K[I + 0] and $1F;</pre></td></tr>
<tr class="covered"><td>4420</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[I + 1] := K[I + 1] and $1F;</pre></td></tr>
<tr class="covered"><td>4421</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[I + 2] := K[I + 2] and $1F;</pre></td></tr>
<tr class="covered"><td>4422</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[I + 3] := K[I + 3] and $1F;</pre></td></tr>
<tr class="nocodegen"><td>4423</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4424</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I, 4);</pre></td></tr>
<tr class="nocodegen"><td>4425</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4426</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(X, SizeOf(X));</pre></td></tr>
<tr class="covered"><td>4427</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(Z, SizeOf(Z));</pre></td></tr>
<tr class="covered"><td>4428</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(T, SizeOf(T));</pre></td></tr>
<tr class="nocodegen"><td>4429</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4430</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>4431</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4432</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4433</td><td><pre style="display:inline;">procedure TCipher_Cast128.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4434</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4435</td><td><pre style="display:inline;"> &nbsp;T, I, A, B: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4436</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>4437</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4438</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>4439</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4440</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>4441</td><td><pre style="display:inline;"> &nbsp;A := SwapUInt32(PUInt32Array(Source)[0]);</pre></td></tr>
<tr class="covered"><td>4442</td><td><pre style="display:inline;"> &nbsp;B := SwapUInt32(PUInt32Array(Source)[1]);</pre></td></tr>
<tr class="covered"><td>4443</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 2 do</pre></td></tr>
<tr class="nocodegen"><td>4444</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4445</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[0] + B;</pre></td></tr>
<tr class="covered"><td>4446</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[16] or T shr (32 - K[16]);</pre></td></tr>
<tr class="covered"><td>4447</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast128_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4448</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4449</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4450</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4451</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[1] xor A;</pre></td></tr>
<tr class="covered"><td>4452</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[17] or T shr (32 - K[17]);</pre></td></tr>
<tr class="covered"><td>4453</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast128_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>4454</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4455</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4456</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4457</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[2] - B;</pre></td></tr>
<tr class="covered"><td>4458</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[18] or T shr (32 - K[18]);</pre></td></tr>
<tr class="covered"><td>4459</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast128_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>4460</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4461</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4462</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4463</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[3] + A;</pre></td></tr>
<tr class="covered"><td>4464</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[19] or T shr (32 - K[19]);</pre></td></tr>
<tr class="covered"><td>4465</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast128_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4466</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4467</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4468</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4469</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>4470</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Break;</pre></td></tr>
<tr class="covered"><td>4471</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[4] xor B;</pre></td></tr>
<tr class="covered"><td>4472</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[20] or T shr (32 - K[20]);</pre></td></tr>
<tr class="covered"><td>4473</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast128_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>4474</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4475</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4476</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4477</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[5] - A;</pre></td></tr>
<tr class="covered"><td>4478</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[21] or T shr (32 - K[21]);</pre></td></tr>
<tr class="covered"><td>4479</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast128_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>4480</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4481</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4482</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4483</td><td><pre style="display:inline;"> &nbsp; &nbsp;if (I = 1) and (FRounds &lt;= 12) then</pre></td></tr>
<tr class="nocodegen"><td>4484</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Break;</pre></td></tr>
<tr class="covered"><td>4485</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[6];</pre></td></tr>
<tr class="covered"><td>4486</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4487</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := SwapUInt32(B);</pre></td></tr>
<tr class="covered"><td>4488</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := SwapUInt32(A);</pre></td></tr>
<tr class="covered"><td>4489</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4490</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4491</td><td><pre style="display:inline;">procedure TCipher_Cast128.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4492</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4493</td><td><pre style="display:inline;"> &nbsp;T, I, A, B: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4494</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>4495</td><td><pre style="display:inline;"> &nbsp;JumpStart: Boolean;</pre></td></tr>
<tr class="covered"><td>4496</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4497</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>4498</td><td><pre style="display:inline;"> &nbsp;JumpStart := False;</pre></td></tr>
<tr class="nocodegen"><td>4499</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4500</td><td><pre style="display:inline;"> &nbsp;K := @PUInt32Array(FAdditionalBuffer)[12];</pre></td></tr>
<tr class="covered"><td>4501</td><td><pre style="display:inline;"> &nbsp;B := SwapUInt32(PUInt32Array(Source)[0]);</pre></td></tr>
<tr class="covered"><td>4502</td><td><pre style="display:inline;"> &nbsp;A := SwapUInt32(PUInt32Array(Source)[1]);</pre></td></tr>
<tr class="covered"><td>4503</td><td><pre style="display:inline;"> &nbsp;I := 2;</pre></td></tr>
<tr class="nocodegen"><td>4504</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4505</td><td><pre style="display:inline;"> &nbsp;if FRounds &lt;= 12 then</pre></td></tr>
<tr class="notcovered"><td>4506</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 6)</pre></td></tr>
<tr class="nocodegen"><td>4507</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>4508</td><td><pre style="display:inline;"> &nbsp; &nbsp;JumpStart := True;</pre></td></tr>
<tr class="nocodegen"><td>4509</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4510</td><td><pre style="display:inline;"> &nbsp;while I &gt; 0 do</pre></td></tr>
<tr class="nocodegen"><td>4511</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4512</td><td><pre style="display:inline;"> &nbsp; &nbsp;if not JumpStart then</pre></td></tr>
<tr class="nocodegen"><td>4513</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4514</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(I);</pre></td></tr>
<tr class="covered"><td>4515</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := K[5] - A;</pre></td></tr>
<tr class="covered"><td>4516</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl K[21] or T shr (32 - K[21]);</pre></td></tr>
<tr class="covered"><td>4517</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B xor (Cast128_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>4518</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4519</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4520</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4521</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := K[4] xor B;</pre></td></tr>
<tr class="covered"><td>4522</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := T shl K[20] or T shr (32 - K[20]);</pre></td></tr>
<tr class="covered"><td>4523</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := A xor (Cast128_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>4524</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4525</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4526</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>4527</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>4528</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>4529</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;JumpStart := False;</pre></td></tr>
<tr class="nocodegen"><td>4530</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4531</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[3] + A;</pre></td></tr>
<tr class="covered"><td>4532</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[19] or T shr (32 - K[19]);</pre></td></tr>
<tr class="covered"><td>4533</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast128_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4534</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4535</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4536</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4537</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[2] - B;</pre></td></tr>
<tr class="covered"><td>4538</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[18] or T shr (32 - K[18]);</pre></td></tr>
<tr class="covered"><td>4539</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast128_Data[0, T shr 24] +</pre></td></tr>
<tr class="nocodegen"><td>4540</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4541</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4542</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4543</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[1] xor A;</pre></td></tr>
<tr class="covered"><td>4544</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[17] or T shr (32 - K[17]);</pre></td></tr>
<tr class="covered"><td>4545</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor (Cast128_Data[0, T shr 24] -</pre></td></tr>
<tr class="nocodegen"><td>4546</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4547</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4548</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4549</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := K[0] + B;</pre></td></tr>
<tr class="covered"><td>4550</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T shl K[16] or T shr (32 - K[16]);</pre></td></tr>
<tr class="covered"><td>4551</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor (Cast128_Data[0, T shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>4552</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[1, T shr 16 and $FF] -</pre></td></tr>
<tr class="nocodegen"><td>4553</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[2, T shr &nbsp;8 and $FF] +</pre></td></tr>
<tr class="nocodegen"><td>4554</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cast128_Data[3, T and $FF]);</pre></td></tr>
<tr class="covered"><td>4555</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 6);</pre></td></tr>
<tr class="nocodegen"><td>4556</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4557</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4558</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := SwapUInt32(A);</pre></td></tr>
<tr class="covered"><td>4559</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := SwapUInt32(B);</pre></td></tr>
<tr class="covered"><td>4560</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4561</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4562</td><td><pre style="display:inline;">{ TCipher_Gost }</pre></td></tr>
<tr class="nocodegen"><td>4563</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4564</td><td><pre style="display:inline;">class function TCipher_Gost.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>4565</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4566</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 32;</pre></td></tr>
<tr class="covered"><td>4567</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>4568</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>4569</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 32;</pre></td></tr>
<tr class="covered"><td>4570</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := false;</pre></td></tr>
<tr class="covered"><td>4571</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4572</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4573</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>4574</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4575</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4576</td><td><pre style="display:inline;">procedure TCipher_Gost.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="covered"><td>4577</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4578</td><td><pre style="display:inline;"> &nbsp;Move(Key, FAdditionalBuffer^, Size);</pre></td></tr>
<tr class="nocodegen"><td>4579</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4580</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>4581</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4582</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4583</td><td><pre style="display:inline;">procedure TCipher_Gost.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4584</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4585</td><td><pre style="display:inline;"> &nbsp;I, A, B, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4586</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>4587</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4588</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>4589</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4590</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>4591</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>4592</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="nocodegen"><td>4593</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4594</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 11 do</pre></td></tr>
<tr class="nocodegen"><td>4595</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4596</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I and 3 = 0 then</pre></td></tr>
<tr class="covered"><td>4597</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>4598</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A + K[0];</pre></td></tr>
<tr class="covered"><td>4599</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Gost_Data[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4600</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4601</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4602</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>4603</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B + K[1];</pre></td></tr>
<tr class="covered"><td>4604</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Gost_Data[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4605</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4606</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4607</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>4608</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[2];</pre></td></tr>
<tr class="covered"><td>4609</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4610</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4611</td><td><pre style="display:inline;"> &nbsp;K := @PUInt32Array(FAdditionalBuffer)[6];</pre></td></tr>
<tr class="nocodegen"><td>4612</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4613</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>4614</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4615</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A + K[1];</pre></td></tr>
<tr class="covered"><td>4616</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Gost_Data[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4617</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4618</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4619</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>4620</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B + K[0];</pre></td></tr>
<tr class="covered"><td>4621</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Gost_Data[0, T &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4622</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4623</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4624</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="covered"><td>4625</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 2);</pre></td></tr>
<tr class="covered"><td>4626</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4627</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4628</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := B;</pre></td></tr>
<tr class="covered"><td>4629</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := A;</pre></td></tr>
<tr class="covered"><td>4630</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4631</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4632</td><td><pre style="display:inline;">procedure TCipher_Gost.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4633</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4634</td><td><pre style="display:inline;"> &nbsp;I, A, B, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4635</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>4636</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4637</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>4638</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4639</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>4640</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>4641</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="nocodegen"><td>4642</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4643</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>4644</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4645</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A + K[0];</pre></td></tr>
<tr class="covered"><td>4646</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Gost_Data[0, T and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4647</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4648</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4649</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24];</pre></td></tr>
<tr class="covered"><td>4650</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B + K[1];</pre></td></tr>
<tr class="covered"><td>4651</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Gost_Data[0, T and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4652</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4653</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4654</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24];</pre></td></tr>
<tr class="covered"><td>4655</td><td><pre style="display:inline;"> &nbsp; &nbsp;K := @K[2];</pre></td></tr>
<tr class="covered"><td>4656</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4657</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4658</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 11 do</pre></td></tr>
<tr class="nocodegen"><td>4659</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4660</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I and 3 = 0 then</pre></td></tr>
<tr class="covered"><td>4661</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K := @PUInt32Array(FAdditionalBuffer)[6];</pre></td></tr>
<tr class="covered"><td>4662</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A + K[1];</pre></td></tr>
<tr class="covered"><td>4663</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Gost_Data[0, T and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4664</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4665</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4666</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24];</pre></td></tr>
<tr class="covered"><td>4667</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B + K[0];</pre></td></tr>
<tr class="covered"><td>4668</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Gost_Data[0, T and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4669</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[1, T shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4670</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[2, T shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>4671</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gost_Data[3, T shr 24];</pre></td></tr>
<tr class="covered"><td>4672</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(K), 2);</pre></td></tr>
<tr class="covered"><td>4673</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4674</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4675</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := B;</pre></td></tr>
<tr class="covered"><td>4676</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := A;</pre></td></tr>
<tr class="covered"><td>4677</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4678</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4679</td><td><pre style="display:inline;">{ TCipher_Misty }</pre></td></tr>
<tr class="nocodegen"><td>4680</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4681</td><td><pre style="display:inline;">class function TCipher_Misty.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>4682</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4683</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>4684</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>4685</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>4686</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 128;</pre></td></tr>
<tr class="covered"><td>4687</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>4688</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4689</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4690</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>4691</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4692</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4693</td><td><pre style="display:inline;">function Misty_I(Value, Key: UInt32): UInt32;</pre></td></tr>
<tr class="covered"><td>4694</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4695</td><td><pre style="display:inline;"> &nbsp;Result := Misty_Data9[Value shr 7 and $1FF] xor (Value and $7F);</pre></td></tr>
<tr class="covered"><td>4696</td><td><pre style="display:inline;"> &nbsp;Value := (Misty_Data7[Value and $7F] xor Result and $7F) xor (Key shr 9 and $7F);</pre></td></tr>
<tr class="covered"><td>4697</td><td><pre style="display:inline;"> &nbsp;Result := Misty_Data9[Result xor (Key and $1FF)] xor Value or Value shl 9;</pre></td></tr>
<tr class="covered"><td>4698</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4699</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4700</td><td><pre style="display:inline;">function Misty_O(Value, K: UInt32; Key: PUInt32Array): UInt32;</pre></td></tr>
<tr class="covered"><td>4701</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4702</td><td><pre style="display:inline;"> &nbsp;Result := Misty_I((Value shr 16) xor Key[K], Key[(K + 5) and 7 + 8]) xor (Value and $FFFF);</pre></td></tr>
<tr class="covered"><td>4703</td><td><pre style="display:inline;"> &nbsp;Value &nbsp;:= Misty_I((Value and $FFFF) xor Key[(K + 2) and 7], Key[(K + 1) and 7 + 8]) xor Result;</pre></td></tr>
<tr class="covered"><td>4704</td><td><pre style="display:inline;"> &nbsp;Result := Misty_I(Result xor Key[(K + 7) and 7], Key[(K + 3) and 7 + 8]) xor Value;</pre></td></tr>
<tr class="covered"><td>4705</td><td><pre style="display:inline;"> &nbsp;Result := Result or (Value xor Key[(K + 4) and 7]) shl 16;</pre></td></tr>
<tr class="covered"><td>4706</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4707</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4708</td><td><pre style="display:inline;">function Misty_E(Value, K: UInt32; Key: PUInt32Array): UInt32;</pre></td></tr>
<tr class="covered"><td>4709</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4710</td><td><pre style="display:inline;"> &nbsp;Result := Value shr 16;</pre></td></tr>
<tr class="covered"><td>4711</td><td><pre style="display:inline;"> &nbsp;Value &nbsp;:= Value and $FFFF;</pre></td></tr>
<tr class="nocodegen"><td>4712</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4713</td><td><pre style="display:inline;"> &nbsp;if K and 1 &lt;&gt; 0 then</pre></td></tr>
<tr class="nocodegen"><td>4714</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4715</td><td><pre style="display:inline;"> &nbsp; &nbsp;K &nbsp; &nbsp; &nbsp;:= K shr 1;</pre></td></tr>
<tr class="covered"><td>4716</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value &nbsp;:= Value &nbsp;xor (Result and Key[(K + 2) and 7 + 8]);</pre></td></tr>
<tr class="covered"><td>4717</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := Result xor (Value &nbsp;or &nbsp;Key[(K + 4) and 7]);</pre></td></tr>
<tr class="nocodegen"><td>4718</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>4719</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4720</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4721</td><td><pre style="display:inline;"> &nbsp; &nbsp;K &nbsp; &nbsp; &nbsp;:= K shr 1;</pre></td></tr>
<tr class="covered"><td>4722</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value &nbsp;:= Value &nbsp;xor (Result and Key[K]);</pre></td></tr>
<tr class="covered"><td>4723</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := Result xor (Value &nbsp;or &nbsp;Key[(K + 6) and 7 + 8]);</pre></td></tr>
<tr class="nocodegen"><td>4724</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4725</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4726</td><td><pre style="display:inline;"> &nbsp;Result:= (Result shl 16) or Value;</pre></td></tr>
<tr class="covered"><td>4727</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4728</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4729</td><td><pre style="display:inline;">function Misty_D(Value, K: UInt32; Key: PUInt32Array): UInt32;</pre></td></tr>
<tr class="covered"><td>4730</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4731</td><td><pre style="display:inline;"> &nbsp;Result := Value shr 16;</pre></td></tr>
<tr class="covered"><td>4732</td><td><pre style="display:inline;"> &nbsp;Value &nbsp;:= Value and $FFFF;</pre></td></tr>
<tr class="nocodegen"><td>4733</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4734</td><td><pre style="display:inline;"> &nbsp;if K and 1 &lt;&gt; 0 then</pre></td></tr>
<tr class="nocodegen"><td>4735</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4736</td><td><pre style="display:inline;"> &nbsp; &nbsp;K &nbsp; &nbsp; &nbsp;:= K shr 1;</pre></td></tr>
<tr class="covered"><td>4737</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := Result xor (Value &nbsp;or &nbsp;Key[(K + 4) and 7]);</pre></td></tr>
<tr class="covered"><td>4738</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value &nbsp;:= Value &nbsp;xor (Result and Key[(K + 2) and 7 + 8]);</pre></td></tr>
<tr class="nocodegen"><td>4739</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>4740</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4741</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4742</td><td><pre style="display:inline;"> &nbsp; &nbsp;K &nbsp; &nbsp; &nbsp;:= K shr 1;</pre></td></tr>
<tr class="covered"><td>4743</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := Result xor (Value &nbsp;or &nbsp;Key[(K + 6) and 7 + 8]);</pre></td></tr>
<tr class="covered"><td>4744</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value &nbsp;:= Value &nbsp;xor (Result and Key[K]);</pre></td></tr>
<tr class="nocodegen"><td>4745</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4746</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4747</td><td><pre style="display:inline;"> &nbsp;Result:= (Result shl 16) or Value;</pre></td></tr>
<tr class="covered"><td>4748</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4749</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4750</td><td><pre style="display:inline;">procedure TCipher_Misty.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4751</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4752</td><td><pre style="display:inline;"> &nbsp;K: array[0..15] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>4753</td><td><pre style="display:inline;"> &nbsp;D: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>4754</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>4755</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4756</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>4757</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>4758</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer;</pre></td></tr>
<tr class="nocodegen"><td>4759</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4760</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="covered"><td>4761</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := K[I * 2] * 256 + K[I * 2 + 1];</pre></td></tr>
<tr class="nocodegen"><td>4762</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4763</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>4764</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4765</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I + &nbsp;8] := Misty_I(D[I], D[(I + 1) and 7]);</pre></td></tr>
<tr class="covered"><td>4766</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I + 16] := D[I + 8] and $1FF;</pre></td></tr>
<tr class="covered"><td>4767</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I + 24] := D[I + 8] shr 9;</pre></td></tr>
<tr class="covered"><td>4768</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4769</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4770</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>4771</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4772</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>4773</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4774</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4775</td><td><pre style="display:inline;">procedure TCipher_Misty.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4776</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4777</td><td><pre style="display:inline;"> &nbsp;A, B: UInt32;</pre></td></tr>
<tr class="covered"><td>4778</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4779</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>4780</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4781</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>4782</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>4783</td><td><pre style="display:inline;"> &nbsp;A := Misty_E(A, 0, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4784</td><td><pre style="display:inline;"> &nbsp;B := Misty_E(B, 1, FAdditionalBuffer) xor Misty_O(A, 0, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4785</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 1, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4786</td><td><pre style="display:inline;"> &nbsp;A := Misty_E(A, 2, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4787</td><td><pre style="display:inline;"> &nbsp;B := Misty_E(B, 3, FAdditionalBuffer) xor Misty_O(A, 2, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4788</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 3, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4789</td><td><pre style="display:inline;"> &nbsp;A := Misty_E(A, 4, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4790</td><td><pre style="display:inline;"> &nbsp;B := Misty_E(B, 5, FAdditionalBuffer) xor Misty_O(A, 4, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4791</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 5, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4792</td><td><pre style="display:inline;"> &nbsp;A := Misty_E(A, 6, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4793</td><td><pre style="display:inline;"> &nbsp;B := Misty_E(B, 7, FAdditionalBuffer) xor Misty_O(A, 6, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4794</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 7, FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>4795</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4796</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := Misty_E(B, 9, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4797</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Misty_E(A, 8, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4798</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4799</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4800</td><td><pre style="display:inline;">procedure TCipher_Misty.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4801</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4802</td><td><pre style="display:inline;"> &nbsp;A, B: UInt32;</pre></td></tr>
<tr class="covered"><td>4803</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4804</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>4805</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4806</td><td><pre style="display:inline;"> &nbsp;B := Misty_D(PUInt32Array(Source)[0], 9, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4807</td><td><pre style="display:inline;"> &nbsp;A := Misty_D(PUInt32Array(Source)[1], 8, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4808</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 7, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4809</td><td><pre style="display:inline;"> &nbsp;B := Misty_D(B xor Misty_O(A, 6, FAdditionalBuffer), 7, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4810</td><td><pre style="display:inline;"> &nbsp;A := Misty_D(A, 6, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4811</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 5, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4812</td><td><pre style="display:inline;"> &nbsp;B := Misty_D(B xor Misty_O(A, 4, FAdditionalBuffer), 5, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4813</td><td><pre style="display:inline;"> &nbsp;A := Misty_D(A, 4, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4814</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 3, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4815</td><td><pre style="display:inline;"> &nbsp;B := Misty_D(B xor Misty_O(A, 2, FAdditionalBuffer), 3, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4816</td><td><pre style="display:inline;"> &nbsp;A := Misty_D(A, 2, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4817</td><td><pre style="display:inline;"> &nbsp;A := A xor Misty_O(B, 1, FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>4818</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4819</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := Misty_D(A, 0, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4820</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Misty_D(B xor Misty_O(A, 0, FAdditionalBuffer), 1, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4821</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4822</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4823</td><td><pre style="display:inline;">{ TCipher_NewDES }</pre></td></tr>
<tr class="nocodegen"><td>4824</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4825</td><td><pre style="display:inline;">procedure NewDES_Func(Source, Dest, Key: PByteArray);</pre></td></tr>
<tr class="nocodegen"><td>4826</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4827</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>4828</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H: Byte;</pre></td></tr>
<tr class="covered"><td>4829</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4830</td><td><pre style="display:inline;"> &nbsp;A := Source[0];</pre></td></tr>
<tr class="covered"><td>4831</td><td><pre style="display:inline;"> &nbsp;B := Source[1];</pre></td></tr>
<tr class="covered"><td>4832</td><td><pre style="display:inline;"> &nbsp;C := Source[2];</pre></td></tr>
<tr class="covered"><td>4833</td><td><pre style="display:inline;"> &nbsp;D := Source[3];</pre></td></tr>
<tr class="covered"><td>4834</td><td><pre style="display:inline;"> &nbsp;E := Source[4];</pre></td></tr>
<tr class="covered"><td>4835</td><td><pre style="display:inline;"> &nbsp;F := Source[5];</pre></td></tr>
<tr class="covered"><td>4836</td><td><pre style="display:inline;"> &nbsp;G := Source[6];</pre></td></tr>
<tr class="covered"><td>4837</td><td><pre style="display:inline;"> &nbsp;H := Source[7];</pre></td></tr>
<tr class="nocodegen"><td>4838</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4839</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>4840</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4841</td><td><pre style="display:inline;"> &nbsp; &nbsp;E := E xor NewDES_Data[A xor Key[0]];</pre></td></tr>
<tr class="covered"><td>4842</td><td><pre style="display:inline;"> &nbsp; &nbsp;F := F xor NewDES_Data[B xor Key[1]];</pre></td></tr>
<tr class="covered"><td>4843</td><td><pre style="display:inline;"> &nbsp; &nbsp;G := G xor NewDES_Data[C xor Key[2]];</pre></td></tr>
<tr class="covered"><td>4844</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := H xor NewDES_Data[D xor Key[3]];</pre></td></tr>
<tr class="covered"><td>4845</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor NewDES_Data[E xor Key[4]];</pre></td></tr>
<tr class="covered"><td>4846</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor NewDES_Data[F xor E];</pre></td></tr>
<tr class="covered"><td>4847</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor NewDES_Data[G xor Key[5]];</pre></td></tr>
<tr class="covered"><td>4848</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor NewDES_Data[H xor Key[6]];</pre></td></tr>
<tr class="covered"><td>4849</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key := @Key[7];</pre></td></tr>
<tr class="covered"><td>4850</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4851</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4852</td><td><pre style="display:inline;"> &nbsp;E := E xor NewDES_Data[A xor Key[0]];</pre></td></tr>
<tr class="covered"><td>4853</td><td><pre style="display:inline;"> &nbsp;F := F xor NewDES_Data[B xor Key[1]];</pre></td></tr>
<tr class="covered"><td>4854</td><td><pre style="display:inline;"> &nbsp;G := G xor NewDES_Data[C xor Key[2]];</pre></td></tr>
<tr class="covered"><td>4855</td><td><pre style="display:inline;"> &nbsp;H := H xor NewDES_Data[D xor Key[3]];</pre></td></tr>
<tr class="nocodegen"><td>4856</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4857</td><td><pre style="display:inline;"> &nbsp;Dest[0] := A;</pre></td></tr>
<tr class="covered"><td>4858</td><td><pre style="display:inline;"> &nbsp;Dest[1] := B;</pre></td></tr>
<tr class="covered"><td>4859</td><td><pre style="display:inline;"> &nbsp;Dest[2] := C;</pre></td></tr>
<tr class="covered"><td>4860</td><td><pre style="display:inline;"> &nbsp;Dest[3] := D;</pre></td></tr>
<tr class="covered"><td>4861</td><td><pre style="display:inline;"> &nbsp;Dest[4] := E;</pre></td></tr>
<tr class="covered"><td>4862</td><td><pre style="display:inline;"> &nbsp;Dest[5] := F;</pre></td></tr>
<tr class="covered"><td>4863</td><td><pre style="display:inline;"> &nbsp;Dest[6] := G;</pre></td></tr>
<tr class="covered"><td>4864</td><td><pre style="display:inline;"> &nbsp;Dest[7] := H;</pre></td></tr>
<tr class="covered"><td>4865</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4866</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4867</td><td><pre style="display:inline;">class function TCipher_NewDES.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>4868</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4869</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 15;</pre></td></tr>
<tr class="covered"><td>4870</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>4871</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>4872</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 60 * 2;</pre></td></tr>
<tr class="covered"><td>4873</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := true;</pre></td></tr>
<tr class="covered"><td>4874</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4875</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4876</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>4877</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4878</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4879</td><td><pre style="display:inline;">procedure TCipher_NewDES.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4880</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4881</td><td><pre style="display:inline;"> &nbsp;K: array[0..14] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>4882</td><td><pre style="display:inline;"> &nbsp;E: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>4883</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>4884</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4885</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>4886</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>4887</td><td><pre style="display:inline;"> &nbsp;E := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>4888</td><td><pre style="display:inline;"> &nbsp;Move(K, E[ 0], 15);</pre></td></tr>
<tr class="covered"><td>4889</td><td><pre style="display:inline;"> &nbsp;Move(K, E[15], 15);</pre></td></tr>
<tr class="covered"><td>4890</td><td><pre style="display:inline;"> &nbsp;Move(K, E[30], 15);</pre></td></tr>
<tr class="covered"><td>4891</td><td><pre style="display:inline;"> &nbsp;Move(K, E[45], 15);</pre></td></tr>
<tr class="covered"><td>4892</td><td><pre style="display:inline;"> &nbsp;E := @E[60];</pre></td></tr>
<tr class="covered"><td>4893</td><td><pre style="display:inline;"> &nbsp;I := 11;</pre></td></tr>
<tr class="nocodegen"><td>4894</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4895</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>4896</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[0] := K[I]; I := (I + 1) mod 15;</pre></td></tr>
<tr class="covered"><td>4897</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[1] := K[I]; I := (I + 1) mod 15;</pre></td></tr>
<tr class="covered"><td>4898</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[2] := K[I]; I := (I + 1) mod 15;</pre></td></tr>
<tr class="covered"><td>4899</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[3] := K[I]; I := (I + 9) mod 15;</pre></td></tr>
<tr class="covered"><td>4900</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 12 then</pre></td></tr>
<tr class="nocodegen"><td>4901</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Break;</pre></td></tr>
<tr class="covered"><td>4902</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[4] := K[I]; Inc(I);</pre></td></tr>
<tr class="covered"><td>4903</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[5] := K[I]; Inc(I);</pre></td></tr>
<tr class="covered"><td>4904</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[6] := K[I]; I := (I + 9) mod 15;</pre></td></tr>
<tr class="covered"><td>4905</td><td><pre style="display:inline;"> &nbsp; &nbsp;E := @E[7];</pre></td></tr>
<tr class="covered"><td>4906</td><td><pre style="display:inline;"> &nbsp;until False;</pre></td></tr>
<tr class="nocodegen"><td>4907</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4908</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>4909</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4910</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>4911</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4912</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4913</td><td><pre style="display:inline;">procedure TCipher_NewDES.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>4914</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4915</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>4916</td><td><pre style="display:inline;"> &nbsp;NewDES_Func(Source, Dest, FAdditionalBuffer);</pre></td></tr>
<tr class="covered"><td>4917</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4918</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4919</td><td><pre style="display:inline;">procedure TCipher_NewDES.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="covered"><td>4920</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4921</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="covered"><td>4922</td><td><pre style="display:inline;"> &nbsp;NewDES_Func(Source, Dest, @PByteArray(FAdditionalBuffer)[60]);</pre></td></tr>
<tr class="covered"><td>4923</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4924</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4925</td><td><pre style="display:inline;">{ TCipher_Q128 }</pre></td></tr>
<tr class="nocodegen"><td>4926</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4927</td><td><pre style="display:inline;">class function TCipher_Q128.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>4928</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4929</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>4930</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>4931</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 16;</pre></td></tr>
<tr class="covered"><td>4932</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 256;</pre></td></tr>
<tr class="covered"><td>4933</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := false;</pre></td></tr>
<tr class="covered"><td>4934</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4935</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>4936</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>4937</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4938</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4939</td><td><pre style="display:inline;">procedure TCipher_Q128.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4940</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4941</td><td><pre style="display:inline;"> &nbsp;K: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4942</td><td><pre style="display:inline;"> &nbsp;D: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>4943</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>4944</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4945</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>4946</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>4947</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer;</pre></td></tr>
<tr class="nocodegen"><td>4948</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4949</td><td><pre style="display:inline;"> &nbsp;for I := 19 downto 1 do</pre></td></tr>
<tr class="nocodegen"><td>4950</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4951</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[1] := K[1] xor Q128_Data[K[0] and $03FF]; K[0] := K[0] shr 10 or K[0] shl 22;</pre></td></tr>
<tr class="covered"><td>4952</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[2] := K[2] xor Q128_Data[K[1] and $03FF]; K[1] := K[1] shr 10 or K[1] shl 22;</pre></td></tr>
<tr class="covered"><td>4953</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[3] := K[3] xor Q128_Data[K[2] and $03FF]; K[2] := K[2] shr 10 or K[2] shl 22;</pre></td></tr>
<tr class="covered"><td>4954</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[0] := K[0] xor Q128_Data[K[3] and $03FF]; K[3] := K[3] shr 10 or K[3] shl 22;</pre></td></tr>
<tr class="covered"><td>4955</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &lt;= 16 then</pre></td></tr>
<tr class="nocodegen"><td>4956</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4957</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D[0] := K[0];</pre></td></tr>
<tr class="covered"><td>4958</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D[1] := K[1];</pre></td></tr>
<tr class="covered"><td>4959</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D[2] := K[2];</pre></td></tr>
<tr class="covered"><td>4960</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D[3] := K[3];</pre></td></tr>
<tr class="covered"><td>4961</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D := @D[4];</pre></td></tr>
<tr class="nocodegen"><td>4962</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4963</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4964</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4965</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>4966</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4967</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>4968</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4969</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4970</td><td><pre style="display:inline;">procedure TCipher_Q128.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4971</td><td><pre style="display:inline;">{$IFDEF X86ASM}</pre></td></tr>
<tr class="covered"><td>4972</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="covered"><td>4973</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; ESI</pre></td></tr>
<tr class="covered"><td>4974</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; EDI</pre></td></tr>
<tr class="covered"><td>4975</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; EBX</pre></td></tr>
<tr class="covered"><td>4976</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>4977</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; ECX</pre></td></tr>
<tr class="covered"><td>4978</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EDI,[EAX].TCipher_Q128.FAdditionalBuffer</pre></td></tr>
<tr class="covered"><td>4979</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EDX + &nbsp;0] &nbsp;// B0</pre></td></tr>
<tr class="covered"><td>4980</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EBX,[EDX + &nbsp;4] &nbsp;// B1</pre></td></tr>
<tr class="covered"><td>4981</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;ECX,[EDX + &nbsp;8] &nbsp;// B2</pre></td></tr>
<tr class="covered"><td>4982</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EDX,[EDX + 12] &nbsp;// B3</pre></td></tr>
<tr class="covered"><td>4983</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EBP,16</pre></td></tr>
<tr class="covered"><td>4984</td><td><pre style="display:inline;">@@1: &nbsp; MOV &nbsp; &nbsp;ESI,EAX</pre></td></tr>
<tr class="covered"><td>4985</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROL &nbsp; &nbsp;ESI,10</pre></td></tr>
<tr class="covered"><td>4986</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>4987</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>4988</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI + 0]</pre></td></tr>
<tr class="covered"><td>4989</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;EAX,EBX</pre></td></tr>
<tr class="covered"><td>4990</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EBX,EAX</pre></td></tr>
<tr class="covered"><td>4991</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROL &nbsp; &nbsp;EBX,10</pre></td></tr>
<tr class="covered"><td>4992</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>4993</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>4994</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI + 4]</pre></td></tr>
<tr class="covered"><td>4995</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;EAX,ECX</pre></td></tr>
<tr class="covered"><td>4996</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;ECX,EAX</pre></td></tr>
<tr class="covered"><td>4997</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROL &nbsp; &nbsp;ECX,10</pre></td></tr>
<tr class="covered"><td>4998</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>4999</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>5000</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI + 8]</pre></td></tr>
<tr class="covered"><td>5001</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;EAX,EDX</pre></td></tr>
<tr class="covered"><td>5002</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EDX,EAX</pre></td></tr>
<tr class="covered"><td>5003</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROL &nbsp; &nbsp;EDX,10</pre></td></tr>
<tr class="covered"><td>5004</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>5005</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>5006</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI + 12]</pre></td></tr>
<tr class="covered"><td>5007</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;EAX,ESI</pre></td></tr>
<tr class="covered"><td>5008</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; DEC &nbsp; &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>5009</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; LEA &nbsp; &nbsp;EDI,[EDI + 16]</pre></td></tr>
<tr class="covered"><td>5010</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; JNZ &nbsp; &nbsp;@@1</pre></td></tr>
<tr class="covered"><td>5011</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;ESI</pre></td></tr>
<tr class="covered"><td>5012</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[ESI + &nbsp;0],EAX &nbsp;// B0</pre></td></tr>
<tr class="covered"><td>5013</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[ESI + &nbsp;4],EBX &nbsp;// B1</pre></td></tr>
<tr class="covered"><td>5014</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[ESI + &nbsp;8],ECX &nbsp;// B2</pre></td></tr>
<tr class="covered"><td>5015</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[ESI + 12],EDX &nbsp;// B3</pre></td></tr>
<tr class="covered"><td>5016</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>5017</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>5018</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>5019</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;ESI</pre></td></tr>
<tr class="covered"><td>5020</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5021</td><td><pre style="display:inline;">{$ELSE !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>5022</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5023</td><td><pre style="display:inline;"> &nbsp;D: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>5024</td><td><pre style="display:inline;"> &nbsp;B0, B1, B2, B3, I: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>5025</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>5026</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5027</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5028</td><td><pre style="display:inline;"> &nbsp;D &nbsp;:= Pointer(FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>5029</td><td><pre style="display:inline;"> &nbsp;B0 := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="nocodegen"><td>5030</td><td><pre style="display:inline;"> &nbsp;B1 := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="nocodegen"><td>5031</td><td><pre style="display:inline;"> &nbsp;B2 := PUInt32Array(Source)[2];</pre></td></tr>
<tr class="nocodegen"><td>5032</td><td><pre style="display:inline;"> &nbsp;B3 := PUInt32Array(Source)[3];</pre></td></tr>
<tr class="nocodegen"><td>5033</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>5034</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5035</td><td><pre style="display:inline;"> &nbsp; &nbsp;B1 := B1 xor (Q128_Data[B0 and $03FF] + D[0]); B0 := B0 shl 10 or B0 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>5036</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := B2 xor (Q128_Data[B1 and $03FF] + D[1]); B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>5037</td><td><pre style="display:inline;"> &nbsp; &nbsp;B3 := B3 xor (Q128_Data[B2 and $03FF] + D[2]); B2 := B2 shl 10 or B2 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>5038</td><td><pre style="display:inline;"> &nbsp; &nbsp;B0 := B0 xor (Q128_Data[B3 and $03FF] + D[3]); B3 := B3 shl 10 or B3 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>5039</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := @D[4];</pre></td></tr>
<tr class="nocodegen"><td>5040</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5041</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := B0;</pre></td></tr>
<tr class="nocodegen"><td>5042</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B1;</pre></td></tr>
<tr class="nocodegen"><td>5043</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := B2;</pre></td></tr>
<tr class="nocodegen"><td>5044</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := B3;</pre></td></tr>
<tr class="nocodegen"><td>5045</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5046</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>5047</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5048</td><td><pre style="display:inline;">procedure TCipher_Q128.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5049</td><td><pre style="display:inline;">{$IFDEF X86ASM}</pre></td></tr>
<tr class="covered"><td>5050</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="covered"><td>5051</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; ESI</pre></td></tr>
<tr class="covered"><td>5052</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; EDI</pre></td></tr>
<tr class="covered"><td>5053</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; EBX</pre></td></tr>
<tr class="covered"><td>5054</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; EBP</pre></td></tr>
<tr class="covered"><td>5055</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; PUSH &nbsp; ECX</pre></td></tr>
<tr class="covered"><td>5056</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EDI,[EAX].TCipher_Q128.FAdditionalBuffer</pre></td></tr>
<tr class="covered"><td>5057</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; LEA &nbsp; &nbsp;EDI,[EDI + 64 * 4]</pre></td></tr>
<tr class="covered"><td>5058</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;ESI,[EDX + &nbsp;0] &nbsp; // B0</pre></td></tr>
<tr class="covered"><td>5059</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EBX,[EDX + &nbsp;4] &nbsp;// B1</pre></td></tr>
<tr class="covered"><td>5060</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;ECX,[EDX + &nbsp;8] &nbsp;// B2</pre></td></tr>
<tr class="covered"><td>5061</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EDX,[EDX + 12] &nbsp;// B3</pre></td></tr>
<tr class="covered"><td>5062</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EBP,16</pre></td></tr>
<tr class="covered"><td>5063</td><td><pre style="display:inline;">@@1: &nbsp; SUB &nbsp; &nbsp;EDI,16</pre></td></tr>
<tr class="covered"><td>5064</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROR &nbsp; &nbsp;EDX,10</pre></td></tr>
<tr class="covered"><td>5065</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,EDX</pre></td></tr>
<tr class="covered"><td>5066</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>5067</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>5068</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI + 12]</pre></td></tr>
<tr class="covered"><td>5069</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;ESI,EAX</pre></td></tr>
<tr class="covered"><td>5070</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROR &nbsp; &nbsp;ECX,10</pre></td></tr>
<tr class="covered"><td>5071</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,ECX</pre></td></tr>
<tr class="covered"><td>5072</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>5073</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>5074</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI + &nbsp;8]</pre></td></tr>
<tr class="covered"><td>5075</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;EDX,EAX</pre></td></tr>
<tr class="covered"><td>5076</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROR &nbsp; &nbsp;EBX,10</pre></td></tr>
<tr class="covered"><td>5077</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,EBX</pre></td></tr>
<tr class="covered"><td>5078</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>5079</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>5080</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI + &nbsp;4]</pre></td></tr>
<tr class="covered"><td>5081</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;ECX,EAX</pre></td></tr>
<tr class="covered"><td>5082</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ROR &nbsp; &nbsp;ESI,10</pre></td></tr>
<tr class="covered"><td>5083</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,ESI</pre></td></tr>
<tr class="covered"><td>5084</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; AND &nbsp; &nbsp;EAX,03FFh</pre></td></tr>
<tr class="covered"><td>5085</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;EAX,[EAX * 4 + OFFSET Q128_DATA]</pre></td></tr>
<tr class="covered"><td>5086</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; ADD &nbsp; &nbsp;EAX,[EDI]</pre></td></tr>
<tr class="covered"><td>5087</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp;EBX,EAX</pre></td></tr>
<tr class="covered"><td>5088</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; DEC &nbsp; &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>5089</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; JNZ &nbsp; &nbsp;@@1</pre></td></tr>
<tr class="covered"><td>5090</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;EAX</pre></td></tr>
<tr class="covered"><td>5091</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[EAX + &nbsp;0],ESI &nbsp;// B0</pre></td></tr>
<tr class="covered"><td>5092</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[EAX + &nbsp;4],EBX &nbsp;// B1</pre></td></tr>
<tr class="covered"><td>5093</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[EAX + &nbsp;8],ECX &nbsp;// B2</pre></td></tr>
<tr class="covered"><td>5094</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; MOV &nbsp; &nbsp;[EAX + 12],EDX &nbsp;// B3</pre></td></tr>
<tr class="covered"><td>5095</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;EBP</pre></td></tr>
<tr class="covered"><td>5096</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;EBX</pre></td></tr>
<tr class="covered"><td>5097</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;EDI</pre></td></tr>
<tr class="covered"><td>5098</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; POP &nbsp; &nbsp;ESI</pre></td></tr>
<tr class="covered"><td>5099</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5100</td><td><pre style="display:inline;">{$ELSE !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>5101</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5102</td><td><pre style="display:inline;"> &nbsp;D: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>5103</td><td><pre style="display:inline;"> &nbsp;B0, B1, B2, B3, I: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>5104</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>5105</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5106</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5107</td><td><pre style="display:inline;"> &nbsp;D &nbsp;:= @PUInt32Array(FAdditionalBuffer)[60];</pre></td></tr>
<tr class="nocodegen"><td>5108</td><td><pre style="display:inline;"> &nbsp;B0 := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="nocodegen"><td>5109</td><td><pre style="display:inline;"> &nbsp;B1 := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="nocodegen"><td>5110</td><td><pre style="display:inline;"> &nbsp;B2 := PUInt32Array(Source)[2];</pre></td></tr>
<tr class="nocodegen"><td>5111</td><td><pre style="display:inline;"> &nbsp;B3 := PUInt32Array(Source)[3];</pre></td></tr>
<tr class="nocodegen"><td>5112</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>5113</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5114</td><td><pre style="display:inline;"> &nbsp; &nbsp;B3 := B3 shr 10 or B3 shl 22; B0 := B0 xor (Q128_Data[B3 and $03FF] + D[3]);</pre></td></tr>
<tr class="nocodegen"><td>5115</td><td><pre style="display:inline;"> &nbsp; &nbsp;B2 := B2 shr 10 or B2 shl 22; B3 := B3 xor (Q128_Data[B2 and $03FF] + D[2]);</pre></td></tr>
<tr class="nocodegen"><td>5116</td><td><pre style="display:inline;"> &nbsp; &nbsp;B1 := B1 shr 10 or B1 shl 22; B2 := B2 xor (Q128_Data[B1 and $03FF] + D[1]);</pre></td></tr>
<tr class="nocodegen"><td>5117</td><td><pre style="display:inline;"> &nbsp; &nbsp;B0 := B0 shr 10 or B0 shl 22; B1 := B1 xor (Q128_Data[B0 and $03FF] + D[0]);</pre></td></tr>
<tr class="nocodegen"><td>5118</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PUInt32(D), 4);</pre></td></tr>
<tr class="nocodegen"><td>5119</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5120</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := B0;</pre></td></tr>
<tr class="nocodegen"><td>5121</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B1;</pre></td></tr>
<tr class="nocodegen"><td>5122</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[2] := B2;</pre></td></tr>
<tr class="nocodegen"><td>5123</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[3] := B3;</pre></td></tr>
<tr class="nocodegen"><td>5124</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5125</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>5126</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5127</td><td><pre style="display:inline;">{ TCipher_RC2 }</pre></td></tr>
<tr class="nocodegen"><td>5128</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5129</td><td><pre style="display:inline;">class function TCipher_RC2.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>5130</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5131</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 128;</pre></td></tr>
<tr class="covered"><td>5132</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>5133</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>5134</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 128;</pre></td></tr>
<tr class="covered"><td>5135</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>5136</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>5137</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>5138</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>5139</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5140</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5141</td><td><pre style="display:inline;">procedure TCipher_RC2.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5142</td><td><pre style="display:inline;">// New keyscheduling according to RFC2268 and it&apos;s testcases. The V3 keysetup</pre></td></tr>
<tr class="nocodegen"><td>5143</td><td><pre style="display:inline;">// was using an older, inferior version. Special thanks to Brendan Bosnan for</pre></td></tr>
<tr class="nocodegen"><td>5144</td><td><pre style="display:inline;">// pointing that out.</pre></td></tr>
<tr class="nocodegen"><td>5145</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5146</td><td><pre style="display:inline;"> &nbsp;I, L, Mask, KeyEffectiveBits: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5147</td><td><pre style="display:inline;"> &nbsp;K: PByteArray;</pre></td></tr>
<tr class="covered"><td>5148</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5149</td><td><pre style="display:inline;"> &nbsp;if Size &lt;= 0 then</pre></td></tr>
<tr class="nocodegen"><td>5150</td><td><pre style="display:inline;"> &nbsp; &nbsp;Exit;</pre></td></tr>
<tr class="covered"><td>5151</td><td><pre style="display:inline;"> &nbsp;KeyEffectiveBits := Size * 8;</pre></td></tr>
<tr class="covered"><td>5152</td><td><pre style="display:inline;"> &nbsp;L := KeyEffectiveBits and 7;</pre></td></tr>
<tr class="covered"><td>5153</td><td><pre style="display:inline;"> &nbsp;if L = 0 then</pre></td></tr>
<tr class="covered"><td>5154</td><td><pre style="display:inline;"> &nbsp; &nbsp;Mask := $FF</pre></td></tr>
<tr class="nocodegen"><td>5155</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>5156</td><td><pre style="display:inline;"> &nbsp; &nbsp;Mask := $FF shr (8 - L);</pre></td></tr>
<tr class="covered"><td>5157</td><td><pre style="display:inline;"> &nbsp;L := (KeyEffectiveBits + 7) shr 3;</pre></td></tr>
<tr class="covered"><td>5158</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5159</td><td><pre style="display:inline;"> &nbsp;Move(Key, K[0], Size);</pre></td></tr>
<tr class="covered"><td>5160</td><td><pre style="display:inline;"> &nbsp;for I := Size to 127 do</pre></td></tr>
<tr class="covered"><td>5161</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[I] := RC2_Data[(K[I - Size] + K[I - 1]) and $FF];</pre></td></tr>
<tr class="covered"><td>5162</td><td><pre style="display:inline;"> &nbsp;K[128 - L] := RC2_Data[K[128 - L] and Mask];</pre></td></tr>
<tr class="covered"><td>5163</td><td><pre style="display:inline;"> &nbsp;for I := 127 - L downto 0 do</pre></td></tr>
<tr class="covered"><td>5164</td><td><pre style="display:inline;"> &nbsp; &nbsp; K[I] := RC2_Data[K[I + 1] xor K[I + L]];</pre></td></tr>
<tr class="nocodegen"><td>5165</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5166</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>5167</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5168</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5169</td><td><pre style="display:inline;">procedure TCipher_RC2.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5170</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5171</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5172</td><td><pre style="display:inline;"> &nbsp;K: PWordArray;</pre></td></tr>
<tr class="nocodegen"><td>5173</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: Word;</pre></td></tr>
<tr class="covered"><td>5174</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5175</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5176</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5177</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5178</td><td><pre style="display:inline;"> &nbsp;A := PWordArray(Source)[0];</pre></td></tr>
<tr class="covered"><td>5179</td><td><pre style="display:inline;"> &nbsp;B := PWordArray(Source)[1];</pre></td></tr>
<tr class="covered"><td>5180</td><td><pre style="display:inline;"> &nbsp;C := PWordArray(Source)[2];</pre></td></tr>
<tr class="covered"><td>5181</td><td><pre style="display:inline;"> &nbsp;D := PWordArray(Source)[3];</pre></td></tr>
<tr class="covered"><td>5182</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>5183</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5184</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(A, (B and not D) + (C and D) + K[I * 4 + 0]); A := A shl 1 or A shr 15;</pre></td></tr>
<tr class="covered"><td>5185</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, (C and not A) + (D and A) + K[I * 4 + 1]); B := B shl 2 or B shr 14;</pre></td></tr>
<tr class="covered"><td>5186</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, (D and not B) + (A and B) + K[I * 4 + 2]); C := C shl 3 or C shr 13;</pre></td></tr>
<tr class="covered"><td>5187</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, (A and not C) + (B and C) + K[I * 4 + 3]); D := D shl 5 or D shr 11;</pre></td></tr>
<tr class="covered"><td>5188</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I in [4, 10] then</pre></td></tr>
<tr class="nocodegen"><td>5189</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5190</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(A, K[D and $3F]);</pre></td></tr>
<tr class="covered"><td>5191</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(B, K[A and $3F]);</pre></td></tr>
<tr class="covered"><td>5192</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(C, K[B and $3F]);</pre></td></tr>
<tr class="covered"><td>5193</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(D, K[C and $3F]);</pre></td></tr>
<tr class="nocodegen"><td>5194</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5195</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5196</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[0] := A;</pre></td></tr>
<tr class="covered"><td>5197</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[1] := B;</pre></td></tr>
<tr class="covered"><td>5198</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[2] := C;</pre></td></tr>
<tr class="covered"><td>5199</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[3] := D;</pre></td></tr>
<tr class="covered"><td>5200</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5201</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5202</td><td><pre style="display:inline;">procedure TCipher_RC2.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5203</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5204</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5205</td><td><pre style="display:inline;"> &nbsp;K: PWordArray;</pre></td></tr>
<tr class="nocodegen"><td>5206</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: Word;</pre></td></tr>
<tr class="covered"><td>5207</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5208</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5209</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5210</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5211</td><td><pre style="display:inline;"> &nbsp;A := PWordArray(Source)[0];</pre></td></tr>
<tr class="covered"><td>5212</td><td><pre style="display:inline;"> &nbsp;B := PWordArray(Source)[1];</pre></td></tr>
<tr class="covered"><td>5213</td><td><pre style="display:inline;"> &nbsp;C := PWordArray(Source)[2];</pre></td></tr>
<tr class="covered"><td>5214</td><td><pre style="display:inline;"> &nbsp;D := PWordArray(Source)[3];</pre></td></tr>
<tr class="covered"><td>5215</td><td><pre style="display:inline;"> &nbsp;for I := 15 downto 0 do</pre></td></tr>
<tr class="nocodegen"><td>5216</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5217</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D shr 5 or D shl 11 - (A and not C) - (B and C) - K[I * 4 + 3];</pre></td></tr>
<tr class="covered"><td>5218</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C shr 3 or C shl 13 - (D and not B) - (A and B) - K[I * 4 + 2];</pre></td></tr>
<tr class="covered"><td>5219</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shr 2 or B shl 14 - (C and not A) - (D and A) - K[I * 4 + 1];</pre></td></tr>
<tr class="covered"><td>5220</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shr 1 or A shl 15 - (B and not D) - (C and D) - K[I * 4 + 0];</pre></td></tr>
<tr class="covered"><td>5221</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I in [5, 11] then</pre></td></tr>
<tr class="nocodegen"><td>5222</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5223</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(D, K[C and $3F]);</pre></td></tr>
<tr class="covered"><td>5224</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(C, K[B and $3F]);</pre></td></tr>
<tr class="covered"><td>5225</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(B, K[A and $3F]);</pre></td></tr>
<tr class="covered"><td>5226</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(A, K[D and $3F]);</pre></td></tr>
<tr class="nocodegen"><td>5227</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5228</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5229</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[0] := A;</pre></td></tr>
<tr class="covered"><td>5230</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[1] := B;</pre></td></tr>
<tr class="covered"><td>5231</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[2] := C;</pre></td></tr>
<tr class="covered"><td>5232</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[3] := D;</pre></td></tr>
<tr class="covered"><td>5233</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5234</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5235</td><td><pre style="display:inline;">{ TCipher_RC5 }</pre></td></tr>
<tr class="nocodegen"><td>5236</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5237</td><td><pre style="display:inline;">class function TCipher_RC5.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>5238</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5239</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 256;</pre></td></tr>
<tr class="covered"><td>5240</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>5241</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>5242</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 136;</pre></td></tr>
<tr class="covered"><td>5243</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := false;</pre></td></tr>
<tr class="covered"><td>5244</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 0;</pre></td></tr>
<tr class="covered"><td>5245</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 256;</pre></td></tr>
<tr class="covered"><td>5246</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>5247</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5248</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5249</td><td><pre style="display:inline;">procedure TCipher_RC5.SetRounds(Value: Integer);</pre></td></tr>
<tr class="covered"><td>5250</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5251</td><td><pre style="display:inline;"> &nbsp;if Value &lt;&gt; FRounds then</pre></td></tr>
<tr class="nocodegen"><td>5252</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5253</td><td><pre style="display:inline;"> &nbsp; &nbsp;if not (FState in [csNew, csInitialized, csDone]) then</pre></td></tr>
<tr class="notcovered"><td>5254</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Done;</pre></td></tr>
<tr class="nocodegen"><td>5255</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5256</td><td><pre style="display:inline;"> &nbsp; &nbsp;if Value &lt; 0 then</pre></td></tr>
<tr class="covered"><td>5257</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Value := 12;</pre></td></tr>
<tr class="nocodegen"><td>5258</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5259</td><td><pre style="display:inline;"> &nbsp; &nbsp;if (Value &gt; Context.MaxRounds) then</pre></td></tr>
<tr class="covered"><td>5260</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Value := Context.MaxRounds;</pre></td></tr>
<tr class="nocodegen"><td>5261</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5262</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := Value;</pre></td></tr>
<tr class="nocodegen"><td>5263</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5264</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5265</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5266</td><td><pre style="display:inline;">procedure TCipher_RC5.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5267</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5268</td><td><pre style="display:inline;"> &nbsp;K: array[0..63] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>5269</td><td><pre style="display:inline;"> &nbsp;L, Z, I, J: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5270</td><td><pre style="display:inline;"> &nbsp;D: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>5271</td><td><pre style="display:inline;"> &nbsp;A, B, T: UInt32;</pre></td></tr>
<tr class="covered"><td>5272</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5273</td><td><pre style="display:inline;"> &nbsp;if FRounds &lt;= 0 then</pre></td></tr>
<tr class="covered"><td>5274</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds := 12;</pre></td></tr>
<tr class="covered"><td>5275</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>5276</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>5277</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5278</td><td><pre style="display:inline;"> &nbsp;L := (Size + 3) shr 2;</pre></td></tr>
<tr class="covered"><td>5279</td><td><pre style="display:inline;"> &nbsp;if L &lt;= 0 then</pre></td></tr>
<tr class="notcovered"><td>5280</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := 1;</pre></td></tr>
<tr class="covered"><td>5281</td><td><pre style="display:inline;"> &nbsp;T := $B7E15163;</pre></td></tr>
<tr class="covered"><td>5282</td><td><pre style="display:inline;"> &nbsp;for I := 0 to (FRounds + 1) * 2 do</pre></td></tr>
<tr class="nocodegen"><td>5283</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5284</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := T;</pre></td></tr>
<tr class="covered"><td>5285</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(T, $9E3779B9);</pre></td></tr>
<tr class="covered"><td>5286</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5287</td><td><pre style="display:inline;"> &nbsp;if L &gt; (FRounds + 1) * 2 then</pre></td></tr>
<tr class="notcovered"><td>5288</td><td><pre style="display:inline;"> &nbsp; &nbsp;Z := L * 3</pre></td></tr>
<tr class="nocodegen"><td>5289</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>5290</td><td><pre style="display:inline;"> &nbsp; &nbsp;Z := (FRounds + 1) * 6;</pre></td></tr>
<tr class="covered"><td>5291</td><td><pre style="display:inline;"> &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>5292</td><td><pre style="display:inline;"> &nbsp;J := 0;</pre></td></tr>
<tr class="covered"><td>5293</td><td><pre style="display:inline;"> &nbsp;A := 0;</pre></td></tr>
<tr class="covered"><td>5294</td><td><pre style="display:inline;"> &nbsp;B := 0;</pre></td></tr>
<tr class="covered"><td>5295</td><td><pre style="display:inline;"> &nbsp;for Z := Z downto 1 do</pre></td></tr>
<tr class="nocodegen"><td>5296</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5297</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := D[I] + A + B;</pre></td></tr>
<tr class="covered"><td>5298</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A shl 3 or A shr 29;</pre></td></tr>
<tr class="covered"><td>5299</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := A;</pre></td></tr>
<tr class="covered"><td>5300</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A + B;</pre></td></tr>
<tr class="covered"><td>5301</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := K[J] + T;</pre></td></tr>
<tr class="covered"><td>5302</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B shl T or B shr (32 - T);</pre></td></tr>
<tr class="covered"><td>5303</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[J] := B;</pre></td></tr>
<tr class="covered"><td>5304</td><td><pre style="display:inline;"> &nbsp; &nbsp;I := (I + 1) mod ((FRounds + 1) * 2);</pre></td></tr>
<tr class="covered"><td>5305</td><td><pre style="display:inline;"> &nbsp; &nbsp;J := (J + 1) mod L;</pre></td></tr>
<tr class="covered"><td>5306</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5307</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>5308</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5309</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>5310</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5311</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5312</td><td><pre style="display:inline;">procedure TCipher_RC5.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5313</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5314</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>5315</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5316</td><td><pre style="display:inline;"> &nbsp;A, B: UInt32;</pre></td></tr>
<tr class="covered"><td>5317</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5318</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5319</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5320</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5321</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0] + K[0];</pre></td></tr>
<tr class="covered"><td>5322</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1] + K[1];</pre></td></tr>
<tr class="covered"><td>5323</td><td><pre style="display:inline;"> &nbsp;for I := 1 to FRounds do</pre></td></tr>
<tr class="nocodegen"><td>5324</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5325</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor B; A := A shl B or A shr (32 - B) + K[I * 2 + 0];</pre></td></tr>
<tr class="covered"><td>5326</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor A; B := B shl A or B shr (32 - A) + K[I * 2 + 1];</pre></td></tr>
<tr class="covered"><td>5327</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5328</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A;</pre></td></tr>
<tr class="covered"><td>5329</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B;</pre></td></tr>
<tr class="covered"><td>5330</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5331</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5332</td><td><pre style="display:inline;">procedure TCipher_RC5.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5333</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5334</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>5335</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5336</td><td><pre style="display:inline;"> &nbsp;A, B: UInt32;</pre></td></tr>
<tr class="covered"><td>5337</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5338</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5339</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5340</td><td><pre style="display:inline;"> &nbsp;K := @PUInt32Array(FAdditionalBuffer)[0];</pre></td></tr>
<tr class="covered"><td>5341</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>5342</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>5343</td><td><pre style="display:inline;"> &nbsp;for I := FRounds downto 1 do</pre></td></tr>
<tr class="nocodegen"><td>5344</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5345</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B - K[I * 2 + 1]; B := B shr A or B shl (32 - A) xor A;</pre></td></tr>
<tr class="covered"><td>5346</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A - K[I * 2 + 0]; A := A shr B or A shl (32 - B) xor B;</pre></td></tr>
<tr class="covered"><td>5347</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5348</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := A - K[0];</pre></td></tr>
<tr class="covered"><td>5349</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := B - K[1];</pre></td></tr>
<tr class="covered"><td>5350</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5351</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5352</td><td><pre style="display:inline;">{ TCipher_SAFER }</pre></td></tr>
<tr class="nocodegen"><td>5353</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5354</td><td><pre style="display:inline;">class function TCipher_SAFER.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>5355</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5356</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>5357</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>5358</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>5359</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 768;</pre></td></tr>
<tr class="covered"><td>5360</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := false;</pre></td></tr>
<tr class="covered"><td>5361</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 4;</pre></td></tr>
<tr class="covered"><td>5362</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 13;</pre></td></tr>
<tr class="covered"><td>5363</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>5364</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5365</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5366</td><td><pre style="display:inline;">procedure TCipher_SAFER.SetRounds(Value: Integer);</pre></td></tr>
<tr class="covered"><td>5367</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5368</td><td><pre style="display:inline;"> &nbsp;if not (FState in [csNew, csInitialized, csDone]) then</pre></td></tr>
<tr class="notcovered"><td>5369</td><td><pre style="display:inline;"> &nbsp; &nbsp;Done;</pre></td></tr>
<tr class="covered"><td>5370</td><td><pre style="display:inline;"> &nbsp;if (Value &lt; 4) or (Value &gt; 13) then</pre></td></tr>
<tr class="covered"><td>5371</td><td><pre style="display:inline;"> &nbsp; &nbsp;case FVersion of // Default Rounds</pre></td></tr>
<tr class="covered"><td>5372</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;svK40, svSK40: Value := 5;</pre></td></tr>
<tr class="covered"><td>5373</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;svK64, svSK64: Value := 6;</pre></td></tr>
<tr class="covered"><td>5374</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;svK128, svSK128: Value := 10;</pre></td></tr>
<tr class="nocodegen"><td>5375</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>5376</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Value := 8;</pre></td></tr>
<tr class="nocodegen"><td>5377</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5378</td><td><pre style="display:inline;"> &nbsp;FRounds := Value;</pre></td></tr>
<tr class="covered"><td>5379</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5380</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5381</td><td><pre style="display:inline;">procedure TCipher_SAFER.SetVersion(Value: TSAFERVersion);</pre></td></tr>
<tr class="covered"><td>5382</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5383</td><td><pre style="display:inline;"> &nbsp;if Value &lt;&gt; FVersion then</pre></td></tr>
<tr class="nocodegen"><td>5384</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5385</td><td><pre style="display:inline;"> &nbsp; &nbsp;if not (FState in [csNew, csInitialized, csDone]) then</pre></td></tr>
<tr class="notcovered"><td>5386</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Done;</pre></td></tr>
<tr class="covered"><td>5387</td><td><pre style="display:inline;"> &nbsp; &nbsp;FVersion := Value;</pre></td></tr>
<tr class="covered"><td>5388</td><td><pre style="display:inline;"> &nbsp; &nbsp;SetRounds(0);</pre></td></tr>
<tr class="nocodegen"><td>5389</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5390</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5391</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5392</td><td><pre style="display:inline;">procedure TCipher_SAFER.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5393</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5394</td><td><pre style="display:inline;"> &nbsp;procedure InitTab;</pre></td></tr>
<tr class="nocodegen"><td>5395</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>5396</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, E: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5397</td><td><pre style="display:inline;"> &nbsp; &nbsp;Exp: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>5398</td><td><pre style="display:inline;"> &nbsp; &nbsp;Log: PByteArray;</pre></td></tr>
<tr class="covered"><td>5399</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5400</td><td><pre style="display:inline;"> &nbsp; &nbsp;Exp := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5401</td><td><pre style="display:inline;"> &nbsp; &nbsp;Log := @Exp[256];</pre></td></tr>
<tr class="covered"><td>5402</td><td><pre style="display:inline;"> &nbsp; &nbsp;E &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>5403</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="nocodegen"><td>5404</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5405</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Exp[I] := E and $FF;</pre></td></tr>
<tr class="covered"><td>5406</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Log[E and $FF] := I;</pre></td></tr>
<tr class="covered"><td>5407</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;E := (E * 45) mod 257;</pre></td></tr>
<tr class="covered"><td>5408</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5409</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5410</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5411</td><td><pre style="display:inline;"> &nbsp;procedure InitKey;</pre></td></tr>
<tr class="nocodegen"><td>5412</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>5413</td><td><pre style="display:inline;"> &nbsp; &nbsp;D: PByte;</pre></td></tr>
<tr class="nocodegen"><td>5414</td><td><pre style="display:inline;"> &nbsp; &nbsp;Exp: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>5415</td><td><pre style="display:inline;"> &nbsp; &nbsp;Strong: Boolean;</pre></td></tr>
<tr class="nocodegen"><td>5416</td><td><pre style="display:inline;"> &nbsp; &nbsp;K: array[Boolean, 0..8] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>5417</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, J: Integer;</pre></td></tr>
<tr class="covered"><td>5418</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5419</td><td><pre style="display:inline;"> &nbsp; &nbsp;Strong := FVersion in [svSK40, svSK64, svSK128];</pre></td></tr>
<tr class="covered"><td>5420</td><td><pre style="display:inline;"> &nbsp; &nbsp;Exp := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5421</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := @Exp[512];</pre></td></tr>
<tr class="covered"><td>5422</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="nocodegen"><td>5423</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Setup Key A</pre></td></tr>
<tr class="covered"><td>5424</td><td><pre style="display:inline;"> &nbsp; &nbsp;I := Size;</pre></td></tr>
<tr class="covered"><td>5425</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &gt; 8 then</pre></td></tr>
<tr class="covered"><td>5426</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;I := 8;</pre></td></tr>
<tr class="covered"><td>5427</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(Key, K[False], I);</pre></td></tr>
<tr class="nocodegen"><td>5428</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Setup the Key for K-40, SK-40</pre></td></tr>
<tr class="covered"><td>5429</td><td><pre style="display:inline;"> &nbsp; &nbsp;if FVersion in [svK40, svSK40] then</pre></td></tr>
<tr class="nocodegen"><td>5430</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>5431</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[False, 5] := K[False, 0] xor K[False, 2] xor 129;</pre></td></tr>
<tr class="notcovered"><td>5432</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[False, 6] := K[False, 0] xor K[False, 3] xor K[False, 4] xor 66;</pre></td></tr>
<tr class="notcovered"><td>5433</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[False, 7] := K[False, 1] xor K[False, 2] xor K[False, 4] xor 36;</pre></td></tr>
<tr class="notcovered"><td>5434</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[False, 8] := K[False, 1] xor K[False, 3] xor 24;</pre></td></tr>
<tr class="notcovered"><td>5435</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Move(K[False], K[True], SizeOf(K[False]));</pre></td></tr>
<tr class="nocodegen"><td>5436</td><td><pre style="display:inline;"> &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>5437</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>5438</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5439</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if Size &gt; 8 then</pre></td></tr>
<tr class="nocodegen"><td>5440</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5441</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;I := Size - 8;</pre></td></tr>
<tr class="covered"><td>5442</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;if I &gt; 8 then</pre></td></tr>
<tr class="notcovered"><td>5443</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;I := 8;</pre></td></tr>
<tr class="covered"><td>5444</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Move(TByteArray(Key)[8], K[True], I);</pre></td></tr>
<tr class="nocodegen"><td>5445</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>5446</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>5447</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Move(K[False], K[True], 9);</pre></td></tr>
<tr class="covered"><td>5448</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5449</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5450</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;K[False, 8] := K[False, 8] xor K[False, I];</pre></td></tr>
<tr class="covered"><td>5451</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;K[True, 8] &nbsp;:= K[True, 8] &nbsp;xor K[True, I];</pre></td></tr>
<tr class="covered"><td>5452</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5453</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5454</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Setup the KeyData</pre></td></tr>
<tr class="covered"><td>5455</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(K[True], D^, 8);</pre></td></tr>
<tr class="covered"><td>5456</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, 8);</pre></td></tr>
<tr class="nocodegen"><td>5457</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5458</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 8 do</pre></td></tr>
<tr class="covered"><td>5459</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;K[False, I] := K[False, I] shr 3 or K[False, I] shl 5;</pre></td></tr>
<tr class="nocodegen"><td>5460</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5461</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 1 to FRounds do</pre></td></tr>
<tr class="nocodegen"><td>5462</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5463</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for J := 0 to 8 do</pre></td></tr>
<tr class="nocodegen"><td>5464</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5465</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;K[False, J] := K[False, J] shl 6 or K[False, J] shr 2;</pre></td></tr>
<tr class="covered"><td>5466</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;K[True, J] := K[True, J] shl 6 or K[True, J] shr 2;</pre></td></tr>
<tr class="covered"><td>5467</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5468</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for J := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5469</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5470</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;if Strong then</pre></td></tr>
<tr class="covered"><td>5471</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;D^ := K[False, (J + I * 2 - 1) mod 9] + Exp[Exp[18 * I + J + 1]]</pre></td></tr>
<tr class="nocodegen"><td>5472</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>5473</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;D^ := K[False, J] + Exp[Exp[18 * I + J + 1]];</pre></td></tr>
<tr class="covered"><td>5474</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(D);</pre></td></tr>
<tr class="covered"><td>5475</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5476</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for J := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5477</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5478</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;if Strong then</pre></td></tr>
<tr class="covered"><td>5479</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;D^ := K[True, (J + I * 2) mod 9] + Exp[Exp[18 * I + J + 10]]</pre></td></tr>
<tr class="nocodegen"><td>5480</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>5481</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;D^ := K[True, J] + Exp[Exp[18 * I + J + 10]];</pre></td></tr>
<tr class="covered"><td>5482</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(D);</pre></td></tr>
<tr class="covered"><td>5483</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5484</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5485</td><td><pre style="display:inline;"> &nbsp; &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="covered"><td>5486</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5487</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5488</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5489</td><td><pre style="display:inline;"> &nbsp;if (FRounds &lt; 4) or (FRounds &gt; 13) then</pre></td></tr>
<tr class="covered"><td>5490</td><td><pre style="display:inline;"> &nbsp; &nbsp;case FVersion of</pre></td></tr>
<tr class="notcovered"><td>5491</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;svK40, svSK40: &nbsp; &nbsp;FRounds := 5;</pre></td></tr>
<tr class="notcovered"><td>5492</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;svK64, svSK64: &nbsp; &nbsp;FRounds := 6;</pre></td></tr>
<tr class="covered"><td>5493</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;svK128, svSK128: &nbsp;FRounds := 10;</pre></td></tr>
<tr class="nocodegen"><td>5494</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>5495</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;FRounds := 8;</pre></td></tr>
<tr class="nocodegen"><td>5496</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5497</td><td><pre style="display:inline;"> &nbsp;InitTab;</pre></td></tr>
<tr class="covered"><td>5498</td><td><pre style="display:inline;"> &nbsp;InitKey;</pre></td></tr>
<tr class="nocodegen"><td>5499</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5500</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>5501</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5502</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5503</td><td><pre style="display:inline;">procedure TCipher_SAFER.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5504</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5505</td><td><pre style="display:inline;"> &nbsp;Exp, Log, Key: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>5506</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5507</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H, T: Byte;</pre></td></tr>
<tr class="covered"><td>5508</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5509</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5510</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5511</td><td><pre style="display:inline;"> &nbsp;Exp := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5512</td><td><pre style="display:inline;"> &nbsp;Log := @Exp[256];</pre></td></tr>
<tr class="covered"><td>5513</td><td><pre style="display:inline;"> &nbsp;Key := @Exp[512];</pre></td></tr>
<tr class="nocodegen"><td>5514</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5515</td><td><pre style="display:inline;"> &nbsp;A := PByteArray(Source)[0];</pre></td></tr>
<tr class="covered"><td>5516</td><td><pre style="display:inline;"> &nbsp;B := PByteArray(Source)[1];</pre></td></tr>
<tr class="covered"><td>5517</td><td><pre style="display:inline;"> &nbsp;C := PByteArray(Source)[2];</pre></td></tr>
<tr class="covered"><td>5518</td><td><pre style="display:inline;"> &nbsp;D := PByteArray(Source)[3];</pre></td></tr>
<tr class="covered"><td>5519</td><td><pre style="display:inline;"> &nbsp;E := PByteArray(Source)[4];</pre></td></tr>
<tr class="covered"><td>5520</td><td><pre style="display:inline;"> &nbsp;F := PByteArray(Source)[5];</pre></td></tr>
<tr class="covered"><td>5521</td><td><pre style="display:inline;"> &nbsp;G := PByteArray(Source)[6];</pre></td></tr>
<tr class="covered"><td>5522</td><td><pre style="display:inline;"> &nbsp;H := PByteArray(Source)[7];</pre></td></tr>
<tr class="nocodegen"><td>5523</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5524</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>5525</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5526</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor Key[0];</pre></td></tr>
<tr class="covered"><td>5527</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B &nbsp;+ &nbsp;Key[1];</pre></td></tr>
<tr class="covered"><td>5528</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C &nbsp;+ &nbsp;Key[2];</pre></td></tr>
<tr class="covered"><td>5529</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor Key[3];</pre></td></tr>
<tr class="covered"><td>5530</td><td><pre style="display:inline;"> &nbsp; &nbsp;E := E xor Key[4];</pre></td></tr>
<tr class="covered"><td>5531</td><td><pre style="display:inline;"> &nbsp; &nbsp;F := F &nbsp;+ &nbsp;Key[5];</pre></td></tr>
<tr class="covered"><td>5532</td><td><pre style="display:inline;"> &nbsp; &nbsp;G := G &nbsp;+ &nbsp;Key[6];</pre></td></tr>
<tr class="covered"><td>5533</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := H xor Key[7];</pre></td></tr>
<tr class="nocodegen"><td>5534</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5535</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := Exp[A] &nbsp;+ &nbsp;Key[8];</pre></td></tr>
<tr class="covered"><td>5536</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := Log[B] xor Key[9];</pre></td></tr>
<tr class="covered"><td>5537</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := Log[C] xor Key[10];</pre></td></tr>
<tr class="covered"><td>5538</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := Exp[D] &nbsp;+ &nbsp;Key[11];</pre></td></tr>
<tr class="covered"><td>5539</td><td><pre style="display:inline;"> &nbsp; &nbsp;E := Exp[E] &nbsp;+ &nbsp;Key[12];</pre></td></tr>
<tr class="covered"><td>5540</td><td><pre style="display:inline;"> &nbsp; &nbsp;F := Log[F] xor Key[13];</pre></td></tr>
<tr class="covered"><td>5541</td><td><pre style="display:inline;"> &nbsp; &nbsp;G := Log[G] xor Key[14];</pre></td></tr>
<tr class="covered"><td>5542</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := Exp[H] &nbsp;+ &nbsp;Key[15];</pre></td></tr>
<tr class="covered"><td>5543</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, A); Inc(A, B);</pre></td></tr>
<tr class="covered"><td>5544</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, C); Inc(C, D);</pre></td></tr>
<tr class="covered"><td>5545</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(F, E); Inc(E, F);</pre></td></tr>
<tr class="covered"><td>5546</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(H, G); Inc(G, H);</pre></td></tr>
<tr class="covered"><td>5547</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, A); Inc(A, C);</pre></td></tr>
<tr class="covered"><td>5548</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(G, E); Inc(E, G);</pre></td></tr>
<tr class="covered"><td>5549</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(D, B); Inc(B, D);</pre></td></tr>
<tr class="covered"><td>5550</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(H, F); Inc(F, H);</pre></td></tr>
<tr class="covered"><td>5551</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(E, A); Inc(A, E);</pre></td></tr>
<tr class="covered"><td>5552</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(F, B); Inc(B, F);</pre></td></tr>
<tr class="covered"><td>5553</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(G, C); Inc(C, G);</pre></td></tr>
<tr class="covered"><td>5554</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(H, D); Inc(D, H);</pre></td></tr>
<tr class="covered"><td>5555</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B; B := E; E := C; C := T;</pre></td></tr>
<tr class="covered"><td>5556</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := D; D := F; F := G; G := T;</pre></td></tr>
<tr class="covered"><td>5557</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key := @Key[16];</pre></td></tr>
<tr class="covered"><td>5558</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5559</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5560</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[0] := A xor Key[0];</pre></td></tr>
<tr class="covered"><td>5561</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[1] := B &nbsp;+ &nbsp;Key[1];</pre></td></tr>
<tr class="covered"><td>5562</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[2] := C &nbsp;+ &nbsp;Key[2];</pre></td></tr>
<tr class="covered"><td>5563</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[3] := D xor Key[3];</pre></td></tr>
<tr class="covered"><td>5564</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[4] := E xor Key[4];</pre></td></tr>
<tr class="covered"><td>5565</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[5] := F &nbsp;+ &nbsp;Key[5];</pre></td></tr>
<tr class="covered"><td>5566</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[6] := G &nbsp;+ &nbsp;Key[6];</pre></td></tr>
<tr class="covered"><td>5567</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[7] := H xor Key[7];</pre></td></tr>
<tr class="covered"><td>5568</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5569</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5570</td><td><pre style="display:inline;">procedure TCipher_SAFER.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5571</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5572</td><td><pre style="display:inline;"> &nbsp;Exp, Log, Key: PByteArray;</pre></td></tr>
<tr class="nocodegen"><td>5573</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5574</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H, T: Byte;</pre></td></tr>
<tr class="covered"><td>5575</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5576</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5577</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5578</td><td><pre style="display:inline;"> &nbsp;Exp := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5579</td><td><pre style="display:inline;"> &nbsp;Log := @Exp[256];</pre></td></tr>
<tr class="covered"><td>5580</td><td><pre style="display:inline;"> &nbsp;Key := @Exp[504 + 8 * (FRounds * 2 + 1)];</pre></td></tr>
<tr class="nocodegen"><td>5581</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5582</td><td><pre style="display:inline;"> &nbsp;A := PByteArray(Source)[0] xor Key[0];</pre></td></tr>
<tr class="covered"><td>5583</td><td><pre style="display:inline;"> &nbsp;B := PByteArray(Source)[1] &nbsp;- &nbsp;Key[1];</pre></td></tr>
<tr class="covered"><td>5584</td><td><pre style="display:inline;"> &nbsp;C := PByteArray(Source)[2] &nbsp;- &nbsp;Key[2];</pre></td></tr>
<tr class="covered"><td>5585</td><td><pre style="display:inline;"> &nbsp;D := PByteArray(Source)[3] xor Key[3];</pre></td></tr>
<tr class="covered"><td>5586</td><td><pre style="display:inline;"> &nbsp;E := PByteArray(Source)[4] xor Key[4];</pre></td></tr>
<tr class="covered"><td>5587</td><td><pre style="display:inline;"> &nbsp;F := PByteArray(Source)[5] &nbsp;- &nbsp;Key[5];</pre></td></tr>
<tr class="covered"><td>5588</td><td><pre style="display:inline;"> &nbsp;G := PByteArray(Source)[6] &nbsp;- &nbsp;Key[6];</pre></td></tr>
<tr class="covered"><td>5589</td><td><pre style="display:inline;"> &nbsp;H := PByteArray(Source)[7] xor Key[7];</pre></td></tr>
<tr class="nocodegen"><td>5590</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5591</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>5592</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5593</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(PByte(Key), 16);</pre></td></tr>
<tr class="covered"><td>5594</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := E; E := B; B := C; C := T;</pre></td></tr>
<tr class="covered"><td>5595</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := F; F := D; D := G; G := T;</pre></td></tr>
<tr class="covered"><td>5596</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, E); Dec(E, A);</pre></td></tr>
<tr class="covered"><td>5597</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, F); Dec(F, B);</pre></td></tr>
<tr class="covered"><td>5598</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, G); Dec(G, C);</pre></td></tr>
<tr class="covered"><td>5599</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(D, H); Dec(H, D);</pre></td></tr>
<tr class="covered"><td>5600</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, C); Dec(C, A);</pre></td></tr>
<tr class="covered"><td>5601</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(E, G); Dec(G, E);</pre></td></tr>
<tr class="covered"><td>5602</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, D); Dec(D, B);</pre></td></tr>
<tr class="covered"><td>5603</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(F, H); Dec(H, F);</pre></td></tr>
<tr class="covered"><td>5604</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, B); Dec(B, A);</pre></td></tr>
<tr class="covered"><td>5605</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, D); Dec(D, C);</pre></td></tr>
<tr class="covered"><td>5606</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(E, F); Dec(F, E);</pre></td></tr>
<tr class="covered"><td>5607</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(G, H); Dec(H, G);</pre></td></tr>
<tr class="covered"><td>5608</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := H &nbsp;- &nbsp;Key[15];</pre></td></tr>
<tr class="covered"><td>5609</td><td><pre style="display:inline;"> &nbsp; &nbsp;G := G xor Key[14];</pre></td></tr>
<tr class="covered"><td>5610</td><td><pre style="display:inline;"> &nbsp; &nbsp;F := F xor Key[13];</pre></td></tr>
<tr class="covered"><td>5611</td><td><pre style="display:inline;"> &nbsp; &nbsp;E := E &nbsp;- &nbsp;Key[12];</pre></td></tr>
<tr class="covered"><td>5612</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D &nbsp;- &nbsp;Key[11];</pre></td></tr>
<tr class="covered"><td>5613</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor Key[10];</pre></td></tr>
<tr class="covered"><td>5614</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor Key[9];</pre></td></tr>
<tr class="covered"><td>5615</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A &nbsp;- &nbsp;Key[8];</pre></td></tr>
<tr class="covered"><td>5616</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := Log[H] xor Key[7];</pre></td></tr>
<tr class="covered"><td>5617</td><td><pre style="display:inline;"> &nbsp; &nbsp;G := Exp[G] &nbsp;- &nbsp;Key[6];</pre></td></tr>
<tr class="covered"><td>5618</td><td><pre style="display:inline;"> &nbsp; &nbsp;F := Exp[F] &nbsp;- &nbsp;Key[5];</pre></td></tr>
<tr class="covered"><td>5619</td><td><pre style="display:inline;"> &nbsp; &nbsp;E := Log[E] xor Key[4];</pre></td></tr>
<tr class="covered"><td>5620</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := Log[D] xor Key[3];</pre></td></tr>
<tr class="covered"><td>5621</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := Exp[C] &nbsp;- &nbsp;Key[2];</pre></td></tr>
<tr class="covered"><td>5622</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := Exp[B] &nbsp;- &nbsp;Key[1];</pre></td></tr>
<tr class="covered"><td>5623</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := Log[A] xor Key[0];</pre></td></tr>
<tr class="covered"><td>5624</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5625</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5626</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[0] := A;</pre></td></tr>
<tr class="covered"><td>5627</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[1] := B;</pre></td></tr>
<tr class="covered"><td>5628</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[2] := C;</pre></td></tr>
<tr class="covered"><td>5629</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[3] := D;</pre></td></tr>
<tr class="covered"><td>5630</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[4] := E;</pre></td></tr>
<tr class="covered"><td>5631</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[5] := F;</pre></td></tr>
<tr class="covered"><td>5632</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[6] := G;</pre></td></tr>
<tr class="covered"><td>5633</td><td><pre style="display:inline;"> &nbsp;PByteArray(Dest)[7] := H;</pre></td></tr>
<tr class="covered"><td>5634</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5635</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5636</td><td><pre style="display:inline;">{ TCipher_SharkBase }</pre></td></tr>
<tr class="nocodegen"><td>5637</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5638</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>5639</td><td><pre style="display:inline;"> &nbsp;SHARK_ROOT &nbsp; &nbsp; &nbsp;= $01F5; // GF(256) polynomial x^8 + x^7 + x^6 + x^5 + x^4 + x^2 + 1</pre></td></tr>
<tr class="nocodegen"><td>5640</td><td><pre style="display:inline;"> &nbsp;SHARK_ROUNDS &nbsp; &nbsp;= 6;</pre></td></tr>
<tr class="nocodegen"><td>5641</td><td><pre style="display:inline;"> &nbsp;SHARK_ROUNDKEYS = SHARK_ROUNDS + 1;</pre></td></tr>
<tr class="nocodegen"><td>5642</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5643</td><td><pre style="display:inline;">{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5644</td><td><pre style="display:inline;">function TCipher_SharkBase.Shark(D: TLong64; K: PLong64): TLong64;</pre></td></tr>
<tr class="nocodegen"><td>5645</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5646</td><td><pre style="display:inline;"> &nbsp;R, T: Integer;</pre></td></tr>
<tr class="covered"><td>5647</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5648</td><td><pre style="display:inline;"> &nbsp;for R := 0 to 4 do</pre></td></tr>
<tr class="nocodegen"><td>5649</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5650</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.L := D.L xor K.L;</pre></td></tr>
<tr class="covered"><td>5651</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.R := D.R xor K.R;</pre></td></tr>
<tr class="covered"><td>5652</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(K);</pre></td></tr>
<tr class="covered"><td>5653</td><td><pre style="display:inline;"> &nbsp; &nbsp;T &nbsp; := Shark_CE[0, D.R shr 23 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5654</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[1, D.R shr 15 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5655</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[2, D.R shr &nbsp;7 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5656</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[3, D.R shl &nbsp;1 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5657</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[4, D.L shr 23 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5658</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[5, D.L shr 15 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5659</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[6, D.L shr &nbsp;7 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5660</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[7, D.L shl &nbsp;1 and $1FE];</pre></td></tr>
<tr class="nocodegen"><td>5661</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5662</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.R := Shark_CE[0, D.R shr 23 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5663</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[1, D.R shr 15 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5664</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[2, D.R shr &nbsp;7 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5665</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[3, D.R shl &nbsp;1 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5666</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[4, D.L shr 23 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5667</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[5, D.L shr 15 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5668</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[6, D.L shr &nbsp;7 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5669</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[7, D.L shl &nbsp;1 and $1FE or 1];</pre></td></tr>
<tr class="covered"><td>5670</td><td><pre style="display:inline;"> &nbsp; &nbsp;D.L := T;</pre></td></tr>
<tr class="covered"><td>5671</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5672</td><td><pre style="display:inline;"> &nbsp;D.L := D.L xor K.L;</pre></td></tr>
<tr class="covered"><td>5673</td><td><pre style="display:inline;"> &nbsp;D.R := D.R xor K.R;</pre></td></tr>
<tr class="covered"><td>5674</td><td><pre style="display:inline;"> &nbsp;Inc(K);</pre></td></tr>
<tr class="covered"><td>5675</td><td><pre style="display:inline;"> &nbsp;D.L := UInt32(Shark_SE[D.L shr 24 and $FF]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>5676</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[D.L shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>5677</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[D.L shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>5678</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[D.L &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="covered"><td>5679</td><td><pre style="display:inline;"> &nbsp;D.R := UInt32(Shark_SE[D.R shr 24 and $FF]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>5680</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[D.R shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>5681</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[D.R shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>5682</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[D.R &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="covered"><td>5683</td><td><pre style="display:inline;"> &nbsp;Result.L := D.L xor K.L;</pre></td></tr>
<tr class="covered"><td>5684</td><td><pre style="display:inline;"> &nbsp;Result.R := D.R xor K.R;</pre></td></tr>
<tr class="covered"><td>5685</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5686</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>5687</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5688</td><td><pre style="display:inline;">{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5689</td><td><pre style="display:inline;">function TCipher_SharkBase.Transform(A: TLong64; Log, ALog: TLogArray): TLong64;</pre></td></tr>
<tr class="nocodegen"><td>5690</td><td><pre style="display:inline;"> &nbsp;function Mul(A, B: Integer): Byte;</pre></td></tr>
<tr class="covered"><td>5691</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5692</td><td><pre style="display:inline;"> &nbsp; &nbsp;// GF(256) multiplication via logarithm tables</pre></td></tr>
<tr class="covered"><td>5693</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := ALog[(Log[A] + Log[B]) mod 255];</pre></td></tr>
<tr class="covered"><td>5694</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5695</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5696</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5697</td><td><pre style="display:inline;"> &nbsp;I, J: Byte;</pre></td></tr>
<tr class="nocodegen"><td>5698</td><td><pre style="display:inline;"> &nbsp;K, T: array[0..7] of Byte;</pre></td></tr>
<tr class="covered"><td>5699</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5700</td><td><pre style="display:inline;"> &nbsp;Move(A.R, K[0], 4);</pre></td></tr>
<tr class="covered"><td>5701</td><td><pre style="display:inline;"> &nbsp;Move(A.L, K[4], 4);</pre></td></tr>
<tr class="covered"><td>5702</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(K, K, 2);</pre></td></tr>
<tr class="nocodegen"><td>5703</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5704</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5705</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5706</td><td><pre style="display:inline;"> &nbsp; &nbsp;T[I] := Mul(Shark_I[I, 0], K[0]);</pre></td></tr>
<tr class="covered"><td>5707</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 1 to 7 do</pre></td></tr>
<tr class="covered"><td>5708</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[I] := T[I] xor Mul(Shark_I[I, J], K[J]);</pre></td></tr>
<tr class="covered"><td>5709</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5710</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5711</td><td><pre style="display:inline;"> &nbsp;Result.L := T[0];</pre></td></tr>
<tr class="covered"><td>5712</td><td><pre style="display:inline;"> &nbsp;Result.R := 0;</pre></td></tr>
<tr class="covered"><td>5713</td><td><pre style="display:inline;"> &nbsp;for I := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5714</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5715</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result.R := Result.R shl 8 or Result.L shr 24;</pre></td></tr>
<tr class="covered"><td>5716</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result.L := Result.L shl 8 xor T[I];</pre></td></tr>
<tr class="covered"><td>5717</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5718</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5719</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5720</td><td><pre style="display:inline;">{$ELSE CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5721</td><td><pre style="display:inline;">function TCipher_SharkBase.Transform(A: UInt64; Log, ALog: TLogArray): UInt64;</pre></td></tr>
<tr class="nocodegen"><td>5722</td><td><pre style="display:inline;"> &nbsp;function Mul(A, B: Integer): Byte;</pre></td></tr>
<tr class="nocodegen"><td>5723</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5724</td><td><pre style="display:inline;"> &nbsp; &nbsp;// GF(256) multiplication via logarithm tables</pre></td></tr>
<tr class="nocodegen"><td>5725</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := ALog[(Log[A] + Log[B]) mod 255];</pre></td></tr>
<tr class="nocodegen"><td>5726</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5727</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5728</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5729</td><td><pre style="display:inline;"> &nbsp;I, J: Byte;</pre></td></tr>
<tr class="nocodegen"><td>5730</td><td><pre style="display:inline;"> &nbsp;K, T: array[0..7] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>5731</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>5732</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5733</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[I] := A shr (56 - 8 * i);</pre></td></tr>
<tr class="nocodegen"><td>5734</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5735</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5736</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5737</td><td><pre style="display:inline;"> &nbsp; &nbsp;T[I] := Mul(Shark_I[I, 0], K[0]);</pre></td></tr>
<tr class="nocodegen"><td>5738</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5739</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T[I] := T[I] xor Mul(Shark_I[I, J], K[J]);</pre></td></tr>
<tr class="nocodegen"><td>5740</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5741</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5742</td><td><pre style="display:inline;"> &nbsp;Result := T[0];</pre></td></tr>
<tr class="nocodegen"><td>5743</td><td><pre style="display:inline;"> &nbsp;for I := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5744</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := (Result shl 8) xor T[I];</pre></td></tr>
<tr class="nocodegen"><td>5745</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5746</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>5747</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5748</td><td><pre style="display:inline;">class function TCipher_SharkBase.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>5749</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5750</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>5751</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>5752</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>5753</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 112;</pre></td></tr>
<tr class="covered"><td>5754</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := False;</pre></td></tr>
<tr class="covered"><td>5755</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>5756</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>5757</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>5758</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5759</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5760</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5761</td><td><pre style="display:inline;">procedure TCipher_SharkBase.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5762</td><td><pre style="display:inline;">{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5763</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5764</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5765</td><td><pre style="display:inline;"> &nbsp;T, L, R: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>5766</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>5767</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5768</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5769</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5770</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5771</td><td><pre style="display:inline;"> &nbsp;L := PLong64(Source).L;</pre></td></tr>
<tr class="covered"><td>5772</td><td><pre style="display:inline;"> &nbsp;R := PLong64(Source).R;</pre></td></tr>
<tr class="covered"><td>5773</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 4 do</pre></td></tr>
<tr class="nocodegen"><td>5774</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5775</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor K[I * 2 + 0];</pre></td></tr>
<tr class="covered"><td>5776</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R xor K[I * 2 + 1];</pre></td></tr>
<tr class="covered"><td>5777</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := Shark_CE[0, R shr 23 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5778</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[1, R shr 15 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5779</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[2, R shr &nbsp;7 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5780</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[3, R shl &nbsp;1 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5781</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[4, L shr 23 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5782</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[5, L shr 15 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5783</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[6, L shr &nbsp;7 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5784</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[7, L shl &nbsp;1 and $1FE];</pre></td></tr>
<tr class="covered"><td>5785</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := Shark_CE[0, R shr 23 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5786</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[1, R shr 15 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5787</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[2, R shr &nbsp;7 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5788</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[3, R shl &nbsp;1 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5789</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[4, L shr 23 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5790</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[5, L shr 15 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5791</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[6, L shr &nbsp;7 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5792</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[7, L shl &nbsp;1 and $1FE or 1];</pre></td></tr>
<tr class="covered"><td>5793</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := T;</pre></td></tr>
<tr class="covered"><td>5794</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5795</td><td><pre style="display:inline;"> &nbsp;L := L xor K[10];</pre></td></tr>
<tr class="covered"><td>5796</td><td><pre style="display:inline;"> &nbsp;R := R xor K[11];</pre></td></tr>
<tr class="covered"><td>5797</td><td><pre style="display:inline;"> &nbsp;L := UInt32(Shark_SE[L shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>5798</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[L shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>5799</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[L shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>5800</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[L &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="covered"><td>5801</td><td><pre style="display:inline;"> &nbsp;R := UInt32(Shark_SE[R shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>5802</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[R shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>5803</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[R shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>5804</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SE[R &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="covered"><td>5805</td><td><pre style="display:inline;"> &nbsp;PLong64(Dest).L := L xor K[12];</pre></td></tr>
<tr class="covered"><td>5806</td><td><pre style="display:inline;"> &nbsp;PLong64(Dest).R := R xor K[13];</pre></td></tr>
<tr class="nocodegen"><td>5807</td><td><pre style="display:inline;">{$ELSE CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5808</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>5809</td><td><pre style="display:inline;"> &nbsp;// 64 bit</pre></td></tr>
<tr class="nocodegen"><td>5810</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BufferSize);</pre></td></tr>
<tr class="nocodegen"><td>5811</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5812</td><td><pre style="display:inline;"> &nbsp;PUInt64(Dest)^ := SharkEncode(PUInt64(Source)^, FAdditionalBuffer);</pre></td></tr>
<tr class="nocodegen"><td>5813</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="covered"><td>5814</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5815</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5816</td><td><pre style="display:inline;">{$IFDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5817</td><td><pre style="display:inline;">function TCipher_SharkBase.SharkEncode(D: UInt64; K: PUInt64): UInt64;</pre></td></tr>
<tr class="nocodegen"><td>5818</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5819</td><td><pre style="display:inline;"> &nbsp;R: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5820</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>5821</td><td><pre style="display:inline;"> &nbsp;for R := 1 to SHARK_ROUNDS - 1 do</pre></td></tr>
<tr class="nocodegen"><td>5822</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5823</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor K^;</pre></td></tr>
<tr class="nocodegen"><td>5824</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(K);</pre></td></tr>
<tr class="nocodegen"><td>5825</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := Shark_CE[0, D shr 56 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>5826</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[1, D shr 48 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>5827</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[2, D shr 40 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>5828</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[3, D shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>5829</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[4, D shr 24 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>5830</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[5, D shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>5831</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[6, D shr 8 &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>5832</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CE[7, D &nbsp; &nbsp; &nbsp; &nbsp;and $FF];</pre></td></tr>
<tr class="nocodegen"><td>5833</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5834</td><td><pre style="display:inline;"> &nbsp;D := D xor K^;</pre></td></tr>
<tr class="nocodegen"><td>5835</td><td><pre style="display:inline;"> &nbsp;Inc(K);</pre></td></tr>
<tr class="nocodegen"><td>5836</td><td><pre style="display:inline;"> &nbsp;D := UInt64(Shark_SE[D shr 56 and $FF]) shl 56 xor</pre></td></tr>
<tr class="nocodegen"><td>5837</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SE[D shr 48 and $FF]) shl 48 xor</pre></td></tr>
<tr class="nocodegen"><td>5838</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SE[D shr 40 and $FF]) shl 40 xor</pre></td></tr>
<tr class="nocodegen"><td>5839</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SE[D shr 32 and $FF]) shl 32 xor</pre></td></tr>
<tr class="nocodegen"><td>5840</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SE[D shr 24 and $FF]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>5841</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SE[D shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>5842</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SE[D shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>5843</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SE[D &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>5844</td><td><pre style="display:inline;"> &nbsp;Result := D xor K^;</pre></td></tr>
<tr class="nocodegen"><td>5845</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5846</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>5847</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5848</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5849</td><td><pre style="display:inline;">{ TCipher_Shark }</pre></td></tr>
<tr class="nocodegen"><td>5850</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5851</td><td><pre style="display:inline;">{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5852</td><td><pre style="display:inline;">procedure TCipher_Shark.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5853</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5854</td><td><pre style="display:inline;"> &nbsp;Log, ALog: TLogArray;</pre></td></tr>
<tr class="nocodegen"><td>5855</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5856</td><td><pre style="display:inline;"> &nbsp;procedure InitLog;</pre></td></tr>
<tr class="nocodegen"><td>5857</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>5858</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, J: Word;</pre></td></tr>
<tr class="covered"><td>5859</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5860</td><td><pre style="display:inline;"> &nbsp; &nbsp;ALog[0] := 1;</pre></td></tr>
<tr class="covered"><td>5861</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 1 to 255 do</pre></td></tr>
<tr class="nocodegen"><td>5862</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5863</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;J := ALog[I - 1] shl 1;</pre></td></tr>
<tr class="covered"><td>5864</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if J and $100 &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>5865</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;J := J xor SHARK_ROOT;</pre></td></tr>
<tr class="covered"><td>5866</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ALog[I] := J;</pre></td></tr>
<tr class="covered"><td>5867</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5868</td><td><pre style="display:inline;"> &nbsp; &nbsp;Log[0] := 0;</pre></td></tr>
<tr class="covered"><td>5869</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 254 do</pre></td></tr>
<tr class="covered"><td>5870</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Log[ALog[I]] := I;</pre></td></tr>
<tr class="covered"><td>5871</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5872</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5873</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5874</td><td><pre style="display:inline;"> &nbsp;T: array[0..6] of TLong64;</pre></td></tr>
<tr class="nocodegen"><td>5875</td><td><pre style="display:inline;"> &nbsp;A: array[0..6] of TLong64;</pre></td></tr>
<tr class="nocodegen"><td>5876</td><td><pre style="display:inline;"> &nbsp;K: array[0..15] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>5877</td><td><pre style="display:inline;"> &nbsp;I, J, R: Byte;</pre></td></tr>
<tr class="nocodegen"><td>5878</td><td><pre style="display:inline;"> &nbsp;E, D: PLong64Array;</pre></td></tr>
<tr class="nocodegen"><td>5879</td><td><pre style="display:inline;"> &nbsp;L: TLong64;</pre></td></tr>
<tr class="covered"><td>5880</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5881</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>5882</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>5883</td><td><pre style="display:inline;"> &nbsp;InitLog;</pre></td></tr>
<tr class="covered"><td>5884</td><td><pre style="display:inline;"> &nbsp;E := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>5885</td><td><pre style="display:inline;"> &nbsp;D := @E[7];</pre></td></tr>
<tr class="covered"><td>5886</td><td><pre style="display:inline;"> &nbsp;Move(Shark_CE[0], T, SizeOf(T));</pre></td></tr>
<tr class="covered"><td>5887</td><td><pre style="display:inline;"> &nbsp;T[6] := Transform(T[6], Log, ALog);</pre></td></tr>
<tr class="covered"><td>5888</td><td><pre style="display:inline;"> &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>5889</td><td><pre style="display:inline;"> &nbsp;for R := 0 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>5890</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5891</td><td><pre style="display:inline;"> &nbsp; &nbsp;A[R].L := K[I and $F];</pre></td></tr>
<tr class="covered"><td>5892</td><td><pre style="display:inline;"> &nbsp; &nbsp;A[R].R := 0;</pre></td></tr>
<tr class="covered"><td>5893</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>5894</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>5895</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5896</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[R].R := A[R].R shl 8 or A[R].L shr 24;</pre></td></tr>
<tr class="covered"><td>5897</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[R].L := A[R].L shl 8 or K[I and $F];</pre></td></tr>
<tr class="covered"><td>5898</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>5899</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5900</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5901</td><td><pre style="display:inline;"> &nbsp;L.L := 0;</pre></td></tr>
<tr class="covered"><td>5902</td><td><pre style="display:inline;"> &nbsp;L.R := 0;</pre></td></tr>
<tr class="covered"><td>5903</td><td><pre style="display:inline;"> &nbsp;L := Shark(L, @T);</pre></td></tr>
<tr class="covered"><td>5904</td><td><pre style="display:inline;"> &nbsp;E[0].L := A[0].L xor L.L;</pre></td></tr>
<tr class="covered"><td>5905</td><td><pre style="display:inline;"> &nbsp;E[0].R := A[0].R xor L.R;</pre></td></tr>
<tr class="covered"><td>5906</td><td><pre style="display:inline;"> &nbsp;for R := 1 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>5907</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5908</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Shark(E[R - 1], @T);</pre></td></tr>
<tr class="covered"><td>5909</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[R].L := A[R].L xor L.L;</pre></td></tr>
<tr class="covered"><td>5910</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[R].R := A[R].R xor L.R;</pre></td></tr>
<tr class="covered"><td>5911</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5912</td><td><pre style="display:inline;"> &nbsp;E[6] := Transform(E[6], Log, ALog);</pre></td></tr>
<tr class="covered"><td>5913</td><td><pre style="display:inline;"> &nbsp;D[0] := E[6];</pre></td></tr>
<tr class="covered"><td>5914</td><td><pre style="display:inline;"> &nbsp;D[6] := E[0];</pre></td></tr>
<tr class="covered"><td>5915</td><td><pre style="display:inline;"> &nbsp;for R := 1 to 5 do</pre></td></tr>
<tr class="covered"><td>5916</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[R] := Transform(E[6-R], Log, ALog);</pre></td></tr>
<tr class="covered"><td>5917</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(T, SizeOf(T));</pre></td></tr>
<tr class="covered"><td>5918</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(A, SizeOf(A));</pre></td></tr>
<tr class="covered"><td>5919</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>5920</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5921</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>5922</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5923</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>5924</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5925</td><td><pre style="display:inline;">{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5926</td><td><pre style="display:inline;">procedure TCipher_SharkBase.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5927</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5928</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>5929</td><td><pre style="display:inline;"> &nbsp;T, R, L: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>5930</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>5931</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>5932</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>5933</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>5934</td><td><pre style="display:inline;"> &nbsp;K := @PUInt32Array(FAdditionalBuffer)[14];</pre></td></tr>
<tr class="covered"><td>5935</td><td><pre style="display:inline;"> &nbsp;L := PLong64(Source).L;</pre></td></tr>
<tr class="covered"><td>5936</td><td><pre style="display:inline;"> &nbsp;R := PLong64(Source).R;</pre></td></tr>
<tr class="covered"><td>5937</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 4 do</pre></td></tr>
<tr class="nocodegen"><td>5938</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>5939</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := L xor K[I * 2 + 0];</pre></td></tr>
<tr class="covered"><td>5940</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := R xor K[I * 2 + 1];</pre></td></tr>
<tr class="covered"><td>5941</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := Shark_CD[0, R shr 23 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5942</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[1, R shr 15 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5943</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[2, R shr &nbsp;7 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5944</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[3, R shl &nbsp;1 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5945</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[4, L shr 23 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5946</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[5, L shr 15 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5947</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[6, L shr &nbsp;7 and $1FE] xor</pre></td></tr>
<tr class="nocodegen"><td>5948</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[7, L shl &nbsp;1 and $1FE];</pre></td></tr>
<tr class="covered"><td>5949</td><td><pre style="display:inline;"> &nbsp; &nbsp;R := Shark_CD[0, R shr 23 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5950</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[1, R shr 15 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5951</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[2, R shr &nbsp;7 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5952</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[3, R shl &nbsp;1 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5953</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[4, L shr 23 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5954</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[5, L shr 15 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5955</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[6, L shr &nbsp;7 and $1FE or 1] xor</pre></td></tr>
<tr class="nocodegen"><td>5956</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[7, L shl &nbsp;1 and $1FE or 1];</pre></td></tr>
<tr class="covered"><td>5957</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := T;</pre></td></tr>
<tr class="covered"><td>5958</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>5959</td><td><pre style="display:inline;"> &nbsp;L := L xor K[10];</pre></td></tr>
<tr class="covered"><td>5960</td><td><pre style="display:inline;"> &nbsp;R := R xor K[11];</pre></td></tr>
<tr class="covered"><td>5961</td><td><pre style="display:inline;"> &nbsp;L := UInt32(Shark_SD[L shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>5962</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SD[L shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>5963</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SD[L shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>5964</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SD[L &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="covered"><td>5965</td><td><pre style="display:inline;"> &nbsp;R := UInt32(Shark_SD[R shr 24 &nbsp; &nbsp; &nbsp; &nbsp;]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>5966</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SD[R shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>5967</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SD[R shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>5968</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt32(Shark_SD[R &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="covered"><td>5969</td><td><pre style="display:inline;"> &nbsp;PLong64(Dest).L := L xor K[12];</pre></td></tr>
<tr class="covered"><td>5970</td><td><pre style="display:inline;"> &nbsp;PLong64(Dest).R := R xor K[13];</pre></td></tr>
<tr class="covered"><td>5971</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>5972</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5973</td><td><pre style="display:inline;">{$ELSE CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>5974</td><td><pre style="display:inline;">procedure TCipher_Shark.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>5975</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5976</td><td><pre style="display:inline;"> &nbsp;Log, ALog: TLogArray;</pre></td></tr>
<tr class="nocodegen"><td>5977</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5978</td><td><pre style="display:inline;"> &nbsp;procedure InitLog;</pre></td></tr>
<tr class="nocodegen"><td>5979</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>5980</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, J: Word;</pre></td></tr>
<tr class="nocodegen"><td>5981</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5982</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Generate GF(256) anti-logarithm and logarithm tables</pre></td></tr>
<tr class="nocodegen"><td>5983</td><td><pre style="display:inline;"> &nbsp; &nbsp;ALog[0] := 1;</pre></td></tr>
<tr class="nocodegen"><td>5984</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 1 to 255 do</pre></td></tr>
<tr class="nocodegen"><td>5985</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>5986</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;J := ALog[I - 1] shl 1;</pre></td></tr>
<tr class="nocodegen"><td>5987</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if J and $100 &lt;&gt; 0 then</pre></td></tr>
<tr class="nocodegen"><td>5988</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;J := J xor SHARK_ROOT;</pre></td></tr>
<tr class="nocodegen"><td>5989</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ALog[I] := J;</pre></td></tr>
<tr class="nocodegen"><td>5990</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5991</td><td><pre style="display:inline;"> &nbsp; &nbsp;Log[0] := 0;</pre></td></tr>
<tr class="nocodegen"><td>5992</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 0 to 254 do</pre></td></tr>
<tr class="nocodegen"><td>5993</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Log[ALog[I]] := I;</pre></td></tr>
<tr class="nocodegen"><td>5994</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>5995</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>5996</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>5997</td><td><pre style="display:inline;"> &nbsp;T: array[0..SHARK_ROUNDS] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>5998</td><td><pre style="display:inline;"> &nbsp;A: array[0..SHARK_ROUNDKEYS-1] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>5999</td><td><pre style="display:inline;"> &nbsp;K: array[0..15] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>6000</td><td><pre style="display:inline;"> &nbsp;I, J, R: Integer;</pre></td></tr>
<tr class="nocodegen"><td>6001</td><td><pre style="display:inline;"> &nbsp;E, D: PUInt64Array;</pre></td></tr>
<tr class="nocodegen"><td>6002</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>6003</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="nocodegen"><td>6004</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="nocodegen"><td>6005</td><td><pre style="display:inline;"> &nbsp;InitLog;</pre></td></tr>
<tr class="nocodegen"><td>6006</td><td><pre style="display:inline;"> &nbsp;E := FAdditionalBuffer; // encryption round key</pre></td></tr>
<tr class="nocodegen"><td>6007</td><td><pre style="display:inline;"> &nbsp;D := @E[SHARK_ROUNDS + 1]; // decryption round key</pre></td></tr>
<tr class="nocodegen"><td>6008</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6009</td><td><pre style="display:inline;"> &nbsp;Move(Shark_CE[0], T, SizeOf(T));</pre></td></tr>
<tr class="nocodegen"><td>6010</td><td><pre style="display:inline;"> &nbsp;T[SHARK_ROUNDS] := Transform(T[SHARK_ROUNDS], Log, ALog);</pre></td></tr>
<tr class="nocodegen"><td>6011</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6012</td><td><pre style="display:inline;"> &nbsp;I := 0;</pre></td></tr>
<tr class="nocodegen"><td>6013</td><td><pre style="display:inline;"> &nbsp;for R := 0 to High(A) do</pre></td></tr>
<tr class="nocodegen"><td>6014</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>6015</td><td><pre style="display:inline;"> &nbsp; &nbsp;A[R] := K[I and $F];</pre></td></tr>
<tr class="nocodegen"><td>6016</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="nocodegen"><td>6017</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>6018</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>6019</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[R] := A[R] shl 8 or K[I and $F];</pre></td></tr>
<tr class="nocodegen"><td>6020</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="nocodegen"><td>6021</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6022</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6023</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6024</td><td><pre style="display:inline;"> &nbsp;E[0] := A[0] xor SharkEncode(0, @T);</pre></td></tr>
<tr class="nocodegen"><td>6025</td><td><pre style="display:inline;"> &nbsp;for R := 1 to High(A) do</pre></td></tr>
<tr class="nocodegen"><td>6026</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[R] := A[R] xor SharkEncode(E[R - 1], @T);</pre></td></tr>
<tr class="nocodegen"><td>6027</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6028</td><td><pre style="display:inline;"> &nbsp;E[SHARK_ROUNDS] := Transform(E[SHARK_ROUNDS], Log, ALog);</pre></td></tr>
<tr class="nocodegen"><td>6029</td><td><pre style="display:inline;"> &nbsp;D[0] := E[SHARK_ROUNDS];</pre></td></tr>
<tr class="nocodegen"><td>6030</td><td><pre style="display:inline;"> &nbsp;D[SHARK_ROUNDS] := E[0];</pre></td></tr>
<tr class="nocodegen"><td>6031</td><td><pre style="display:inline;"> &nbsp;for R := 1 to SHARK_ROUNDS - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6032</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[R] := Transform(E[SHARK_ROUNDS - R], Log, ALog);</pre></td></tr>
<tr class="nocodegen"><td>6033</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6034</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(T, SizeOf(T));</pre></td></tr>
<tr class="nocodegen"><td>6035</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(A, SizeOf(A));</pre></td></tr>
<tr class="nocodegen"><td>6036</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>6037</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6038</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>6039</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6040</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6041</td><td><pre style="display:inline;">procedure TCipher_SharkBase.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6042</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6043</td><td><pre style="display:inline;"> &nbsp;R: Integer;</pre></td></tr>
<tr class="nocodegen"><td>6044</td><td><pre style="display:inline;"> &nbsp;D: UInt64;</pre></td></tr>
<tr class="nocodegen"><td>6045</td><td><pre style="display:inline;"> &nbsp;K: PUInt64;</pre></td></tr>
<tr class="nocodegen"><td>6046</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>6047</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BufferSize);</pre></td></tr>
<tr class="nocodegen"><td>6048</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6049</td><td><pre style="display:inline;"> &nbsp;D := PUInt64(Source)^;</pre></td></tr>
<tr class="nocodegen"><td>6050</td><td><pre style="display:inline;"> &nbsp;K := @PUInt64Array(FAdditionalBuffer)[SHARK_ROUNDS + 1]; // decryption round key</pre></td></tr>
<tr class="nocodegen"><td>6051</td><td><pre style="display:inline;"> &nbsp;for R := 1 to SHARK_ROUNDS - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6052</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>6053</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := D xor K^;</pre></td></tr>
<tr class="nocodegen"><td>6054</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(K);</pre></td></tr>
<tr class="nocodegen"><td>6055</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := Shark_CD[0, D shr 56 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>6056</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[1, D shr 48 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>6057</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[2, D shr 40 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>6058</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[3, D shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>6059</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[4, D shr 24 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>6060</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[5, D shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>6061</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[6, D shr 8 &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>6062</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Shark_CD[7, D &nbsp; &nbsp; &nbsp; &nbsp;and $FF];</pre></td></tr>
<tr class="nocodegen"><td>6063</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6064</td><td><pre style="display:inline;"> &nbsp;D := D xor K^;</pre></td></tr>
<tr class="nocodegen"><td>6065</td><td><pre style="display:inline;"> &nbsp;Inc(K);</pre></td></tr>
<tr class="nocodegen"><td>6066</td><td><pre style="display:inline;"> &nbsp;D := UInt64(Shark_SD[D shr 56 and $FF]) shl 56 xor</pre></td></tr>
<tr class="nocodegen"><td>6067</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SD[D shr 48 and $FF]) shl 48 xor</pre></td></tr>
<tr class="nocodegen"><td>6068</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SD[D shr 40 and $FF]) shl 40 xor</pre></td></tr>
<tr class="nocodegen"><td>6069</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SD[D shr 32 and $FF]) shl 32 xor</pre></td></tr>
<tr class="nocodegen"><td>6070</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SD[D shr 24 and $FF]) shl 24 xor</pre></td></tr>
<tr class="nocodegen"><td>6071</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SD[D shr 16 and $FF]) shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>6072</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SD[D shr &nbsp;8 and $FF]) shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>6073</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; UInt64(Shark_SD[D &nbsp; &nbsp; &nbsp; &nbsp;and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>6074</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6075</td><td><pre style="display:inline;"> &nbsp;PUInt64(Dest)^ := D xor K^;</pre></td></tr>
<tr class="nocodegen"><td>6076</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6077</td><td><pre style="display:inline;">{$ENDIF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>6078</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6079</td><td><pre style="display:inline;">{ TCipher_Shark_DEC52 }</pre></td></tr>
<tr class="nocodegen"><td>6080</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6081</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6082</td><td><pre style="display:inline;">procedure TCipher_Shark_DEC52.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6083</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6084</td><td><pre style="display:inline;"> &nbsp;Log, ALog: TLogArray;</pre></td></tr>
<tr class="nocodegen"><td>6085</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6086</td><td><pre style="display:inline;"> &nbsp;procedure InitLog;</pre></td></tr>
<tr class="nocodegen"><td>6087</td><td><pre style="display:inline;"> &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>6088</td><td><pre style="display:inline;"> &nbsp; &nbsp;I, J: Word;</pre></td></tr>
<tr class="covered"><td>6089</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>6090</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Generate GF(256) anti-logarithm and logarithm tables</pre></td></tr>
<tr class="covered"><td>6091</td><td><pre style="display:inline;"> &nbsp; &nbsp;ALog[0] := 1;</pre></td></tr>
<tr class="covered"><td>6092</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 1 to 255 do</pre></td></tr>
<tr class="nocodegen"><td>6093</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6094</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;J := ALog[I - 1] shl 1;</pre></td></tr>
<tr class="covered"><td>6095</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if J and $100 &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>6096</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;J := J xor SHARK_ROOT;</pre></td></tr>
<tr class="covered"><td>6097</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ALog[I] := J;</pre></td></tr>
<tr class="covered"><td>6098</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>6099</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 1 to 254 do</pre></td></tr>
<tr class="covered"><td>6100</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Log[ALog[I]] := I;</pre></td></tr>
<tr class="covered"><td>6101</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6102</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6103</td><td><pre style="display:inline;">{$IFNDEF CPU64BITS}</pre></td></tr>
<tr class="nocodegen"><td>6104</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6105</td><td><pre style="display:inline;"> &nbsp;T: array[0..SHARK_ROUNDS] of TLong64;</pre></td></tr>
<tr class="nocodegen"><td>6106</td><td><pre style="display:inline;"> &nbsp;A: array[0..SHARK_ROUNDS] of TLong64;</pre></td></tr>
<tr class="nocodegen"><td>6107</td><td><pre style="display:inline;"> &nbsp;K: array[0..15] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>6108</td><td><pre style="display:inline;"> &nbsp;I, J, R: Byte;</pre></td></tr>
<tr class="nocodegen"><td>6109</td><td><pre style="display:inline;"> &nbsp;E, D: PLong64Array;</pre></td></tr>
<tr class="nocodegen"><td>6110</td><td><pre style="display:inline;"> &nbsp;L: TLong64;</pre></td></tr>
<tr class="covered"><td>6111</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6112</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>6113</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>6114</td><td><pre style="display:inline;"> &nbsp;InitLog;</pre></td></tr>
<tr class="covered"><td>6115</td><td><pre style="display:inline;"> &nbsp;E := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>6116</td><td><pre style="display:inline;"> &nbsp;D := @E[7];</pre></td></tr>
<tr class="covered"><td>6117</td><td><pre style="display:inline;"> &nbsp;Move(Shark_CE[0], T, SizeOf(T));</pre></td></tr>
<tr class="covered"><td>6118</td><td><pre style="display:inline;"> &nbsp;T[6] := Transform(T[6], Log, ALog);</pre></td></tr>
<tr class="covered"><td>6119</td><td><pre style="display:inline;"> &nbsp;I := 0;</pre></td></tr>
<tr class="covered"><td>6120</td><td><pre style="display:inline;"> &nbsp;for R := 0 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>6121</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6122</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>6123</td><td><pre style="display:inline;"> &nbsp; &nbsp;A[R].L := K[I and $F];</pre></td></tr>
<tr class="covered"><td>6124</td><td><pre style="display:inline;"> &nbsp; &nbsp;A[R].R := 0;</pre></td></tr>
<tr class="covered"><td>6125</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>6126</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6127</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="covered"><td>6128</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[R].R := A[R].R shl 8 or A[R].L shr 24;</pre></td></tr>
<tr class="covered"><td>6129</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[R].L := A[R].L shl 8 or K[I and $F];</pre></td></tr>
<tr class="covered"><td>6130</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>6131</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>6132</td><td><pre style="display:inline;"> &nbsp;L.L := 0;</pre></td></tr>
<tr class="covered"><td>6133</td><td><pre style="display:inline;"> &nbsp;L.R := 0;</pre></td></tr>
<tr class="covered"><td>6134</td><td><pre style="display:inline;"> &nbsp;L := Shark(L, @T);</pre></td></tr>
<tr class="covered"><td>6135</td><td><pre style="display:inline;"> &nbsp;E[0].L := A[0].L xor L.L;</pre></td></tr>
<tr class="covered"><td>6136</td><td><pre style="display:inline;"> &nbsp;E[0].R := A[0].R xor L.R;</pre></td></tr>
<tr class="covered"><td>6137</td><td><pre style="display:inline;"> &nbsp;for R := 1 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>6138</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6139</td><td><pre style="display:inline;"> &nbsp; &nbsp;L := Shark(E[R - 1], @T);</pre></td></tr>
<tr class="covered"><td>6140</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[R].L := A[R].L xor L.L;</pre></td></tr>
<tr class="covered"><td>6141</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[R].R := A[R].R xor L.R;</pre></td></tr>
<tr class="covered"><td>6142</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>6143</td><td><pre style="display:inline;"> &nbsp;E[6] := Transform(E[6], Log, ALog);</pre></td></tr>
<tr class="covered"><td>6144</td><td><pre style="display:inline;"> &nbsp;D[0] := E[6];</pre></td></tr>
<tr class="covered"><td>6145</td><td><pre style="display:inline;"> &nbsp;D[6] := E[0];</pre></td></tr>
<tr class="covered"><td>6146</td><td><pre style="display:inline;"> &nbsp;for R := 1 to 5 do</pre></td></tr>
<tr class="covered"><td>6147</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[R] := Transform(E[6-R], Log, ALog);</pre></td></tr>
<tr class="covered"><td>6148</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(T, SizeOf(T));</pre></td></tr>
<tr class="covered"><td>6149</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(A, SizeOf(A));</pre></td></tr>
<tr class="covered"><td>6150</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>6151</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6152</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>6153</td><td><pre style="display:inline;"> &nbsp;{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>6154</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6155</td><td><pre style="display:inline;"> &nbsp;T: array[0..SHARK_ROUNDS] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>6156</td><td><pre style="display:inline;"> &nbsp;A: array[0..SHARK_ROUNDKEYS-1] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>6157</td><td><pre style="display:inline;"> &nbsp;K: array[0..15] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>6158</td><td><pre style="display:inline;"> &nbsp;I, J, R: Integer;</pre></td></tr>
<tr class="nocodegen"><td>6159</td><td><pre style="display:inline;"> &nbsp;E, D: PUInt64Array;</pre></td></tr>
<tr class="nocodegen"><td>6160</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>6161</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="nocodegen"><td>6162</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="nocodegen"><td>6163</td><td><pre style="display:inline;"> &nbsp;InitLog;</pre></td></tr>
<tr class="nocodegen"><td>6164</td><td><pre style="display:inline;"> &nbsp;E := FAdditionalBuffer; // encryption round key</pre></td></tr>
<tr class="nocodegen"><td>6165</td><td><pre style="display:inline;"> &nbsp;D := @E[SHARK_ROUNDS + 1]; // decryption round key</pre></td></tr>
<tr class="nocodegen"><td>6166</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6167</td><td><pre style="display:inline;"> &nbsp;Move(Shark_CE[0], T, SizeOf(T));</pre></td></tr>
<tr class="nocodegen"><td>6168</td><td><pre style="display:inline;"> &nbsp;T[SHARK_ROUNDS] := Transform(T[SHARK_ROUNDS], Log, ALog);</pre></td></tr>
<tr class="nocodegen"><td>6169</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6170</td><td><pre style="display:inline;"> &nbsp;I := 0;</pre></td></tr>
<tr class="nocodegen"><td>6171</td><td><pre style="display:inline;"> &nbsp;for R := 0 to High(A) do</pre></td></tr>
<tr class="nocodegen"><td>6172</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>6173</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="nocodegen"><td>6174</td><td><pre style="display:inline;"> &nbsp; &nbsp;A[R] := K[I and $F];</pre></td></tr>
<tr class="nocodegen"><td>6175</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 1 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>6176</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>6177</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(I);</pre></td></tr>
<tr class="nocodegen"><td>6178</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[R] := A[R] shl 8 or K[I and $F];</pre></td></tr>
<tr class="nocodegen"><td>6179</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6180</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6181</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6182</td><td><pre style="display:inline;"> &nbsp;E[0] := A[0] xor SharkEncode(0, @T);</pre></td></tr>
<tr class="nocodegen"><td>6183</td><td><pre style="display:inline;"> &nbsp;for R := 1 to High(A) do</pre></td></tr>
<tr class="nocodegen"><td>6184</td><td><pre style="display:inline;"> &nbsp; &nbsp;E[R] := A[R] xor SharkEncode(E[R - 1], @T);</pre></td></tr>
<tr class="nocodegen"><td>6185</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6186</td><td><pre style="display:inline;"> &nbsp;E[SHARK_ROUNDS] := Transform(E[SHARK_ROUNDS], Log, ALog);</pre></td></tr>
<tr class="nocodegen"><td>6187</td><td><pre style="display:inline;"> &nbsp;D[0] := E[SHARK_ROUNDS];</pre></td></tr>
<tr class="nocodegen"><td>6188</td><td><pre style="display:inline;"> &nbsp;D[SHARK_ROUNDS] := E[0];</pre></td></tr>
<tr class="nocodegen"><td>6189</td><td><pre style="display:inline;"> &nbsp;for R := 1 to SHARK_ROUNDS - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6190</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[R] := Transform(E[SHARK_ROUNDS - R], Log, ALog);</pre></td></tr>
<tr class="nocodegen"><td>6191</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6192</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(T, SizeOf(T));</pre></td></tr>
<tr class="nocodegen"><td>6193</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(A, SizeOf(A));</pre></td></tr>
<tr class="nocodegen"><td>6194</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>6195</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6196</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>6197</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="covered"><td>6198</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6199</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6200</td><td><pre style="display:inline;">{ TCipher_Skipjack }</pre></td></tr>
<tr class="nocodegen"><td>6201</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6202</td><td><pre style="display:inline;">class function TCipher_Skipjack.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>6203</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6204</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 10;</pre></td></tr>
<tr class="covered"><td>6205</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8;</pre></td></tr>
<tr class="covered"><td>6206</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8;</pre></td></tr>
<tr class="covered"><td>6207</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= $A00;</pre></td></tr>
<tr class="covered"><td>6208</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := false;</pre></td></tr>
<tr class="covered"><td>6209</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>6210</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 1;</pre></td></tr>
<tr class="covered"><td>6211</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>6212</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6213</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6214</td><td><pre style="display:inline;">procedure TCipher_Skipjack.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6215</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6216</td><td><pre style="display:inline;"> &nbsp;K: array[0..9] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>6217</td><td><pre style="display:inline;"> &nbsp;D: PByte;</pre></td></tr>
<tr class="nocodegen"><td>6218</td><td><pre style="display:inline;"> &nbsp;I, J: Integer;</pre></td></tr>
<tr class="covered"><td>6219</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6220</td><td><pre style="display:inline;"> &nbsp;FillChar(K, SizeOf(K), 0);</pre></td></tr>
<tr class="covered"><td>6221</td><td><pre style="display:inline;"> &nbsp;Move(Key, K, Size);</pre></td></tr>
<tr class="covered"><td>6222</td><td><pre style="display:inline;"> &nbsp;D := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>6223</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 9 do</pre></td></tr>
<tr class="covered"><td>6224</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 255 do</pre></td></tr>
<tr class="nocodegen"><td>6225</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6226</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D^ := Skipjack_Data[J xor K[I]];</pre></td></tr>
<tr class="covered"><td>6227</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(D);</pre></td></tr>
<tr class="covered"><td>6228</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="covered"><td>6229</td><td><pre style="display:inline;"> &nbsp;ProtectBuffer(K, SizeOf(K));</pre></td></tr>
<tr class="nocodegen"><td>6230</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6231</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>6232</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6233</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6234</td><td><pre style="display:inline;">procedure TCipher_Skipjack.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6235</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6236</td><td><pre style="display:inline;"> &nbsp;Tab, Min: PSkipjackTab;</pre></td></tr>
<tr class="nocodegen"><td>6237</td><td><pre style="display:inline;"> &nbsp;Max: PByte;</pre></td></tr>
<tr class="nocodegen"><td>6238</td><td><pre style="display:inline;"> &nbsp;K, T, A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>6239</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6240</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6241</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6242</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6243</td><td><pre style="display:inline;"> &nbsp;Min := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>6244</td><td><pre style="display:inline;"> &nbsp;Max := PByte(Min) + 9 * 256; // for Pointer Math</pre></td></tr>
<tr class="covered"><td>6245</td><td><pre style="display:inline;"> &nbsp;Tab := Min;</pre></td></tr>
<tr class="covered"><td>6246</td><td><pre style="display:inline;"> &nbsp;A &nbsp; := Swap(PWordArray(Source)[0]);</pre></td></tr>
<tr class="covered"><td>6247</td><td><pre style="display:inline;"> &nbsp;B &nbsp; := Swap(PWordArray(Source)[1]);</pre></td></tr>
<tr class="covered"><td>6248</td><td><pre style="display:inline;"> &nbsp;C &nbsp; := Swap(PWordArray(Source)[2]);</pre></td></tr>
<tr class="covered"><td>6249</td><td><pre style="display:inline;"> &nbsp;D &nbsp; := Swap(PWordArray(Source)[3]);</pre></td></tr>
<tr class="covered"><td>6250</td><td><pre style="display:inline;"> &nbsp;K &nbsp; := 0;</pre></td></tr>
<tr class="nocodegen"><td>6251</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6252</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6253</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(K);</pre></td></tr>
<tr class="covered"><td>6254</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A;</pre></td></tr>
<tr class="covered"><td>6255</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6256</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6257</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6258</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6259</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := T xor D xor K;</pre></td></tr>
<tr class="covered"><td>6260</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := C;</pre></td></tr>
<tr class="covered"><td>6261</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := B;</pre></td></tr>
<tr class="covered"><td>6262</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := T;</pre></td></tr>
<tr class="covered"><td>6263</td><td><pre style="display:inline;"> &nbsp;until K = 8;</pre></td></tr>
<tr class="nocodegen"><td>6264</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6265</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6266</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(K);</pre></td></tr>
<tr class="covered"><td>6267</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A;</pre></td></tr>
<tr class="covered"><td>6268</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := D;</pre></td></tr>
<tr class="covered"><td>6269</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := C;</pre></td></tr>
<tr class="covered"><td>6270</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := T xor B xor K;</pre></td></tr>
<tr class="covered"><td>6271</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6272</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6273</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6274</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6275</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := T;</pre></td></tr>
<tr class="covered"><td>6276</td><td><pre style="display:inline;"> &nbsp;until K = 16;</pre></td></tr>
<tr class="nocodegen"><td>6277</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6278</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6279</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(K);</pre></td></tr>
<tr class="covered"><td>6280</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A;</pre></td></tr>
<tr class="covered"><td>6281</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6282</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6283</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6284</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6285</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := T xor D xor K;</pre></td></tr>
<tr class="covered"><td>6286</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := C;</pre></td></tr>
<tr class="covered"><td>6287</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := B;</pre></td></tr>
<tr class="covered"><td>6288</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := T;</pre></td></tr>
<tr class="covered"><td>6289</td><td><pre style="display:inline;"> &nbsp;until K = 24;</pre></td></tr>
<tr class="nocodegen"><td>6290</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6291</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6292</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(K);</pre></td></tr>
<tr class="covered"><td>6293</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A;</pre></td></tr>
<tr class="covered"><td>6294</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := D;</pre></td></tr>
<tr class="covered"><td>6295</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := C;</pre></td></tr>
<tr class="covered"><td>6296</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := T xor B xor K;</pre></td></tr>
<tr class="covered"><td>6297</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6298</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6299</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6300</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackIncCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6301</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := T;</pre></td></tr>
<tr class="covered"><td>6302</td><td><pre style="display:inline;"> &nbsp;until K = 32;</pre></td></tr>
<tr class="nocodegen"><td>6303</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6304</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[0] := Swap(A);</pre></td></tr>
<tr class="covered"><td>6305</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[1] := Swap(B);</pre></td></tr>
<tr class="covered"><td>6306</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[2] := Swap(C);</pre></td></tr>
<tr class="covered"><td>6307</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[3] := Swap(D);</pre></td></tr>
<tr class="covered"><td>6308</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6309</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6310</td><td><pre style="display:inline;">procedure TCipher_Skipjack.SkipjackIncCheck(var ATab: PSkipjackTab; AMin: PSkipjackTab; AMax: PByte);</pre></td></tr>
<tr class="covered"><td>6311</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6312</td><td><pre style="display:inline;"> &nbsp;Inc(ATab);</pre></td></tr>
<tr class="nocodegen"><td>6313</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6314</td><td><pre style="display:inline;"> &nbsp;if PByte(ATab) &gt; AMax then</pre></td></tr>
<tr class="covered"><td>6315</td><td><pre style="display:inline;"> &nbsp; &nbsp;ATab := AMin;</pre></td></tr>
<tr class="covered"><td>6316</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6317</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6318</td><td><pre style="display:inline;">procedure TCipher_Skipjack.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6319</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6320</td><td><pre style="display:inline;"> &nbsp;Tab, Max: PSkipjackTab;</pre></td></tr>
<tr class="nocodegen"><td>6321</td><td><pre style="display:inline;"> &nbsp;Min: PByte; // for Pointer Math</pre></td></tr>
<tr class="nocodegen"><td>6322</td><td><pre style="display:inline;"> &nbsp;K, T, A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>6323</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6324</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6325</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6326</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6327</td><td><pre style="display:inline;"> &nbsp;Min := FAdditionalBuffer;</pre></td></tr>
<tr class="covered"><td>6328</td><td><pre style="display:inline;"> &nbsp;Max := Pointer(Min + 9 * 256);</pre></td></tr>
<tr class="covered"><td>6329</td><td><pre style="display:inline;"> &nbsp;Tab := Pointer(Min + 7 * 256);</pre></td></tr>
<tr class="covered"><td>6330</td><td><pre style="display:inline;"> &nbsp;A &nbsp; := Swap(PWordArray(Source)[0]); // holds an Integer, Compiler makes faster Code</pre></td></tr>
<tr class="covered"><td>6331</td><td><pre style="display:inline;"> &nbsp;B &nbsp; := Swap(PWordArray(Source)[1]);</pre></td></tr>
<tr class="covered"><td>6332</td><td><pre style="display:inline;"> &nbsp;C &nbsp; := Swap(PWordArray(Source)[2]);</pre></td></tr>
<tr class="covered"><td>6333</td><td><pre style="display:inline;"> &nbsp;D &nbsp; := Swap(PWordArray(Source)[3]);</pre></td></tr>
<tr class="covered"><td>6334</td><td><pre style="display:inline;"> &nbsp;K &nbsp; := 32;</pre></td></tr>
<tr class="nocodegen"><td>6335</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6336</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6337</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B;</pre></td></tr>
<tr class="covered"><td>6338</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6339</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6340</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6341</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6342</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := T xor C xor K;</pre></td></tr>
<tr class="covered"><td>6343</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := D;</pre></td></tr>
<tr class="covered"><td>6344</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := A;</pre></td></tr>
<tr class="covered"><td>6345</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := T;</pre></td></tr>
<tr class="covered"><td>6346</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(K);</pre></td></tr>
<tr class="covered"><td>6347</td><td><pre style="display:inline;"> &nbsp;until K = 24;</pre></td></tr>
<tr class="nocodegen"><td>6348</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6349</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6350</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B;</pre></td></tr>
<tr class="covered"><td>6351</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := C;</pre></td></tr>
<tr class="covered"><td>6352</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := D;</pre></td></tr>
<tr class="covered"><td>6353</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := T xor A xor K;</pre></td></tr>
<tr class="covered"><td>6354</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6355</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6356</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6357</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6358</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := T;</pre></td></tr>
<tr class="covered"><td>6359</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(K);</pre></td></tr>
<tr class="covered"><td>6360</td><td><pre style="display:inline;"> &nbsp;until K = 16;</pre></td></tr>
<tr class="nocodegen"><td>6361</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6362</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6363</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B;</pre></td></tr>
<tr class="covered"><td>6364</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6365</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6366</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6367</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6368</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := C xor T xor K;</pre></td></tr>
<tr class="covered"><td>6369</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := D;</pre></td></tr>
<tr class="covered"><td>6370</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := A;</pre></td></tr>
<tr class="covered"><td>6371</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := T;</pre></td></tr>
<tr class="covered"><td>6372</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(K);</pre></td></tr>
<tr class="covered"><td>6373</td><td><pre style="display:inline;"> &nbsp;until K = 8;</pre></td></tr>
<tr class="nocodegen"><td>6374</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6375</td><td><pre style="display:inline;"> &nbsp;repeat</pre></td></tr>
<tr class="covered"><td>6376</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B;</pre></td></tr>
<tr class="covered"><td>6377</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := C;</pre></td></tr>
<tr class="covered"><td>6378</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := D;</pre></td></tr>
<tr class="covered"><td>6379</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := T xor A xor K;</pre></td></tr>
<tr class="covered"><td>6380</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6381</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6382</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T shr 8]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6383</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := T xor Tab[T and $FF] shl 8; &nbsp; SkipjackDecCheck(Tab, Min, Max);</pre></td></tr>
<tr class="covered"><td>6384</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := T;</pre></td></tr>
<tr class="covered"><td>6385</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(K);</pre></td></tr>
<tr class="covered"><td>6386</td><td><pre style="display:inline;"> &nbsp;until K = 0;</pre></td></tr>
<tr class="nocodegen"><td>6387</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6388</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[0] := Swap(A);</pre></td></tr>
<tr class="covered"><td>6389</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[1] := Swap(B);</pre></td></tr>
<tr class="covered"><td>6390</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[2] := Swap(C);</pre></td></tr>
<tr class="covered"><td>6391</td><td><pre style="display:inline;"> &nbsp;PWordArray(Dest)[3] := Swap(D);</pre></td></tr>
<tr class="covered"><td>6392</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6393</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6394</td><td><pre style="display:inline;">procedure TCipher_Skipjack.SkipjackDecCheck(var ATab: PSkipjackTab; AMin: PByte; AMax: PSkipjackTab);</pre></td></tr>
<tr class="covered"><td>6395</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6396</td><td><pre style="display:inline;"> &nbsp;Dec(ATab);</pre></td></tr>
<tr class="nocodegen"><td>6397</td><td><pre style="display:inline;">// &nbsp; &nbsp;{$IFDEF DELPHIORBCB}</pre></td></tr>
<tr class="nocodegen"><td>6398</td><td><pre style="display:inline;">// &nbsp; &nbsp;if ATab &lt; AMin then</pre></td></tr>
<tr class="nocodegen"><td>6399</td><td><pre style="display:inline;">// &nbsp; &nbsp;{$ELSE !DELPHIORBCB}</pre></td></tr>
<tr class="nocodegen"><td>6400</td><td><pre style="display:inline;">{ TODO : Pr&uuml;fen ob so korrekt, da ATab auf PByte umgestellt wurde}</pre></td></tr>
<tr class="covered"><td>6401</td><td><pre style="display:inline;"> &nbsp;if PByte(ATab) &lt; AMin then</pre></td></tr>
<tr class="nocodegen"><td>6402</td><td><pre style="display:inline;">// &nbsp; &nbsp;{$ENDIF !DELPHIORBCB}</pre></td></tr>
<tr class="covered"><td>6403</td><td><pre style="display:inline;"> &nbsp; &nbsp;ATab := AMax;</pre></td></tr>
<tr class="covered"><td>6404</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6405</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6406</td><td><pre style="display:inline;">{ TCipher_TEA }</pre></td></tr>
<tr class="nocodegen"><td>6407</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6408</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>6409</td><td><pre style="display:inline;"> &nbsp;TEA_Delta = $9E3779B9; // magic constant, decimal 2654435769</pre></td></tr>
<tr class="nocodegen"><td>6410</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6411</td><td><pre style="display:inline;">class function TCipher_TEA.Context: TCipherContext;</pre></td></tr>
<tr class="covered"><td>6412</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6413</td><td><pre style="display:inline;"> &nbsp;Result.KeySize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16; &nbsp; // 128 bits</pre></td></tr>
<tr class="covered"><td>6414</td><td><pre style="display:inline;"> &nbsp;Result.BlockSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 8; &nbsp; &nbsp;// 64 bits</pre></td></tr>
<tr class="covered"><td>6415</td><td><pre style="display:inline;"> &nbsp;Result.BufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= 8; &nbsp; &nbsp;// 64 bits</pre></td></tr>
<tr class="covered"><td>6416</td><td><pre style="display:inline;"> &nbsp;Result.AdditionalBufferSize &nbsp; &nbsp; &nbsp; &nbsp;:= 32; &nbsp; // 256 bits</pre></td></tr>
<tr class="covered"><td>6417</td><td><pre style="display:inline;"> &nbsp;Result.NeedsAdditionalBufferBackup := false;</pre></td></tr>
<tr class="covered"><td>6418</td><td><pre style="display:inline;"> &nbsp;Result.MinRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 16;</pre></td></tr>
<tr class="covered"><td>6419</td><td><pre style="display:inline;"> &nbsp;Result.MaxRounds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; := 256;</pre></td></tr>
<tr class="covered"><td>6420</td><td><pre style="display:inline;"> &nbsp;Result.CipherType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:= [ctSymmetric, ctBlock];</pre></td></tr>
<tr class="covered"><td>6421</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6422</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6423</td><td><pre style="display:inline;">procedure TCipher_TEA.SetRounds(Value: Integer);</pre></td></tr>
<tr class="covered"><td>6424</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6425</td><td><pre style="display:inline;"> &nbsp;if not (FState in [csNew, csInitialized, csDone]) then</pre></td></tr>
<tr class="notcovered"><td>6426</td><td><pre style="display:inline;"> &nbsp; &nbsp;Done;</pre></td></tr>
<tr class="covered"><td>6427</td><td><pre style="display:inline;"> &nbsp;if Value &lt; Context.MinRounds then</pre></td></tr>
<tr class="covered"><td>6428</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := Context.MinRounds</pre></td></tr>
<tr class="nocodegen"><td>6429</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>6430</td><td><pre style="display:inline;"> &nbsp;if Value &gt; Context.MaxRounds then</pre></td></tr>
<tr class="covered"><td>6431</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := Context.MaxRounds;</pre></td></tr>
<tr class="covered"><td>6432</td><td><pre style="display:inline;"> &nbsp;FRounds := Value;</pre></td></tr>
<tr class="covered"><td>6433</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6434</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6435</td><td><pre style="display:inline;">procedure TCipher_TEA.DoInit(const Key; Size: Integer);</pre></td></tr>
<tr class="covered"><td>6436</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6437</td><td><pre style="display:inline;"> &nbsp;Move(Key, FAdditionalBuffer^, Size);</pre></td></tr>
<tr class="covered"><td>6438</td><td><pre style="display:inline;"> &nbsp;SetRounds(FRounds);</pre></td></tr>
<tr class="nocodegen"><td>6439</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6440</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="covered"><td>6441</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6442</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6443</td><td><pre style="display:inline;">procedure TCipher_TEA.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6444</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6445</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>6446</td><td><pre style="display:inline;"> &nbsp;Sum,</pre></td></tr>
<tr class="nocodegen"><td>6447</td><td><pre style="display:inline;"> &nbsp;X, Y, A, B, C, D: UInt32;</pre></td></tr>
<tr class="covered"><td>6448</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6449</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6450</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6451</td><td><pre style="display:inline;"> &nbsp;Sum := 0;</pre></td></tr>
<tr class="nocodegen"><td>6452</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6453</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(FAdditionalBuffer)[0];</pre></td></tr>
<tr class="covered"><td>6454</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(FAdditionalBuffer)[1];</pre></td></tr>
<tr class="covered"><td>6455</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(FAdditionalBuffer)[2];</pre></td></tr>
<tr class="covered"><td>6456</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(FAdditionalBuffer)[3];</pre></td></tr>
<tr class="covered"><td>6457</td><td><pre style="display:inline;"> &nbsp;X := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>6458</td><td><pre style="display:inline;"> &nbsp;Y := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="nocodegen"><td>6459</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6460</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6461</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6462</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Sum, TEA_Delta);</pre></td></tr>
<tr class="covered"><td>6463</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(X, (((Y shl 4 + A) xor Y) + Sum) xor (Y shr 5 + B));</pre></td></tr>
<tr class="covered"><td>6464</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Y, (((X shl 4 + C) xor X) + Sum) xor (X shr 5 + D));</pre></td></tr>
<tr class="covered"><td>6465</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6466</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6467</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := X;</pre></td></tr>
<tr class="covered"><td>6468</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Y;</pre></td></tr>
<tr class="covered"><td>6469</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6470</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6471</td><td><pre style="display:inline;">procedure TCipher_TEA.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6472</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6473</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>6474</td><td><pre style="display:inline;"> &nbsp;Sum,</pre></td></tr>
<tr class="nocodegen"><td>6475</td><td><pre style="display:inline;"> &nbsp;X, Y, A, B, C, D: UInt32;</pre></td></tr>
<tr class="covered"><td>6476</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6477</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6478</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6479</td><td><pre style="display:inline;"> &nbsp;Sum := TEA_Delta * UInt32(FRounds);</pre></td></tr>
<tr class="nocodegen"><td>6480</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6481</td><td><pre style="display:inline;"> &nbsp;A := PUInt32Array(FAdditionalBuffer)[0];</pre></td></tr>
<tr class="covered"><td>6482</td><td><pre style="display:inline;"> &nbsp;B := PUInt32Array(FAdditionalBuffer)[1];</pre></td></tr>
<tr class="covered"><td>6483</td><td><pre style="display:inline;"> &nbsp;C := PUInt32Array(FAdditionalBuffer)[2];</pre></td></tr>
<tr class="covered"><td>6484</td><td><pre style="display:inline;"> &nbsp;D := PUInt32Array(FAdditionalBuffer)[3];</pre></td></tr>
<tr class="covered"><td>6485</td><td><pre style="display:inline;"> &nbsp;X := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>6486</td><td><pre style="display:inline;"> &nbsp;Y := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="nocodegen"><td>6487</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6488</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6489</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6490</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(Y, (X shl 4 + C) xor X + Sum xor (X shr 5 + D));</pre></td></tr>
<tr class="covered"><td>6491</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(X, (Y shl 4 + A) xor Y + Sum xor (Y shr 5 + B));</pre></td></tr>
<tr class="covered"><td>6492</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(Sum, TEA_Delta);</pre></td></tr>
<tr class="covered"><td>6493</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6494</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6495</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := X;</pre></td></tr>
<tr class="covered"><td>6496</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Y;</pre></td></tr>
<tr class="covered"><td>6497</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6498</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6499</td><td><pre style="display:inline;">{ TCipher_XTEA }</pre></td></tr>
<tr class="nocodegen"><td>6500</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6501</td><td><pre style="display:inline;">procedure TCipher_XTEA.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6502</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6503</td><td><pre style="display:inline;"> &nbsp;Sum,</pre></td></tr>
<tr class="nocodegen"><td>6504</td><td><pre style="display:inline;"> &nbsp;I, X, Y: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>6505</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>6506</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6507</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6508</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6509</td><td><pre style="display:inline;"> &nbsp;Sum := 0;</pre></td></tr>
<tr class="nocodegen"><td>6510</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6511</td><td><pre style="display:inline;"> &nbsp;X := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>6512</td><td><pre style="display:inline;"> &nbsp;Y := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>6513</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="nocodegen"><td>6514</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6515</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6516</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6517</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(X, (((Y shl 4) xor (Y shr 5)) + Y) xor (Sum + K[Sum and 3]));</pre></td></tr>
<tr class="covered"><td>6518</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Sum, TEA_Delta);</pre></td></tr>
<tr class="covered"><td>6519</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Y, (((X shl 4) xor (X shr 5)) + X) xor (Sum + K[Sum shr 11 and 3]));</pre></td></tr>
<tr class="covered"><td>6520</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6521</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6522</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := X;</pre></td></tr>
<tr class="covered"><td>6523</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Y;</pre></td></tr>
<tr class="covered"><td>6524</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6525</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6526</td><td><pre style="display:inline;">procedure TCipher_XTEA.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6527</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6528</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>6529</td><td><pre style="display:inline;"> &nbsp;Sum,</pre></td></tr>
<tr class="nocodegen"><td>6530</td><td><pre style="display:inline;"> &nbsp;X, Y: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>6531</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>6532</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6533</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6534</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6535</td><td><pre style="display:inline;"> &nbsp;Sum := TEA_Delta * UInt32(FRounds);</pre></td></tr>
<tr class="nocodegen"><td>6536</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6537</td><td><pre style="display:inline;"> &nbsp;X := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>6538</td><td><pre style="display:inline;"> &nbsp;Y := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>6539</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="nocodegen"><td>6540</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6541</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6542</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6543</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(Y, (((X shl 4) xor (X shr 5)) + X) xor (Sum + K[Sum shr 11 and 3]));</pre></td></tr>
<tr class="covered"><td>6544</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(Sum, TEA_Delta);</pre></td></tr>
<tr class="covered"><td>6545</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(X, (((Y shl 4) xor (Y shr 5)) + Y) xor (Sum + K[Sum and 3]));</pre></td></tr>
<tr class="covered"><td>6546</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6547</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6548</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := X;</pre></td></tr>
<tr class="covered"><td>6549</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Y;</pre></td></tr>
<tr class="covered"><td>6550</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6551</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6552</td><td><pre style="display:inline;">{ TCipher_XTEA_DEC52 }</pre></td></tr>
<tr class="nocodegen"><td>6553</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6554</td><td><pre style="display:inline;">procedure TCipher_XTEA_DEC52.DoEncode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6555</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6556</td><td><pre style="display:inline;"> &nbsp;Sum,</pre></td></tr>
<tr class="nocodegen"><td>6557</td><td><pre style="display:inline;"> &nbsp;I, X, Y: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>6558</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>6559</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6560</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6561</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6562</td><td><pre style="display:inline;"> &nbsp;Sum := 0;</pre></td></tr>
<tr class="nocodegen"><td>6563</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6564</td><td><pre style="display:inline;"> &nbsp;X := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>6565</td><td><pre style="display:inline;"> &nbsp;Y := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>6566</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="nocodegen"><td>6567</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6568</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6569</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6570</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(X, (Y shl 4 xor Y shr 5) + (Y xor Sum) + K[Sum and 3]);</pre></td></tr>
<tr class="covered"><td>6571</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Sum, TEA_Delta);</pre></td></tr>
<tr class="covered"><td>6572</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Y, (X shl 4 xor X shr 5) + (X xor Sum) + K[Sum shr 11 and 3]);</pre></td></tr>
<tr class="covered"><td>6573</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6574</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6575</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := X;</pre></td></tr>
<tr class="covered"><td>6576</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Y;</pre></td></tr>
<tr class="covered"><td>6577</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6578</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6579</td><td><pre style="display:inline;">procedure TCipher_XTEA_DEC52.DoDecode(Source, Dest: Pointer; Size: Integer);</pre></td></tr>
<tr class="nocodegen"><td>6580</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>6581</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>6582</td><td><pre style="display:inline;"> &nbsp;Sum,</pre></td></tr>
<tr class="nocodegen"><td>6583</td><td><pre style="display:inline;"> &nbsp;X, Y: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>6584</td><td><pre style="display:inline;"> &nbsp;K: PUInt32Array;</pre></td></tr>
<tr class="covered"><td>6585</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>6586</td><td><pre style="display:inline;"> &nbsp;Assert(Size = Context.BlockSize);</pre></td></tr>
<tr class="nocodegen"><td>6587</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6588</td><td><pre style="display:inline;"> &nbsp;Sum := TEA_Delta * UInt32(FRounds);</pre></td></tr>
<tr class="nocodegen"><td>6589</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6590</td><td><pre style="display:inline;"> &nbsp;X := PUInt32Array(Source)[0];</pre></td></tr>
<tr class="covered"><td>6591</td><td><pre style="display:inline;"> &nbsp;Y := PUInt32Array(Source)[1];</pre></td></tr>
<tr class="covered"><td>6592</td><td><pre style="display:inline;"> &nbsp;K := FAdditionalBuffer;</pre></td></tr>
<tr class="nocodegen"><td>6593</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6594</td><td><pre style="display:inline;"> &nbsp;for I := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>6595</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>6596</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(Y, (X shl 4 xor X shr 5) + (X xor Sum) + K[Sum shr 11 and 3]);</pre></td></tr>
<tr class="covered"><td>6597</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(Sum, TEA_Delta);</pre></td></tr>
<tr class="covered"><td>6598</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(X, (Y shl 4 xor Y shr 5) + (Y xor Sum) + K[Sum and 3]);</pre></td></tr>
<tr class="covered"><td>6599</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>6600</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6601</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[0] := X;</pre></td></tr>
<tr class="covered"><td>6602</td><td><pre style="display:inline;"> &nbsp;PUInt32Array(Dest)[1] := Y;</pre></td></tr>
<tr class="covered"><td>6603</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>6604</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6605</td><td><pre style="display:inline;">{$IFDEF RESTORE_RANGECHECKS}{$R+}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>6606</td><td><pre style="display:inline;">{$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>6607</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6608</td><td><pre style="display:inline;">initialization</pre></td></tr>
<tr class="covered"><td>6609</td><td><pre style="display:inline;"> &nbsp;SetDefaultCipherClass(TCipher_Null);</pre></td></tr>
<tr class="nocodegen"><td>6610</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6611</td><td><pre style="display:inline;"> &nbsp;{$IFNDEF ManualRegisterCipherClasses}</pre></td></tr>
<tr class="covered"><td>6612</td><td><pre style="display:inline;"> &nbsp;TCipher_Null.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6613</td><td><pre style="display:inline;"> &nbsp;TCipher_Blowfish.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6614</td><td><pre style="display:inline;"> &nbsp;TCipher_Twofish.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6615</td><td><pre style="display:inline;"> &nbsp;TCipher_IDEA.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6616</td><td><pre style="display:inline;"> &nbsp;TCipher_Cast256.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6617</td><td><pre style="display:inline;"> &nbsp;TCipher_Mars.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6618</td><td><pre style="display:inline;"> &nbsp;TCipher_RC4.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6619</td><td><pre style="display:inline;"> &nbsp;TCipher_RC6.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>6620</td><td><pre style="display:inline;">// Explicitely not registered, as Rijndael is 1:1 the same as AES and AES is the</pre></td></tr>
<tr class="nocodegen"><td>6621</td><td><pre style="display:inline;">// more common name</pre></td></tr>
<tr class="nocodegen"><td>6622</td><td><pre style="display:inline;">// &nbsp;TCipher_Rijndael.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6623</td><td><pre style="display:inline;"> &nbsp;TCipher_AES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6624</td><td><pre style="display:inline;"> &nbsp;TCipher_Square.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6625</td><td><pre style="display:inline;"> &nbsp;TCipher_SCOP.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6626</td><td><pre style="display:inline;"> &nbsp;TCipher_Sapphire.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6627</td><td><pre style="display:inline;"> &nbsp;TCipher_1DES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6628</td><td><pre style="display:inline;"> &nbsp;TCipher_2DES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6629</td><td><pre style="display:inline;"> &nbsp;TCipher_3DES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6630</td><td><pre style="display:inline;"> &nbsp;TCipher_2DDES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6631</td><td><pre style="display:inline;"> &nbsp;TCipher_3DDES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6632</td><td><pre style="display:inline;"> &nbsp;TCipher_3TDES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6633</td><td><pre style="display:inline;"> &nbsp;TCipher_3Way.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6634</td><td><pre style="display:inline;"> &nbsp;TCipher_Cast128.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6635</td><td><pre style="display:inline;"> &nbsp;TCipher_Gost.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>6636</td><td><pre style="display:inline;">// Explicitely not registered, as this is an alias for Gost only</pre></td></tr>
<tr class="nocodegen"><td>6637</td><td><pre style="display:inline;">// &nbsp;TCipher_Magma.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6638</td><td><pre style="display:inline;"> &nbsp;TCipher_Misty.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6639</td><td><pre style="display:inline;"> &nbsp;TCipher_NewDES.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6640</td><td><pre style="display:inline;"> &nbsp;TCipher_Q128.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6641</td><td><pre style="display:inline;"> &nbsp;TCipher_RC2.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6642</td><td><pre style="display:inline;"> &nbsp;TCipher_RC5.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6643</td><td><pre style="display:inline;"> &nbsp;TCipher_SAFER.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6644</td><td><pre style="display:inline;"> &nbsp;TCipher_Shark.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6645</td><td><pre style="display:inline;"> &nbsp;TCipher_Skipjack.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6646</td><td><pre style="display:inline;"> &nbsp;TCipher_TEA.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6647</td><td><pre style="display:inline;"> &nbsp;TCipher_XTEA.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="covered"><td>6648</td><td><pre style="display:inline;"> &nbsp;TCipher_TEAN.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>6649</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>6650</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$IFDEF OLD_REGISTER_FAULTY_CIPHERS}</pre></td></tr>
<tr class="nocodegen"><td>6651</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Those classes are only there for those who might have relied on the</pre></td></tr>
<tr class="nocodegen"><td>6652</td><td><pre style="display:inline;"> &nbsp; &nbsp;// faulty implementation</pre></td></tr>
<tr class="nocodegen"><td>6653</td><td><pre style="display:inline;"> &nbsp; &nbsp;TCipher_SCOP_DEC52.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>6654</td><td><pre style="display:inline;"> &nbsp; &nbsp;TCipher_Shark_DEC52.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>6655</td><td><pre style="display:inline;"> &nbsp; &nbsp;TCipher_XTEA_DEC52.RegisterClass(TDECCipher.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>6656</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>6657</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>6658</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6659</td><td><pre style="display:inline;">finalization</pre></td></tr>
<tr class="nocodegen"><td>6660</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>6661</td><td><pre style="display:inline;">end.</pre></td></tr>
</table>
</body>
</html>
