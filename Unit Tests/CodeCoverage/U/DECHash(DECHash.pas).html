<!DOCTYPE html>
<html>
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
table {border-spacing:0; border-collapse:collapse;}
table, td, th {border: 1px solid black;}
td, th {background: white; margin: 0; padding: 2px 0.5em 2px 0.5em}
td {border-width: 0 1px 0 0;}
th {border-width: 1px 1px 1px 0;}
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: courier,monospace; font-size: 10pt;}
th {background: #CCCCCC;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: 100%;}
table.s tr td {padding: 0 0.25em 0 0.25em;}
table.s tr td:first-child {text-align: right; font-weight: bold;}
table.s tr.notcovered td {background: #DDDDFF;}
table.s tr.nocodegen td {background: #FFFFEE;}
table.s tr.covered td {background: #CCFFCC;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum tr td {border-width: 1px;}
table.sum tr th {text-align:right;}
table.sum tr th:first-child {text-align:center;}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
</style>
</head>
<body>
<p>Coverage report for <strong>DECHash (D:\Projekte\DECGitMaster\Source\DECHash.pas)</strong>.</p>
<p> Generated at 29.10.2021 18:49:30 by <a href="http://code.google.com/p/delphi-code-coverage/" title="Code Coverage for Delphi 5+">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p> Statistics for D:\Projekte\DECGitMaster\Source\DECHash.pas </p>
<table  class="o"><tr><td>Number of lines covered</td><td>750</td></tr><tr><td>Number of lines with code gen</td><td>768</td></tr><tr><td>Line coverage</td><td>97%</td></tr></table>
<br /><br />
<table  class="s">
<tr class="nocodegen"><td>1</td><td><pre style="display:inline;">{*****************************************************************************</pre></td></tr>
<tr class="nocodegen"><td>2</td><td><pre style="display:inline;"> &nbsp;The DEC team (see file NOTICE.txt) licenses this file</pre></td></tr>
<tr class="nocodegen"><td>3</td><td><pre style="display:inline;"> &nbsp;to you under the Apache License, Version 2.0 (the</pre></td></tr>
<tr class="nocodegen"><td>4</td><td><pre style="display:inline;"> &nbsp;&quot;License&quot;); you may not use this file except in compliance</pre></td></tr>
<tr class="nocodegen"><td>5</td><td><pre style="display:inline;"> &nbsp;with the License. A copy of this licence is found in the root directory</pre></td></tr>
<tr class="nocodegen"><td>6</td><td><pre style="display:inline;"> &nbsp;of this project in the file LICENCE.txt or alternatively at</pre></td></tr>
<tr class="nocodegen"><td>7</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>8</td><td><pre style="display:inline;"> &nbsp; &nbsp;http://www.apache.org/licenses/LICENSE-2.0</pre></td></tr>
<tr class="nocodegen"><td>9</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>10</td><td><pre style="display:inline;"> &nbsp;Unless required by applicable law or agreed to in writing,</pre></td></tr>
<tr class="nocodegen"><td>11</td><td><pre style="display:inline;"> &nbsp;software distributed under the License is distributed on an</pre></td></tr>
<tr class="nocodegen"><td>12</td><td><pre style="display:inline;"> &nbsp;&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</pre></td></tr>
<tr class="nocodegen"><td>13</td><td><pre style="display:inline;"> &nbsp;KIND, either express or implied. &nbsp;See the License for the</pre></td></tr>
<tr class="nocodegen"><td>14</td><td><pre style="display:inline;"> &nbsp;specific language governing permissions and limitations</pre></td></tr>
<tr class="nocodegen"><td>15</td><td><pre style="display:inline;"> &nbsp;under the License.</pre></td></tr>
<tr class="nocodegen"><td>16</td><td><pre style="display:inline;">*****************************************************************************}</pre></td></tr>
<tr class="nocodegen"><td>17</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>18</td><td><pre style="display:inline;">/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>19</td><td><pre style="display:inline;">/// &nbsp; Hash functions. Be aware that the x86 ASM implementations, if activated</pre></td></tr>
<tr class="nocodegen"><td>20</td><td><pre style="display:inline;">/// &nbsp; by the define, are provided by DECHash.asm86.inc!</pre></td></tr>
<tr class="nocodegen"><td>21</td><td><pre style="display:inline;">/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>22</td><td><pre style="display:inline;">unit DECHash;</pre></td></tr>
<tr class="nocodegen"><td>23</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>24</td><td><pre style="display:inline;">interface</pre></td></tr>
<tr class="nocodegen"><td>25</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>26</td><td><pre style="display:inline;">{$INCLUDE DECOptions.inc}</pre></td></tr>
<tr class="nocodegen"><td>27</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>28</td><td><pre style="display:inline;">uses</pre></td></tr>
<tr class="nocodegen"><td>29</td><td><pre style="display:inline;"> &nbsp;{$IFDEF FPC}</pre></td></tr>
<tr class="nocodegen"><td>30</td><td><pre style="display:inline;"> &nbsp;SysUtils, Classes,</pre></td></tr>
<tr class="nocodegen"><td>31</td><td><pre style="display:inline;"> &nbsp;{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>32</td><td><pre style="display:inline;"> &nbsp;System.SysUtils, System.Classes,</pre></td></tr>
<tr class="nocodegen"><td>33</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>34</td><td><pre style="display:inline;"> &nbsp;DECBaseClass, DECFormatBase, DECUtil, DECHashBase, DECHashAuthentication,</pre></td></tr>
<tr class="nocodegen"><td>35</td><td><pre style="display:inline;"> &nbsp;DECHashBitBase, DECHashInterface, DECTypes;</pre></td></tr>
<tr class="nocodegen"><td>36</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>37</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>38</td><td><pre style="display:inline;"> &nbsp;// Hash Classes</pre></td></tr>
<tr class="nocodegen"><td>39</td><td><pre style="display:inline;"> &nbsp;THash_MD2 &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>40</td><td><pre style="display:inline;"> &nbsp;THash_MD4 &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>41</td><td><pre style="display:inline;"> &nbsp;THash_MD5 &nbsp; &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>42</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD128 &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>43</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD160 &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>44</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD256 &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>45</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD320 &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>46</td><td><pre style="display:inline;"> &nbsp;THash_SHA0 &nbsp; &nbsp; &nbsp; &nbsp;= class; &nbsp;// SHA-0</pre></td></tr>
<tr class="nocodegen"><td>47</td><td><pre style="display:inline;"> &nbsp;THash_SHA1 &nbsp; &nbsp; &nbsp; &nbsp;= class; &nbsp;// SHA-1</pre></td></tr>
<tr class="nocodegen"><td>48</td><td><pre style="display:inline;"> &nbsp;THash_SHA224 &nbsp; &nbsp; &nbsp;= class; &nbsp;// SHA-2, SHA-224</pre></td></tr>
<tr class="nocodegen"><td>49</td><td><pre style="display:inline;"> &nbsp;THash_SHA256 &nbsp; &nbsp; &nbsp;= class; &nbsp;// SHA-2, SHA-256</pre></td></tr>
<tr class="nocodegen"><td>50</td><td><pre style="display:inline;"> &nbsp;THash_SHA384 &nbsp; &nbsp; &nbsp;= class; &nbsp;// SHA-2, SHA-384</pre></td></tr>
<tr class="nocodegen"><td>51</td><td><pre style="display:inline;"> &nbsp;THash_SHA512 &nbsp; &nbsp; &nbsp;= class; &nbsp;// SHA-2, SHA-512</pre></td></tr>
<tr class="nocodegen"><td>52</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_224 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>53</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_256 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>54</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_384 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>55</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_512 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>56</td><td><pre style="display:inline;"> &nbsp;THash_Shake128 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>57</td><td><pre style="display:inline;"> &nbsp;THash_Shake256 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>58</td><td><pre style="display:inline;"> &nbsp;THash_Haval128 &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>59</td><td><pre style="display:inline;"> &nbsp;THash_Haval160 &nbsp; &nbsp;= class; &nbsp;// Haval 160, 3 Rounds</pre></td></tr>
<tr class="nocodegen"><td>60</td><td><pre style="display:inline;"> &nbsp;THash_Haval192 &nbsp; &nbsp;= class; &nbsp;// Haval 192, 4 Rounds</pre></td></tr>
<tr class="nocodegen"><td>61</td><td><pre style="display:inline;"> &nbsp;THash_Haval224 &nbsp; &nbsp;= class; &nbsp;// Haval 224, 4 Rounds</pre></td></tr>
<tr class="nocodegen"><td>62</td><td><pre style="display:inline;"> &nbsp;THash_Haval256 &nbsp; &nbsp;= class; &nbsp;// Haval 256, 5 Rounds</pre></td></tr>
<tr class="nocodegen"><td>63</td><td><pre style="display:inline;"> &nbsp;THash_Tiger &nbsp; &nbsp; &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>64</td><td><pre style="display:inline;"> &nbsp;THash_Panama &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>65</td><td><pre style="display:inline;"> &nbsp;{$IFDEF OLD_WHIRLPOOL_NAMES}</pre></td></tr>
<tr class="nocodegen"><td>66</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool &nbsp; = class;</pre></td></tr>
<tr class="nocodegen"><td>67</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool1New = class;</pre></td></tr>
<tr class="nocodegen"><td>68</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>69</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>70</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool0 &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>71</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool1 &nbsp;= class; // differs, depending on OLD_WHIRLPOOL_NAMES define</pre></td></tr>
<tr class="nocodegen"><td>72</td><td><pre style="display:inline;"> &nbsp;THash_WhirlpoolT &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>73</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>74</td><td><pre style="display:inline;"> &nbsp;THash_Square &nbsp; &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>75</td><td><pre style="display:inline;"> &nbsp;THash_Snefru128 &nbsp; = class; &nbsp;// derived from the Xerox Secure Hash Function</pre></td></tr>
<tr class="nocodegen"><td>76</td><td><pre style="display:inline;"> &nbsp;THash_Snefru256 &nbsp; = class; &nbsp;// &quot; - &quot;</pre></td></tr>
<tr class="nocodegen"><td>77</td><td><pre style="display:inline;"> &nbsp;THash_Sapphire &nbsp; &nbsp;= class;</pre></td></tr>
<tr class="nocodegen"><td>78</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>79</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>80</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Implementation of the MD2 hash algorithm. Considered to be broken,</pre></td></tr>
<tr class="nocodegen"><td>81</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; at least on paper.</pre></td></tr>
<tr class="nocodegen"><td>82</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>83</td><td><pre style="display:inline;"> &nbsp;THash_MD2 = class(TDECHashAuthentication)</pre></td></tr>
<tr class="nocodegen"><td>84</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>85</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..63] of Byte;</pre></td></tr>
<tr class="nocodegen"><td>86</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>87</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>88</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>89</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>90</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>91</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>92</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>93</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>94</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>95</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>96</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>97</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Base class for the MD4 hash alrogithm and for other hash-algorithms which</pre></td></tr>
<tr class="nocodegen"><td>98</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; are close relatives to the MD4 algorithm like the RipeMD ones.</pre></td></tr>
<tr class="nocodegen"><td>99</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>100</td><td><pre style="display:inline;"> &nbsp;THashBaseMD4 = class(TDECHashAuthentication)</pre></td></tr>
<tr class="nocodegen"><td>101</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>102</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..9] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>103</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>104</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>105</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>106</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>107</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>108</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>109</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>110</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>111</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>112</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>113</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The MD4 algorithm is considered to be broken, at least on paper.</pre></td></tr>
<tr class="nocodegen"><td>114</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>115</td><td><pre style="display:inline;"> &nbsp;THash_MD4 = class(THashBaseMD4)</pre></td></tr>
<tr class="nocodegen"><td>116</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>117</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>118</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>119</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>120</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>121</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The MD5 algorithm is considered to be broken. Using it in HMAC algorithms</pre></td></tr>
<tr class="nocodegen"><td>122</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; is still ok.</pre></td></tr>
<tr class="nocodegen"><td>123</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>124</td><td><pre style="display:inline;"> &nbsp;THash_MD5 = class(THashBaseMD4)</pre></td></tr>
<tr class="nocodegen"><td>125</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>126</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>127</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>128</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>129</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>130</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Do not confuse with the original RipeMD algorithm which &iacute;s being</pre></td></tr>
<tr class="nocodegen"><td>131</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; considered to be unsafe anyway. Considered to be broken due to the only</pre></td></tr>
<tr class="nocodegen"><td>132</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; 128 Bit long message digest result.</pre></td></tr>
<tr class="nocodegen"><td>133</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>134</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD128 = class(THashBaseMD4)</pre></td></tr>
<tr class="nocodegen"><td>135</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>136</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>137</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>138</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>139</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD160 = class(THashBaseMD4)</pre></td></tr>
<tr class="nocodegen"><td>140</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>141</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>142</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>143</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>144</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>145</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>146</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD256 = class(THashBaseMD4)</pre></td></tr>
<tr class="nocodegen"><td>147</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>148</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>149</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>150</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>151</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>152</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>153</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>154</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD320 = class(THashBaseMD4)</pre></td></tr>
<tr class="nocodegen"><td>155</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>156</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>157</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>158</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>159</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>160</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>161</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>162</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Implementation of the SHA0 hash algorithm. This is the original version</pre></td></tr>
<tr class="nocodegen"><td>163</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; of the SHA algorithm released in 1993. In 1995 some security issues have</pre></td></tr>
<tr class="nocodegen"><td>164</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; been identified in this algorithm so he got replaced by the slightly</pre></td></tr>
<tr class="nocodegen"><td>165</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; modified SHA1 algorithm. The recommendation is to not use this SHA0</pre></td></tr>
<tr class="nocodegen"><td>166</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; algorithm at all. It is only being provided for scenarios where</pre></td></tr>
<tr class="nocodegen"><td>167</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; compatibility with this algorithm is required.</pre></td></tr>
<tr class="nocodegen"><td>168</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>169</td><td><pre style="display:inline;"> &nbsp;THash_SHA0 = class(THashBaseMD4)</pre></td></tr>
<tr class="nocodegen"><td>170</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>171</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>172</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>173</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>174</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>175</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>176</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>177</td><td><pre style="display:inline;"> &nbsp;{$IFDEF OLD_SHA_NAME}</pre></td></tr>
<tr class="nocodegen"><td>178</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>179</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Implementation of the SHA0 hash algorithm. This is the original version</pre></td></tr>
<tr class="nocodegen"><td>180</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; of the SHA algorithm released in 1993. In 1995 some security issues have</pre></td></tr>
<tr class="nocodegen"><td>181</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; been identified in this algorithm so he got replaced by the slightly</pre></td></tr>
<tr class="nocodegen"><td>182</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; modified SHA1 algorithm. The recommendation is to not use this SHA0</pre></td></tr>
<tr class="nocodegen"><td>183</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; algorithm at all. It is only being provided for scenarios where</pre></td></tr>
<tr class="nocodegen"><td>184</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; compatibility with this algorithm is required.</pre></td></tr>
<tr class="nocodegen"><td>185</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>186</td><td><pre style="display:inline;"> &nbsp;THash_SHA = class(THash_SHA0)</pre></td></tr>
<tr class="nocodegen"><td>187</td><td><pre style="display:inline;"> &nbsp;{$IFDEF X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>188</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>189</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>190</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>191</td><td><pre style="display:inline;"> &nbsp;{$ENDIF};</pre></td></tr>
<tr class="nocodegen"><td>192</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>193</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>194</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>195</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>196</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Implementation of the SHA1 hash algorithm. At least since February 2017</pre></td></tr>
<tr class="nocodegen"><td>197</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; collisions have been found for this algorithm so it&apos;s now completely</pre></td></tr>
<tr class="nocodegen"><td>198</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; clear that it should not be used if possible! Use SHA256 or SHA512</pre></td></tr>
<tr class="nocodegen"><td>199</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; instead!</pre></td></tr>
<tr class="nocodegen"><td>200</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>201</td><td><pre style="display:inline;"> &nbsp;THash_SHA1 = class(THash_SHA0);</pre></td></tr>
<tr class="nocodegen"><td>202</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>203</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>204</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This algorithm is part of the SHA2 series of hash algorithms.</pre></td></tr>
<tr class="nocodegen"><td>205</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>206</td><td><pre style="display:inline;"> &nbsp;THash_SHA256 = class(THash_SHA0)</pre></td></tr>
<tr class="nocodegen"><td>207</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>208</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>209</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>210</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>211</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>212</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>213</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>214</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>215</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This algorithm is part of the SHA2 series of hash algorithms.</pre></td></tr>
<tr class="nocodegen"><td>216</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; German BSI recommends not to use this algorithm, they recommend SHA256</pre></td></tr>
<tr class="nocodegen"><td>217</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; or higher instead.</pre></td></tr>
<tr class="nocodegen"><td>218</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>219</td><td><pre style="display:inline;"> &nbsp;THash_SHA224 = class(THash_SHA256)</pre></td></tr>
<tr class="nocodegen"><td>220</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>221</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>222</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>223</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>224</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>225</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>226</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>227</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>228</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This algorithm is part of the SHA2 series of hash algorithms.</pre></td></tr>
<tr class="nocodegen"><td>229</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>230</td><td><pre style="display:inline;"> &nbsp;THash_SHA384 = class(TDECHashAuthentication)</pre></td></tr>
<tr class="nocodegen"><td>231</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>232</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..7] of Int64;</pre></td></tr>
<tr class="nocodegen"><td>233</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>234</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>235</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>236</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>237</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>238</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>239</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>240</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>241</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>242</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>243</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>244</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This algorithm is part of the SHA2 series of hash algorithms.</pre></td></tr>
<tr class="nocodegen"><td>245</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>246</td><td><pre style="display:inline;"> &nbsp;THash_SHA512 = class(THash_SHA384)</pre></td></tr>
<tr class="nocodegen"><td>247</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>248</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>249</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>250</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>251</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>252</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>253</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>254</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Base class for tall SHA3 implementations</pre></td></tr>
<tr class="nocodegen"><td>255</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>256</td><td><pre style="display:inline;"> &nbsp;THash_SHA3Base = class(TDECHashBit)</pre></td></tr>
<tr class="nocodegen"><td>257</td><td><pre style="display:inline;"> &nbsp;strict private</pre></td></tr>
<tr class="nocodegen"><td>258</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Declarations for SHA3. Must be declared here to allow private methods</pre></td></tr>
<tr class="nocodegen"><td>259</td><td><pre style="display:inline;"> &nbsp; &nbsp;// to use these types as well.</pre></td></tr>
<tr class="nocodegen"><td>260</td><td><pre style="display:inline;"> &nbsp; &nbsp;const</pre></td></tr>
<tr class="nocodegen"><td>261</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;KeccakPermutationSize &nbsp; &nbsp; &nbsp; &nbsp;= 1600;</pre></td></tr>
<tr class="nocodegen"><td>262</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>263</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Maximum bitrate? If yes this would be higher than any value listed here:</pre></td></tr>
<tr class="nocodegen"><td>264</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; https://keccak.team/keccak.html</pre></td></tr>
<tr class="nocodegen"><td>265</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>266</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;KeccakMaximumRate &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1536;</pre></td></tr>
<tr class="nocodegen"><td>267</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>268</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; KeccakPermutationSize converted into bytes instead of bits</pre></td></tr>
<tr class="nocodegen"><td>269</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>270</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;KeccakPermutationSizeInBytes = KeccakPermutationSize div 8;</pre></td></tr>
<tr class="nocodegen"><td>271</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>272</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; KeccakMaximumRate converted into bytes instead of bits</pre></td></tr>
<tr class="nocodegen"><td>273</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>274</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;KeccakMaximumRateInBytes &nbsp; &nbsp; = KeccakMaximumRate div 8;</pre></td></tr>
<tr class="nocodegen"><td>275</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>276</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>277</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Number of times to run the algorithm on the data</pre></td></tr>
<tr class="nocodegen"><td>278</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>279</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;cKeccakNumberOfRounds &nbsp; &nbsp; &nbsp; &nbsp;= 24;</pre></td></tr>
<tr class="nocodegen"><td>280</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>281</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>282</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Precalculated values for the 24 rounds of the algorithm</pre></td></tr>
<tr class="nocodegen"><td>283</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>284</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;cRoundConstants : array[0..23] of UInt64 = (</pre></td></tr>
<tr class="nocodegen"><td>285</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($0000000000000001), UInt64($0000000000008082),</pre></td></tr>
<tr class="nocodegen"><td>286</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($800000000000808A), UInt64($8000000080008000),</pre></td></tr>
<tr class="nocodegen"><td>287</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($000000000000808B), UInt64($0000000080000001),</pre></td></tr>
<tr class="nocodegen"><td>288</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($8000000080008081), UInt64($8000000000008009),</pre></td></tr>
<tr class="nocodegen"><td>289</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($000000000000008A), UInt64($0000000000000088),</pre></td></tr>
<tr class="nocodegen"><td>290</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($0000000080008009), UInt64($000000008000000A),</pre></td></tr>
<tr class="nocodegen"><td>291</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($000000008000808B), UInt64($800000000000008B),</pre></td></tr>
<tr class="nocodegen"><td>292</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($8000000000008089), UInt64($8000000000008003),</pre></td></tr>
<tr class="nocodegen"><td>293</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($8000000000008002), UInt64($8000000000000080),</pre></td></tr>
<tr class="nocodegen"><td>294</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($000000000000800A), UInt64($800000008000000A),</pre></td></tr>
<tr class="nocodegen"><td>295</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($8000000080008081), UInt64($8000000000008080),</pre></td></tr>
<tr class="nocodegen"><td>296</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;UInt64($0000000080000001), UInt64($8000000080008008)</pre></td></tr>
<tr class="nocodegen"><td>297</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;);</pre></td></tr>
<tr class="nocodegen"><td>298</td><td><pre style="display:inline;"> &nbsp; &nbsp;type</pre></td></tr>
<tr class="nocodegen"><td>299</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;TState_B = packed array[0..KeccakPermutationSizeInBytes-1] of UInt8;</pre></td></tr>
<tr class="nocodegen"><td>300</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;TState_L = packed array[0..(KeccakPermutationSizeInBytes) div 4 - 1] of Int32;</pre></td></tr>
<tr class="nocodegen"><td>301</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;TKDQueue = packed array[0..KeccakMaximumRateInBytes-1] of UInt8;</pre></td></tr>
<tr class="nocodegen"><td>302</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>303</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>304</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Calculation status of the algorithm</pre></td></tr>
<tr class="nocodegen"><td>305</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>306</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;TSpongeState = packed record</pre></td></tr>
<tr class="nocodegen"><td>307</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; State &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : TState_B;</pre></td></tr>
<tr class="nocodegen"><td>308</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>309</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; Data of the queue to be processed</pre></td></tr>
<tr class="nocodegen"><td>310</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>311</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DataQueue &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : TKDQueue;</pre></td></tr>
<tr class="nocodegen"><td>312</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>313</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; Bitrate r of Keccak</pre></td></tr>
<tr class="nocodegen"><td>314</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>315</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rate &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: UInt16;</pre></td></tr>
<tr class="nocodegen"><td>316</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>317</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; Capacity c of Keccak</pre></td></tr>
<tr class="nocodegen"><td>318</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>319</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Capacity &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: UInt16;</pre></td></tr>
<tr class="nocodegen"><td>320</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>321</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; How many bits are in the queue</pre></td></tr>
<tr class="nocodegen"><td>322</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>323</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitsInQueue &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : UInt16;</pre></td></tr>
<tr class="nocodegen"><td>324</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>325</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; Length of the hash value to generate in bit</pre></td></tr>
<tr class="nocodegen"><td>326</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>327</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FixedOutputLength &nbsp; &nbsp; &nbsp; &nbsp; : UInt16;</pre></td></tr>
<tr class="nocodegen"><td>328</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>329</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; Number of bits which can be squeezed</pre></td></tr>
<tr class="nocodegen"><td>330</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>331</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitsAvailableForSqueezing : UInt16;</pre></td></tr>
<tr class="nocodegen"><td>332</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>333</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; Flag which is set to true when entering the</pre></td></tr>
<tr class="nocodegen"><td>334</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; squeezing state. Suppresses further absorb calls.</pre></td></tr>
<tr class="nocodegen"><td>335</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>336</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SqueezeActive &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : Boolean;</pre></td></tr>
<tr class="nocodegen"><td>337</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>338</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &nbsp; If an operation fails it sets this error code</pre></td></tr>
<tr class="nocodegen"><td>339</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>340</td><td><pre style="display:inline;"> &nbsp; &nbsp;// &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Fill3: packed array[405..HASHCTXSIZE] of byte;</pre></td></tr>
<tr class="nocodegen"><td>341</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>342</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>343</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>344</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Buffer type</pre></td></tr>
<tr class="nocodegen"><td>345</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>346</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;TBABytes = array[0..65535] of UInt8;</pre></td></tr>
<tr class="nocodegen"><td>347</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>348</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Pointer to a buffer</pre></td></tr>
<tr class="nocodegen"><td>349</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>350</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PBABytes = ^TBABytes;</pre></td></tr>
<tr class="nocodegen"><td>351</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>352</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>353</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Type for the generated hash value</pre></td></tr>
<tr class="nocodegen"><td>354</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>355</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;TSHA3Digest = array of UInt8;</pre></td></tr>
<tr class="nocodegen"><td>356</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>357</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>358</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Function to give input data for the sponge function to absorb</pre></td></tr>
<tr class="nocodegen"><td>359</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>360</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Data&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>361</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Pointer to the data to work on</pre></td></tr>
<tr class="nocodegen"><td>362</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>363</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;DatabitLen&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>364</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Length of the data passed via the pointer in bit</pre></td></tr>
<tr class="nocodegen"><td>365</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>366</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>367</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Raises an EDECHashEception when DataBit len not divideable by 8 without</pre></td></tr>
<tr class="nocodegen"><td>368</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; reminder or when already in squeezin state.</pre></td></tr>
<tr class="nocodegen"><td>369</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/remarks&gt;</pre></td></tr>
<tr class="nocodegen"><td>370</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure Absorb(Data: PBABytes; DatabitLen: Int32);</pre></td></tr>
<tr class="nocodegen"><td>371</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>372</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>373</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Absorb remaining bits from queue</pre></td></tr>
<tr class="nocodegen"><td>374</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>375</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure AbsorbQueue;</pre></td></tr>
<tr class="nocodegen"><td>376</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>377</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$IFDEF PUREPASCAL}</pre></td></tr>
<tr class="nocodegen"><td>378</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>379</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Circular left shift</pre></td></tr>
<tr class="nocodegen"><td>380</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>381</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;x&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>382</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Value to be shifted</pre></td></tr>
<tr class="nocodegen"><td>383</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>384</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;c&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>385</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Number of bits the value will be shifted</pre></td></tr>
<tr class="nocodegen"><td>386</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>387</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>388</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Shifted value</pre></td></tr>
<tr class="nocodegen"><td>389</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>390</td><td><pre style="display:inline;"> &nbsp; &nbsp;function RotL(const x: UInt64; c: Integer): UInt64; inline;</pre></td></tr>
<tr class="nocodegen"><td>391</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>392</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>393</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Circular left shift by 1</pre></td></tr>
<tr class="nocodegen"><td>394</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>395</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;x&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>396</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Value to be shifted</pre></td></tr>
<tr class="nocodegen"><td>397</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>398</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>399</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Shifted value</pre></td></tr>
<tr class="nocodegen"><td>400</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>401</td><td><pre style="display:inline;"> &nbsp; &nbsp;function RotL1(var x: UInt64): UInt64; inline;</pre></td></tr>
<tr class="nocodegen"><td>402</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>403</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>404</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Permutates the values in the passed state</pre></td></tr>
<tr class="nocodegen"><td>405</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>406</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;State&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>407</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; State to permutate</pre></td></tr>
<tr class="nocodegen"><td>408</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>409</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure KeccakPermutation(var State: TState_L);</pre></td></tr>
<tr class="nocodegen"><td>410</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>411</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>412</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Carries out the XorIntoState and the permutation</pre></td></tr>
<tr class="nocodegen"><td>413</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>414</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;State&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>415</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; State of the algorithm which gets modified by the permutation in this method</pre></td></tr>
<tr class="nocodegen"><td>416</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>417</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Data&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>418</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Pointer to the data to operate on</pre></td></tr>
<tr class="nocodegen"><td>419</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>420</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;LaneCount&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>421</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Number of times the loop in this algorithm has tpo be carried out</pre></td></tr>
<tr class="nocodegen"><td>422</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>423</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure KeccakAbsorb(var state: TState_B; data: PUInt64; laneCount: Integer);</pre></td></tr>
<tr class="nocodegen"><td>424</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>425</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>426</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Include input message data bits into the sponge state</pre></td></tr>
<tr class="nocodegen"><td>427</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>428</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure XORIntoState(var state: TState_L; pI: PUInt64; laneCount: Integer);</pre></td></tr>
<tr class="nocodegen"><td>429</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>430</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>431</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Update state with DataBitLen bits from data. May be called multiple</pre></td></tr>
<tr class="nocodegen"><td>432</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; times, only the last DataBitLen may be a non-multiple of 8</pre></td></tr>
<tr class="nocodegen"><td>433</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; (the corresponding byte) must be MSB aligned, i.e. in the</pre></td></tr>
<tr class="nocodegen"><td>434</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; (databitlen and 7) most significant bits.</pre></td></tr>
<tr class="nocodegen"><td>435</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>436</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;data&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>437</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Data to work on</pre></td></tr>
<tr class="nocodegen"><td>438</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>439</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;DataBitLen&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>440</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Length of the data in bits</pre></td></tr>
<tr class="nocodegen"><td>441</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>442</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoUpdate(Data: Pointer; DataBitLen: Int32);</pre></td></tr>
<tr class="nocodegen"><td>443</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>444</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>445</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Squeeze output data from the sponge function. If the sponge function</pre></td></tr>
<tr class="nocodegen"><td>446</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; was in the absorbing phase, this function switches it to the squeezing</pre></td></tr>
<tr class="nocodegen"><td>447</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; phase.</pre></td></tr>
<tr class="nocodegen"><td>448</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>449</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Output&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>450</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; pointer to the buffer where to store the output data</pre></td></tr>
<tr class="nocodegen"><td>451</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>452</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;OutputLength&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>453</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; number of output bits desired, must be a multiple of 8.</pre></td></tr>
<tr class="nocodegen"><td>454</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>455</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>456</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; 0 if successful, 1 otherwise.</pre></td></tr>
<tr class="nocodegen"><td>457</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>458</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure Squeeze(var Output: TSHA3Digest; OutputLength: Int32);</pre></td></tr>
<tr class="nocodegen"><td>459</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>460</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; The algorithm starts in the absorb phase (one puts data into the sponge)</pre></td></tr>
<tr class="nocodegen"><td>461</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; and ends with the squeze phase (one squeezes the sponge) and this method</pre></td></tr>
<tr class="nocodegen"><td>462</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; does everything needed at the transition point between these two phases</pre></td></tr>
<tr class="nocodegen"><td>463</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>464</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure PadAndSwitchToSqueezingPhase;</pre></td></tr>
<tr class="nocodegen"><td>465</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>466</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>467</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; ???</pre></td></tr>
<tr class="nocodegen"><td>468</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>469</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Outp&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>470</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Pointer where the output will be stored in</pre></td></tr>
<tr class="nocodegen"><td>471</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>472</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;State&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>473</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; State to work on</pre></td></tr>
<tr class="nocodegen"><td>474</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>475</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;LaneCount&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>476</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Number of iterations</pre></td></tr>
<tr class="nocodegen"><td>477</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>478</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure ExtractFromState(Outp: Pointer; const State: TState_L; LaneCount: Integer);</pre></td></tr>
<tr class="nocodegen"><td>479</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>480</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>481</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Update final bits in LSB format, pad them, and compute the hash value</pre></td></tr>
<tr class="nocodegen"><td>482</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>483</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Bits&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>484</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Value used for padding if the length of the message to be hashed</pre></td></tr>
<tr class="nocodegen"><td>485</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; is not a multiple of 8 bit bytes.</pre></td></tr>
<tr class="nocodegen"><td>486</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>487</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;BitLen&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>488</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Number of needed padding bits?</pre></td></tr>
<tr class="nocodegen"><td>489</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>490</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;HashValue&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>491</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; The hash value which shall be updated by this method</pre></td></tr>
<tr class="nocodegen"><td>492</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>493</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure FinalBit_LSB(Bits: Byte; Bitlen: UInt16;</pre></td></tr>
<tr class="nocodegen"><td>494</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var HashValue: TSHA3Digest);</pre></td></tr>
<tr class="nocodegen"><td>495</td><td><pre style="display:inline;"> &nbsp;strict protected</pre></td></tr>
<tr class="nocodegen"><td>496</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>497</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Contains the current state of the algorithms sponge part</pre></td></tr>
<tr class="nocodegen"><td>498</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>499</td><td><pre style="display:inline;"> &nbsp; &nbsp;FSpongeState : TSpongeState;</pre></td></tr>
<tr class="nocodegen"><td>500</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>501</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>502</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; The generated hash value is stored here</pre></td></tr>
<tr class="nocodegen"><td>503</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>504</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest &nbsp; &nbsp; &nbsp;: TSHA3Digest;</pre></td></tr>
<tr class="nocodegen"><td>505</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>506</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>507</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; When true, the output length has been set (applicable for the expandable</pre></td></tr>
<tr class="nocodegen"><td>508</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; output length algorithm variants named Shake) and needs to be preserved</pre></td></tr>
<tr class="nocodegen"><td>509</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; in InitSponge</pre></td></tr>
<tr class="nocodegen"><td>510</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>511</td><td><pre style="display:inline;"> &nbsp; &nbsp;FOutpLengSet : Boolean;</pre></td></tr>
<tr class="nocodegen"><td>512</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>513</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>514</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Initializes the state of the Keccak/SHA3 sponge function. It is set to</pre></td></tr>
<tr class="nocodegen"><td>515</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; the absorbing phase by this. If invalid parameter values are specified</pre></td></tr>
<tr class="nocodegen"><td>516</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; a EDECHashException will be raised</pre></td></tr>
<tr class="nocodegen"><td>517</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>518</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;rate&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>519</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Block length of the message to be processed, depends directly on the</pre></td></tr>
<tr class="nocodegen"><td>520</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; SHA3 variant (224, 256...) to be used</pre></td></tr>
<tr class="nocodegen"><td>521</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>522</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;capacity&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>523</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Capacity c (it could directly be calculated from the rate as</pre></td></tr>
<tr class="nocodegen"><td>524</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; c = 1600 - r but the original author Wolfgang Erhardt decided against</pre></td></tr>
<tr class="nocodegen"><td>525</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; this.</pre></td></tr>
<tr class="nocodegen"><td>526</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; The capacity is the size of that part of the state vector which, when</pre></td></tr>
<tr class="nocodegen"><td>527</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; xored with the message blocks and when extracting the resulting hash,</pre></td></tr>
<tr class="nocodegen"><td>528</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; stays untouched.</pre></td></tr>
<tr class="nocodegen"><td>529</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>530</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure InitSponge(Rate, Capacity: UInt16);</pre></td></tr>
<tr class="nocodegen"><td>531</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>532</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>533</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Init internal data</pre></td></tr>
<tr class="nocodegen"><td>534</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>535</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>536</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>537</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Dummy method to avoid the compiler warning about a class with abstract method</pre></td></tr>
<tr class="nocodegen"><td>538</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>539</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>540</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>541</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Final step of the calculation</pre></td></tr>
<tr class="nocodegen"><td>542</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>543</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>544</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>545</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>546</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the calculated hash value</pre></td></tr>
<tr class="nocodegen"><td>547</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>548</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>549</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Hash value calculated</pre></td></tr>
<tr class="nocodegen"><td>550</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/returns&gt;</pre></td></tr>
<tr class="nocodegen"><td>551</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>552</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>553</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>554</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Dimension hash result buffer</pre></td></tr>
<tr class="nocodegen"><td>555</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>556</td><td><pre style="display:inline;"> &nbsp; &nbsp;constructor Create; override;</pre></td></tr>
<tr class="nocodegen"><td>557</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>558</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Processes one chunk of data to be hashed.</pre></td></tr>
<tr class="nocodegen"><td>559</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>560</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Data&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>561</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Data on which the hash value shall be calculated on</pre></td></tr>
<tr class="nocodegen"><td>562</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>563</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;DataSize&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>564</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Size of the data in bytes</pre></td></tr>
<tr class="nocodegen"><td>565</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>566</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure Calc(const Data; DataSize: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>567</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>568</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>569</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>570</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; 224 bit SHA3 variant</pre></td></tr>
<tr class="nocodegen"><td>571</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>572</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_224 = class(THash_SHA3Base)</pre></td></tr>
<tr class="nocodegen"><td>573</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>574</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>575</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>576</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>577</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>578</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>579</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>580</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>581</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; 256 bit SHA3 variant</pre></td></tr>
<tr class="nocodegen"><td>582</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>583</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_256 = class(THash_SHA3Base)</pre></td></tr>
<tr class="nocodegen"><td>584</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>585</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>586</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>587</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>588</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>589</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>590</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>591</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>592</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; 384 bit SHA3 variant</pre></td></tr>
<tr class="nocodegen"><td>593</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>594</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_384 = class(THash_SHA3Base)</pre></td></tr>
<tr class="nocodegen"><td>595</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>596</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>597</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>598</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>599</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>600</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>601</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>602</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>603</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; 512 bit SHA3 variant</pre></td></tr>
<tr class="nocodegen"><td>604</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>605</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_512 = class(THash_SHA3Base)</pre></td></tr>
<tr class="nocodegen"><td>606</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>607</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>608</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>609</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>610</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>611</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>612</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>613</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>614</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Base class for the Shake implementations</pre></td></tr>
<tr class="nocodegen"><td>615</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>616</td><td><pre style="display:inline;"> &nbsp;THash_ShakeBase = class(THash_SHA3Base, IDECHashExtensibleOutput)</pre></td></tr>
<tr class="nocodegen"><td>617</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>618</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>619</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the length of the calculated hash value in byte</pre></td></tr>
<tr class="nocodegen"><td>620</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>621</td><td><pre style="display:inline;"> &nbsp; &nbsp;function &nbsp;GetHashSize: UInt16;</pre></td></tr>
<tr class="nocodegen"><td>622</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>623</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Defines the length of the calculated hash value</pre></td></tr>
<tr class="nocodegen"><td>624</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>625</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Value&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>626</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Length of the hash value to be returned in byte</pre></td></tr>
<tr class="nocodegen"><td>627</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>628</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetHashSize(const Value: UInt16);</pre></td></tr>
<tr class="nocodegen"><td>629</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>630</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>631</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the calculated hash value as byte array. Needs to be overriden</pre></td></tr>
<tr class="nocodegen"><td>632</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; here as the length of the output needs to be determined differently due</pre></td></tr>
<tr class="nocodegen"><td>633</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; to Shake being extensible output length.</pre></td></tr>
<tr class="nocodegen"><td>634</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>635</td><td><pre style="display:inline;"> &nbsp; &nbsp;function DigestAsBytes: TBytes; override;</pre></td></tr>
<tr class="nocodegen"><td>636</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>637</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Define the lenght of the resulting hash value in byte as these functions</pre></td></tr>
<tr class="nocodegen"><td>638</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; are extendable output functions</pre></td></tr>
<tr class="nocodegen"><td>639</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>640</td><td><pre style="display:inline;"> &nbsp; &nbsp;property HashSize : UInt16</pre></td></tr>
<tr class="nocodegen"><td>641</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;read &nbsp; GetHashSize</pre></td></tr>
<tr class="nocodegen"><td>642</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;write &nbsp;SetHashSize;</pre></td></tr>
<tr class="nocodegen"><td>643</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>644</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>645</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>646</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Shake128 veriant of SHA3</pre></td></tr>
<tr class="nocodegen"><td>647</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>648</td><td><pre style="display:inline;"> &nbsp;THash_Shake128 = class(THash_ShakeBase)</pre></td></tr>
<tr class="nocodegen"><td>649</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>650</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>651</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>652</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>653</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>654</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>655</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>656</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>657</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Shake128 veriant of SHA3</pre></td></tr>
<tr class="nocodegen"><td>658</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>659</td><td><pre style="display:inline;"> &nbsp;THash_Shake256 = class(THash_ShakeBase)</pre></td></tr>
<tr class="nocodegen"><td>660</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>661</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>662</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>663</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>664</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>665</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>666</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>667</td><td><pre style="display:inline;"> &nbsp;THavalBaseTransformMethod = procedure(Buffer: PUInt32Array) of object;</pre></td></tr>
<tr class="nocodegen"><td>668</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>669</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>670</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Base class for all Haval implementations</pre></td></tr>
<tr class="nocodegen"><td>671</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>672</td><td><pre style="display:inline;"> &nbsp;THashBaseHaval = class(TDECHashAuthentication, IDECHashRounds)</pre></td></tr>
<tr class="nocodegen"><td>673</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>674</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..7] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>675</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>676</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; UInt32 for compatibility with 32 bit ASM implementation</pre></td></tr>
<tr class="nocodegen"><td>677</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>678</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>679</td><td><pre style="display:inline;"> &nbsp; &nbsp;FTransform: THavalBaseTransformMethod;</pre></td></tr>
<tr class="nocodegen"><td>680</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>681</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Defines the number of calculation rounds and if a value outside the</pre></td></tr>
<tr class="nocodegen"><td>682</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; allowed range is given it sets rounds to a value based on digest size.</pre></td></tr>
<tr class="nocodegen"><td>683</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>684</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetRounds(Value: UInt32);</pre></td></tr>
<tr class="nocodegen"><td>685</td><td><pre style="display:inline;"> &nbsp; &nbsp;function &nbsp;GetRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>686</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>687</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>688</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>689</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform3(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>690</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform4(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>691</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform5(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>692</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>693</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>694</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>695</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>696</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>697</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the minimum possible number for the rounds parameter.</pre></td></tr>
<tr class="nocodegen"><td>698</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Value depends on Digest size which depends on concrete implementation</pre></td></tr>
<tr class="nocodegen"><td>699</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>700</td><td><pre style="display:inline;"> &nbsp; &nbsp;function GetMinRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>701</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>702</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the maximum possible number for the rounds parameter.</pre></td></tr>
<tr class="nocodegen"><td>703</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Value depends on Digest size which depends on concrete implementation</pre></td></tr>
<tr class="nocodegen"><td>704</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>705</td><td><pre style="display:inline;"> &nbsp; &nbsp;function GetMaxRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>706</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>707</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>708</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Defines the number of rounds the algorithm performs on the input data.</pre></td></tr>
<tr class="nocodegen"><td>709</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; The range for this parameter is 3-5 rounds. If a value outside this</pre></td></tr>
<tr class="nocodegen"><td>710</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; range is assigned, the value used depends on the DigestSize. For</pre></td></tr>
<tr class="nocodegen"><td>711</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; DigestSizes &lt;= 20 it will be set to 3, for values &lt;= 28 to 4 and for</pre></td></tr>
<tr class="nocodegen"><td>712</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; bigger values to 5. For 3 rounds the algorithm is considered unsafe,</pre></td></tr>
<tr class="nocodegen"><td>713</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; as in 2003 collisions could be found with a setting of 3 rounds only.</pre></td></tr>
<tr class="nocodegen"><td>714</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>715</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: UInt32 read GetRounds write SetRounds default 3;</pre></td></tr>
<tr class="nocodegen"><td>716</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>717</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>718</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>719</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; In 2004 collisions for this one were found, so this one should be</pre></td></tr>
<tr class="nocodegen"><td>720</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; considered to be unsafe.</pre></td></tr>
<tr class="nocodegen"><td>721</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>722</td><td><pre style="display:inline;"> &nbsp;THash_Haval128 = class(THashBaseHaval)</pre></td></tr>
<tr class="nocodegen"><td>723</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>724</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>725</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>726</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>727</td><td><pre style="display:inline;"> &nbsp;THash_Haval160 = class(THashBaseHaval)</pre></td></tr>
<tr class="nocodegen"><td>728</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>729</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>730</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>731</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>732</td><td><pre style="display:inline;"> &nbsp;THash_Haval192 = class(THashBaseHaval)</pre></td></tr>
<tr class="nocodegen"><td>733</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>734</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>735</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>736</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>737</td><td><pre style="display:inline;"> &nbsp;THash_Haval224 = class(THashBaseHaval)</pre></td></tr>
<tr class="nocodegen"><td>738</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>739</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>740</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>741</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>742</td><td><pre style="display:inline;"> &nbsp;THash_Haval256 = class(THashBaseHaval)</pre></td></tr>
<tr class="nocodegen"><td>743</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>744</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>745</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>746</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>747</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>748</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This is actually an implementation of the 192 bit variant of the Tiger</pre></td></tr>
<tr class="nocodegen"><td>749</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; hash algorithm with 3 rounds, unless a different value is assigned</pre></td></tr>
<tr class="nocodegen"><td>750</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; to the rounds property. It is considered to be unsafe at least in the</pre></td></tr>
<tr class="nocodegen"><td>751</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; 192 Bit variant!</pre></td></tr>
<tr class="nocodegen"><td>752</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>753</td><td><pre style="display:inline;"> &nbsp;THash_Tiger = class(THashBaseMD4, IDECHashRounds)</pre></td></tr>
<tr class="nocodegen"><td>754</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>755</td><td><pre style="display:inline;"> &nbsp; &nbsp;const</pre></td></tr>
<tr class="nocodegen"><td>756</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>757</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Minimum number of rounds for the Tigher hash function. Trying to set a</pre></td></tr>
<tr class="nocodegen"><td>758</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; lower one sets the rounds to this value.</pre></td></tr>
<tr class="nocodegen"><td>759</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>760</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;cTigerMinRounds = 3;</pre></td></tr>
<tr class="nocodegen"><td>761</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>762</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; Maximum number of rounds for the Tigher hash function. Trying to set a</pre></td></tr>
<tr class="nocodegen"><td>763</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; higher one sets the rounds to this value.</pre></td></tr>
<tr class="nocodegen"><td>764</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>765</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;cTigerMaxRounds = 32;</pre></td></tr>
<tr class="nocodegen"><td>766</td><td><pre style="display:inline;"> &nbsp; &nbsp;var</pre></td></tr>
<tr class="nocodegen"><td>767</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>768</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &nbsp; UInt32 for compatibility with 32 bit ASM implementation</pre></td></tr>
<tr class="nocodegen"><td>769</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>770</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;FRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>771</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;function &nbsp;GetRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>772</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;procedure SetRounds(Value: UInt32);</pre></td></tr>
<tr class="nocodegen"><td>773</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>774</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>775</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>776</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>777</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>778</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>779</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the minimum possible number for the rounds parameter</pre></td></tr>
<tr class="nocodegen"><td>780</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>781</td><td><pre style="display:inline;"> &nbsp; &nbsp;function GetMinRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>782</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>783</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the maximum possible number for the rounds parameter</pre></td></tr>
<tr class="nocodegen"><td>784</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>785</td><td><pre style="display:inline;"> &nbsp; &nbsp;function GetMaxRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>786</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>787</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>788</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Defines the number of rounds the algorithm will perform on the data</pre></td></tr>
<tr class="nocodegen"><td>789</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; passed. Valid values are in the range from 3-32 rounds and values</pre></td></tr>
<tr class="nocodegen"><td>790</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; outside this range will lead to a rounds value of 3 or 32 to be used,</pre></td></tr>
<tr class="nocodegen"><td>791</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; depending on whether a lower or higher value has been given.</pre></td></tr>
<tr class="nocodegen"><td>792</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>793</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: UInt32 read GetRounds write SetRounds default 3;</pre></td></tr>
<tr class="nocodegen"><td>794</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>795</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>796</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>797</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; As there seem to exist 128 and 160 bit variants of Tiger, which seem to</pre></td></tr>
<tr class="nocodegen"><td>798</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; be truncated variants of Tiger 192, but we want to keep compatibility</pre></td></tr>
<tr class="nocodegen"><td>799</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; with old code we introduce an alias for the time being.</pre></td></tr>
<tr class="nocodegen"><td>800</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; It is considered to be unsafe at least in the 192 Bit variant!</pre></td></tr>
<tr class="nocodegen"><td>801</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>802</td><td><pre style="display:inline;"> &nbsp;THash_Tiger192 = THash_Tiger;</pre></td></tr>
<tr class="nocodegen"><td>803</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>804</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>805</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The Panama algorithm is being considered to be unsafe. Support is only</pre></td></tr>
<tr class="nocodegen"><td>806</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; being provided for backward compatibility.</pre></td></tr>
<tr class="nocodegen"><td>807</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>808</td><td><pre style="display:inline;"> &nbsp;THash_Panama = class(TDECHashAuthentication)</pre></td></tr>
<tr class="nocodegen"><td>809</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>810</td><td><pre style="display:inline;"> &nbsp; &nbsp;FLFSRBuffer: array[0..31, 0..7] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>811</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..16] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>812</td><td><pre style="display:inline;"> &nbsp; &nbsp;FTap: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>813</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>814</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>815</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>816</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>817</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoPull;</pre></td></tr>
<tr class="nocodegen"><td>818</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>819</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>820</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>821</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override; // 32</pre></td></tr>
<tr class="nocodegen"><td>822</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>823</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>824</td><td><pre style="display:inline;"> &nbsp;THashBaseWhirlpool = class(TDECHashAuthentication)</pre></td></tr>
<tr class="nocodegen"><td>825</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>826</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..15] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>827</td><td><pre style="display:inline;"> &nbsp; &nbsp;FTableC: Pointer;</pre></td></tr>
<tr class="nocodegen"><td>828</td><td><pre style="display:inline;"> &nbsp; &nbsp;FTableR: Pointer;</pre></td></tr>
<tr class="nocodegen"><td>829</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>830</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>831</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>832</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>833</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>834</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>835</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>836</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>837</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>838</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>839</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This is the original variant of the algorithmus. Do not use it as some</pre></td></tr>
<tr class="nocodegen"><td>840</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; security flaw has been detected early on by its inventors. DEC contains</pre></td></tr>
<tr class="nocodegen"><td>841</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; it for backwards compatibility and completeness.</pre></td></tr>
<tr class="nocodegen"><td>842</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>843</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool0 = class(THashBaseWhirlpool)</pre></td></tr>
<tr class="nocodegen"><td>844</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>845</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>846</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>847</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>848</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>849</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This is variant of the algorithmus fixing the security flaw of the</pre></td></tr>
<tr class="nocodegen"><td>850</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; original version Whirlpool0. Do not use it in new code as it has been</pre></td></tr>
<tr class="nocodegen"><td>851</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; superseeded by the optimized Whirlpool1 (THash_Whirlpool1 class in DEC)</pre></td></tr>
<tr class="nocodegen"><td>852</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; variant which is additionally more safe as well! It is there for</pre></td></tr>
<tr class="nocodegen"><td>853</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; backwards compatibility and completeness only.</pre></td></tr>
<tr class="nocodegen"><td>854</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>855</td><td><pre style="display:inline;"> &nbsp;THash_WhirlpoolT = class(THashBaseWhirlpool)</pre></td></tr>
<tr class="nocodegen"><td>856</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>857</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>858</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>859</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>860</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>861</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The current version of Whirlpool but not the one used in code developed</pre></td></tr>
<tr class="nocodegen"><td>862</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; against the older DEC 5.x versions. The name of the one used in your</pre></td></tr>
<tr class="nocodegen"><td>863</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; code differs, depending whether you opt tu use the old DEC 5.2 compatible</pre></td></tr>
<tr class="nocodegen"><td>864</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; class names where the name Whirlpool1 was already taken by the variant</pre></td></tr>
<tr class="nocodegen"><td>865</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; nowadays known as Whirlpool-T.</pre></td></tr>
<tr class="nocodegen"><td>866</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>867</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool1_ = class(THashBaseWhirlpool)</pre></td></tr>
<tr class="nocodegen"><td>868</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>869</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>870</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>871</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>872</td><td><pre style="display:inline;"> &nbsp;{$IFDEF OLD_WHIRLPOOL_NAMES}</pre></td></tr>
<tr class="nocodegen"><td>873</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>874</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This is the original variant of the algorithmus. Do not use it as some</pre></td></tr>
<tr class="nocodegen"><td>875</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; security flaw has been detected early on by its inventors. DEC contains</pre></td></tr>
<tr class="nocodegen"><td>876</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; it for backwards compatibility and completeness.</pre></td></tr>
<tr class="nocodegen"><td>877</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>878</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool = class(THash_Whirlpool0);</pre></td></tr>
<tr class="nocodegen"><td>879</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>880</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This is variant of the algorithmus fixing the security flaw of the</pre></td></tr>
<tr class="nocodegen"><td>881</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; original version Whirlpool0. Do not use it in new code as it has been</pre></td></tr>
<tr class="nocodegen"><td>882</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; superseeded by the optimized Whirlpool1 (THash_Whirlpool1 class in DEC)</pre></td></tr>
<tr class="nocodegen"><td>883</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; variant which is additionally more safe as well! It is there for</pre></td></tr>
<tr class="nocodegen"><td>884</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; backwards compatibility and completeness only.</pre></td></tr>
<tr class="nocodegen"><td>885</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>886</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool1 = class(THash_WhirlpoolT);</pre></td></tr>
<tr class="nocodegen"><td>887</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>888</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The current version of Whirlpool but not the one used in code developed</pre></td></tr>
<tr class="nocodegen"><td>889</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; against the older DEC 5.x versions. The name of the one used in your</pre></td></tr>
<tr class="nocodegen"><td>890</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; code differs, depending whether you opt tu use the old DEC 5.2 compatible</pre></td></tr>
<tr class="nocodegen"><td>891</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; class names where the name Whirlpool1 was already taken by the variant</pre></td></tr>
<tr class="nocodegen"><td>892</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; nowadays known as Whirlpool-T.</pre></td></tr>
<tr class="nocodegen"><td>893</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>894</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool1New = class(THash_Whirlpool1_);</pre></td></tr>
<tr class="nocodegen"><td>895</td><td><pre style="display:inline;"> &nbsp;{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>896</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>897</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; The current version of Whirlpool but not the one used in code developed</pre></td></tr>
<tr class="nocodegen"><td>898</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; against the older DEC 5.x versions. The name of the one used in your</pre></td></tr>
<tr class="nocodegen"><td>899</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; code differs, depending whether you opt tu use the old DEC 5.2 compatible</pre></td></tr>
<tr class="nocodegen"><td>900</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; class names where the name Whirlpool1 was already taken by the variant</pre></td></tr>
<tr class="nocodegen"><td>901</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; nowadays known as Whirlpool-T.</pre></td></tr>
<tr class="nocodegen"><td>902</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>903</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool1 = class(THash_Whirlpool1_);</pre></td></tr>
<tr class="nocodegen"><td>904</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>905</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>906</td><td><pre style="display:inline;"> &nbsp;THash_Square = class(TDECHashAuthentication)</pre></td></tr>
<tr class="nocodegen"><td>907</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>908</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>909</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>910</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>911</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>912</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>913</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>914</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>915</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>916</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>917</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>918</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>919</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>920</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This 1990 developed hash function was named after the Egyptian Pharaoh</pre></td></tr>
<tr class="nocodegen"><td>921</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Sneferu. Be sure to set SecurityLevel to at least 8. See remark there.</pre></td></tr>
<tr class="nocodegen"><td>922</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>923</td><td><pre style="display:inline;"> &nbsp;THashBaseSnefru = class(TDECHashAuthentication, IDECHashRounds)</pre></td></tr>
<tr class="nocodegen"><td>924</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>925</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..23] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>926</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>927</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Number of rounds the loop will do on the data.</pre></td></tr>
<tr class="nocodegen"><td>928</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; UInt32 for compatibility with 32 bit ASM implementation</pre></td></tr>
<tr class="nocodegen"><td>929</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>930</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>931</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>932</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Sets the number of rounds for the looping over the data</pre></td></tr>
<tr class="nocodegen"><td>933</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>934</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetRounds(Value: UInt32);</pre></td></tr>
<tr class="nocodegen"><td>935</td><td><pre style="display:inline;"> &nbsp; &nbsp;function &nbsp;GetRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>936</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>937</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>938</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>939</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>940</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>941</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the minimum possible number for the rounds parameter.</pre></td></tr>
<tr class="nocodegen"><td>942</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Value depends on Digest size which depends on concrete implementation</pre></td></tr>
<tr class="nocodegen"><td>943</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>944</td><td><pre style="display:inline;"> &nbsp; &nbsp;function GetMinRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>945</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the maximum possible number for the rounds parameter.</pre></td></tr>
<tr class="nocodegen"><td>946</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Value depends on Digest size which depends on concrete implementation</pre></td></tr>
<tr class="nocodegen"><td>947</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>948</td><td><pre style="display:inline;"> &nbsp; &nbsp;function GetMaxRounds: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>949</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>950</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>951</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Can be set from 2 to 8, default is 8. This is the number of rounds the</pre></td></tr>
<tr class="nocodegen"><td>952</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; algorithm will use. With the default of 8 rounds it is being considered</pre></td></tr>
<tr class="nocodegen"><td>953</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; as safe as of spring 2016, with less rounds this algorithm is considered</pre></td></tr>
<tr class="nocodegen"><td>954</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; to be unsafe and even with 8 rounds it is not really strong.</pre></td></tr>
<tr class="nocodegen"><td>955</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>956</td><td><pre style="display:inline;"> &nbsp; &nbsp;property Rounds: UInt32</pre></td></tr>
<tr class="nocodegen"><td>957</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;read &nbsp; GetRounds</pre></td></tr>
<tr class="nocodegen"><td>958</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;write &nbsp;SetRounds;</pre></td></tr>
<tr class="nocodegen"><td>959</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>960</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>961</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>962</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This 1990 developed hash function was named after the Egyptian Pharaoh</pre></td></tr>
<tr class="nocodegen"><td>963</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Sneferu. Be sure to set SecurityLevel to at least 8. See remark for</pre></td></tr>
<tr class="nocodegen"><td>964</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; THashBaseSnefru.SecurityLevel.</pre></td></tr>
<tr class="nocodegen"><td>965</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>966</td><td><pre style="display:inline;"> &nbsp;THash_Snefru128 = class(THashBaseSnefru)</pre></td></tr>
<tr class="nocodegen"><td>967</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>968</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>969</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>970</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>971</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override; // 48</pre></td></tr>
<tr class="nocodegen"><td>972</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>973</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>974</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>975</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; This 1990 developed hash function was named after the Egyptian Pharaoh</pre></td></tr>
<tr class="nocodegen"><td>976</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Sneferu. Be sure to set SecurityLevel to at least 8. See remark</pre></td></tr>
<tr class="nocodegen"><td>977</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; THashBaseSnefru.SecurityLevel.</pre></td></tr>
<tr class="nocodegen"><td>978</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>979</td><td><pre style="display:inline;"> &nbsp;THash_Snefru256 = class(THashBaseSnefru)</pre></td></tr>
<tr class="nocodegen"><td>980</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>981</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>982</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>983</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>984</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override; // 32</pre></td></tr>
<tr class="nocodegen"><td>985</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>986</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>987</td><td><pre style="display:inline;"> &nbsp;THash_Sapphire = class(TDECHashAuthentication)</pre></td></tr>
<tr class="nocodegen"><td>988</td><td><pre style="display:inline;"> &nbsp;private</pre></td></tr>
<tr class="nocodegen"><td>989</td><td><pre style="display:inline;"> &nbsp; &nbsp;FCards: array[0..255] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>990</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest: array[0..15] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>991</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRotor: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>992</td><td><pre style="display:inline;"> &nbsp; &nbsp;FRatchet: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>993</td><td><pre style="display:inline;"> &nbsp; &nbsp;FAvalanche: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>994</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPlain: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>995</td><td><pre style="display:inline;"> &nbsp; &nbsp;FCipher: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>996</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigestSize: UInt8;</pre></td></tr>
<tr class="nocodegen"><td>997</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>998</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>999</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Set the length of the output hash value in byte.</pre></td></tr>
<tr class="nocodegen"><td>1000</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1001</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;param name=&quot;Value&quot;&gt;</pre></td></tr>
<tr class="nocodegen"><td>1002</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Minimum value is 1 byte, maximum value is 64 byte = 512 bit.</pre></td></tr>
<tr class="nocodegen"><td>1003</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Sets the size to the default size returned by DigestSize otherwise.</pre></td></tr>
<tr class="nocodegen"><td>1004</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; is specified.</pre></td></tr>
<tr class="nocodegen"><td>1005</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/param&gt;</pre></td></tr>
<tr class="nocodegen"><td>1006</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure SetDigestSize(Value: UInt8);</pre></td></tr>
<tr class="nocodegen"><td>1007</td><td><pre style="display:inline;"> &nbsp;protected</pre></td></tr>
<tr class="nocodegen"><td>1008</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoInit; override;</pre></td></tr>
<tr class="nocodegen"><td>1009</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoDone; override;</pre></td></tr>
<tr class="nocodegen"><td>1010</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure DoTransform(Buffer: PUInt32Array); override;</pre></td></tr>
<tr class="nocodegen"><td>1011</td><td><pre style="display:inline;"> &nbsp;public</pre></td></tr>
<tr class="nocodegen"><td>1012</td><td><pre style="display:inline;"> &nbsp; &nbsp;function Digest: PByteArray; override;</pre></td></tr>
<tr class="nocodegen"><td>1013</td><td><pre style="display:inline;"> &nbsp; &nbsp;function DigestAsBytes: TBytes; override;</pre></td></tr>
<tr class="nocodegen"><td>1014</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1015</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns the default digest/hash size in bit. If RequestedDigestSize is</pre></td></tr>
<tr class="nocodegen"><td>1016</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; not set, the defauilt size returned here is being used.</pre></td></tr>
<tr class="nocodegen"><td>1017</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1018</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function DigestSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>1019</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1020</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; Returns on which block size this algorithm operates. Since the Sapphire</pre></td></tr>
<tr class="nocodegen"><td>1021</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; hash originates from a Sapphire stream cipher algorithm this is always 1.</pre></td></tr>
<tr class="nocodegen"><td>1022</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1023</td><td><pre style="display:inline;"> &nbsp; &nbsp;class function BlockSize: UInt32; override;</pre></td></tr>
<tr class="nocodegen"><td>1024</td><td><pre style="display:inline;"> &nbsp; &nbsp;procedure Calc(const Data; DataSize: Integer); override;</pre></td></tr>
<tr class="nocodegen"><td>1025</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1026</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1027</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; This property defines the length of the output from the hash calculation</pre></td></tr>
<tr class="nocodegen"><td>1028</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; in byte. The maximum value is 64 byte = 512 bit. Values bigger 64 byte</pre></td></tr>
<tr class="nocodegen"><td>1029</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; and a value of 0 lead to the default size returned by DigestSize otherwise.</pre></td></tr>
<tr class="nocodegen"><td>1030</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; This setting is only respected by the DigestAsBytes method and all other</pre></td></tr>
<tr class="nocodegen"><td>1031</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; convenience methods using that one like CalcStream, CalcString,</pre></td></tr>
<tr class="nocodegen"><td>1032</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &nbsp; DigestAsString or DigestAsRawString.</pre></td></tr>
<tr class="nocodegen"><td>1033</td><td><pre style="display:inline;"> &nbsp; &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1034</td><td><pre style="display:inline;"> &nbsp; &nbsp;property RequestedDigestSize: UInt8</pre></td></tr>
<tr class="nocodegen"><td>1035</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;read &nbsp; FDigestSize</pre></td></tr>
<tr class="nocodegen"><td>1036</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;write &nbsp;SetDigestSize;</pre></td></tr>
<tr class="nocodegen"><td>1037</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1038</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1039</td><td><pre style="display:inline;">implementation</pre></td></tr>
<tr class="nocodegen"><td>1040</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1041</td><td><pre style="display:inline;">uses</pre></td></tr>
<tr class="nocodegen"><td>1042</td><td><pre style="display:inline;"> &nbsp;DECData, DECDataHash;</pre></td></tr>
<tr class="nocodegen"><td>1043</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1044</td><td><pre style="display:inline;">{$IFOPT Q+}{$DEFINE RESTORE_OVERFLOWCHECKS}{$Q-}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>1045</td><td><pre style="display:inline;">{$IFOPT R+}{$DEFINE RESTORE_RANGECHECKS}{$R-}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>1046</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1047</td><td><pre style="display:inline;">{$IFDEF X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1048</td><td><pre style="display:inline;"> &nbsp;{$DEFINE INCLUDED} // allows having the DECHash.inc in the IDE&apos;s project manager</pre></td></tr>
<tr class="nocodegen"><td>1049</td><td><pre style="display:inline;"> &nbsp;{$INCLUDE DECHash.asm86.inc}</pre></td></tr>
<tr class="nocodegen"><td>1050</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1051</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1052</td><td><pre style="display:inline;">{ Speed comparison of ASM vs. PurePascal Implementation. Valid only for Win32 compiler</pre></td></tr>
<tr class="nocodegen"><td>1053</td><td><pre style="display:inline;"> &nbsp;and this was for DEC 5.1 and thus compiler versions &lt; D2009!</pre></td></tr>
<tr class="nocodegen"><td>1054</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1055</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assembler &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pascal</pre></td></tr>
<tr class="nocodegen"><td>1056</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1057</td><td><pre style="display:inline;"> &nbsp;THash_SHA512 &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp; 85.1 cycles/byte &nbsp; &nbsp; &nbsp;17.62 Mb/sec &nbsp; &nbsp; &nbsp;220.9 cycles/byte &nbsp; &nbsp; &nbsp; 6.79 Mb/sec &nbsp;159%</pre></td></tr>
<tr class="nocodegen"><td>1058</td><td><pre style="display:inline;"> &nbsp;THash_SHA384 &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp; 85.2 cycles/byte &nbsp; &nbsp; &nbsp;17.61 Mb/sec &nbsp; &nbsp; &nbsp;220.0 cycles/byte &nbsp; &nbsp; &nbsp; 6.82 Mb/sec &nbsp;158%</pre></td></tr>
<tr class="nocodegen"><td>1059</td><td><pre style="display:inline;"> &nbsp;THash_Tiger &nbsp; &nbsp; : &nbsp; &nbsp; &nbsp; 24.6 cycles/byte &nbsp; &nbsp; &nbsp;60.98 Mb/sec &nbsp; &nbsp; &nbsp; 60.7 cycles/byte &nbsp; &nbsp; &nbsp;24.69 Mb/sec &nbsp;147%</pre></td></tr>
<tr class="nocodegen"><td>1060</td><td><pre style="display:inline;"> &nbsp;THash_Haval128 &nbsp;: &nbsp; &nbsp; &nbsp; 13.3 cycles/byte &nbsp; &nbsp; 112.55 Mb/sec &nbsp; &nbsp; &nbsp; 26.0 cycles/byte &nbsp; &nbsp; &nbsp;57.77 Mb/sec &nbsp; 95%</pre></td></tr>
<tr class="nocodegen"><td>1061</td><td><pre style="display:inline;"> &nbsp;THash_SHA1 &nbsp; &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp; 20.1 cycles/byte &nbsp; &nbsp; &nbsp;74.80 Mb/sec &nbsp; &nbsp; &nbsp; 36.1 cycles/byte &nbsp; &nbsp; &nbsp;41.51 Mb/sec &nbsp; 80%</pre></td></tr>
<tr class="nocodegen"><td>1062</td><td><pre style="display:inline;"> &nbsp;THash_SHA &nbsp; &nbsp; &nbsp; : &nbsp; &nbsp; &nbsp; 20.0 cycles/byte &nbsp; &nbsp; &nbsp;75.03 Mb/sec &nbsp; &nbsp; &nbsp; 35.5 cycles/byte &nbsp; &nbsp; &nbsp;42.21 Mb/sec &nbsp; 78%</pre></td></tr>
<tr class="nocodegen"><td>1063</td><td><pre style="display:inline;"> &nbsp;THash_Haval160 &nbsp;: &nbsp; &nbsp; &nbsp; 13.2 cycles/byte &nbsp; &nbsp; 113.30 Mb/sec &nbsp; &nbsp; &nbsp; 22.7 cycles/byte &nbsp; &nbsp; &nbsp;66.12 Mb/sec &nbsp; 71%</pre></td></tr>
<tr class="nocodegen"><td>1064</td><td><pre style="display:inline;"> &nbsp;THash_Haval256 &nbsp;: &nbsp; &nbsp; &nbsp; 25.9 cycles/byte &nbsp; &nbsp; &nbsp;57.84 Mb/sec &nbsp; &nbsp; &nbsp; 40.5 cycles/byte &nbsp; &nbsp; &nbsp;37.07 Mb/sec &nbsp; 56%</pre></td></tr>
<tr class="nocodegen"><td>1065</td><td><pre style="display:inline;"> &nbsp;THash_Snefru128 : &nbsp; &nbsp; &nbsp;159.7 cycles/byte &nbsp; &nbsp; &nbsp; 9.39 Mb/sec &nbsp; &nbsp; &nbsp;248.2 cycles/byte &nbsp; &nbsp; &nbsp; 6.04 Mb/sec &nbsp; 55%</pre></td></tr>
<tr class="nocodegen"><td>1066</td><td><pre style="display:inline;"> &nbsp;THash_Snefru256 : &nbsp; &nbsp; &nbsp;239.3 cycles/byte &nbsp; &nbsp; &nbsp; 6.27 Mb/sec &nbsp; &nbsp; &nbsp;367.9 cycles/byte &nbsp; &nbsp; &nbsp; 4.08 Mb/sec &nbsp; 54%</pre></td></tr>
<tr class="nocodegen"><td>1067</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD256 : &nbsp; &nbsp; &nbsp; 14.5 cycles/byte &nbsp; &nbsp; 103.16 Mb/sec &nbsp; &nbsp; &nbsp; 21.4 cycles/byte &nbsp; &nbsp; &nbsp;70.08 Mb/sec &nbsp; 47%</pre></td></tr>
<tr class="nocodegen"><td>1068</td><td><pre style="display:inline;"> &nbsp;THash_MD4 &nbsp; &nbsp; &nbsp; : &nbsp; &nbsp; &nbsp; &nbsp;5.8 cycles/byte &nbsp; &nbsp; 256.73 Mb/sec &nbsp; &nbsp; &nbsp; &nbsp;8.5 cycles/byte &nbsp; &nbsp; 176.92 Mb/sec &nbsp; 45%</pre></td></tr>
<tr class="nocodegen"><td>1069</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1070</td><td><pre style="display:inline;"> &nbsp;THash_MD2 &nbsp; &nbsp; &nbsp; : &nbsp; &nbsp; &nbsp;251.6 cycles/byte &nbsp; &nbsp; &nbsp; 5.96 Mb/sec &nbsp; &nbsp; &nbsp;366.1 cycles/byte &nbsp; &nbsp; &nbsp; 4.10 Mb/sec &nbsp; 45%</pre></td></tr>
<tr class="nocodegen"><td>1071</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD128 : &nbsp; &nbsp; &nbsp; 15.2 cycles/byte &nbsp; &nbsp; &nbsp;98.89 Mb/sec &nbsp; &nbsp; &nbsp; 21.2 cycles/byte &nbsp; &nbsp; &nbsp;70.61 Mb/sec &nbsp; 40%</pre></td></tr>
<tr class="nocodegen"><td>1072</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD320 : &nbsp; &nbsp; &nbsp; 25.5 cycles/byte &nbsp; &nbsp; &nbsp;58.73 Mb/sec &nbsp; &nbsp; &nbsp; 35.8 cycles/byte &nbsp; &nbsp; &nbsp;41.87 Mb/sec &nbsp; 40%</pre></td></tr>
<tr class="nocodegen"><td>1073</td><td><pre style="display:inline;"> &nbsp;THash_MD5 &nbsp; &nbsp; &nbsp; : &nbsp; &nbsp; &nbsp; &nbsp;8.9 cycles/byte &nbsp; &nbsp; 169.43 Mb/sec &nbsp; &nbsp; &nbsp; 11.4 cycles/byte &nbsp; &nbsp; 131.01 Mb/sec &nbsp; 29%</pre></td></tr>
<tr class="nocodegen"><td>1074</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD160 : &nbsp; &nbsp; &nbsp; 26.5 cycles/byte &nbsp; &nbsp; &nbsp;56.66 Mb/sec &nbsp; &nbsp; &nbsp; 31.4 cycles/byte &nbsp; &nbsp; &nbsp;47.79 Mb/sec &nbsp; 19%</pre></td></tr>
<tr class="nocodegen"><td>1075</td><td><pre style="display:inline;"> &nbsp;THash_Square &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp; 44.7 cycles/byte &nbsp; &nbsp; &nbsp;33.58 Mb/sec &nbsp; &nbsp; &nbsp; 53.1 cycles/byte &nbsp; &nbsp; &nbsp;28.23 Mb/sec &nbsp; 19%</pre></td></tr>
<tr class="nocodegen"><td>1076</td><td><pre style="display:inline;"> &nbsp;THash_Haval192 &nbsp;: &nbsp; &nbsp; &nbsp; 32.5 cycles/byte &nbsp; &nbsp; &nbsp;46.17 Mb/sec &nbsp; &nbsp; &nbsp; 37.6 cycles/byte &nbsp; &nbsp; &nbsp;39.87 Mb/sec &nbsp; 18%</pre></td></tr>
<tr class="nocodegen"><td>1077</td><td><pre style="display:inline;"> &nbsp;THash_WhirlpoolT: &nbsp; &nbsp; &nbsp;104.9 cycles/byte &nbsp; &nbsp; &nbsp;14.30 Mb/sec &nbsp; &nbsp; &nbsp;122.8 cycles/byte &nbsp; &nbsp; &nbsp;12.22 Mb/sec &nbsp; 17%</pre></td></tr>
<tr class="nocodegen"><td>1078</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool0: &nbsp; &nbsp; &nbsp;104.7 cycles/byte &nbsp; &nbsp; &nbsp;14.33 Mb/sec &nbsp; &nbsp; &nbsp;119.9 cycles/byte &nbsp; &nbsp; &nbsp;12.51 Mb/sec &nbsp; 15%</pre></td></tr>
<tr class="nocodegen"><td>1079</td><td><pre style="display:inline;"> &nbsp;THash_Sapphire &nbsp;: &nbsp; &nbsp; &nbsp; 52.9 cycles/byte &nbsp; &nbsp; &nbsp;28.35 Mb/sec &nbsp; &nbsp; &nbsp; 53.8 cycles/byte &nbsp; &nbsp; &nbsp;27.86 Mb/sec &nbsp; &nbsp;2%</pre></td></tr>
<tr class="nocodegen"><td>1080</td><td><pre style="display:inline;"> &nbsp;THash_Haval224 &nbsp;: &nbsp; &nbsp; &nbsp; 32.0 cycles/byte &nbsp; &nbsp; &nbsp;46.82 Mb/sec &nbsp; &nbsp; &nbsp; 32.3 cycles/byte &nbsp; &nbsp; &nbsp;46.46 Mb/sec &nbsp; &nbsp;1%</pre></td></tr>
<tr class="nocodegen"><td>1081</td><td><pre style="display:inline;"> &nbsp;THash_SHA256 &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp; 47.8 cycles/byte &nbsp; &nbsp; &nbsp;31.35 Mb/sec &nbsp; &nbsp; &nbsp; 47.8 cycles/byte &nbsp; &nbsp; &nbsp;31.39 Mb/sec &nbsp; &nbsp;0%</pre></td></tr>
<tr class="nocodegen"><td>1082</td><td><pre style="display:inline;"> &nbsp;THash_Panama &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp; &nbsp;8.9 cycles/byte &nbsp; &nbsp; 169.01 Mb/sec &nbsp; &nbsp; &nbsp; &nbsp;7.3 cycles/byte &nbsp; &nbsp; 206.55 Mb/sec &nbsp;-18%</pre></td></tr>
<tr class="nocodegen"><td>1083</td><td><pre style="display:inline;">}</pre></td></tr>
<tr class="nocodegen"><td>1084</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1085</td><td><pre style="display:inline;">resourcestring</pre></td></tr>
<tr class="nocodegen"><td>1086</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1087</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Failure message when a hash algorithm is initialized with wrong parameters</pre></td></tr>
<tr class="nocodegen"><td>1088</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1089</td><td><pre style="display:inline;"> &nbsp;sHashInitFailure &nbsp; = &apos;Invalid %0:s algorithm initialization parameters specified: %1:s&apos;;</pre></td></tr>
<tr class="nocodegen"><td>1090</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1091</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Failure message when absorb is callt with a bitlength not divideable by 8</pre></td></tr>
<tr class="nocodegen"><td>1092</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; without reminder or when it is called while already in squeezing state</pre></td></tr>
<tr class="nocodegen"><td>1093</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1094</td><td><pre style="display:inline;"> &nbsp;sSHA3AbsorbFailure = &apos;Absorb: number of bits mod 8 &lt;&gt; 0 or squeezing active. Bits: %0:d, &apos;+</pre></td></tr>
<tr class="nocodegen"><td>1095</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &apos;Squeezing: %1:s&apos;;</pre></td></tr>
<tr class="nocodegen"><td>1096</td><td><pre style="display:inline;"> &nbsp;/// &lt;summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1097</td><td><pre style="display:inline;"> &nbsp;/// &nbsp; Part of the failure message shown when setting HashSize of Shake algorithms to 0</pre></td></tr>
<tr class="nocodegen"><td>1098</td><td><pre style="display:inline;"> &nbsp;/// &lt;/summary&gt;</pre></td></tr>
<tr class="nocodegen"><td>1099</td><td><pre style="display:inline;"> &nbsp;sHashOutputLength0 = &apos;HashSize must not be 0&apos;;</pre></td></tr>
<tr class="nocodegen"><td>1100</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1101</td><td><pre style="display:inline;">{ THash_MD2 }</pre></td></tr>
<tr class="nocodegen"><td>1102</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1103</td><td><pre style="display:inline;">{$IFNDEF THash_MD2_asm}</pre></td></tr>
<tr class="nocodegen"><td>1104</td><td><pre style="display:inline;">procedure THash_MD2.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>1105</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1106</td><td><pre style="display:inline;"> &nbsp;I, J, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1107</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1108</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>1109</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1110</td><td><pre style="display:inline;"> &nbsp; &nbsp;PUInt32Array(@FDigest[16])[I] := Buffer[I];</pre></td></tr>
<tr class="nocodegen"><td>1111</td><td><pre style="display:inline;"> &nbsp; &nbsp;PUInt32Array(@FDigest[32])[I] := PUInt32Array(@FDigest[0])[I] xor PUInt32Array(@FDigest[16])[I];</pre></td></tr>
<tr class="nocodegen"><td>1112</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1113</td><td><pre style="display:inline;"> &nbsp;T := FDigest[63];</pre></td></tr>
<tr class="nocodegen"><td>1114</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>1115</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1116</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := FDigest[I + 48] xor MD2_PISubst[FDigest[I + 16] xor Byte(T)];</pre></td></tr>
<tr class="nocodegen"><td>1117</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[I + 48] := Byte(T);</pre></td></tr>
<tr class="nocodegen"><td>1118</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1119</td><td><pre style="display:inline;"> &nbsp;T := 0;</pre></td></tr>
<tr class="nocodegen"><td>1120</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 17 do</pre></td></tr>
<tr class="nocodegen"><td>1121</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1122</td><td><pre style="display:inline;"> &nbsp; &nbsp;for J := 0 to 47 do</pre></td></tr>
<tr class="nocodegen"><td>1123</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>1124</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := FDigest[J] xor MD2_PISubst[T];</pre></td></tr>
<tr class="nocodegen"><td>1125</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;FDigest[J] := Byte(T);</pre></td></tr>
<tr class="nocodegen"><td>1126</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1127</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T + I) and $FF;</pre></td></tr>
<tr class="nocodegen"><td>1128</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>1129</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1130</td><td><pre style="display:inline;">{$ENDIF !THash_MD2_asm}</pre></td></tr>
<tr class="nocodegen"><td>1131</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1132</td><td><pre style="display:inline;">procedure THash_MD2.DoInit;</pre></td></tr>
<tr class="covered"><td>1133</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1134</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>1135</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1136</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1137</td><td><pre style="display:inline;">procedure THash_MD2.DoDone;</pre></td></tr>
<tr class="nocodegen"><td>1138</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1139</td><td><pre style="display:inline;"> &nbsp;Remain: Integer;</pre></td></tr>
<tr class="covered"><td>1140</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1141</td><td><pre style="display:inline;"> &nbsp;Remain := FBufferSize - FBufferIndex;</pre></td></tr>
<tr class="covered"><td>1142</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], Remain, Remain);</pre></td></tr>
<tr class="covered"><td>1143</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>1144</td><td><pre style="display:inline;"> &nbsp;Move(FDigest[48], FBuffer^, FBufferSize);</pre></td></tr>
<tr class="covered"><td>1145</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>1146</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1147</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1148</td><td><pre style="display:inline;">function THash_MD2.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>1149</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1150</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>1151</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1152</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1153</td><td><pre style="display:inline;">class function THash_MD2.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>1154</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1155</td><td><pre style="display:inline;"> &nbsp;Result := 16;</pre></td></tr>
<tr class="covered"><td>1156</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1157</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1158</td><td><pre style="display:inline;">class function THash_MD2.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>1159</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1160</td><td><pre style="display:inline;"> &nbsp;Result := 16;</pre></td></tr>
<tr class="covered"><td>1161</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1162</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1163</td><td><pre style="display:inline;">{ THashBaseMD4 }</pre></td></tr>
<tr class="nocodegen"><td>1164</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1165</td><td><pre style="display:inline;">procedure THashBaseMD4.DoInit;</pre></td></tr>
<tr class="covered"><td>1166</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1167</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := $67452301;</pre></td></tr>
<tr class="covered"><td>1168</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := $EFCDAB89;</pre></td></tr>
<tr class="covered"><td>1169</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := $98BADCFE;</pre></td></tr>
<tr class="covered"><td>1170</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := $10325476;</pre></td></tr>
<tr class="covered"><td>1171</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := $C3D2E1F0;</pre></td></tr>
<tr class="covered"><td>1172</td><td><pre style="display:inline;"> &nbsp;FDigest[5] := $76543210;</pre></td></tr>
<tr class="covered"><td>1173</td><td><pre style="display:inline;"> &nbsp;FDigest[6] := $FEDCBA98;</pre></td></tr>
<tr class="covered"><td>1174</td><td><pre style="display:inline;"> &nbsp;FDigest[7] := $89ABCDEF;</pre></td></tr>
<tr class="covered"><td>1175</td><td><pre style="display:inline;"> &nbsp;FDigest[8] := $01234567;</pre></td></tr>
<tr class="covered"><td>1176</td><td><pre style="display:inline;"> &nbsp;FDigest[9] := $3C2D1E0F;</pre></td></tr>
<tr class="covered"><td>1177</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1178</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1179</td><td><pre style="display:inline;">procedure THashBaseMD4.DoDone;</pre></td></tr>
<tr class="covered"><td>1180</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1181</td><td><pre style="display:inline;"> &nbsp;if FCount[2] or FCount[3] &lt;&gt; 0 then</pre></td></tr>
<tr class="notcovered"><td>1182</td><td><pre style="display:inline;"> &nbsp; &nbsp;RaiseHashOverflowError;</pre></td></tr>
<tr class="covered"><td>1183</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="covered"><td>1184</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $80;</pre></td></tr>
<tr class="covered"><td>1185</td><td><pre style="display:inline;"> &nbsp;FBuffer[FBufferIndex] := FPaddingByte;</pre></td></tr>
<tr class="covered"><td>1186</td><td><pre style="display:inline;"> &nbsp;Inc(FBufferIndex);</pre></td></tr>
<tr class="covered"><td>1187</td><td><pre style="display:inline;"> &nbsp;if FBufferIndex &gt; FBufferSize - 8 then</pre></td></tr>
<tr class="nocodegen"><td>1188</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>1189</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>1190</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>1191</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBufferIndex := 0;</pre></td></tr>
<tr class="nocodegen"><td>1192</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>1193</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>1194</td><td><pre style="display:inline;"> &nbsp;Move(FCount, FBuffer[FBufferSize - 8], 8);</pre></td></tr>
<tr class="covered"><td>1195</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>1196</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1197</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1198</td><td><pre style="display:inline;">function THashBaseMD4.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>1199</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1200</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>1201</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1202</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1203</td><td><pre style="display:inline;">class function THashBaseMD4.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>1204</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1205</td><td><pre style="display:inline;"> &nbsp;Result := 16;</pre></td></tr>
<tr class="covered"><td>1206</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1207</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1208</td><td><pre style="display:inline;">class function THashBaseMD4.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>1209</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1210</td><td><pre style="display:inline;"> &nbsp;Result := 64;</pre></td></tr>
<tr class="covered"><td>1211</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1212</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1213</td><td><pre style="display:inline;">{ THash_MD4 }</pre></td></tr>
<tr class="nocodegen"><td>1214</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1215</td><td><pre style="display:inline;">{$IFNDEF THash_MD4_asm}</pre></td></tr>
<tr class="nocodegen"><td>1216</td><td><pre style="display:inline;">procedure THash_MD4.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>1217</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>1218</td><td><pre style="display:inline;"> &nbsp;S1 = $5A827999;</pre></td></tr>
<tr class="nocodegen"><td>1219</td><td><pre style="display:inline;"> &nbsp;S2 = $6ED9EBA1;</pre></td></tr>
<tr class="nocodegen"><td>1220</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1221</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1222</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1223</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1224</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1225</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1226</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1227</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1228</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or not B and D + Buffer[ 0]); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1229</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or not A and C + Buffer[ 1]); D := D shl &nbsp;7 or D shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1230</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or not D and B + Buffer[ 2]); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1231</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or not C and A + Buffer[ 3]); B := B shl 19 or B shr 13;</pre></td></tr>
<tr class="nocodegen"><td>1232</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or not B and D + Buffer[ 4]); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1233</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or not A and C + Buffer[ 5]); D := D shl &nbsp;7 or D shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1234</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or not D and B + Buffer[ 6]); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1235</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or not C and A + Buffer[ 7]); B := B shl 19 or B shr 13;</pre></td></tr>
<tr class="nocodegen"><td>1236</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or not B and D + Buffer[ 8]); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1237</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or not A and C + Buffer[ 9]); D := D shl &nbsp;7 or D shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1238</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or not D and B + Buffer[10]); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1239</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or not C and A + Buffer[11]); B := B shl 19 or B shr 13;</pre></td></tr>
<tr class="nocodegen"><td>1240</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or not B and D + Buffer[12]); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1241</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or not A and C + Buffer[13]); D := D shl &nbsp;7 or D shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1242</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or not D and B + Buffer[14]); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1243</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or not C and A + Buffer[15]); B := B shl 19 or B shr 13;</pre></td></tr>
<tr class="nocodegen"><td>1244</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1245</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or B and D or C and D + Buffer[ 0] + S1); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1246</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or A and C or B and C + Buffer[ 4] + S1); D := D shl &nbsp;5 or D shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1247</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or D and B or A and B + Buffer[ 8] + S1); C := C shl &nbsp;9 or C shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1248</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or C and A or D and A + Buffer[12] + S1); B := B shl 13 or B shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1249</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or B and D or C and D + Buffer[ 1] + S1); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1250</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or A and C or B and C + Buffer[ 5] + S1); D := D shl &nbsp;5 or D shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1251</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or D and B or A and B + Buffer[ 9] + S1); C := C shl &nbsp;9 or C shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1252</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or C and A or D and A + Buffer[13] + S1); B := B shl 13 or B shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1253</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or B and D or C and D + Buffer[ 2] + S1); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1254</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or A and C or B and C + Buffer[ 6] + S1); D := D shl &nbsp;5 or D shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1255</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or D and B or A and B + Buffer[10] + S1); C := C shl &nbsp;9 or C shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1256</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or C and A or D and A + Buffer[14] + S1); B := B shl 13 or B shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1257</td><td><pre style="display:inline;"> &nbsp;Inc(A, B and C or B and D or C and D + Buffer[ 3] + S1); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1258</td><td><pre style="display:inline;"> &nbsp;Inc(D, A and B or A and C or B and C + Buffer[ 7] + S1); D := D shl &nbsp;5 or D shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1259</td><td><pre style="display:inline;"> &nbsp;Inc(C, D and A or D and B or A and B + Buffer[11] + S1); C := C shl &nbsp;9 or C shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1260</td><td><pre style="display:inline;"> &nbsp;Inc(B, C and D or C and A or D and A + Buffer[15] + S1); B := B shl 13 or B shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1261</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1262</td><td><pre style="display:inline;"> &nbsp;Inc(A, B xor C xor D + Buffer[ 0] + S2); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1263</td><td><pre style="display:inline;"> &nbsp;Inc(D, A xor B xor C + Buffer[ 8] + S2); D := D shl &nbsp;9 or D shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1264</td><td><pre style="display:inline;"> &nbsp;Inc(C, D xor A xor B + Buffer[ 4] + S2); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1265</td><td><pre style="display:inline;"> &nbsp;Inc(B, C xor D xor A + Buffer[12] + S2); B := B shl 15 or B shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1266</td><td><pre style="display:inline;"> &nbsp;Inc(A, B xor C xor D + Buffer[ 2] + S2); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1267</td><td><pre style="display:inline;"> &nbsp;Inc(D, A xor B xor C + Buffer[10] + S2); D := D shl &nbsp;9 or D shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1268</td><td><pre style="display:inline;"> &nbsp;Inc(C, D xor A xor B + Buffer[ 6] + S2); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1269</td><td><pre style="display:inline;"> &nbsp;Inc(B, C xor D xor A + Buffer[14] + S2); B := B shl 15 or B shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1270</td><td><pre style="display:inline;"> &nbsp;Inc(A, B xor C xor D + Buffer[ 1] + S2); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1271</td><td><pre style="display:inline;"> &nbsp;Inc(D, A xor B xor C + Buffer[ 9] + S2); D := D shl &nbsp;9 or D shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1272</td><td><pre style="display:inline;"> &nbsp;Inc(C, D xor A xor B + Buffer[ 5] + S2); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1273</td><td><pre style="display:inline;"> &nbsp;Inc(B, C xor D xor A + Buffer[13] + S2); B := B shl 15 or B shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1274</td><td><pre style="display:inline;"> &nbsp;Inc(A, B xor C xor D + Buffer[ 3] + S2); A := A shl &nbsp;3 or A shr 29;</pre></td></tr>
<tr class="nocodegen"><td>1275</td><td><pre style="display:inline;"> &nbsp;Inc(D, A xor B xor C + Buffer[11] + S2); D := D shl &nbsp;9 or D shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1276</td><td><pre style="display:inline;"> &nbsp;Inc(C, D xor A xor B + Buffer[ 7] + S2); C := C shl 11 or C shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1277</td><td><pre style="display:inline;"> &nbsp;Inc(B, C xor D xor A + Buffer[15] + S2); B := B shl 15 or B shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1278</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1279</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>1280</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>1281</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>1282</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>1283</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1284</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>1285</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1286</td><td><pre style="display:inline;">{ THash_MD5 }</pre></td></tr>
<tr class="nocodegen"><td>1287</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1288</td><td><pre style="display:inline;">{$IFNDEF THash_MD5_asm}</pre></td></tr>
<tr class="nocodegen"><td>1289</td><td><pre style="display:inline;">procedure THash_MD5.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>1290</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1291</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1292</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1293</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1294</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1295</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1296</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1297</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1298</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 0] + $D76AA478 + (D xor (B and (C xor D)))); A := A shl &nbsp;7 or A shr 25 + B;</pre></td></tr>
<tr class="nocodegen"><td>1299</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 1] + $E8C7B756 + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;</pre></td></tr>
<tr class="nocodegen"><td>1300</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 2] + $242070DB + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;</pre></td></tr>
<tr class="nocodegen"><td>1301</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 3] + $C1BDCEEE + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;</pre></td></tr>
<tr class="nocodegen"><td>1302</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 4] + $F57C0FAF + (D xor (B and (C xor D)))); A := A shl &nbsp;7 or A shr 25 + B;</pre></td></tr>
<tr class="nocodegen"><td>1303</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 5] + $4787C62A + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;</pre></td></tr>
<tr class="nocodegen"><td>1304</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 6] + $A8304613 + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;</pre></td></tr>
<tr class="nocodegen"><td>1305</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 7] + $FD469501 + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;</pre></td></tr>
<tr class="nocodegen"><td>1306</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 8] + $698098D8 + (D xor (B and (C xor D)))); A := A shl &nbsp;7 or A shr 25 + B;</pre></td></tr>
<tr class="nocodegen"><td>1307</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 9] + $8B44F7AF + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;</pre></td></tr>
<tr class="nocodegen"><td>1308</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[10] + $FFFF5BB1 + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;</pre></td></tr>
<tr class="nocodegen"><td>1309</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[11] + $895CD7BE + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;</pre></td></tr>
<tr class="nocodegen"><td>1310</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[12] + $6B901122 + (D xor (B and (C xor D)))); A := A shl &nbsp;7 or A shr 25 + B;</pre></td></tr>
<tr class="nocodegen"><td>1311</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[13] + $FD987193 + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;</pre></td></tr>
<tr class="nocodegen"><td>1312</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[14] + $A679438E + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;</pre></td></tr>
<tr class="nocodegen"><td>1313</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[15] + $49B40821 + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;</pre></td></tr>
<tr class="nocodegen"><td>1314</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1315</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 1] + $F61E2562 + (C xor (D and (B xor C)))); A := A shl &nbsp;5 or A shr 27 + B;</pre></td></tr>
<tr class="nocodegen"><td>1316</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 6] + $C040B340 + (B xor (C and (A xor B)))); D := D shl &nbsp;9 or D shr 23 + A;</pre></td></tr>
<tr class="nocodegen"><td>1317</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[11] + $265E5A51 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;</pre></td></tr>
<tr class="nocodegen"><td>1318</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 0] + $E9B6C7AA + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;</pre></td></tr>
<tr class="nocodegen"><td>1319</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 5] + $D62F105D + (C xor (D and (B xor C)))); A := A shl &nbsp;5 or A shr 27 + B;</pre></td></tr>
<tr class="nocodegen"><td>1320</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[10] + $02441453 + (B xor (C and (A xor B)))); D := D shl &nbsp;9 or D shr 23 + A;</pre></td></tr>
<tr class="nocodegen"><td>1321</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[15] + $D8A1E681 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;</pre></td></tr>
<tr class="nocodegen"><td>1322</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 4] + $E7D3FBC8 + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;</pre></td></tr>
<tr class="nocodegen"><td>1323</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 9] + $21E1CDE6 + (C xor (D and (B xor C)))); A := A shl &nbsp;5 or A shr 27 + B;</pre></td></tr>
<tr class="nocodegen"><td>1324</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[14] + $C33707D6 + (B xor (C and (A xor B)))); D := D shl &nbsp;9 or D shr 23 + A;</pre></td></tr>
<tr class="nocodegen"><td>1325</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 3] + $F4D50D87 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;</pre></td></tr>
<tr class="nocodegen"><td>1326</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 8] + $455A14ED + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;</pre></td></tr>
<tr class="nocodegen"><td>1327</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[13] + $A9E3E905 + (C xor (D and (B xor C)))); A := A shl &nbsp;5 or A shr 27 + B;</pre></td></tr>
<tr class="nocodegen"><td>1328</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 2] + $FCEFA3F8 + (B xor (C and (A xor B)))); D := D shl &nbsp;9 or D shr 23 + A;</pre></td></tr>
<tr class="nocodegen"><td>1329</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 7] + $676F02D9 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;</pre></td></tr>
<tr class="nocodegen"><td>1330</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[12] + $8D2A4C8A + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;</pre></td></tr>
<tr class="nocodegen"><td>1331</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1332</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 5] + $FFFA3942 + (B xor C xor D)); A := A shl &nbsp;4 or A shr 28 + B;</pre></td></tr>
<tr class="nocodegen"><td>1333</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 8] + $8771F681 + (A xor B xor C)); D := D shl 11 or D shr 21 + A;</pre></td></tr>
<tr class="nocodegen"><td>1334</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[11] + $6D9D6122 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;</pre></td></tr>
<tr class="nocodegen"><td>1335</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[14] + $FDE5380C + (C xor D xor A)); B := B shl 23 or B shr &nbsp;9 + C;</pre></td></tr>
<tr class="nocodegen"><td>1336</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 1] + $A4BEEA44 + (B xor C xor D)); A := A shl &nbsp;4 or A shr 28 + B;</pre></td></tr>
<tr class="nocodegen"><td>1337</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 4] + $4BDECFA9 + (A xor B xor C)); D := D shl 11 or D shr 21 + A;</pre></td></tr>
<tr class="nocodegen"><td>1338</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 7] + $F6BB4B60 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;</pre></td></tr>
<tr class="nocodegen"><td>1339</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[10] + $BEBFBC70 + (C xor D xor A)); B := B shl 23 or B shr &nbsp;9 + C;</pre></td></tr>
<tr class="nocodegen"><td>1340</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[13] + $289B7EC6 + (B xor C xor D)); A := A shl &nbsp;4 or A shr 28 + B;</pre></td></tr>
<tr class="nocodegen"><td>1341</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 0] + $EAA127FA + (A xor B xor C)); D := D shl 11 or D shr 21 + A;</pre></td></tr>
<tr class="nocodegen"><td>1342</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 3] + $D4EF3085 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;</pre></td></tr>
<tr class="nocodegen"><td>1343</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 6] + $04881D05 + (C xor D xor A)); B := B shl 23 or B shr &nbsp;9 + C;</pre></td></tr>
<tr class="nocodegen"><td>1344</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 9] + $D9D4D039 + (B xor C xor D)); A := A shl &nbsp;4 or A shr 28 + B;</pre></td></tr>
<tr class="nocodegen"><td>1345</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[12] + $E6DB99E5 + (A xor B xor C)); D := D shl 11 or D shr 21 + A;</pre></td></tr>
<tr class="nocodegen"><td>1346</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[15] + $1FA27CF8 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;</pre></td></tr>
<tr class="nocodegen"><td>1347</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 2] + $C4AC5665 + (C xor D xor A)); B := B shl 23 or B shr &nbsp;9 + C;</pre></td></tr>
<tr class="nocodegen"><td>1348</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1349</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 0] + $F4292244 + (C xor (B or not D))); A := A shl &nbsp;6 or A shr 26 + B;</pre></td></tr>
<tr class="nocodegen"><td>1350</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 7] + $432AFF97 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;</pre></td></tr>
<tr class="nocodegen"><td>1351</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[14] + $AB9423A7 + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;</pre></td></tr>
<tr class="nocodegen"><td>1352</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 5] + $FC93A039 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;</pre></td></tr>
<tr class="nocodegen"><td>1353</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[12] + $655B59C3 + (C xor (B or not D))); A := A shl &nbsp;6 or A shr 26 + B;</pre></td></tr>
<tr class="nocodegen"><td>1354</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[ 3] + $8F0CCC92 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;</pre></td></tr>
<tr class="nocodegen"><td>1355</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[10] + $FFEFF47D + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;</pre></td></tr>
<tr class="nocodegen"><td>1356</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 1] + $85845DD1 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;</pre></td></tr>
<tr class="nocodegen"><td>1357</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 8] + $6FA87E4F + (C xor (B or not D))); A := A shl &nbsp;6 or A shr 26 + B;</pre></td></tr>
<tr class="nocodegen"><td>1358</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[15] + $FE2CE6E0 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;</pre></td></tr>
<tr class="nocodegen"><td>1359</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 6] + $A3014314 + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;</pre></td></tr>
<tr class="nocodegen"><td>1360</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[13] + $4E0811A1 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;</pre></td></tr>
<tr class="nocodegen"><td>1361</td><td><pre style="display:inline;"> &nbsp;Inc(A, Buffer[ 4] + $F7537E82 + (C xor (B or not D))); A := A shl &nbsp;6 or A shr 26 + B;</pre></td></tr>
<tr class="nocodegen"><td>1362</td><td><pre style="display:inline;"> &nbsp;Inc(D, Buffer[11] + $BD3AF235 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;</pre></td></tr>
<tr class="nocodegen"><td>1363</td><td><pre style="display:inline;"> &nbsp;Inc(C, Buffer[ 2] + $2AD7D2BB + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;</pre></td></tr>
<tr class="nocodegen"><td>1364</td><td><pre style="display:inline;"> &nbsp;Inc(B, Buffer[ 9] + $EB86D391 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;</pre></td></tr>
<tr class="nocodegen"><td>1365</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1366</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>1367</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>1368</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>1369</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>1370</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1371</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>1372</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1373</td><td><pre style="display:inline;">{ THash_RipeMD128 }</pre></td></tr>
<tr class="nocodegen"><td>1374</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1375</td><td><pre style="display:inline;">{$IFNDEF X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1376</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>1377</td><td><pre style="display:inline;"> &nbsp;RipeS1 = $5A827999;</pre></td></tr>
<tr class="nocodegen"><td>1378</td><td><pre style="display:inline;"> &nbsp;RipeS2 = $6ED9EBA1;</pre></td></tr>
<tr class="nocodegen"><td>1379</td><td><pre style="display:inline;"> &nbsp;RipeS3 = $8F1BBCDC;</pre></td></tr>
<tr class="nocodegen"><td>1380</td><td><pre style="display:inline;"> &nbsp;RipeS4 = $A953FD4E;</pre></td></tr>
<tr class="nocodegen"><td>1381</td><td><pre style="display:inline;"> &nbsp;RipeS5 = $50A28BE6;</pre></td></tr>
<tr class="nocodegen"><td>1382</td><td><pre style="display:inline;"> &nbsp;RipeS6 = $5C4DD124;</pre></td></tr>
<tr class="nocodegen"><td>1383</td><td><pre style="display:inline;"> &nbsp;RipeS7 = $6D703EF3;</pre></td></tr>
<tr class="nocodegen"><td>1384</td><td><pre style="display:inline;"> &nbsp;RipeS8 = $7A6D76E9;</pre></td></tr>
<tr class="nocodegen"><td>1385</td><td><pre style="display:inline;">{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>1386</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1387</td><td><pre style="display:inline;">{$IFNDEF THash_RipeMD128_asm}</pre></td></tr>
<tr class="nocodegen"><td>1388</td><td><pre style="display:inline;">procedure THash_RipeMD128.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>1389</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1390</td><td><pre style="display:inline;"> &nbsp;A1, B1, C1, D1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1391</td><td><pre style="display:inline;"> &nbsp;A2, B2, C2, D2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1392</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1393</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1394</td><td><pre style="display:inline;"> &nbsp;A1 := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1395</td><td><pre style="display:inline;"> &nbsp;B1 := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1396</td><td><pre style="display:inline;"> &nbsp;C1 := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1397</td><td><pre style="display:inline;"> &nbsp;D1 := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1398</td><td><pre style="display:inline;"> &nbsp;A2 := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1399</td><td><pre style="display:inline;"> &nbsp;B2 := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1400</td><td><pre style="display:inline;"> &nbsp;C2 := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1401</td><td><pre style="display:inline;"> &nbsp;D2 := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1402</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1403</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1404</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 1]); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1405</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1406</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 3]); B1 := B1 shl 12 or B1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1407</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 4]); A1 := A1 shl &nbsp;5 or A1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1408</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 5]); D1 := D1 shl &nbsp;8 or D1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1409</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 6]); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1410</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 7]); B1 := B1 shl &nbsp;9 or B1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1411</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1412</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 9]); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1413</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 14 or C1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1414</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[11]); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1415</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[12]); A1 := A1 shl &nbsp;6 or A1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1416</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[13]); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1417</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[14]); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1418</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[15]); B1 := B1 shl &nbsp;8 or B1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1419</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1420</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS1); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1421</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 4] + RipeS1); D1 := D1 shl &nbsp;6 or D1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1422</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[13] + RipeS1); C1 := C1 shl &nbsp;8 or C1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1423</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1424</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1425</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1426</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[15] + RipeS1); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1427</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS1); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1428</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[12] + RipeS1); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1429</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS1); D1 := D1 shl 12 or D1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1430</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 9] + RipeS1); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1431</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 5] + RipeS1); B1 := B1 shl &nbsp;9 or B1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1432</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 2] + RipeS1); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1433</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS1); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1434</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[11] + RipeS1); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1435</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 8] + RipeS1); B1 := B1 shl 12 or B1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1436</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1437</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS2); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1438</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[10] + RipeS2); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1439</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[14] + RipeS2); C1 := C1 shl &nbsp;6 or C1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1440</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 4] + RipeS2); B1 := B1 shl &nbsp;7 or B1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1441</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 9] + RipeS2); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1442</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS2); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1443</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1444</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1445</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1446</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); D1 := D1 shl &nbsp;8 or D1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1447</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 0] + RipeS2); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1448</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 6] + RipeS2); B1 := B1 shl &nbsp;6 or B1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1449</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[13] + RipeS2); A1 := A1 shl &nbsp;5 or A1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1450</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS2); D1 := D1 shl 12 or D1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1451</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS2); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1452</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS2); B1 := B1 shl &nbsp;5 or B1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1453</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1454</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS3); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1455</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 9] + RipeS3); D1 := D1 shl 12 or D1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1456</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS3); C1 := C1 shl 14 or C1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1457</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[10] + RipeS3); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1458</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS3); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1459</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS3); D1 := D1 shl 15 or D1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1460</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[12] + RipeS3); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1461</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS3); B1 := B1 shl &nbsp;8 or B1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1462</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS3); A1 := A1 shl &nbsp;9 or A1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1463</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1464</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS3); C1 := C1 shl &nbsp;5 or C1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1465</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[15] + RipeS3); B1 := B1 shl &nbsp;6 or B1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1466</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl &nbsp;8 or A1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1467</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); D1 := D1 shl &nbsp;6 or D1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1468</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); C1 := C1 shl &nbsp;5 or C1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1469</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 2] + RipeS3); B1 := B1 shl 12 or B1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1470</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1471</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1472</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1473</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1474</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1475</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1476</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 5] + RipeS5); A1 := A1 shl &nbsp;8 or A1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1477</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[14] + RipeS5); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1478</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS5); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1479</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 0] + RipeS5); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1480</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 9] + RipeS5); A1 := A1 shl 13 or A1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1481</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS5); D1 := D1 shl 15 or D1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1482</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS5); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1483</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS5); B1 := B1 shl &nbsp;5 or B1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1484</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS5); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1485</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS5); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1486</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[15] + RipeS5); C1 := C1 shl &nbsp;8 or C1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1487</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 8] + RipeS5); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1488</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS5); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1489</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS5); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1490</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS5); C1 := C1 shl 12 or C1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1491</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[12] + RipeS5); B1 := B1 shl &nbsp;6 or B1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1492</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1493</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 6] + RipeS6); A1 := A1 shl &nbsp;9 or A1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1494</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1495</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1496</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 7] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1497</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1498</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[13] + RipeS6); D1 := D1 shl &nbsp;8 or D1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1499</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS6); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1500</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[10] + RipeS6); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1501</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[14] + RipeS6); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1502</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS6); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1503</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS6); C1 := C1 shl 12 or C1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1504</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1505</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS6); A1 := A1 shl &nbsp;6 or A1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1506</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS6); D1 := D1 shl 15 or D1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1507</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 1] + RipeS6); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1508</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 2] + RipeS6); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1509</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1510</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[15] + RipeS7); A1 := A1 shl &nbsp;9 or A1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1511</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS7); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1512</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 1] + RipeS7); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1513</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS7); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1514</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS7); A1 := A1 shl &nbsp;8 or A1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1515</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS7); D1 := D1 shl &nbsp;6 or D1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1516</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 6] + RipeS7); C1 := C1 shl &nbsp;6 or C1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1517</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1518</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1519</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS7); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1520</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[12] + RipeS7); C1 := C1 shl &nbsp;5 or C1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1521</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 2] + RipeS7); B1 := B1 shl 14 or B1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1522</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS7); A1 := A1 shl 13 or A1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1523</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS7); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1524</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 4] + RipeS7); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1525</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[13] + RipeS7); B1 := B1 shl &nbsp;5 or B1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1526</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1527</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 15 or A1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1528</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 6]); D1 := D1 shl &nbsp;5 or D1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1529</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 4]); C1 := C1 shl &nbsp;8 or C1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1530</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 1]); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1531</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 3]); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1532</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[11]); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1533</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[15]); C1 := C1 shl &nbsp;6 or C1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1534</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 0]); B1 := B1 shl 14 or B1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1535</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl &nbsp;6 or A1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1536</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[12]); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1537</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 12 or C1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1538</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[13]); B1 := B1 shl &nbsp;9 or B1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1539</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 9]); A1 := A1 shl 12 or A1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1540</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 7]); D1 := D1 shl &nbsp;5 or D1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1541</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1542</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[14]); B1 := B1 shl &nbsp;8 or B1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1543</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1544</td><td><pre style="display:inline;"> &nbsp;Inc(D1, C2 + FDigest[1]);</pre></td></tr>
<tr class="nocodegen"><td>1545</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := FDigest[2] + D2 + A1;</pre></td></tr>
<tr class="nocodegen"><td>1546</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := FDigest[3] + A2 + B1;</pre></td></tr>
<tr class="nocodegen"><td>1547</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := FDIgest[0] + B2 + C1;</pre></td></tr>
<tr class="nocodegen"><td>1548</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := D1;</pre></td></tr>
<tr class="nocodegen"><td>1549</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1550</td><td><pre style="display:inline;">{$ENDIF !THash_RipeMD128_asm}</pre></td></tr>
<tr class="nocodegen"><td>1551</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1552</td><td><pre style="display:inline;">{ THash_RipeMD160 }</pre></td></tr>
<tr class="nocodegen"><td>1553</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1554</td><td><pre style="display:inline;">{$IFNDEF THash_RipeMD160_asm}</pre></td></tr>
<tr class="nocodegen"><td>1555</td><td><pre style="display:inline;">procedure THash_RipeMD160.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>1556</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1557</td><td><pre style="display:inline;"> &nbsp;A1, B1, C1, D1, E1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1558</td><td><pre style="display:inline;"> &nbsp;A2, B2, C2, D2, E2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1559</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1560</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1561</td><td><pre style="display:inline;"> &nbsp;A1 := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1562</td><td><pre style="display:inline;"> &nbsp;B1 := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1563</td><td><pre style="display:inline;"> &nbsp;C1 := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1564</td><td><pre style="display:inline;"> &nbsp;D1 := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1565</td><td><pre style="display:inline;"> &nbsp;E1 := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>1566</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1567</td><td><pre style="display:inline;"> &nbsp;A2 := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1568</td><td><pre style="display:inline;"> &nbsp;B2 := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1569</td><td><pre style="display:inline;"> &nbsp;C2 := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1570</td><td><pre style="display:inline;"> &nbsp;D2 := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1571</td><td><pre style="display:inline;"> &nbsp;E2 := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>1572</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1573</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1574</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 1]); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1575</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 2]); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1576</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 3]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1577</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[ 4]); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1578</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1579</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 6]); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1580</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 7]); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1581</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 8]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1582</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[ 9]); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1583</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[10]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1584</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[11]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1585</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[12]); D1 := D1 shl &nbsp;6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1586</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[13]); C1 := C1 shl &nbsp;7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1587</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[14]); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1588</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1589</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1590</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS1); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1591</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 4] + RipeS1); D1 := D1 shl &nbsp;6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1592</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[13] + RipeS1); C1 := C1 shl &nbsp;8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1593</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1594</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1595</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1596</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[15] + RipeS1); D1 := D1 shl &nbsp;7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1597</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 3] + RipeS1); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1598</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[12] + RipeS1); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1599</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS1); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1600</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 9] + RipeS1); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1601</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 5] + RipeS1); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1602</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS1); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1603</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[14] + RipeS1); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1604</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS1); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1605</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS1); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1606</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1607</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[ 3] + RipeS2); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1608</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[10] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1609</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[14] + RipeS2); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1610</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS2); A1 := A1 shl &nbsp;7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1611</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS2); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1612</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS2); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1613</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1614</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1615</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1616</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); E1 := E1 shl &nbsp;8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1617</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[ 0] + RipeS2); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1618</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS2); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1619</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[13] + RipeS2); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1620</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS2); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1621</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 5] + RipeS2); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1622</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS2); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1623</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1624</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 1] + RipeS3); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1625</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS3); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1626</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[11] + RipeS3); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1627</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS3); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1628</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 0] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1629</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 8] + RipeS3); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1630</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[12] + RipeS3); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1631</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 4] + RipeS3); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1632</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS3); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1633</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1634</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 7] + RipeS3); C1 := C1 shl &nbsp;5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1635</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[15] + RipeS3); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1636</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1637</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); E1 := E1 shl &nbsp;6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1638</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1639</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 2] + RipeS3); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1640</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1641</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 4] + RipeS4); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1642</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 0] + RipeS4); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1643</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[ 5] + RipeS4); E1 := E1 shl &nbsp;5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1644</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 9] + RipeS4); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1645</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[ 7] + RipeS4); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1646</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[12] + RipeS4); B1 := B1 shl &nbsp;8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1647</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS4); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1648</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[10] + RipeS4); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1649</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[14] + RipeS4); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1650</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[ 1] + RipeS4); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1651</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS4); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1652</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 8] + RipeS4); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1653</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS4); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1654</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 6] + RipeS4); D1 := D1 shl &nbsp;8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1655</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[15] + RipeS4); C1 := C1 shl &nbsp;5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1656</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[13] + RipeS4); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1657</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1658</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1659</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1660</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1661</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1662</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1663</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1664</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 5] + RipeS5); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1665</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[14] + RipeS5); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1666</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 7] + RipeS5); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1667</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[ 0] + RipeS5); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1668</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 9] + RipeS5); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1669</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS5); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1670</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS5); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1671</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 4] + RipeS5); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1672</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[13] + RipeS5); C1 := C1 shl &nbsp;7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1673</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 6] + RipeS5); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1674</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[15] + RipeS5); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1675</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[ 8] + RipeS5); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1676</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 1] + RipeS5); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1677</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[10] + RipeS5); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1678</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS5); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1679</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[12] + RipeS5); A1 := A1 shl &nbsp;6 or A1 shr 26 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1680</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1681</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS6); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1682</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1683</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1684</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 7] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1685</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1686</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS6); E1 := E1 shl &nbsp;8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1687</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 5] + RipeS6); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1688</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[10] + RipeS6); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1689</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[14] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1690</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[15] + RipeS6); A1 := A1 shl &nbsp;7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1691</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS6); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1692</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[12] + RipeS6); D1 := D1 shl &nbsp;7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1693</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 4] + RipeS6); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1694</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS6); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1695</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS6); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1696</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS6); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1697</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1698</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS7); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1699</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 5] + RipeS7); C1 := C1 shl &nbsp;7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1700</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS7); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1701</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS7); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1702</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS7); E1 := E1 shl &nbsp;8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1703</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[14] + RipeS7); D1 := D1 shl &nbsp;6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1704</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS7); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1705</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1706</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1707</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 8] + RipeS7); E1 := E1 shl 13 or E1 shr 19 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1708</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS7); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1709</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 2] + RipeS7); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1710</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[10] + RipeS7); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1711</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS7); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1712</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 4] + RipeS7); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1713</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[13] + RipeS7); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1714</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1715</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 8] + RipeS8); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1716</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 6] + RipeS8); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1717</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 4] + RipeS8); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1718</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 1] + RipeS8); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1719</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 3] + RipeS8); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1720</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[11] + RipeS8); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1721</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[15] + RipeS8); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1722</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS8); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1723</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS8); E1 := E1 shl &nbsp;6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1724</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[12] + RipeS8); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1725</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS8); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1726</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[13] + RipeS8); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1727</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 9] + RipeS8); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1728</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS8); E1 := E1 shl &nbsp;5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1729</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[10] + RipeS8); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1730</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[14] + RipeS8); C1 := C1 shl &nbsp;8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1731</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1732</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[12]); B1 := B1 shl &nbsp;8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1733</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl &nbsp;5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1734</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[10]); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1735</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 4]); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1736</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 1]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1737</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[ 5]); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1738</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1739</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 7]); E1 := E1 shl &nbsp;6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1740</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 6]); D1 := D1 shl &nbsp;8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1741</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 2]); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1742</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[13]); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1743</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[14]); A1 := A1 shl &nbsp;5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1744</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 0]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1745</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 3]); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1746</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 9]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1747</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[11]); B1 := B1 shl 11 or B1 shr 21 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>1748</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1749</td><td><pre style="display:inline;"> &nbsp;Inc(D1, C2 + FDigest[1]);</pre></td></tr>
<tr class="nocodegen"><td>1750</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := FDigest[2] + D2 + E1;</pre></td></tr>
<tr class="nocodegen"><td>1751</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := FDigest[3] + E2 + A1;</pre></td></tr>
<tr class="nocodegen"><td>1752</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := FDigest[4] + A2 + B1;</pre></td></tr>
<tr class="nocodegen"><td>1753</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := FDigest[0] + B2 + C1;</pre></td></tr>
<tr class="nocodegen"><td>1754</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := D1;</pre></td></tr>
<tr class="nocodegen"><td>1755</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1756</td><td><pre style="display:inline;">{$ENDIF !THash_RipeMD160_asm}</pre></td></tr>
<tr class="nocodegen"><td>1757</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1758</td><td><pre style="display:inline;">class function THash_RipeMD160.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>1759</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1760</td><td><pre style="display:inline;"> &nbsp;Result := 20;</pre></td></tr>
<tr class="covered"><td>1761</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1762</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1763</td><td><pre style="display:inline;">{ THash_RipeMD256 }</pre></td></tr>
<tr class="nocodegen"><td>1764</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1765</td><td><pre style="display:inline;">{$IFNDEF THash_RipeMD256_asm}</pre></td></tr>
<tr class="nocodegen"><td>1766</td><td><pre style="display:inline;">procedure THash_RipeMD256.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>1767</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1768</td><td><pre style="display:inline;"> &nbsp;A1, B1, C1, D1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1769</td><td><pre style="display:inline;"> &nbsp;A2, B2, C2, D2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1770</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1771</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1772</td><td><pre style="display:inline;"> &nbsp;A1 := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1773</td><td><pre style="display:inline;"> &nbsp;B1 := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1774</td><td><pre style="display:inline;"> &nbsp;C1 := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1775</td><td><pre style="display:inline;"> &nbsp;D1 := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1776</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1777</td><td><pre style="display:inline;"> &nbsp;A2 := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>1778</td><td><pre style="display:inline;"> &nbsp;B2 := FDigest[5];</pre></td></tr>
<tr class="nocodegen"><td>1779</td><td><pre style="display:inline;"> &nbsp;C2 := FDigest[6];</pre></td></tr>
<tr class="nocodegen"><td>1780</td><td><pre style="display:inline;"> &nbsp;D2 := FDigest[7];</pre></td></tr>
<tr class="nocodegen"><td>1781</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1782</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1783</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 1]); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1784</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1785</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 3]); B1 := B1 shl 12 or B1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1786</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 4]); A1 := A1 shl &nbsp;5 or A1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1787</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 5]); D1 := D1 shl &nbsp;8 or D1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1788</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 6]); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1789</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 7]); B1 := B1 shl &nbsp;9 or B1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1790</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1791</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 9]); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1792</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 14 or C1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1793</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[11]); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1794</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[12]); A1 := A1 shl &nbsp;6 or A1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1795</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[13]); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1796</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[14]); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1797</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[15]); B1 := B1 shl &nbsp;8 or B1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1798</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1799</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1800</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1801</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1802</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1803</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1804</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 5] + RipeS5); A1 := A1 shl &nbsp;8 or A1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1805</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[14] + RipeS5); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1806</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS5); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1807</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 0] + RipeS5); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1808</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 9] + RipeS5); A1 := A1 shl 13 or A1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1809</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS5); D1 := D1 shl 15 or D1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1810</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS5); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1811</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS5); B1 := B1 shl &nbsp;5 or B1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1812</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS5); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1813</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS5); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1814</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[15] + RipeS5); C1 := C1 shl &nbsp;8 or C1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1815</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 8] + RipeS5); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1816</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS5); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1817</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS5); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1818</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS5); C1 := C1 shl 12 or C1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1819</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[12] + RipeS5); B1 := B1 shl &nbsp;6 or B1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1820</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1821</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1822</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1823</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1824</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1825</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS1); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1826</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 4] + RipeS1); D1 := D1 shl &nbsp;6 or D1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1827</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[13] + RipeS1); C1 := C1 shl &nbsp;8 or C1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1828</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1829</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1830</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1831</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[15] + RipeS1); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1832</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS1); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1833</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[12] + RipeS1); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1834</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS1); D1 := D1 shl 12 or D1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1835</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 9] + RipeS1); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1836</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 5] + RipeS1); B1 := B1 shl &nbsp;9 or B1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1837</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 2] + RipeS1); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1838</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS1); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1839</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[11] + RipeS1); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1840</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 8] + RipeS1); B1 := B1 shl 12 or B1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1841</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1842</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1843</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1844</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1845</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1846</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1847</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 6] + RipeS6); A1 := A1 shl &nbsp;9 or A1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1848</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1849</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1850</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 7] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1851</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1852</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[13] + RipeS6); D1 := D1 shl &nbsp;8 or D1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1853</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS6); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1854</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[10] + RipeS6); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1855</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[14] + RipeS6); A1 := A1 shl &nbsp;7 or A1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1856</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS6); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1857</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS6); C1 := C1 shl 12 or C1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1858</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1859</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS6); A1 := A1 shl &nbsp;6 or A1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1860</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS6); D1 := D1 shl 15 or D1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1861</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 1] + RipeS6); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1862</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 2] + RipeS6); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1863</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1864</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1865</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1866</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1867</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1868</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS2); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1869</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[10] + RipeS2); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1870</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[14] + RipeS2); C1 := C1 shl &nbsp;6 or C1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1871</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 4] + RipeS2); B1 := B1 shl &nbsp;7 or B1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1872</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 9] + RipeS2); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1873</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS2); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1874</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1875</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1876</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1877</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); D1 := D1 shl &nbsp;8 or D1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1878</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 0] + RipeS2); C1 := C1 shl 13 or C1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1879</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[ 6] + RipeS2); B1 := B1 shl &nbsp;6 or B1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1880</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[13] + RipeS2); A1 := A1 shl &nbsp;5 or A1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1881</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS2); D1 := D1 shl 12 or D1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1882</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS2); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1883</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS2); B1 := B1 shl &nbsp;5 or B1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1884</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1885</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1886</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1887</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1888</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1889</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1890</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[15] + RipeS7); A1 := A1 shl &nbsp;9 or A1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1891</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS7); D1 := D1 shl &nbsp;7 or D1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1892</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 1] + RipeS7); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1893</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS7); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1894</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS7); A1 := A1 shl &nbsp;8 or A1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1895</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS7); D1 := D1 shl &nbsp;6 or D1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1896</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 6] + RipeS7); C1 := C1 shl &nbsp;6 or C1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1897</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1898</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1899</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS7); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1900</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[12] + RipeS7); C1 := C1 shl &nbsp;5 or C1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1901</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 2] + RipeS7); B1 := B1 shl 14 or B1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1902</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS7); A1 := A1 shl 13 or A1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1903</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS7); D1 := D1 shl 13 or D1 shr 19;</pre></td></tr>
<tr class="nocodegen"><td>1904</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 4] + RipeS7); C1 := C1 shl &nbsp;7 or C1 shr 25;</pre></td></tr>
<tr class="nocodegen"><td>1905</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and A1 + Buffer[13] + RipeS7); B1 := B1 shl &nbsp;5 or B1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1906</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1907</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1908</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1909</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1910</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1911</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS3); A1 := A1 shl 11 or A1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1912</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 9] + RipeS3); D1 := D1 shl 12 or D1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1913</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS3); C1 := C1 shl 14 or C1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1914</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[10] + RipeS3); B1 := B1 shl 15 or B1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1915</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS3); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1916</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS3); D1 := D1 shl 15 or D1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1917</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[12] + RipeS3); C1 := C1 shl &nbsp;9 or C1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1918</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS3); B1 := B1 shl &nbsp;8 or B1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1919</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS3); A1 := A1 shl &nbsp;9 or A1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1920</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1921</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS3); C1 := C1 shl &nbsp;5 or C1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1922</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[15] + RipeS3); B1 := B1 shl &nbsp;6 or B1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1923</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl &nbsp;8 or A1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1924</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); D1 := D1 shl &nbsp;6 or D1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1925</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); C1 := C1 shl &nbsp;5 or C1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1926</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 2] + RipeS3); B1 := B1 shl 12 or B1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1927</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1928</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1929</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1930</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1931</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>1932</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1933</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 15 or A1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1934</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 6]); D1 := D1 shl &nbsp;5 or D1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1935</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 4]); C1 := C1 shl &nbsp;8 or C1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1936</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 1]); B1 := B1 shl 11 or B1 shr 21;</pre></td></tr>
<tr class="nocodegen"><td>1937</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 3]); A1 := A1 shl 14 or A1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1938</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[11]); D1 := D1 shl 14 or D1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1939</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[15]); C1 := C1 shl &nbsp;6 or C1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1940</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[ 0]); B1 := B1 shl 14 or B1 shr 18;</pre></td></tr>
<tr class="nocodegen"><td>1941</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl &nbsp;6 or A1 shr 26;</pre></td></tr>
<tr class="nocodegen"><td>1942</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[12]); D1 := D1 shl &nbsp;9 or D1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1943</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 12 or C1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1944</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[13]); B1 := B1 shl &nbsp;9 or B1 shr 23;</pre></td></tr>
<tr class="nocodegen"><td>1945</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 9]); A1 := A1 shl 12 or A1 shr 20;</pre></td></tr>
<tr class="nocodegen"><td>1946</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 xor B1 xor C1 + Buffer[ 7]); D1 := D1 shl &nbsp;5 or D1 shr 27;</pre></td></tr>
<tr class="nocodegen"><td>1947</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 15 or C1 shr 17;</pre></td></tr>
<tr class="nocodegen"><td>1948</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor A1 + Buffer[14]); B1 := B1 shl &nbsp;8 or B1 shr 24;</pre></td></tr>
<tr class="nocodegen"><td>1949</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1950</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A2);</pre></td></tr>
<tr class="nocodegen"><td>1951</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B2);</pre></td></tr>
<tr class="nocodegen"><td>1952</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C2);</pre></td></tr>
<tr class="nocodegen"><td>1953</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D1);</pre></td></tr>
<tr class="nocodegen"><td>1954</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1955</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], A1);</pre></td></tr>
<tr class="nocodegen"><td>1956</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[5], B1);</pre></td></tr>
<tr class="nocodegen"><td>1957</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[6], C1);</pre></td></tr>
<tr class="nocodegen"><td>1958</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[7], D2);</pre></td></tr>
<tr class="nocodegen"><td>1959</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1960</td><td><pre style="display:inline;">{$ENDIF !THash_RipeMD256_asm}</pre></td></tr>
<tr class="nocodegen"><td>1961</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1962</td><td><pre style="display:inline;">procedure THash_RipeMD256.DoInit;</pre></td></tr>
<tr class="covered"><td>1963</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1964</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := $67452301;</pre></td></tr>
<tr class="covered"><td>1965</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := $EFCDAB89;</pre></td></tr>
<tr class="covered"><td>1966</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := $98BADCFE;</pre></td></tr>
<tr class="covered"><td>1967</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := $10325476;</pre></td></tr>
<tr class="covered"><td>1968</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := $76543210;</pre></td></tr>
<tr class="covered"><td>1969</td><td><pre style="display:inline;"> &nbsp;FDigest[5] := $FEDCBA98;</pre></td></tr>
<tr class="covered"><td>1970</td><td><pre style="display:inline;"> &nbsp;FDigest[6] := $89ABCDEF;</pre></td></tr>
<tr class="covered"><td>1971</td><td><pre style="display:inline;"> &nbsp;FDigest[7] := $01234567;</pre></td></tr>
<tr class="covered"><td>1972</td><td><pre style="display:inline;"> &nbsp;FDigest[8] := $01234567;</pre></td></tr>
<tr class="covered"><td>1973</td><td><pre style="display:inline;"> &nbsp;FDigest[9] := $3C2D1E0F;</pre></td></tr>
<tr class="covered"><td>1974</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1975</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1976</td><td><pre style="display:inline;">class function THash_RipeMD256.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>1977</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>1978</td><td><pre style="display:inline;"> &nbsp;Result := 32;</pre></td></tr>
<tr class="covered"><td>1979</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>1980</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1981</td><td><pre style="display:inline;">{ THash_RipeMD320 }</pre></td></tr>
<tr class="nocodegen"><td>1982</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>1983</td><td><pre style="display:inline;">{$IFNDEF THash_RipeMD320_asm}</pre></td></tr>
<tr class="nocodegen"><td>1984</td><td><pre style="display:inline;">procedure THash_RipeMD320.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>1985</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>1986</td><td><pre style="display:inline;"> &nbsp;A1, B1, C1, D1, E1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1987</td><td><pre style="display:inline;"> &nbsp;A2, B2, C2, D2, E2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1988</td><td><pre style="display:inline;"> &nbsp;T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>1989</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>1990</td><td><pre style="display:inline;"> &nbsp;A1 := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>1991</td><td><pre style="display:inline;"> &nbsp;B1 := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>1992</td><td><pre style="display:inline;"> &nbsp;C1 := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>1993</td><td><pre style="display:inline;"> &nbsp;D1 := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>1994</td><td><pre style="display:inline;"> &nbsp;E1 := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>1995</td><td><pre style="display:inline;"> &nbsp;A2 := FDigest[5];</pre></td></tr>
<tr class="nocodegen"><td>1996</td><td><pre style="display:inline;"> &nbsp;B2 := FDigest[6];</pre></td></tr>
<tr class="nocodegen"><td>1997</td><td><pre style="display:inline;"> &nbsp;C2 := FDigest[7];</pre></td></tr>
<tr class="nocodegen"><td>1998</td><td><pre style="display:inline;"> &nbsp;D2 := FDigest[8];</pre></td></tr>
<tr class="nocodegen"><td>1999</td><td><pre style="display:inline;"> &nbsp;E2 := FDigest[9];</pre></td></tr>
<tr class="nocodegen"><td>2000</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2001</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2002</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 1]); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2003</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 2]); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2004</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 3]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2005</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[ 4]); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2006</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2007</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 6]); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2008</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 7]); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2009</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 8]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2010</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[ 9]); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2011</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[10]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2012</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[11]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2013</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[12]); D1 := D1 shl &nbsp;6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2014</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[13]); C1 := C1 shl &nbsp;7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2015</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[14]); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2016</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2017</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2018</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2019</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2020</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2021</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2022</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2023</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2024</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 5] + RipeS5); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2025</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[14] + RipeS5); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2026</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 7] + RipeS5); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2027</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[ 0] + RipeS5); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2028</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 9] + RipeS5); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2029</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS5); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2030</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS5); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2031</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 4] + RipeS5); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2032</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[13] + RipeS5); C1 := C1 shl &nbsp;7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2033</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 6] + RipeS5); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2034</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[15] + RipeS5); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2035</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[ 8] + RipeS5); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2036</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 1] + RipeS5); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2037</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[10] + RipeS5); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2038</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS5); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2039</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[12] + RipeS5); A1 := A1 shl &nbsp;6 or A1 shr 26 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2040</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2041</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2042</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2043</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2044</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2045</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2046</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS1); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2047</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 4] + RipeS1); D1 := D1 shl &nbsp;6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2048</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[13] + RipeS1); C1 := C1 shl &nbsp;8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2049</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2050</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2051</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2052</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[15] + RipeS1); D1 := D1 shl &nbsp;7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2053</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 3] + RipeS1); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2054</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[12] + RipeS1); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2055</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS1); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2056</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 9] + RipeS1); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2057</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 5] + RipeS1); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2058</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS1); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2059</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[14] + RipeS1); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2060</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS1); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2061</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS1); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2062</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2063</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2064</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2065</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2066</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2067</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2068</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2069</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS6); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2070</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2071</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2072</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 7] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2073</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2074</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS6); E1 := E1 shl &nbsp;8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2075</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 5] + RipeS6); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2076</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[10] + RipeS6); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2077</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[14] + RipeS6); B1 := B1 shl &nbsp;7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2078</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[15] + RipeS6); A1 := A1 shl &nbsp;7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2079</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS6); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2080</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[12] + RipeS6); D1 := D1 shl &nbsp;7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2081</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 4] + RipeS6); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2082</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS6); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2083</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS6); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2084</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS6); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2085</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2086</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2087</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2088</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2089</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2090</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2091</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[ 3] + RipeS2); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2092</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[10] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2093</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[14] + RipeS2); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2094</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS2); A1 := A1 shl &nbsp;7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2095</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS2); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2096</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS2); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2097</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2098</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2099</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2100</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); E1 := E1 shl &nbsp;8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2101</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[ 0] + RipeS2); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2102</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS2); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2103</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[13] + RipeS2); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2104</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS2); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2105</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 5] + RipeS2); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2106</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS2); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2107</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2108</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2109</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2110</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2111</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2112</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2113</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2114</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS7); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2115</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 5] + RipeS7); C1 := C1 shl &nbsp;7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2116</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS7); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2117</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS7); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2118</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS7); E1 := E1 shl &nbsp;8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2119</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[14] + RipeS7); D1 := D1 shl &nbsp;6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2120</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS7); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2121</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2122</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2123</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 8] + RipeS7); E1 := E1 shl 13 or E1 shr 19 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2124</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS7); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2125</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 or not E1 xor A1 + Buffer[ 2] + RipeS7); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2126</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 or not D1 xor E1 + Buffer[10] + RipeS7); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2127</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS7); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2128</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 or not B1 xor C1 + Buffer[ 4] + RipeS7); E1 := E1 shl &nbsp;7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2129</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 or not A1 xor B1 + Buffer[13] + RipeS7); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2130</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2131</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2132</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2133</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2134</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2135</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2136</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 1] + RipeS3); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2137</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS3); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2138</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[11] + RipeS3); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2139</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS3); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2140</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 0] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2141</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 8] + RipeS3); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2142</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[12] + RipeS3); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2143</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 4] + RipeS3); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2144</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS3); E1 := E1 shl &nbsp;9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2145</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2146</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 7] + RipeS3); C1 := C1 shl &nbsp;5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2147</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and E1 or D1 and not E1 + Buffer[15] + RipeS3); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2148</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2149</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); E1 := E1 shl &nbsp;6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2150</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2151</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 2] + RipeS3); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2152</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2153</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2154</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2155</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2156</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2157</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2158</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2159</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 8] + RipeS8); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2160</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 6] + RipeS8); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2161</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 4] + RipeS8); A1 := A1 shl &nbsp;8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2162</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 1] + RipeS8); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2163</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 3] + RipeS8); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2164</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[11] + RipeS8); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2165</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[15] + RipeS8); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2166</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS8); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2167</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS8); E1 := E1 shl &nbsp;6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2168</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[12] + RipeS8); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2169</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS8); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2170</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 and D1 or not C1 and E1 + Buffer[13] + RipeS8); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2171</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 9] + RipeS8); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2172</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS8); E1 := E1 shl &nbsp;5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2173</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 and A1 or not E1 and B1 + Buffer[10] + RipeS8); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2174</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 and E1 or not D1 and A1 + Buffer[14] + RipeS8); C1 := C1 shl &nbsp;8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2175</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2176</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2177</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2178</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2179</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2180</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2181</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 4] + RipeS4); B1 := B1 shl &nbsp;9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2182</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 0] + RipeS4); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2183</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[ 5] + RipeS4); E1 := E1 shl &nbsp;5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2184</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 9] + RipeS4); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2185</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[ 7] + RipeS4); C1 := C1 shl &nbsp;6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2186</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[12] + RipeS4); B1 := B1 shl &nbsp;8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2187</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS4); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2188</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[10] + RipeS4); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2189</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[14] + RipeS4); D1 := D1 shl &nbsp;5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2190</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[ 1] + RipeS4); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2191</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS4); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2192</td><td><pre style="display:inline;"> &nbsp;Inc(A1, C1 or not D1 xor B1 + Buffer[ 8] + RipeS4); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2193</td><td><pre style="display:inline;"> &nbsp;Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS4); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2194</td><td><pre style="display:inline;"> &nbsp;Inc(D1, A1 or not B1 xor E1 + Buffer[ 6] + RipeS4); D1 := D1 shl &nbsp;8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2195</td><td><pre style="display:inline;"> &nbsp;Inc(C1, E1 or not A1 xor D1 + Buffer[15] + RipeS4); C1 := C1 shl &nbsp;5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2196</td><td><pre style="display:inline;"> &nbsp;Inc(B1, D1 or not E1 xor C1 + Buffer[13] + RipeS4); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2197</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2198</td><td><pre style="display:inline;"> &nbsp;T := A1; A1 := A2; A2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2199</td><td><pre style="display:inline;"> &nbsp;T := B1; B1 := B2; B2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2200</td><td><pre style="display:inline;"> &nbsp;T := C1; C1 := C2; C2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2201</td><td><pre style="display:inline;"> &nbsp;T := D1; D1 := D2; D2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2202</td><td><pre style="display:inline;"> &nbsp;T := E1; E1 := E2; E2 := T;</pre></td></tr>
<tr class="nocodegen"><td>2203</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2204</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[12]); B1 := B1 shl &nbsp;8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2205</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl &nbsp;5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2206</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[10]); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2207</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 4]); D1 := D1 shl &nbsp;9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2208</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 1]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2209</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[ 5]); B1 := B1 shl &nbsp;5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2210</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2211</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 7]); E1 := E1 shl &nbsp;6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2212</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 6]); D1 := D1 shl &nbsp;8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2213</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 2]); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2214</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[13]); B1 := B1 shl &nbsp;6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2215</td><td><pre style="display:inline;"> &nbsp;Inc(A1, B1 xor C1 xor D1 + Buffer[14]); A1 := A1 shl &nbsp;5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2216</td><td><pre style="display:inline;"> &nbsp;Inc(E1, A1 xor B1 xor C1 + Buffer[ 0]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2217</td><td><pre style="display:inline;"> &nbsp;Inc(D1, E1 xor A1 xor B1 + Buffer[ 3]); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2218</td><td><pre style="display:inline;"> &nbsp;Inc(C1, D1 xor E1 xor A1 + Buffer[ 9]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2219</td><td><pre style="display:inline;"> &nbsp;Inc(B1, C1 xor D1 xor E1 + Buffer[11]); B1 := B1 shl 11 or B1 shr 21 + A1; D1 := D1 shl 10 or D1 shr 22;</pre></td></tr>
<tr class="nocodegen"><td>2220</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2221</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A2);</pre></td></tr>
<tr class="nocodegen"><td>2222</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B2);</pre></td></tr>
<tr class="nocodegen"><td>2223</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C2);</pre></td></tr>
<tr class="nocodegen"><td>2224</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D2);</pre></td></tr>
<tr class="nocodegen"><td>2225</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], E1);</pre></td></tr>
<tr class="nocodegen"><td>2226</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[5], A1);</pre></td></tr>
<tr class="nocodegen"><td>2227</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[6], B1);</pre></td></tr>
<tr class="nocodegen"><td>2228</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[7], C1);</pre></td></tr>
<tr class="nocodegen"><td>2229</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[8], D1);</pre></td></tr>
<tr class="nocodegen"><td>2230</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[9], E2);</pre></td></tr>
<tr class="nocodegen"><td>2231</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2232</td><td><pre style="display:inline;">{$ENDIF !THash_RipeMD320_asm}</pre></td></tr>
<tr class="nocodegen"><td>2233</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2234</td><td><pre style="display:inline;">class function THash_RipeMD320.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2235</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2236</td><td><pre style="display:inline;"> &nbsp;Result := 40;</pre></td></tr>
<tr class="covered"><td>2237</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2238</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2239</td><td><pre style="display:inline;">{ THash_SHA }</pre></td></tr>
<tr class="nocodegen"><td>2240</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2241</td><td><pre style="display:inline;">{$IFNDEF THash_SHA_asm}</pre></td></tr>
<tr class="nocodegen"><td>2242</td><td><pre style="display:inline;">procedure THash_SHA0.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>2243</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2244</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2245</td><td><pre style="display:inline;"> &nbsp;W: array[0..79] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2246</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2247</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2248</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Buffer[0], W, 16);</pre></td></tr>
<tr class="nocodegen"><td>2249</td><td><pre style="display:inline;"> &nbsp;if ClassType &lt;&gt; THash_SHA1 then</pre></td></tr>
<tr class="nocodegen"><td>2250</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2251</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 16 to 79 do</pre></td></tr>
<tr class="nocodegen"><td>2252</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2253</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := W[I - 3] xor W[I - 8] xor W[I - 14] xor W[I - 16];</pre></td></tr>
<tr class="nocodegen"><td>2254</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;W[I] := T;</pre></td></tr>
<tr class="nocodegen"><td>2255</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2256</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>2257</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2258</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2259</td><td><pre style="display:inline;"> &nbsp; &nbsp;for I := 16 to 79 do</pre></td></tr>
<tr class="nocodegen"><td>2260</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2261</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := W[I - 3] xor W[I - 8] xor W[I - 14] xor W[I - 16];</pre></td></tr>
<tr class="nocodegen"><td>2262</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;W[I] := T shl 1 or T shr 31;</pre></td></tr>
<tr class="nocodegen"><td>2263</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2264</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2265</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2266</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>2267</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>2268</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>2269</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>2270</td><td><pre style="display:inline;"> &nbsp;E := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>2271</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2272</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[ 0] + $5A827999); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2273</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[ 1] + $5A827999); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2274</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[ 2] + $5A827999); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2275</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[ 3] + $5A827999); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2276</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[ 4] + $5A827999); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2277</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[ 5] + $5A827999); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2278</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[ 6] + $5A827999); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2279</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[ 7] + $5A827999); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2280</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[ 8] + $5A827999); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2281</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[ 9] + $5A827999); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2282</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[10] + $5A827999); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2283</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[11] + $5A827999); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2284</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[12] + $5A827999); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2285</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[13] + $5A827999); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2286</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[14] + $5A827999); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2287</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[15] + $5A827999); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2288</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[16] + $5A827999); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2289</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[17] + $5A827999); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2290</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[18] + $5A827999); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2291</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[19] + $5A827999); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2292</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2293</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[20] + $6ED9EBA1); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2294</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[21] + $6ED9EBA1); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2295</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[22] + $6ED9EBA1); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2296</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[23] + $6ED9EBA1); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2297</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[24] + $6ED9EBA1); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2298</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[25] + $6ED9EBA1); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2299</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[26] + $6ED9EBA1); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2300</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[27] + $6ED9EBA1); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2301</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[28] + $6ED9EBA1); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2302</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[29] + $6ED9EBA1); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2303</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[30] + $6ED9EBA1); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2304</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[31] + $6ED9EBA1); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2305</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[32] + $6ED9EBA1); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2306</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[33] + $6ED9EBA1); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2307</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[34] + $6ED9EBA1); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2308</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[35] + $6ED9EBA1); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2309</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[36] + $6ED9EBA1); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2310</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[37] + $6ED9EBA1); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2311</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[38] + $6ED9EBA1); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2312</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[39] + $6ED9EBA1); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2313</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2314</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[40] + $8F1BBCDC); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2315</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[41] + $8F1BBCDC); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2316</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[42] + $8F1BBCDC); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2317</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[43] + $8F1BBCDC); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2318</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[44] + $8F1BBCDC); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2319</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[45] + $8F1BBCDC); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2320</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[46] + $8F1BBCDC); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2321</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[47] + $8F1BBCDC); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2322</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[48] + $8F1BBCDC); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2323</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[49] + $8F1BBCDC); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2324</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[50] + $8F1BBCDC); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2325</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[51] + $8F1BBCDC); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2326</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[52] + $8F1BBCDC); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2327</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[53] + $8F1BBCDC); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2328</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[54] + $8F1BBCDC); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2329</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[55] + $8F1BBCDC); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2330</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[56] + $8F1BBCDC); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2331</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[57] + $8F1BBCDC); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2332</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[58] + $8F1BBCDC); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2333</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[59] + $8F1BBCDC); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2334</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2335</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[60] + $CA62C1D6); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2336</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[61] + $CA62C1D6); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2337</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[62] + $CA62C1D6); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2338</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[63] + $CA62C1D6); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2339</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[64] + $CA62C1D6); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2340</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[65] + $CA62C1D6); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2341</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[66] + $CA62C1D6); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2342</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[67] + $CA62C1D6); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2343</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[68] + $CA62C1D6); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2344</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[69] + $CA62C1D6); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2345</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[70] + $CA62C1D6); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2346</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[71] + $CA62C1D6); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2347</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[72] + $CA62C1D6); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2348</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[73] + $CA62C1D6); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2349</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[74] + $CA62C1D6); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2350</td><td><pre style="display:inline;"> &nbsp;Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[75] + $CA62C1D6); B := B shr 2 or B shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2351</td><td><pre style="display:inline;"> &nbsp;Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[76] + $CA62C1D6); A := A shr 2 or A shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2352</td><td><pre style="display:inline;"> &nbsp;Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[77] + $CA62C1D6); E := E shr 2 or E shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2353</td><td><pre style="display:inline;"> &nbsp;Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[78] + $CA62C1D6); D := D shr 2 or D shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2354</td><td><pre style="display:inline;"> &nbsp;Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[79] + $CA62C1D6); C := C shr 2 or C shl 30;</pre></td></tr>
<tr class="nocodegen"><td>2355</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2356</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>2357</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>2358</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>2359</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>2360</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], E);</pre></td></tr>
<tr class="nocodegen"><td>2361</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2362</td><td><pre style="display:inline;">{$ENDIF !THash_SHA_asm}</pre></td></tr>
<tr class="nocodegen"><td>2363</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2364</td><td><pre style="display:inline;">procedure THash_SHA0.DoDone;</pre></td></tr>
<tr class="covered"><td>2365</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2366</td><td><pre style="display:inline;"> &nbsp;if FCount[2] or FCount[3] &lt;&gt; 0 then</pre></td></tr>
<tr class="notcovered"><td>2367</td><td><pre style="display:inline;"> &nbsp; &nbsp;RaiseHashOverflowError;</pre></td></tr>
<tr class="covered"><td>2368</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="covered"><td>2369</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $80;</pre></td></tr>
<tr class="covered"><td>2370</td><td><pre style="display:inline;"> &nbsp;FBuffer[FBufferIndex] := FPaddingByte;</pre></td></tr>
<tr class="covered"><td>2371</td><td><pre style="display:inline;"> &nbsp;Inc(FBufferIndex);</pre></td></tr>
<tr class="covered"><td>2372</td><td><pre style="display:inline;"> &nbsp;if FBufferIndex &gt; FBufferSize - 8 then</pre></td></tr>
<tr class="nocodegen"><td>2373</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2374</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>2375</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>2376</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBufferIndex := 0;</pre></td></tr>
<tr class="nocodegen"><td>2377</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2378</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>2379</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - 8])^ := SwapUInt32(FCount[1]);</pre></td></tr>
<tr class="covered"><td>2380</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - 4])^ := SwapUInt32(FCount[0]);</pre></td></tr>
<tr class="covered"><td>2381</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>2382</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(FDigest, FDigest, SizeOf(FDigest) div 4);</pre></td></tr>
<tr class="covered"><td>2383</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2384</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2385</td><td><pre style="display:inline;">class function THash_SHA0.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2386</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2387</td><td><pre style="display:inline;"> &nbsp;Result := 20;</pre></td></tr>
<tr class="covered"><td>2388</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2389</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2390</td><td><pre style="display:inline;">{ THash_SHA256 }</pre></td></tr>
<tr class="nocodegen"><td>2391</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2392</td><td><pre style="display:inline;">procedure THash_SHA256.DoInit;</pre></td></tr>
<tr class="covered"><td>2393</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2394</td><td><pre style="display:inline;"> &nbsp;FDigest[0]:= $6A09E667;</pre></td></tr>
<tr class="covered"><td>2395</td><td><pre style="display:inline;"> &nbsp;FDigest[1]:= $BB67AE85;</pre></td></tr>
<tr class="covered"><td>2396</td><td><pre style="display:inline;"> &nbsp;FDigest[2]:= $3C6EF372;</pre></td></tr>
<tr class="covered"><td>2397</td><td><pre style="display:inline;"> &nbsp;FDigest[3]:= $A54FF53A;</pre></td></tr>
<tr class="covered"><td>2398</td><td><pre style="display:inline;"> &nbsp;FDigest[4]:= $510E527F;</pre></td></tr>
<tr class="covered"><td>2399</td><td><pre style="display:inline;"> &nbsp;FDigest[5]:= $9B05688C;</pre></td></tr>
<tr class="covered"><td>2400</td><td><pre style="display:inline;"> &nbsp;FDigest[6]:= $1F83D9AB;</pre></td></tr>
<tr class="covered"><td>2401</td><td><pre style="display:inline;"> &nbsp;FDigest[7]:= $5BE0CD19;</pre></td></tr>
<tr class="covered"><td>2402</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2403</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2404</td><td><pre style="display:inline;">{$IFNDEF THash_SHA256_asm}</pre></td></tr>
<tr class="nocodegen"><td>2405</td><td><pre style="display:inline;">procedure THash_SHA256.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>2406</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2407</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2408</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2409</td><td><pre style="display:inline;"> &nbsp;T1, T2: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2410</td><td><pre style="display:inline;"> &nbsp;W: array[0..63] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2411</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2412</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Buffer[0], W, 16);</pre></td></tr>
<tr class="nocodegen"><td>2413</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2414</td><td><pre style="display:inline;"> &nbsp;for I := 16 to 63 do</pre></td></tr>
<tr class="nocodegen"><td>2415</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2416</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := W[I - 15];</pre></td></tr>
<tr class="nocodegen"><td>2417</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := W[I - 2];</pre></td></tr>
<tr class="nocodegen"><td>2418</td><td><pre style="display:inline;"> &nbsp; &nbsp;W[I] := W[I - 16] + W[I - 7] +</pre></td></tr>
<tr class="nocodegen"><td>2419</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((T1 shr &nbsp;7 or T1 shl 25) xor (T1 shr 18 or T1 shl 14) xor (T1 shr &nbsp;3)) +</pre></td></tr>
<tr class="nocodegen"><td>2420</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((T2 shr 17 or T2 shl 15) xor (T2 shr 19 or T2 shl 13) xor (T2 shr 10));</pre></td></tr>
<tr class="nocodegen"><td>2421</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2422</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2423</td><td><pre style="display:inline;"> &nbsp;// calculate new hash values</pre></td></tr>
<tr class="nocodegen"><td>2424</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>2425</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>2426</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>2427</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>2428</td><td><pre style="display:inline;"> &nbsp;E := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>2429</td><td><pre style="display:inline;"> &nbsp;F := FDigest[5];</pre></td></tr>
<tr class="nocodegen"><td>2430</td><td><pre style="display:inline;"> &nbsp;G := FDigest[6];</pre></td></tr>
<tr class="nocodegen"><td>2431</td><td><pre style="display:inline;"> &nbsp;H := FDigest[7];</pre></td></tr>
<tr class="nocodegen"><td>2432</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2433</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 63 do</pre></td></tr>
<tr class="nocodegen"><td>2434</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2435</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := ((E shr 6 or E shl 26) xor (E shr 11 or E shl 21) xor</pre></td></tr>
<tr class="nocodegen"><td>2436</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (E shr 25 or E shl 7)) + H + (((F xor G) and E) xor G) + SHA_256K[I] + W[I];</pre></td></tr>
<tr class="nocodegen"><td>2437</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := ((A shr 2 or A shl 30) xor (A shr 13 or A shl 19) xor</pre></td></tr>
<tr class="nocodegen"><td>2438</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (A shr 22 or A shl 10)) + (((B or C) and A) or (B and C));</pre></td></tr>
<tr class="nocodegen"><td>2439</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D + T1; D := C; C := B; B := A; A := T1 + T2;</pre></td></tr>
<tr class="nocodegen"><td>2440</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2441</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2442</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>2443</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>2444</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>2445</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>2446</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], E);</pre></td></tr>
<tr class="nocodegen"><td>2447</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[5], F);</pre></td></tr>
<tr class="nocodegen"><td>2448</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[6], G);</pre></td></tr>
<tr class="nocodegen"><td>2449</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[7], H);</pre></td></tr>
<tr class="nocodegen"><td>2450</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2451</td><td><pre style="display:inline;">{$ENDIF !THash_SHA256_asm}</pre></td></tr>
<tr class="nocodegen"><td>2452</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2453</td><td><pre style="display:inline;">class function THash_SHA256.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2454</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2455</td><td><pre style="display:inline;"> &nbsp;Result := 32;</pre></td></tr>
<tr class="covered"><td>2456</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2457</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2458</td><td><pre style="display:inline;">{ THash_SHA224 }</pre></td></tr>
<tr class="nocodegen"><td>2459</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2460</td><td><pre style="display:inline;">class function THash_SHA224.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2461</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2462</td><td><pre style="display:inline;"> &nbsp;Result := 64;</pre></td></tr>
<tr class="covered"><td>2463</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2464</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2465</td><td><pre style="display:inline;">class function THash_SHA224.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2466</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2467</td><td><pre style="display:inline;"> &nbsp;Result := 28;</pre></td></tr>
<tr class="covered"><td>2468</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2469</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2470</td><td><pre style="display:inline;">procedure THash_SHA224.DoInit;</pre></td></tr>
<tr class="covered"><td>2471</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2472</td><td><pre style="display:inline;"> &nbsp;FDigest[0]:= $C1059ED8;</pre></td></tr>
<tr class="covered"><td>2473</td><td><pre style="display:inline;"> &nbsp;FDigest[1]:= $367CD507;</pre></td></tr>
<tr class="covered"><td>2474</td><td><pre style="display:inline;"> &nbsp;FDigest[2]:= $3070DD17;</pre></td></tr>
<tr class="covered"><td>2475</td><td><pre style="display:inline;"> &nbsp;FDigest[3]:= $F70E5939;</pre></td></tr>
<tr class="covered"><td>2476</td><td><pre style="display:inline;"> &nbsp;FDigest[4]:= $FFC00B31;</pre></td></tr>
<tr class="covered"><td>2477</td><td><pre style="display:inline;"> &nbsp;FDigest[5]:= $68581511;</pre></td></tr>
<tr class="covered"><td>2478</td><td><pre style="display:inline;"> &nbsp;FDigest[6]:= $64F98FA7;</pre></td></tr>
<tr class="covered"><td>2479</td><td><pre style="display:inline;"> &nbsp;FDigest[7]:= $BEFA4FA4;</pre></td></tr>
<tr class="covered"><td>2480</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2481</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2482</td><td><pre style="display:inline;">{ THash_SHA384 }</pre></td></tr>
<tr class="nocodegen"><td>2483</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2484</td><td><pre style="display:inline;">procedure THash_SHA384.DoInit;</pre></td></tr>
<tr class="covered"><td>2485</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2486</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := Int64($CBBB9D5DC1059ED8);</pre></td></tr>
<tr class="covered"><td>2487</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := Int64($629A292A367CD507);</pre></td></tr>
<tr class="covered"><td>2488</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := Int64($9159015A3070DD17);</pre></td></tr>
<tr class="covered"><td>2489</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := Int64($152FECD8F70E5939);</pre></td></tr>
<tr class="covered"><td>2490</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := Int64($67332667FFC00B31);</pre></td></tr>
<tr class="covered"><td>2491</td><td><pre style="display:inline;"> &nbsp;FDigest[5] := Int64($8EB44A8768581511);</pre></td></tr>
<tr class="covered"><td>2492</td><td><pre style="display:inline;"> &nbsp;FDigest[6] := Int64($DB0C2E0D64F98FA7);</pre></td></tr>
<tr class="covered"><td>2493</td><td><pre style="display:inline;"> &nbsp;FDigest[7] := Int64($47B5481DBEFA4FA4);</pre></td></tr>
<tr class="covered"><td>2494</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2495</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2496</td><td><pre style="display:inline;">{$IFNDEF THash_SHA384_asm}</pre></td></tr>
<tr class="nocodegen"><td>2497</td><td><pre style="display:inline;">procedure THash_SHA384.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>2498</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2499</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H: UInt64;</pre></td></tr>
<tr class="nocodegen"><td>2500</td><td><pre style="display:inline;"> &nbsp;T1, T2: UInt64;</pre></td></tr>
<tr class="nocodegen"><td>2501</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>2502</td><td><pre style="display:inline;"> &nbsp;W: array [0..79] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>2503</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2504</td><td><pre style="display:inline;">{ TODO : The array passed is a UInt32 array, which doesn&apos;t fit with the name of this method!}</pre></td></tr>
<tr class="nocodegen"><td>2505</td><td><pre style="display:inline;"> &nbsp;SwapInt64Buffer(Buffer[0], W, 16);</pre></td></tr>
<tr class="nocodegen"><td>2506</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2507</td><td><pre style="display:inline;"> &nbsp;// calculate other 64 uint64</pre></td></tr>
<tr class="nocodegen"><td>2508</td><td><pre style="display:inline;"> &nbsp;for I := 16 to 79 do</pre></td></tr>
<tr class="nocodegen"><td>2509</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2510</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := W[I - 15];</pre></td></tr>
<tr class="nocodegen"><td>2511</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := W[I - 2];</pre></td></tr>
<tr class="nocodegen"><td>2512</td><td><pre style="display:inline;"> &nbsp; &nbsp;W[I] := W[I - 16] + W[I - 7] +</pre></td></tr>
<tr class="nocodegen"><td>2513</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((T1 shr &nbsp;1 or T1 shl 63) xor (T1 shr &nbsp;8 or T1 shl 56) xor (T1 shr &nbsp;7)) +</pre></td></tr>
<tr class="nocodegen"><td>2514</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((T2 shr 19 or T2 shl 45) xor (T2 shr 61 or T2 shl &nbsp;3) xor (T2 shr &nbsp;6));</pre></td></tr>
<tr class="nocodegen"><td>2515</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2516</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2517</td><td><pre style="display:inline;"> &nbsp;// calculate new hash values</pre></td></tr>
<tr class="nocodegen"><td>2518</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>2519</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>2520</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>2521</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>2522</td><td><pre style="display:inline;"> &nbsp;E := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>2523</td><td><pre style="display:inline;"> &nbsp;F := FDigest[5];</pre></td></tr>
<tr class="nocodegen"><td>2524</td><td><pre style="display:inline;"> &nbsp;G := FDigest[6];</pre></td></tr>
<tr class="nocodegen"><td>2525</td><td><pre style="display:inline;"> &nbsp;H := FDigest[7];</pre></td></tr>
<tr class="nocodegen"><td>2526</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2527</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 79 do</pre></td></tr>
<tr class="nocodegen"><td>2528</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2529</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := ((E shr 14 or E shl 50) xor (E shr 18 or E shl 46) xor</pre></td></tr>
<tr class="nocodegen"><td>2530</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (E shr 41 or E shl 23)) + H + (((F xor G) and E) xor G) + SHA_512K[I] + W[I];</pre></td></tr>
<tr class="nocodegen"><td>2531</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := ((A shr 28 or A shl 36) xor (A shr 34 or A shl 30) xor</pre></td></tr>
<tr class="nocodegen"><td>2532</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (A shr 39 or A shl 25)) + (((B or C) and A) or (B and C));</pre></td></tr>
<tr class="nocodegen"><td>2533</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G;</pre></td></tr>
<tr class="nocodegen"><td>2534</td><td><pre style="display:inline;"> &nbsp; &nbsp;G := F;</pre></td></tr>
<tr class="nocodegen"><td>2535</td><td><pre style="display:inline;"> &nbsp; &nbsp;F := E;</pre></td></tr>
<tr class="nocodegen"><td>2536</td><td><pre style="display:inline;"> &nbsp; &nbsp;E := D + T1;</pre></td></tr>
<tr class="nocodegen"><td>2537</td><td><pre style="display:inline;"> &nbsp; &nbsp;D := C;</pre></td></tr>
<tr class="nocodegen"><td>2538</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := B;</pre></td></tr>
<tr class="nocodegen"><td>2539</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := A;</pre></td></tr>
<tr class="nocodegen"><td>2540</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := T1 + T2;</pre></td></tr>
<tr class="nocodegen"><td>2541</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2542</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2543</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>2544</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>2545</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>2546</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>2547</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], E);</pre></td></tr>
<tr class="nocodegen"><td>2548</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[5], F);</pre></td></tr>
<tr class="nocodegen"><td>2549</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[6], G);</pre></td></tr>
<tr class="nocodegen"><td>2550</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[7], H);</pre></td></tr>
<tr class="nocodegen"><td>2551</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2552</td><td><pre style="display:inline;">{$ENDIF !THash_SHA384_asm}</pre></td></tr>
<tr class="nocodegen"><td>2553</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2554</td><td><pre style="display:inline;">procedure THash_SHA384.DoDone;</pre></td></tr>
<tr class="covered"><td>2555</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2556</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="covered"><td>2557</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $80;</pre></td></tr>
<tr class="covered"><td>2558</td><td><pre style="display:inline;"> &nbsp;FBuffer[FBufferIndex] := FPaddingByte;</pre></td></tr>
<tr class="covered"><td>2559</td><td><pre style="display:inline;"> &nbsp;Inc(FBufferIndex);</pre></td></tr>
<tr class="covered"><td>2560</td><td><pre style="display:inline;"> &nbsp;if FBufferIndex &gt; FBufferSize - 16 then</pre></td></tr>
<tr class="nocodegen"><td>2561</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2562</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>2563</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>2564</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBufferIndex := 0;</pre></td></tr>
<tr class="nocodegen"><td>2565</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2566</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>2567</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(FCount, FCount, 4);</pre></td></tr>
<tr class="covered"><td>2568</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - 16])^ := FCount[3];</pre></td></tr>
<tr class="covered"><td>2569</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - 12])^ := FCount[2];</pre></td></tr>
<tr class="covered"><td>2570</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - &nbsp;8])^ := FCount[1];</pre></td></tr>
<tr class="covered"><td>2571</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - &nbsp;4])^ := FCount[0];</pre></td></tr>
<tr class="covered"><td>2572</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>2573</td><td><pre style="display:inline;"> &nbsp;SwapInt64Buffer(FDigest, FDigest, SizeOf(FDigest) div 8);</pre></td></tr>
<tr class="covered"><td>2574</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2575</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2576</td><td><pre style="display:inline;">function THash_SHA384.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>2577</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2578</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>2579</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2580</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2581</td><td><pre style="display:inline;">class function THash_SHA384.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2582</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2583</td><td><pre style="display:inline;"> &nbsp;Result := 48;</pre></td></tr>
<tr class="covered"><td>2584</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2585</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2586</td><td><pre style="display:inline;">class function THash_SHA384.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2587</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2588</td><td><pre style="display:inline;"> &nbsp;Result := 128;</pre></td></tr>
<tr class="covered"><td>2589</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2590</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2591</td><td><pre style="display:inline;">{ THash_SHA512 }</pre></td></tr>
<tr class="nocodegen"><td>2592</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2593</td><td><pre style="display:inline;">procedure THash_SHA512.DoInit;</pre></td></tr>
<tr class="covered"><td>2594</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2595</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := Int64($6A09E667F3BCC908);</pre></td></tr>
<tr class="covered"><td>2596</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := Int64($BB67AE8584CAA73B);</pre></td></tr>
<tr class="covered"><td>2597</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := Int64($3C6EF372FE94F82B);</pre></td></tr>
<tr class="covered"><td>2598</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := Int64($A54FF53A5F1D36F1);</pre></td></tr>
<tr class="covered"><td>2599</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := Int64($510E527FADE682D1);</pre></td></tr>
<tr class="covered"><td>2600</td><td><pre style="display:inline;"> &nbsp;FDigest[5] := Int64($9B05688C2B3E6C1F);</pre></td></tr>
<tr class="covered"><td>2601</td><td><pre style="display:inline;"> &nbsp;FDigest[6] := Int64($1F83D9ABFB41BD6B);</pre></td></tr>
<tr class="covered"><td>2602</td><td><pre style="display:inline;"> &nbsp;FDigest[7] := Int64($5BE0CD19137E2179);</pre></td></tr>
<tr class="covered"><td>2603</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2604</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2605</td><td><pre style="display:inline;">class function THash_SHA512.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2606</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2607</td><td><pre style="display:inline;"> &nbsp;Result := 64;</pre></td></tr>
<tr class="covered"><td>2608</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2609</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2610</td><td><pre style="display:inline;">{ THashBaseHaval }</pre></td></tr>
<tr class="nocodegen"><td>2611</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2612</td><td><pre style="display:inline;">procedure THashBaseHaval.SetRounds(Value: UInt32);</pre></td></tr>
<tr class="covered"><td>2613</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2614</td><td><pre style="display:inline;"> &nbsp;if (Value &lt; GetMinRounds) or (Value &gt; 5) then</pre></td></tr>
<tr class="nocodegen"><td>2615</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2616</td><td><pre style="display:inline;"> &nbsp; &nbsp;if DigestSize &lt;= 20 then</pre></td></tr>
<tr class="covered"><td>2617</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Value := 3</pre></td></tr>
<tr class="nocodegen"><td>2618</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2619</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2620</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if DigestSize &lt;= 28 then</pre></td></tr>
<tr class="covered"><td>2621</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Value := 4</pre></td></tr>
<tr class="nocodegen"><td>2622</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>2623</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Value := 5;</pre></td></tr>
<tr class="nocodegen"><td>2624</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2625</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2626</td><td><pre style="display:inline;"> &nbsp;FRounds := Value;</pre></td></tr>
<tr class="covered"><td>2627</td><td><pre style="display:inline;"> &nbsp;case FRounds of</pre></td></tr>
<tr class="covered"><td>2628</td><td><pre style="display:inline;"> &nbsp; &nbsp;3: FTransform := DoTransform3;</pre></td></tr>
<tr class="covered"><td>2629</td><td><pre style="display:inline;"> &nbsp; &nbsp;4: FTransform := DoTransform4;</pre></td></tr>
<tr class="covered"><td>2630</td><td><pre style="display:inline;"> &nbsp; &nbsp;5: FTransform := DoTransform5;</pre></td></tr>
<tr class="nocodegen"><td>2631</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2632</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2633</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2634</td><td><pre style="display:inline;">procedure THashBaseHaval.DoInit;</pre></td></tr>
<tr class="covered"><td>2635</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2636</td><td><pre style="display:inline;"> &nbsp;SetRounds(FRounds);</pre></td></tr>
<tr class="covered"><td>2637</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := $243F6A88;</pre></td></tr>
<tr class="covered"><td>2638</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := $85A308D3;</pre></td></tr>
<tr class="covered"><td>2639</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := $13198A2E;</pre></td></tr>
<tr class="covered"><td>2640</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := $03707344;</pre></td></tr>
<tr class="covered"><td>2641</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := $A4093822;</pre></td></tr>
<tr class="covered"><td>2642</td><td><pre style="display:inline;"> &nbsp;FDigest[5] := $299F31D0;</pre></td></tr>
<tr class="covered"><td>2643</td><td><pre style="display:inline;"> &nbsp;FDigest[6] := $082EFA98;</pre></td></tr>
<tr class="covered"><td>2644</td><td><pre style="display:inline;"> &nbsp;FDigest[7] := $EC4E6C89;</pre></td></tr>
<tr class="covered"><td>2645</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2646</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2647</td><td><pre style="display:inline;">procedure THashBaseHaval.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="covered"><td>2648</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2649</td><td><pre style="display:inline;"> &nbsp;FTransform(Buffer);</pre></td></tr>
<tr class="covered"><td>2650</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2651</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2652</td><td><pre style="display:inline;">function THashBaseHaval.GetMaxRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>2653</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2654</td><td><pre style="display:inline;"> &nbsp;Result := 5;</pre></td></tr>
<tr class="covered"><td>2655</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2656</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2657</td><td><pre style="display:inline;">function THashBaseHaval.GetMinRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>2658</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2659</td><td><pre style="display:inline;"> &nbsp;if DigestSize &lt;= 20 then</pre></td></tr>
<tr class="covered"><td>2660</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := 3</pre></td></tr>
<tr class="nocodegen"><td>2661</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>2662</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2663</td><td><pre style="display:inline;"> &nbsp; &nbsp;if DigestSize &lt;= 28 then</pre></td></tr>
<tr class="covered"><td>2664</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := 4</pre></td></tr>
<tr class="nocodegen"><td>2665</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="covered"><td>2666</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Result := 5;</pre></td></tr>
<tr class="nocodegen"><td>2667</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2668</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2669</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2670</td><td><pre style="display:inline;">function THashBaseHaval.GetRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>2671</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2672</td><td><pre style="display:inline;"> &nbsp;Result := FRounds;</pre></td></tr>
<tr class="covered"><td>2673</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2674</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2675</td><td><pre style="display:inline;">{$IFNDEF THashBaseHaval_asm}</pre></td></tr>
<tr class="nocodegen"><td>2676</td><td><pre style="display:inline;">procedure THashBaseHaval.DoTransform3(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>2677</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2678</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H, I, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2679</td><td><pre style="display:inline;"> &nbsp;Data: PUInt32;</pre></td></tr>
<tr class="nocodegen"><td>2680</td><td><pre style="display:inline;"> &nbsp;Offset: PByte;</pre></td></tr>
<tr class="nocodegen"><td>2681</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2682</td><td><pre style="display:inline;"> &nbsp;Offset := @Haval_Offset;</pre></td></tr>
<tr class="nocodegen"><td>2683</td><td><pre style="display:inline;"> &nbsp;Data &nbsp; := @Haval_Data;</pre></td></tr>
<tr class="nocodegen"><td>2684</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2685</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>2686</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>2687</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>2688</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>2689</td><td><pre style="display:inline;"> &nbsp;E := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>2690</td><td><pre style="display:inline;"> &nbsp;F := FDigest[5];</pre></td></tr>
<tr class="nocodegen"><td>2691</td><td><pre style="display:inline;"> &nbsp;G := FDigest[6];</pre></td></tr>
<tr class="nocodegen"><td>2692</td><td><pre style="display:inline;"> &nbsp;H := FDigest[7];</pre></td></tr>
<tr class="nocodegen"><td>2693</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2694</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2695</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2696</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := C and (E xor D) xor G and A xor F and B xor E;</pre></td></tr>
<tr class="nocodegen"><td>2697</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[I];</pre></td></tr>
<tr class="nocodegen"><td>2698</td><td><pre style="display:inline;">	H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2699</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2700</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2701</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2702</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2703</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := F and (D and not A xor B and C xor E xor G) xor B and (D xor C) xor A and C xor G;</pre></td></tr>
<tr class="nocodegen"><td>2704</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2705</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2706</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2707</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2708</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2709</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2710</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2711</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2712</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := D and (F and E xor G xor A) xor F and C xor E and B xor A;</pre></td></tr>
<tr class="nocodegen"><td>2713</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2714</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2715</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2716</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2717</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2718</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2719</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>2720</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>2721</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>2722</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>2723</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], E);</pre></td></tr>
<tr class="nocodegen"><td>2724</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[5], F);</pre></td></tr>
<tr class="nocodegen"><td>2725</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[6], G);</pre></td></tr>
<tr class="nocodegen"><td>2726</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[7], H);</pre></td></tr>
<tr class="nocodegen"><td>2727</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2728</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2729</td><td><pre style="display:inline;">procedure THashBaseHaval.DoTransform4(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>2730</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2731</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H, I, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2732</td><td><pre style="display:inline;"> &nbsp;Data: PUInt32;</pre></td></tr>
<tr class="nocodegen"><td>2733</td><td><pre style="display:inline;"> &nbsp;Offset: PByte;</pre></td></tr>
<tr class="nocodegen"><td>2734</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2735</td><td><pre style="display:inline;"> &nbsp;Offset := @Haval_Offset;</pre></td></tr>
<tr class="nocodegen"><td>2736</td><td><pre style="display:inline;"> &nbsp;Data := @Haval_Data;</pre></td></tr>
<tr class="nocodegen"><td>2737</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2738</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>2739</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>2740</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>2741</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>2742</td><td><pre style="display:inline;"> &nbsp;E := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>2743</td><td><pre style="display:inline;"> &nbsp;F := FDigest[5];</pre></td></tr>
<tr class="nocodegen"><td>2744</td><td><pre style="display:inline;"> &nbsp;G := FDigest[6];</pre></td></tr>
<tr class="nocodegen"><td>2745</td><td><pre style="display:inline;"> &nbsp;H := FDigest[7];</pre></td></tr>
<tr class="nocodegen"><td>2746</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2747</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2748</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2749</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := D and (A xor B) xor F and G xor E and C xor A;</pre></td></tr>
<tr class="nocodegen"><td>2750</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[I];</pre></td></tr>
<tr class="nocodegen"><td>2751</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2752</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2753</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2754</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2755</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2756</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B and (G and not A xor C and F xor D xor E) xor C and (G xor F) xor A and F xor E;</pre></td></tr>
<tr class="nocodegen"><td>2757</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2758</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2759</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2760</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2761</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2762</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2763</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2764</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2765</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := G and (C and A xor B xor F) xor C and D xor A and E xor F;</pre></td></tr>
<tr class="nocodegen"><td>2766</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2767</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2768</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2769</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2770</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2771</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2772</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2773</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2774</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A and (E and not C xor F and not G xor B xor G xor D) xor F and</pre></td></tr>
<tr class="nocodegen"><td>2775</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;(B and C xor E xor G) xor C and G xor D;</pre></td></tr>
<tr class="nocodegen"><td>2776</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2777</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2778</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2779</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2780</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2781</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2782</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>2783</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>2784</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>2785</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>2786</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], E);</pre></td></tr>
<tr class="nocodegen"><td>2787</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[5], F);</pre></td></tr>
<tr class="nocodegen"><td>2788</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[6], G);</pre></td></tr>
<tr class="nocodegen"><td>2789</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[7], H);</pre></td></tr>
<tr class="nocodegen"><td>2790</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2791</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2792</td><td><pre style="display:inline;">procedure THashBaseHaval.DoTransform5(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>2793</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2794</td><td><pre style="display:inline;"> &nbsp;A, B, C, D, E, F, G, H, I, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2795</td><td><pre style="display:inline;"> &nbsp;Data: PUInt32;</pre></td></tr>
<tr class="nocodegen"><td>2796</td><td><pre style="display:inline;"> &nbsp;Offset: PByte;</pre></td></tr>
<tr class="nocodegen"><td>2797</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>2798</td><td><pre style="display:inline;"> &nbsp;Offset := @Haval_Offset;</pre></td></tr>
<tr class="nocodegen"><td>2799</td><td><pre style="display:inline;"> &nbsp;Data := @Haval_Data;</pre></td></tr>
<tr class="nocodegen"><td>2800</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2801</td><td><pre style="display:inline;"> &nbsp;A := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>2802</td><td><pre style="display:inline;"> &nbsp;B := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>2803</td><td><pre style="display:inline;"> &nbsp;C := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>2804</td><td><pre style="display:inline;"> &nbsp;D := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>2805</td><td><pre style="display:inline;"> &nbsp;E := FDigest[4];</pre></td></tr>
<tr class="nocodegen"><td>2806</td><td><pre style="display:inline;"> &nbsp;F := FDigest[5];</pre></td></tr>
<tr class="nocodegen"><td>2807</td><td><pre style="display:inline;"> &nbsp;G := FDigest[6];</pre></td></tr>
<tr class="nocodegen"><td>2808</td><td><pre style="display:inline;"> &nbsp;H := FDigest[7];</pre></td></tr>
<tr class="nocodegen"><td>2809</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2810</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2811</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2812</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := C and (G xor B) xor F and E xor A and D xor G;</pre></td></tr>
<tr class="nocodegen"><td>2813</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[I];</pre></td></tr>
<tr class="nocodegen"><td>2814</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2815</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2816</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2817</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2818</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2819</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := D and (E and not A xor B and C xor G xor F) xor B and (E xor C) xor A and C xor F;</pre></td></tr>
<tr class="nocodegen"><td>2820</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2821</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2822</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2823</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2824</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2825</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2826</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2827</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2828</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := E and (B and D xor C xor F) xor B and A xor D and G xor F;</pre></td></tr>
<tr class="nocodegen"><td>2829</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2830</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2831</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2832</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2833</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2834</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2835</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2836</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2837</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := D and (F and not A xor C and not B xor E xor B xor G) xor C and</pre></td></tr>
<tr class="nocodegen"><td>2838</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;(E and A xor F xor B) xor A and B xor G;</pre></td></tr>
<tr class="nocodegen"><td>2839</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2840</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset);</pre></td></tr>
<tr class="nocodegen"><td>2841</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2842</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2843</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2844</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2845</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>2846</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2847</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := B and (D and E and G xor not F) xor D and A xor E and F xor G and C;</pre></td></tr>
<tr class="nocodegen"><td>2848</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;</pre></td></tr>
<tr class="nocodegen"><td>2849</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(Offset); Inc(Data);</pre></td></tr>
<tr class="nocodegen"><td>2850</td><td><pre style="display:inline;"> &nbsp; &nbsp;H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;</pre></td></tr>
<tr class="nocodegen"><td>2851</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2852</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2853</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[0], A);</pre></td></tr>
<tr class="nocodegen"><td>2854</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[1], B);</pre></td></tr>
<tr class="nocodegen"><td>2855</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[2], C);</pre></td></tr>
<tr class="nocodegen"><td>2856</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[3], D);</pre></td></tr>
<tr class="nocodegen"><td>2857</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[4], E);</pre></td></tr>
<tr class="nocodegen"><td>2858</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[5], F);</pre></td></tr>
<tr class="nocodegen"><td>2859</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[6], G);</pre></td></tr>
<tr class="nocodegen"><td>2860</td><td><pre style="display:inline;"> &nbsp;Inc(FDigest[7], H);</pre></td></tr>
<tr class="nocodegen"><td>2861</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2862</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2863</td><td><pre style="display:inline;">{$ENDIF !THashBaseHaval_asm}</pre></td></tr>
<tr class="nocodegen"><td>2864</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2865</td><td><pre style="display:inline;">procedure THashBaseHaval.DoDone;</pre></td></tr>
<tr class="nocodegen"><td>2866</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2867</td><td><pre style="display:inline;"> &nbsp;function ROR(Value, Count: UInt32): UInt32;</pre></td></tr>
<tr class="nocodegen"><td>2868</td><td><pre style="display:inline;"> &nbsp;{$IFDEF X86ASM}</pre></td></tr>
<tr class="covered"><td>2869</td><td><pre style="display:inline;"> &nbsp;asm</pre></td></tr>
<tr class="covered"><td>2870</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;MOV &nbsp; &nbsp; ECX,EDX</pre></td></tr>
<tr class="covered"><td>2871</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;ROR &nbsp; &nbsp; EAX,CL</pre></td></tr>
<tr class="covered"><td>2872</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2873</td><td><pre style="display:inline;"> &nbsp;{$ELSE !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>2874</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>2875</td><td><pre style="display:inline;"> &nbsp; &nbsp;Result := (Value shr Count) or (Value shl (32 - Count));</pre></td></tr>
<tr class="nocodegen"><td>2876</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2877</td><td><pre style="display:inline;"> &nbsp;{$ENDIF !X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>2878</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2879</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>2880</td><td><pre style="display:inline;"> &nbsp;T: Word;</pre></td></tr>
<tr class="covered"><td>2881</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2882</td><td><pre style="display:inline;"> &nbsp;if FCount[2] or FCount[3] &lt;&gt; 0 then</pre></td></tr>
<tr class="notcovered"><td>2883</td><td><pre style="display:inline;"> &nbsp; &nbsp;RaiseHashOverflowError;</pre></td></tr>
<tr class="covered"><td>2884</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="notcovered"><td>2885</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $01;</pre></td></tr>
<tr class="covered"><td>2886</td><td><pre style="display:inline;"> &nbsp;FBuffer[FBufferIndex] := FPaddingByte;</pre></td></tr>
<tr class="covered"><td>2887</td><td><pre style="display:inline;"> &nbsp;Inc(FBufferIndex);</pre></td></tr>
<tr class="covered"><td>2888</td><td><pre style="display:inline;"> &nbsp;if FBufferIndex &gt; FBufferSize - 10 then</pre></td></tr>
<tr class="nocodegen"><td>2889</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>2890</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex - 10, 0);</pre></td></tr>
<tr class="covered"><td>2891</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>2892</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBufferIndex := 0;</pre></td></tr>
<tr class="nocodegen"><td>2893</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2894</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex - 10, 0);</pre></td></tr>
<tr class="covered"><td>2895</td><td><pre style="display:inline;"> &nbsp;T := (DigestSize shl 9) or (UInt32(FRounds) shl 3) or 1;</pre></td></tr>
<tr class="covered"><td>2896</td><td><pre style="display:inline;"> &nbsp;Move(T, FBuffer[FBufferSize - 10], SizeOf(T));</pre></td></tr>
<tr class="covered"><td>2897</td><td><pre style="display:inline;"> &nbsp;Move(FCount, FBuffer[FBufferSize - 8], 8);</pre></td></tr>
<tr class="covered"><td>2898</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="nocodegen"><td>2899</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>2900</td><td><pre style="display:inline;"> &nbsp;case DigestSize of</pre></td></tr>
<tr class="nocodegen"><td>2901</td><td><pre style="display:inline;"> &nbsp; &nbsp;16: begin</pre></td></tr>
<tr class="nocodegen"><td>2902</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[0], ROR(FDigest[7] and $000000FF or</pre></td></tr>
<tr class="nocodegen"><td>2903</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and $FF000000 or</pre></td></tr>
<tr class="nocodegen"><td>2904</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and $00FF0000 or</pre></td></tr>
<tr class="covered"><td>2905</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[4] and $0000FF00, 8));</pre></td></tr>
<tr class="covered"><td>2906</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[1], ROR(FDigest[7] and $0000FF00 or</pre></td></tr>
<tr class="nocodegen"><td>2907</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and $000000FF or</pre></td></tr>
<tr class="nocodegen"><td>2908</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and $FF000000 or</pre></td></tr>
<tr class="nocodegen"><td>2909</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[4] and $00FF0000, 16));</pre></td></tr>
<tr class="covered"><td>2910</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[2], ROR(FDigest[7] and $00FF0000 or</pre></td></tr>
<tr class="nocodegen"><td>2911</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and $0000FF00 or</pre></td></tr>
<tr class="nocodegen"><td>2912</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and $000000FF or</pre></td></tr>
<tr class="nocodegen"><td>2913</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[4] and $FF000000, 24));</pre></td></tr>
<tr class="covered"><td>2914</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[3], &nbsp; &nbsp; FDigest[7] and $FF000000 or</pre></td></tr>
<tr class="nocodegen"><td>2915</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and $00FF0000 or</pre></td></tr>
<tr class="nocodegen"><td>2916</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and $0000FF00 or</pre></td></tr>
<tr class="nocodegen"><td>2917</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[4] and $000000FF);</pre></td></tr>
<tr class="nocodegen"><td>2918</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2919</td><td><pre style="display:inline;"> &nbsp; &nbsp;20: begin</pre></td></tr>
<tr class="nocodegen"><td>2920</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[0], ROR(FDigest[7] and ($3F) or</pre></td></tr>
<tr class="nocodegen"><td>2921</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($7F shl 25) or</pre></td></tr>
<tr class="covered"><td>2922</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and ($3F shl 19), 19));</pre></td></tr>
<tr class="covered"><td>2923</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[1], ROR(FDigest[7] and ($3F shl 6) or</pre></td></tr>
<tr class="nocodegen"><td>2924</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($3F) or</pre></td></tr>
<tr class="nocodegen"><td>2925</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and ($7F shl 25), 25));</pre></td></tr>
<tr class="covered"><td>2926</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[2], &nbsp; &nbsp; FDigest[7] and ($7F shl 12) or</pre></td></tr>
<tr class="nocodegen"><td>2927</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($3F shl &nbsp;6) or</pre></td></tr>
<tr class="nocodegen"><td>2928</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and ($3F));</pre></td></tr>
<tr class="covered"><td>2929</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[3], &nbsp; &nbsp;(FDigest[7] and ($3F shl 19) or</pre></td></tr>
<tr class="nocodegen"><td>2930</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($7F shl 12) or</pre></td></tr>
<tr class="nocodegen"><td>2931</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and ($3F shl &nbsp;6)) shr 6);</pre></td></tr>
<tr class="covered"><td>2932</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[4], &nbsp; &nbsp;(FDigest[7] and ($7F shl 25) or</pre></td></tr>
<tr class="nocodegen"><td>2933</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($3F shl 19) or</pre></td></tr>
<tr class="nocodegen"><td>2934</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[5] and ($7F shl 12)) shr 12);</pre></td></tr>
<tr class="nocodegen"><td>2935</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2936</td><td><pre style="display:inline;"> &nbsp; &nbsp;24: begin</pre></td></tr>
<tr class="nocodegen"><td>2937</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[0], ROR(FDigest[7] and ($1F) or</pre></td></tr>
<tr class="covered"><td>2938</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($3F shl 26), 26));</pre></td></tr>
<tr class="covered"><td>2939</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[1], &nbsp; &nbsp; FDigest[7] and ($1F shl 5) or</pre></td></tr>
<tr class="nocodegen"><td>2940</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($1F));</pre></td></tr>
<tr class="covered"><td>2941</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[2], &nbsp; &nbsp;(FDigest[7] and ($3F shl 10) or</pre></td></tr>
<tr class="nocodegen"><td>2942</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($1F shl &nbsp;5)) shr 5);</pre></td></tr>
<tr class="covered"><td>2943</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[3], &nbsp; &nbsp;(FDigest[7] and ($1F shl 16) or</pre></td></tr>
<tr class="nocodegen"><td>2944</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($3F shl 10)) shr 10);</pre></td></tr>
<tr class="covered"><td>2945</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[4], &nbsp; &nbsp;(FDigest[7] and ($1F shl 21) or</pre></td></tr>
<tr class="nocodegen"><td>2946</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($1F shl 16)) shr 16);</pre></td></tr>
<tr class="covered"><td>2947</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[5], &nbsp; &nbsp;(FDigest[7] and ($3F shl 26) or</pre></td></tr>
<tr class="nocodegen"><td>2948</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FDigest[6] and ($1F shl 21)) shr 21);</pre></td></tr>
<tr class="nocodegen"><td>2949</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2950</td><td><pre style="display:inline;"> &nbsp; &nbsp;28: begin</pre></td></tr>
<tr class="covered"><td>2951</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[0], FDigest[7] shr 27 and $1F);</pre></td></tr>
<tr class="covered"><td>2952</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[1], FDigest[7] shr 22 and $1F);</pre></td></tr>
<tr class="covered"><td>2953</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[2], FDigest[7] shr 18 and $0F);</pre></td></tr>
<tr class="covered"><td>2954</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[3], FDigest[7] shr 13 and $1F);</pre></td></tr>
<tr class="covered"><td>2955</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[4], FDigest[7] shr &nbsp;9 and $0F);</pre></td></tr>
<tr class="covered"><td>2956</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[5], FDigest[7] shr &nbsp;4 and $1F);</pre></td></tr>
<tr class="covered"><td>2957</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inc(FDigest[6], FDigest[7] &nbsp; &nbsp; &nbsp; &nbsp;and $0F);</pre></td></tr>
<tr class="nocodegen"><td>2958</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>2959</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>2960</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2961</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2962</td><td><pre style="display:inline;">function THashBaseHaval.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>2963</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2964</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>2965</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2966</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2967</td><td><pre style="display:inline;">class function THashBaseHaval.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2968</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2969</td><td><pre style="display:inline;"> &nbsp;Result := 128;</pre></td></tr>
<tr class="covered"><td>2970</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2971</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2972</td><td><pre style="display:inline;">{ THash_Haval128 }</pre></td></tr>
<tr class="nocodegen"><td>2973</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2974</td><td><pre style="display:inline;">class function THash_Haval128.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2975</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2976</td><td><pre style="display:inline;"> &nbsp;Result := 16;</pre></td></tr>
<tr class="covered"><td>2977</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2978</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2979</td><td><pre style="display:inline;">{ THash_Haval160 }</pre></td></tr>
<tr class="nocodegen"><td>2980</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2981</td><td><pre style="display:inline;">class function THash_Haval160.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2982</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2983</td><td><pre style="display:inline;"> &nbsp;Result := 20;</pre></td></tr>
<tr class="covered"><td>2984</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2985</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2986</td><td><pre style="display:inline;">{ THash_Haval192 }</pre></td></tr>
<tr class="nocodegen"><td>2987</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2988</td><td><pre style="display:inline;">class function THash_Haval192.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2989</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2990</td><td><pre style="display:inline;"> &nbsp;Result := 24;</pre></td></tr>
<tr class="covered"><td>2991</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2992</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2993</td><td><pre style="display:inline;">{ THash_Haval224 }</pre></td></tr>
<tr class="nocodegen"><td>2994</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>2995</td><td><pre style="display:inline;">class function THash_Haval224.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>2996</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>2997</td><td><pre style="display:inline;"> &nbsp;Result := 28;</pre></td></tr>
<tr class="covered"><td>2998</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>2999</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3000</td><td><pre style="display:inline;">{ THash_Haval256 }</pre></td></tr>
<tr class="nocodegen"><td>3001</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3002</td><td><pre style="display:inline;">class function THash_Haval256.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3003</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3004</td><td><pre style="display:inline;"> &nbsp;Result := 32;</pre></td></tr>
<tr class="covered"><td>3005</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3006</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3007</td><td><pre style="display:inline;">{ THash_Tiger }</pre></td></tr>
<tr class="nocodegen"><td>3008</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3009</td><td><pre style="display:inline;">procedure THash_Tiger.SetRounds(Value: UInt32);</pre></td></tr>
<tr class="covered"><td>3010</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3011</td><td><pre style="display:inline;"> &nbsp;if (Value &lt; cTigerMinRounds) then</pre></td></tr>
<tr class="covered"><td>3012</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := cTigerMinRounds;</pre></td></tr>
<tr class="nocodegen"><td>3013</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3014</td><td><pre style="display:inline;"> &nbsp;if (Value &gt; cTigerMaxRounds) then</pre></td></tr>
<tr class="covered"><td>3015</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := cTigerMaxRounds;</pre></td></tr>
<tr class="nocodegen"><td>3016</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>3017</td><td><pre style="display:inline;"> &nbsp;FRounds := Value;</pre></td></tr>
<tr class="covered"><td>3018</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3019</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3020</td><td><pre style="display:inline;">procedure THash_Tiger.DoInit;</pre></td></tr>
<tr class="covered"><td>3021</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3022</td><td><pre style="display:inline;"> &nbsp;SetRounds(FRounds);</pre></td></tr>
<tr class="covered"><td>3023</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="covered"><td>3024</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $01;</pre></td></tr>
<tr class="covered"><td>3025</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := $89ABCDEF;</pre></td></tr>
<tr class="covered"><td>3026</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := $01234567;</pre></td></tr>
<tr class="covered"><td>3027</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := $76543210;</pre></td></tr>
<tr class="covered"><td>3028</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := $FEDCBA98;</pre></td></tr>
<tr class="covered"><td>3029</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := $C3B2E187;</pre></td></tr>
<tr class="covered"><td>3030</td><td><pre style="display:inline;"> &nbsp;FDigest[5] := $F096A5B4;</pre></td></tr>
<tr class="covered"><td>3031</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3032</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3033</td><td><pre style="display:inline;">{$IFNDEF THash_Tiger_asm}</pre></td></tr>
<tr class="nocodegen"><td>3034</td><td><pre style="display:inline;">procedure THash_Tiger.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3035</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>3036</td><td><pre style="display:inline;"> &nbsp;PTiger_Data = ^TTiger_Data;</pre></td></tr>
<tr class="nocodegen"><td>3037</td><td><pre style="display:inline;"> &nbsp;TTiger_Data = array[0..3, 0..255] of Int64;</pre></td></tr>
<tr class="nocodegen"><td>3038</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3039</td><td><pre style="display:inline;"> &nbsp;PInt64Array = ^TInt64Array;</pre></td></tr>
<tr class="nocodegen"><td>3040</td><td><pre style="display:inline;"> &nbsp;TInt64Array = array[0..7] of Int64;</pre></td></tr>
<tr class="nocodegen"><td>3041</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3042</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3043</td><td><pre style="display:inline;"> &nbsp;A, B, C, T: Int64;</pre></td></tr>
<tr class="nocodegen"><td>3044</td><td><pre style="display:inline;"> &nbsp;x0, x1, x2, x3, x4, x5, x6, x7: UInt64;</pre></td></tr>
<tr class="nocodegen"><td>3045</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3046</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>3047</td><td><pre style="display:inline;"> &nbsp;A &nbsp;:= PInt64Array(@FDigest)[0];</pre></td></tr>
<tr class="nocodegen"><td>3048</td><td><pre style="display:inline;"> &nbsp;B &nbsp;:= PInt64Array(@FDigest)[1];</pre></td></tr>
<tr class="nocodegen"><td>3049</td><td><pre style="display:inline;"> &nbsp;C &nbsp;:= PInt64Array(@FDigest)[2];</pre></td></tr>
<tr class="nocodegen"><td>3050</td><td><pre style="display:inline;"> &nbsp;x0 := PInt64Array(Buffer)[0];</pre></td></tr>
<tr class="nocodegen"><td>3051</td><td><pre style="display:inline;"> &nbsp;x1 := PInt64Array(Buffer)[1];</pre></td></tr>
<tr class="nocodegen"><td>3052</td><td><pre style="display:inline;"> &nbsp;x2 := PInt64Array(Buffer)[2];</pre></td></tr>
<tr class="nocodegen"><td>3053</td><td><pre style="display:inline;"> &nbsp;x3 := PInt64Array(Buffer)[3];</pre></td></tr>
<tr class="nocodegen"><td>3054</td><td><pre style="display:inline;"> &nbsp;x4 := PInt64Array(Buffer)[4];</pre></td></tr>
<tr class="nocodegen"><td>3055</td><td><pre style="display:inline;"> &nbsp;x5 := PInt64Array(Buffer)[5];</pre></td></tr>
<tr class="nocodegen"><td>3056</td><td><pre style="display:inline;"> &nbsp;x6 := PInt64Array(Buffer)[6];</pre></td></tr>
<tr class="nocodegen"><td>3057</td><td><pre style="display:inline;"> &nbsp;x7 := PInt64Array(Buffer)[7];</pre></td></tr>
<tr class="nocodegen"><td>3058</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3059</td><td><pre style="display:inline;"> &nbsp;for I := 1 to FRounds do // a Loop is faster for PC with small Cache</pre></td></tr>
<tr class="nocodegen"><td>3060</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3061</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I &gt; 1 then // Key Schedule</pre></td></tr>
<tr class="nocodegen"><td>3062</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3063</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(x0, x7 xor $A5A5A5A5A5A5A5A5);</pre></td></tr>
<tr class="nocodegen"><td>3064</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;x1 := x1 xor x0;</pre></td></tr>
<tr class="nocodegen"><td>3065</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(x2, x1);</pre></td></tr>
<tr class="nocodegen"><td>3066</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(x3, x2 xor (not x1 shl 19));</pre></td></tr>
<tr class="nocodegen"><td>3067</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;x4 := x4 xor x3;</pre></td></tr>
<tr class="nocodegen"><td>3068</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(x5, x4);</pre></td></tr>
<tr class="nocodegen"><td>3069</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(x6, x5 xor (not x4 shr 23));</pre></td></tr>
<tr class="nocodegen"><td>3070</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;x7 := x7 xor x6;</pre></td></tr>
<tr class="nocodegen"><td>3071</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(x0, x7);</pre></td></tr>
<tr class="nocodegen"><td>3072</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(x1, x0 xor (not x7 shl 19));</pre></td></tr>
<tr class="nocodegen"><td>3073</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;x2 := x2 xor x1;</pre></td></tr>
<tr class="nocodegen"><td>3074</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(x3, x2);</pre></td></tr>
<tr class="nocodegen"><td>3075</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(x4, x3 xor (not x2 shr 23));</pre></td></tr>
<tr class="nocodegen"><td>3076</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;x5 := x5 xor x4;</pre></td></tr>
<tr class="nocodegen"><td>3077</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(x6, x5);</pre></td></tr>
<tr class="nocodegen"><td>3078</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(x7, x6 xor $0123456789ABCDEF);</pre></td></tr>
<tr class="nocodegen"><td>3079</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3080</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3081</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor x0;</pre></td></tr>
<tr class="nocodegen"><td>3082</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, TTiger_Data(Tiger_Data)[0, UInt32(C) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3083</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(C) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3084</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3085</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(C shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3086</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, TTiger_Data(Tiger_Data)[3, UInt32(C) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3087</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(C) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3088</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(C shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3089</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(C shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3090</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3091</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3092</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B shl 2 + B</pre></td></tr>
<tr class="nocodegen"><td>3093</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3094</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3095</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3096</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := B shl 3 - B</pre></td></tr>
<tr class="nocodegen"><td>3097</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3098</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := B shl 3 + B;</pre></td></tr>
<tr class="nocodegen"><td>3099</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3100</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3101</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor x1;</pre></td></tr>
<tr class="nocodegen"><td>3102</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, TTiger_Data(Tiger_Data)[0, UInt32(A) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3103</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(A) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3104</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3105</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(A shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3106</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, TTiger_Data(Tiger_Data)[3, UInt32(A) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3107</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(A) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3108</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(A shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3109</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(A shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3110</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3111</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3112</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C shl 2 + C</pre></td></tr>
<tr class="nocodegen"><td>3113</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3114</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3115</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3116</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := C shl 3 - C</pre></td></tr>
<tr class="nocodegen"><td>3117</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3118</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := C shl 3 + C;</pre></td></tr>
<tr class="nocodegen"><td>3119</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3120</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3121</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor x2;</pre></td></tr>
<tr class="nocodegen"><td>3122</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, TTiger_Data(Tiger_Data)[0, UInt32(B) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3123</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(B) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3124</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;B &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3125</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(B shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3126</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(A, TTiger_Data(Tiger_Data)[3, UInt32(B) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3127</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(B) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3128</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(B shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3129</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(B shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3130</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3131</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3132</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := A shl 2 + A</pre></td></tr>
<tr class="nocodegen"><td>3133</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3134</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3135</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3136</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;A := A shl 3 - A</pre></td></tr>
<tr class="nocodegen"><td>3137</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3138</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;A := A shl 3 + A;</pre></td></tr>
<tr class="nocodegen"><td>3139</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3140</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3141</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor x3;</pre></td></tr>
<tr class="nocodegen"><td>3142</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, TTiger_Data(Tiger_Data)[0, UInt32(C) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3143</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(C) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3144</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3145</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(C shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3146</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, TTiger_Data(Tiger_Data)[3, UInt32(C) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3147</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(C) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3148</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(C shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3149</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(C shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3150</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3151</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3152</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B shl 2 + B</pre></td></tr>
<tr class="nocodegen"><td>3153</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3154</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3155</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3156</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := B shl 3 - B</pre></td></tr>
<tr class="nocodegen"><td>3157</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3158</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := B shl 3 + B;</pre></td></tr>
<tr class="nocodegen"><td>3159</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3160</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3161</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor x4;</pre></td></tr>
<tr class="nocodegen"><td>3162</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, TTiger_Data(Tiger_Data)[0, UInt32(A) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3163</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(A) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3164</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3165</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(A shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3166</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, TTiger_Data(Tiger_Data)[3, UInt32(A) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3167</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(A) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3168</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(A shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3169</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(A shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3170</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3171</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3172</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C shl 2 + C</pre></td></tr>
<tr class="nocodegen"><td>3173</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3174</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3175</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3176</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := C shl 3 - C</pre></td></tr>
<tr class="nocodegen"><td>3177</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3178</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := C shl 3 + C;</pre></td></tr>
<tr class="nocodegen"><td>3179</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3180</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3181</td><td><pre style="display:inline;"> &nbsp; &nbsp;B := B xor x5;</pre></td></tr>
<tr class="nocodegen"><td>3182</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(C, TTiger_Data(Tiger_Data)[0, UInt32(B) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3183</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(B) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3184</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;B &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3185</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(B shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3186</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(A, TTiger_Data(Tiger_Data)[3, UInt32(B) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3187</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(B) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3188</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(B shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3189</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(B shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3190</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3191</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3192</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A := A shl 2 + A</pre></td></tr>
<tr class="nocodegen"><td>3193</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3194</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3195</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3196</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;A := A shl 3 - A</pre></td></tr>
<tr class="nocodegen"><td>3197</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3198</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;A := A shl 3 + A;</pre></td></tr>
<tr class="nocodegen"><td>3199</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3200</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3201</td><td><pre style="display:inline;"> &nbsp; &nbsp;C := C xor x6;</pre></td></tr>
<tr class="nocodegen"><td>3202</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(A, TTiger_Data(Tiger_Data)[0, UInt32(C) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3203</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(C) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3204</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3205</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(C shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3206</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(B, TTiger_Data(Tiger_Data)[3, UInt32(C) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3207</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(C) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3208</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(C shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3209</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(C shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3210</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3211</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3212</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B := B shl 2 + B</pre></td></tr>
<tr class="nocodegen"><td>3213</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3214</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3215</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3216</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := B shl 3 - B</pre></td></tr>
<tr class="nocodegen"><td>3217</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3218</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;B := B shl 3 + B;</pre></td></tr>
<tr class="nocodegen"><td>3219</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3220</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3221</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := A xor x7;</pre></td></tr>
<tr class="nocodegen"><td>3222</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(B, TTiger_Data(Tiger_Data)[0, UInt32(A) &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3223</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(A) shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3224</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A &nbsp;shr 32 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3225</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[3, UInt32(A shr 32) shr 16 and $FF]);</pre></td></tr>
<tr class="nocodegen"><td>3226</td><td><pre style="display:inline;"> &nbsp; &nbsp;Inc(C, TTiger_Data(Tiger_Data)[3, UInt32(A) shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3227</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[2, UInt32(A) shr 24] xor</pre></td></tr>
<tr class="nocodegen"><td>3228</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[1, UInt32(A shr 32) shr 8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3229</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TTiger_Data(Tiger_Data)[0, UInt32(A shr 32) shr 24]);</pre></td></tr>
<tr class="nocodegen"><td>3230</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3231</td><td><pre style="display:inline;"> &nbsp; &nbsp;if I = 1 then</pre></td></tr>
<tr class="nocodegen"><td>3232</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C := C shl 2 + C</pre></td></tr>
<tr class="nocodegen"><td>3233</td><td><pre style="display:inline;"> &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3234</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3235</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if I = 2 then</pre></td></tr>
<tr class="nocodegen"><td>3236</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := C shl 3 - C</pre></td></tr>
<tr class="nocodegen"><td>3237</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>3238</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;C := C shl 3 + C;</pre></td></tr>
<tr class="nocodegen"><td>3239</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3240</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3241</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := A; A := C; C := B; B := T;</pre></td></tr>
<tr class="nocodegen"><td>3242</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3243</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3244</td><td><pre style="display:inline;"> &nbsp;PInt64Array(@FDigest)[0] := A xor PInt64Array(@FDigest)[0];</pre></td></tr>
<tr class="nocodegen"><td>3245</td><td><pre style="display:inline;"> &nbsp;PInt64Array(@FDigest)[1] := B &nbsp;- &nbsp;PInt64Array(@FDigest)[1];</pre></td></tr>
<tr class="nocodegen"><td>3246</td><td><pre style="display:inline;"> &nbsp;PInt64Array(@FDigest)[2] := C &nbsp;+ &nbsp;PInt64Array(@FDigest)[2];</pre></td></tr>
<tr class="nocodegen"><td>3247</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3248</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>3249</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3250</td><td><pre style="display:inline;">function THash_Tiger.GetMaxRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>3251</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3252</td><td><pre style="display:inline;"> &nbsp;Result := cTigerMaxRounds;</pre></td></tr>
<tr class="covered"><td>3253</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3254</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3255</td><td><pre style="display:inline;">function THash_Tiger.GetMinRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>3256</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3257</td><td><pre style="display:inline;"> &nbsp;Result := cTigerMinRounds;</pre></td></tr>
<tr class="covered"><td>3258</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3259</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3260</td><td><pre style="display:inline;">function THash_Tiger.GetRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>3261</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3262</td><td><pre style="display:inline;"> &nbsp;Result := FRounds;</pre></td></tr>
<tr class="covered"><td>3263</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3264</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3265</td><td><pre style="display:inline;">class function THash_Tiger.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3266</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3267</td><td><pre style="display:inline;"> &nbsp;Result := 24;</pre></td></tr>
<tr class="covered"><td>3268</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3269</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3270</td><td><pre style="display:inline;">{ THash_Panama }</pre></td></tr>
<tr class="nocodegen"><td>3271</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3272</td><td><pre style="display:inline;">procedure THash_Panama.DoInit;</pre></td></tr>
<tr class="covered"><td>3273</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3274</td><td><pre style="display:inline;"> &nbsp;FillChar(FLFSRBuffer, SizeOf(FLFSRBuffer), 0);</pre></td></tr>
<tr class="covered"><td>3275</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>3276</td><td><pre style="display:inline;"> &nbsp;FTap := 0;</pre></td></tr>
<tr class="covered"><td>3277</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3278</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3279</td><td><pre style="display:inline;">{$IFNDEF THash_Panama_asm}</pre></td></tr>
<tr class="nocodegen"><td>3280</td><td><pre style="display:inline;">procedure THash_Panama.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3281</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3282</td><td><pre style="display:inline;"> &nbsp;T0, T1, T2, T3: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3283</td><td><pre style="display:inline;"> &nbsp;PBufB, PTap0, PTap25: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3284</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>3285</td><td><pre style="display:inline;"> &nbsp;// perform non-linearity stage (GAMMA)</pre></td></tr>
<tr class="nocodegen"><td>3286</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3287</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3288</td><td><pre style="display:inline;"> &nbsp;FDigest[ 0] := FDigest[ 0] xor (FDigest[ 1] or not FDigest[ 2]);</pre></td></tr>
<tr class="nocodegen"><td>3289</td><td><pre style="display:inline;"> &nbsp;FDigest[ 1] := FDigest[ 1] xor (FDigest[ 2] or not FDigest[ 3]);</pre></td></tr>
<tr class="nocodegen"><td>3290</td><td><pre style="display:inline;"> &nbsp;FDigest[ 2] := FDigest[ 2] xor (FDigest[ 3] or not FDigest[ 4]);</pre></td></tr>
<tr class="nocodegen"><td>3291</td><td><pre style="display:inline;"> &nbsp;FDigest[ 3] := FDigest[ 3] xor (FDigest[ 4] or not FDigest[ 5]);</pre></td></tr>
<tr class="nocodegen"><td>3292</td><td><pre style="display:inline;"> &nbsp;FDigest[ 4] := FDigest[ 4] xor (FDigest[ 5] or not FDigest[ 6]);</pre></td></tr>
<tr class="nocodegen"><td>3293</td><td><pre style="display:inline;"> &nbsp;FDigest[ 5] := FDigest[ 5] xor (FDigest[ 6] or not FDigest[ 7]);</pre></td></tr>
<tr class="nocodegen"><td>3294</td><td><pre style="display:inline;"> &nbsp;FDigest[ 6] := FDigest[ 6] xor (FDigest[ 7] or not FDigest[ 8]);</pre></td></tr>
<tr class="nocodegen"><td>3295</td><td><pre style="display:inline;"> &nbsp;FDigest[ 7] := FDigest[ 7] xor (FDigest[ 8] or not FDigest[ 9]);</pre></td></tr>
<tr class="nocodegen"><td>3296</td><td><pre style="display:inline;"> &nbsp;FDigest[ 8] := FDigest[ 8] xor (FDigest[ 9] or not FDigest[10]);</pre></td></tr>
<tr class="nocodegen"><td>3297</td><td><pre style="display:inline;"> &nbsp;FDigest[ 9] := FDigest[ 9] xor (FDigest[10] or not FDigest[11]);</pre></td></tr>
<tr class="nocodegen"><td>3298</td><td><pre style="display:inline;"> &nbsp;FDigest[10] := FDigest[10] xor (FDigest[11] or not FDigest[12]);</pre></td></tr>
<tr class="nocodegen"><td>3299</td><td><pre style="display:inline;"> &nbsp;FDigest[11] := FDigest[11] xor (FDigest[12] or not FDigest[13]);</pre></td></tr>
<tr class="nocodegen"><td>3300</td><td><pre style="display:inline;"> &nbsp;FDigest[12] := FDigest[12] xor (FDigest[13] or not FDigest[14]);</pre></td></tr>
<tr class="nocodegen"><td>3301</td><td><pre style="display:inline;"> &nbsp;FDigest[13] := FDigest[13] xor (FDigest[14] or not FDigest[15]);</pre></td></tr>
<tr class="nocodegen"><td>3302</td><td><pre style="display:inline;"> &nbsp;FDigest[14] := FDigest[14] xor (FDigest[15] or not FDigest[16]);</pre></td></tr>
<tr class="nocodegen"><td>3303</td><td><pre style="display:inline;"> &nbsp;FDigest[15] := FDigest[15] xor (FDigest[16] or not T0);</pre></td></tr>
<tr class="nocodegen"><td>3304</td><td><pre style="display:inline;"> &nbsp;FDigest[16] := FDigest[16] xor (T0 or not T1);</pre></td></tr>
<tr class="nocodegen"><td>3305</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3306</td><td><pre style="display:inline;"> &nbsp;// perform bit-dispersion stage (PI)</pre></td></tr>
<tr class="nocodegen"><td>3307</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3308</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[ 7]; FDigest[ 1] := (T1 shl &nbsp;1) or (T1 shr 31);</pre></td></tr>
<tr class="nocodegen"><td>3309</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[ 5]; FDigest[ 5] := (T0 shl 15) or (T0 shr 17);</pre></td></tr>
<tr class="nocodegen"><td>3310</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[ 8]; FDigest[ 8] := (T1 shl &nbsp;4) or (T1 shr 28);</pre></td></tr>
<tr class="nocodegen"><td>3311</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[ 6]; FDigest[ 6] := (T0 shl 21) or (T0 shr 11);</pre></td></tr>
<tr class="nocodegen"><td>3312</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[13]; FDigest[13] := (T1 shl 27) or (T1 shr &nbsp;5);</pre></td></tr>
<tr class="nocodegen"><td>3313</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[14]; FDigest[14] := (T0 shl &nbsp;9) or (T0 shr 23);</pre></td></tr>
<tr class="nocodegen"><td>3314</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[ 2]; FDigest[ 2] := (T1 shl &nbsp;3) or (T1 shr 29);</pre></td></tr>
<tr class="nocodegen"><td>3315</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[10]; FDigest[10] := (T0 shl 23) or (T0 shr &nbsp;9);</pre></td></tr>
<tr class="nocodegen"><td>3316</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[16]; FDigest[16] := (T1 shl &nbsp;8) or (T1 shr 24);</pre></td></tr>
<tr class="nocodegen"><td>3317</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[12]; FDigest[12] := (T0 shl 14) or (T0 shr 18);</pre></td></tr>
<tr class="nocodegen"><td>3318</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[ 9]; FDigest[ 9] := (T1 shl 13) or (T1 shr 19);</pre></td></tr>
<tr class="nocodegen"><td>3319</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[11]; FDigest[11] := (T0 shl &nbsp;2) or (T0 shr 30);</pre></td></tr>
<tr class="nocodegen"><td>3320</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[ 4]; FDigest[ 4] := (T1 shl 10) or (T1 shr 22);</pre></td></tr>
<tr class="nocodegen"><td>3321</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[ 3]; FDigest[ 3] := (T0 shl &nbsp;6) or (T0 shr 26);</pre></td></tr>
<tr class="nocodegen"><td>3322</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[15]; FDigest[15] := (T1 shl 24) or (T1 shr &nbsp;8);</pre></td></tr>
<tr class="nocodegen"><td>3323</td><td><pre style="display:inline;"> &nbsp;FDigest[ 7] := (T0 shl 28) or (T0 shr &nbsp;4);</pre></td></tr>
<tr class="nocodegen"><td>3324</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3325</td><td><pre style="display:inline;"> &nbsp;// LFSR emulation</pre></td></tr>
<tr class="nocodegen"><td>3326</td><td><pre style="display:inline;"> &nbsp;PBufB &nbsp;:= @FLFSRBuffer[(FTap + 16) and 31];</pre></td></tr>
<tr class="nocodegen"><td>3327</td><td><pre style="display:inline;"> &nbsp;FTap &nbsp; := (FTap - 1) and 31;</pre></td></tr>
<tr class="nocodegen"><td>3328</td><td><pre style="display:inline;"> &nbsp;PTap0 &nbsp;:= @FLFSRBuffer[FTap];</pre></td></tr>
<tr class="nocodegen"><td>3329</td><td><pre style="display:inline;"> &nbsp;PTap25 := @FLFSRBuffer[(FTap + 25) and 31];</pre></td></tr>
<tr class="nocodegen"><td>3330</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3331</td><td><pre style="display:inline;"> &nbsp;// update the LFSR buffer (LAMBDA_PUSH)</pre></td></tr>
<tr class="nocodegen"><td>3332</td><td><pre style="display:inline;"> &nbsp;PTap25[ 0] := PTap25[ 0] xor PTap0[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3333</td><td><pre style="display:inline;"> &nbsp;PTap25[ 1] := PTap25[ 1] xor PTap0[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3334</td><td><pre style="display:inline;"> &nbsp;PTap25[ 2] := PTap25[ 2] xor PTap0[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3335</td><td><pre style="display:inline;"> &nbsp;PTap25[ 3] := PTap25[ 3] xor PTap0[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3336</td><td><pre style="display:inline;"> &nbsp;PTap25[ 4] := PTap25[ 4] xor PTap0[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3337</td><td><pre style="display:inline;"> &nbsp;PTap25[ 5] := PTap25[ 5] xor PTap0[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3338</td><td><pre style="display:inline;"> &nbsp;PTap25[ 6] := PTap25[ 6] xor PTap0[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3339</td><td><pre style="display:inline;"> &nbsp;PTap25[ 7] := PTap25[ 7] xor PTap0[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3340</td><td><pre style="display:inline;"> &nbsp;PTap0[ 0] := PTap0[ 0] xor Buffer[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3341</td><td><pre style="display:inline;"> &nbsp;PTap0[ 1] := PTap0[ 1] xor Buffer[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3342</td><td><pre style="display:inline;"> &nbsp;PTap0[ 2] := PTap0[ 2] xor Buffer[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3343</td><td><pre style="display:inline;"> &nbsp;PTap0[ 3] := PTap0[ 3] xor Buffer[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3344</td><td><pre style="display:inline;"> &nbsp;PTap0[ 4] := PTap0[ 4] xor Buffer[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3345</td><td><pre style="display:inline;"> &nbsp;PTap0[ 5] := PTap0[ 5] xor Buffer[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3346</td><td><pre style="display:inline;"> &nbsp;PTap0[ 6] := PTap0[ 6] xor Buffer[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3347</td><td><pre style="display:inline;"> &nbsp;PTap0[ 7] := PTap0[ 7] xor Buffer[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3348</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3349</td><td><pre style="display:inline;"> &nbsp;// perform diffusion stage (THETA) + buffer injection stage (SIGMA)</pre></td></tr>
<tr class="nocodegen"><td>3350</td><td><pre style="display:inline;"> &nbsp;T0 := FDigest[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3351</td><td><pre style="display:inline;"> &nbsp;T1 := FDigest[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3352</td><td><pre style="display:inline;"> &nbsp;T2 := FDigest[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3353</td><td><pre style="display:inline;"> &nbsp;T3 := FDigest[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3354</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3355</td><td><pre style="display:inline;"> &nbsp;FDigest[ 0] := FDigest[ 0] xor FDigest[ 1] xor FDigest[ 4] xor 1;</pre></td></tr>
<tr class="nocodegen"><td>3356</td><td><pre style="display:inline;"> &nbsp;FDigest[ 1] := FDigest[ 1] xor FDigest[ 2] xor FDigest[ 5] xor Buffer[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3357</td><td><pre style="display:inline;"> &nbsp;FDigest[ 2] := FDigest[ 2] xor FDigest[ 3] xor FDigest[ 6] xor Buffer[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3358</td><td><pre style="display:inline;"> &nbsp;FDigest[ 3] := FDigest[ 3] xor FDigest[ 4] xor FDigest[ 7] xor Buffer[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3359</td><td><pre style="display:inline;"> &nbsp;FDigest[ 4] := FDigest[ 4] xor FDigest[ 5] xor FDigest[ 8] xor Buffer[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3360</td><td><pre style="display:inline;"> &nbsp;FDigest[ 5] := FDigest[ 5] xor FDigest[ 6] xor FDigest[ 9] xor Buffer[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3361</td><td><pre style="display:inline;"> &nbsp;FDigest[ 6] := FDigest[ 6] xor FDigest[ 7] xor FDigest[10] xor Buffer[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3362</td><td><pre style="display:inline;"> &nbsp;FDigest[ 7] := FDigest[ 7] xor FDigest[ 8] xor FDigest[11] xor Buffer[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3363</td><td><pre style="display:inline;"> &nbsp;FDigest[ 8] := FDigest[ 8] xor FDigest[ 9] xor FDigest[12] xor Buffer[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3364</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3365</td><td><pre style="display:inline;"> &nbsp;FDigest[ 9] := FDigest[ 9] xor FDigest[10] xor FDigest[13] xor PBufB[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3366</td><td><pre style="display:inline;"> &nbsp;FDigest[10] := FDigest[10] xor FDigest[11] xor FDigest[14] xor PBufB[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3367</td><td><pre style="display:inline;"> &nbsp;FDigest[11] := FDigest[11] xor FDigest[12] xor FDigest[15] xor PBufB[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3368</td><td><pre style="display:inline;"> &nbsp;FDigest[12] := FDigest[12] xor FDigest[13] xor FDigest[16] xor PBufB[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3369</td><td><pre style="display:inline;"> &nbsp;FDigest[13] := FDigest[13] xor FDigest[14] xor T0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor PBufB[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3370</td><td><pre style="display:inline;"> &nbsp;FDigest[14] := FDigest[14] xor FDigest[15] xor T1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor PBufB[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3371</td><td><pre style="display:inline;"> &nbsp;FDigest[15] := FDigest[15] xor FDigest[16] xor T2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor PBufB[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3372</td><td><pre style="display:inline;"> &nbsp;FDigest[16] := FDigest[16] xor T0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor T3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor PBufB[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3373</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3374</td><td><pre style="display:inline;">{$ENDIF !THash_Panama_asm}</pre></td></tr>
<tr class="nocodegen"><td>3375</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3376</td><td><pre style="display:inline;">procedure THash_Panama.DoDone;</pre></td></tr>
<tr class="covered"><td>3377</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3378</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="covered"><td>3379</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $01;</pre></td></tr>
<tr class="covered"><td>3380</td><td><pre style="display:inline;"> &nbsp;FBuffer[FBufferIndex] := FPaddingByte;</pre></td></tr>
<tr class="covered"><td>3381</td><td><pre style="display:inline;"> &nbsp;Inc(FBufferIndex);</pre></td></tr>
<tr class="covered"><td>3382</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>3383</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>3384</td><td><pre style="display:inline;"> &nbsp;DoPull;</pre></td></tr>
<tr class="covered"><td>3385</td><td><pre style="display:inline;"> &nbsp;FillChar(FLFSRBuffer, SizeOf(FLFSRBuffer), 0);</pre></td></tr>
<tr class="covered"><td>3386</td><td><pre style="display:inline;"> &nbsp;FTap := 0;</pre></td></tr>
<tr class="covered"><td>3387</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3388</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3389</td><td><pre style="display:inline;">{$IFNDEF THash_Panama_asm}</pre></td></tr>
<tr class="nocodegen"><td>3390</td><td><pre style="display:inline;">procedure THash_Panama.DoPull;</pre></td></tr>
<tr class="nocodegen"><td>3391</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3392</td><td><pre style="display:inline;"> &nbsp;PBufL, PBufB, PTap0, PTap25: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3393</td><td><pre style="display:inline;"> &nbsp;T0, T1, T2, T3: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3394</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3395</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>3396</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 31 do</pre></td></tr>
<tr class="nocodegen"><td>3397</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3398</td><td><pre style="display:inline;"> &nbsp; &nbsp;// LFSR emulation</pre></td></tr>
<tr class="nocodegen"><td>3399</td><td><pre style="display:inline;"> &nbsp; &nbsp;PBufL := @FLFSRBuffer[(FTap + &nbsp;4) and 31];</pre></td></tr>
<tr class="nocodegen"><td>3400</td><td><pre style="display:inline;"> &nbsp; &nbsp;PBufB := @FLFSRBuffer[(FTap + 16) and 31];</pre></td></tr>
<tr class="nocodegen"><td>3401</td><td><pre style="display:inline;"> &nbsp; &nbsp;FTap := (FTap - 1) and 31;</pre></td></tr>
<tr class="nocodegen"><td>3402</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0 &nbsp;:= @FLFSRBuffer[FTap];</pre></td></tr>
<tr class="nocodegen"><td>3403</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25 := @FLFSRBuffer[(FTap + 25) and 31];</pre></td></tr>
<tr class="nocodegen"><td>3404</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3405</td><td><pre style="display:inline;"> &nbsp; &nbsp;// update the LFSR buffer (LAMBDA_PULL)</pre></td></tr>
<tr class="nocodegen"><td>3406</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 0] := PTap25[ 0] xor PTap0[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3407</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 1] := PTap25[ 1] xor PTap0[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3408</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 2] := PTap25[ 2] xor PTap0[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3409</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 3] := PTap25[ 3] xor PTap0[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3410</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 4] := PTap25[ 4] xor PTap0[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3411</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 5] := PTap25[ 5] xor PTap0[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3412</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 6] := PTap25[ 6] xor PTap0[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3413</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap25[ 7] := PTap25[ 7] xor PTap0[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3414</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 0] := PTap0[ 0] xor FDigest[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3415</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 1] := PTap0[ 1] xor FDigest[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3416</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 2] := PTap0[ 2] xor FDigest[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3417</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 3] := PTap0[ 3] xor FDigest[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3418</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 4] := PTap0[ 4] xor FDigest[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3419</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 5] := PTap0[ 5] xor FDigest[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3420</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 6] := PTap0[ 6] xor FDigest[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3421</td><td><pre style="display:inline;"> &nbsp; &nbsp;PTap0[ 7] := PTap0[ 7] xor FDigest[ 8];</pre></td></tr>
<tr class="nocodegen"><td>3422</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3423</td><td><pre style="display:inline;"> &nbsp; &nbsp;// perform non-linearity stage (GAMMA)</pre></td></tr>
<tr class="nocodegen"><td>3424</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3425</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3426</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 0] := FDigest[ 0] xor (FDigest[ 1] or not FDigest[ 2]);</pre></td></tr>
<tr class="nocodegen"><td>3427</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 1] := FDigest[ 1] xor (FDigest[ 2] or not FDigest[ 3]);</pre></td></tr>
<tr class="nocodegen"><td>3428</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 2] := FDigest[ 2] xor (FDigest[ 3] or not FDigest[ 4]);</pre></td></tr>
<tr class="nocodegen"><td>3429</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 3] := FDigest[ 3] xor (FDigest[ 4] or not FDigest[ 5]);</pre></td></tr>
<tr class="nocodegen"><td>3430</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 4] := FDigest[ 4] xor (FDigest[ 5] or not FDigest[ 6]);</pre></td></tr>
<tr class="nocodegen"><td>3431</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 5] := FDigest[ 5] xor (FDigest[ 6] or not FDigest[ 7]);</pre></td></tr>
<tr class="nocodegen"><td>3432</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 6] := FDigest[ 6] xor (FDigest[ 7] or not FDigest[ 8]);</pre></td></tr>
<tr class="nocodegen"><td>3433</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 7] := FDigest[ 7] xor (FDigest[ 8] or not FDigest[ 9]);</pre></td></tr>
<tr class="nocodegen"><td>3434</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 8] := FDigest[ 8] xor (FDigest[ 9] or not FDigest[10]);</pre></td></tr>
<tr class="nocodegen"><td>3435</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 9] := FDigest[ 9] xor (FDigest[10] or not FDigest[11]);</pre></td></tr>
<tr class="nocodegen"><td>3436</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[10] := FDigest[10] xor (FDigest[11] or not FDigest[12]);</pre></td></tr>
<tr class="nocodegen"><td>3437</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[11] := FDigest[11] xor (FDigest[12] or not FDigest[13]);</pre></td></tr>
<tr class="nocodegen"><td>3438</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[12] := FDigest[12] xor (FDigest[13] or not FDigest[14]);</pre></td></tr>
<tr class="nocodegen"><td>3439</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[13] := FDigest[13] xor (FDigest[14] or not FDigest[15]);</pre></td></tr>
<tr class="nocodegen"><td>3440</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[14] := FDigest[14] xor (FDigest[15] or not FDigest[16]);</pre></td></tr>
<tr class="nocodegen"><td>3441</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[15] := FDigest[15] xor (FDigest[16] or not T0);</pre></td></tr>
<tr class="nocodegen"><td>3442</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[16] := FDigest[16] xor (T0 or not T1);</pre></td></tr>
<tr class="nocodegen"><td>3443</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3444</td><td><pre style="display:inline;"> &nbsp; &nbsp;// perform bit-dispersion stage (PI)</pre></td></tr>
<tr class="nocodegen"><td>3445</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3446</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[ 7]; FDigest[ 1] := (T1 shl &nbsp;1) or (T1 shr 31);</pre></td></tr>
<tr class="nocodegen"><td>3447</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[ 5]; FDigest[ 5] := (T0 shl 15) or (T0 shr 17);</pre></td></tr>
<tr class="nocodegen"><td>3448</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[ 8]; FDigest[ 8] := (T1 shl &nbsp;4) or (T1 shr 28);</pre></td></tr>
<tr class="nocodegen"><td>3449</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[ 6]; FDigest[ 6] := (T0 shl 21) or (T0 shr 11);</pre></td></tr>
<tr class="nocodegen"><td>3450</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[13]; FDigest[13] := (T1 shl 27) or (T1 shr &nbsp;5);</pre></td></tr>
<tr class="nocodegen"><td>3451</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[14]; FDigest[14] := (T0 shl &nbsp;9) or (T0 shr 23);</pre></td></tr>
<tr class="nocodegen"><td>3452</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[ 2]; FDigest[ 2] := (T1 shl &nbsp;3) or (T1 shr 29);</pre></td></tr>
<tr class="nocodegen"><td>3453</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[10]; FDigest[10] := (T0 shl 23) or (T0 shr &nbsp;9);</pre></td></tr>
<tr class="nocodegen"><td>3454</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[16]; FDigest[16] := (T1 shl &nbsp;8) or (T1 shr 24);</pre></td></tr>
<tr class="nocodegen"><td>3455</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[12]; FDigest[12] := (T0 shl 14) or (T0 shr 18);</pre></td></tr>
<tr class="nocodegen"><td>3456</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[ 9]; FDigest[ 9] := (T1 shl 13) or (T1 shr 19);</pre></td></tr>
<tr class="nocodegen"><td>3457</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[11]; FDigest[11] := (T0 shl &nbsp;2) or (T0 shr 30);</pre></td></tr>
<tr class="nocodegen"><td>3458</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[ 4]; FDigest[ 4] := (T1 shl 10) or (T1 shr 22);</pre></td></tr>
<tr class="nocodegen"><td>3459</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[ 3]; FDigest[ 3] := (T0 shl &nbsp;6) or (T0 shr 26);</pre></td></tr>
<tr class="nocodegen"><td>3460</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[15]; FDigest[15] := (T1 shl 24) or (T1 shr &nbsp;8);</pre></td></tr>
<tr class="nocodegen"><td>3461</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 7] := (T0 shl 28) or (T0 shr &nbsp;4);</pre></td></tr>
<tr class="nocodegen"><td>3462</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3463</td><td><pre style="display:inline;"> &nbsp; &nbsp;// perform diffusion stage (THETA) + buffer injection stage (SIGMA)</pre></td></tr>
<tr class="nocodegen"><td>3464</td><td><pre style="display:inline;"> &nbsp; &nbsp;T0 := FDigest[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3465</td><td><pre style="display:inline;"> &nbsp; &nbsp;T1 := FDigest[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3466</td><td><pre style="display:inline;"> &nbsp; &nbsp;T2 := FDigest[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3467</td><td><pre style="display:inline;"> &nbsp; &nbsp;T3 := FDigest[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3468</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 0] := FDigest[ 0] xor FDigest[ 1] xor FDigest[ 4] xor 1;</pre></td></tr>
<tr class="nocodegen"><td>3469</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 1] := FDigest[ 1] xor FDigest[ 2] xor FDigest[ 5] xor PBufL[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3470</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 2] := FDigest[ 2] xor FDigest[ 3] xor FDigest[ 6] xor PBufL[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3471</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 3] := FDigest[ 3] xor FDigest[ 4] xor FDigest[ 7] xor PBufL[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3472</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 4] := FDigest[ 4] xor FDigest[ 5] xor FDigest[ 8] xor PBufL[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3473</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 5] := FDigest[ 5] xor FDigest[ 6] xor FDigest[ 9] xor PBufL[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3474</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 6] := FDigest[ 6] xor FDigest[ 7] xor FDigest[10] xor PBufL[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3475</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 7] := FDigest[ 7] xor FDigest[ 8] xor FDigest[11] xor PBufL[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3476</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 8] := FDigest[ 8] xor FDigest[ 9] xor FDigest[12] xor PBufL[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3477</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[ 9] := FDigest[ 9] xor FDigest[10] xor FDigest[13] xor PBufB[ 0];</pre></td></tr>
<tr class="nocodegen"><td>3478</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[10] := FDigest[10] xor FDigest[11] xor FDigest[14] xor PBufB[ 1];</pre></td></tr>
<tr class="nocodegen"><td>3479</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[11] := FDigest[11] xor FDigest[12] xor FDigest[15] xor PBufB[ 2];</pre></td></tr>
<tr class="nocodegen"><td>3480</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[12] := FDigest[12] xor FDigest[13] xor FDigest[16] xor PBufB[ 3];</pre></td></tr>
<tr class="nocodegen"><td>3481</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[13] := FDigest[13] xor FDigest[14] xor T0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor PBufB[ 4];</pre></td></tr>
<tr class="nocodegen"><td>3482</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[14] := FDigest[14] xor FDigest[15] xor T1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor PBufB[ 5];</pre></td></tr>
<tr class="nocodegen"><td>3483</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[15] := FDigest[15] xor FDigest[16] xor T2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor PBufB[ 6];</pre></td></tr>
<tr class="nocodegen"><td>3484</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigest[16] := FDigest[16] xor T0 xor T3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xor PBufB[ 7];</pre></td></tr>
<tr class="nocodegen"><td>3485</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3486</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3487</td><td><pre style="display:inline;"> &nbsp;// move state to Digest buffer</pre></td></tr>
<tr class="nocodegen"><td>3488</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := FDigest[ 9];</pre></td></tr>
<tr class="nocodegen"><td>3489</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := FDigest[10];</pre></td></tr>
<tr class="nocodegen"><td>3490</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := FDigest[11];</pre></td></tr>
<tr class="nocodegen"><td>3491</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := FDigest[12];</pre></td></tr>
<tr class="nocodegen"><td>3492</td><td><pre style="display:inline;"> &nbsp;FDigest[4] := FDigest[13];</pre></td></tr>
<tr class="nocodegen"><td>3493</td><td><pre style="display:inline;"> &nbsp;FDigest[5] := FDigest[14];</pre></td></tr>
<tr class="nocodegen"><td>3494</td><td><pre style="display:inline;"> &nbsp;FDigest[6] := FDigest[15];</pre></td></tr>
<tr class="nocodegen"><td>3495</td><td><pre style="display:inline;"> &nbsp;FDigest[7] := FDigest[16];</pre></td></tr>
<tr class="nocodegen"><td>3496</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3497</td><td><pre style="display:inline;">{$ENDIF !THash_Panama_asm}</pre></td></tr>
<tr class="nocodegen"><td>3498</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3499</td><td><pre style="display:inline;">function THash_Panama.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>3500</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3501</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>3502</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3503</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3504</td><td><pre style="display:inline;">class function THash_Panama.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3505</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3506</td><td><pre style="display:inline;"> &nbsp;Result := 32;</pre></td></tr>
<tr class="covered"><td>3507</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3508</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3509</td><td><pre style="display:inline;">class function THash_Panama.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3510</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3511</td><td><pre style="display:inline;"> &nbsp;Result := 32</pre></td></tr>
<tr class="covered"><td>3512</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3513</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3514</td><td><pre style="display:inline;">{ THashBaseWhirlpool }</pre></td></tr>
<tr class="nocodegen"><td>3515</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3516</td><td><pre style="display:inline;">{$IFNDEF THashBaseWhirlpool_asm}</pre></td></tr>
<tr class="nocodegen"><td>3517</td><td><pre style="display:inline;">procedure THashBaseWhirlpool.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3518</td><td><pre style="display:inline;">type</pre></td></tr>
<tr class="nocodegen"><td>3519</td><td><pre style="display:inline;"> &nbsp;PWhirlData = ^TWhirlData;</pre></td></tr>
<tr class="nocodegen"><td>3520</td><td><pre style="display:inline;"> &nbsp;TWhirlData = array[0..15] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3521</td><td><pre style="display:inline;"> &nbsp;PWhirlTable = ^TWhirlTable;</pre></td></tr>
<tr class="nocodegen"><td>3522</td><td><pre style="display:inline;"> &nbsp;TWhirlTable = array[0..7, 0..511] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3523</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3524</td><td><pre style="display:inline;"> &nbsp;procedure Whirl(var L: TWhirlData; const K: TWhirlData; const T: PWhirlTable);</pre></td></tr>
<tr class="nocodegen"><td>3525</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3526</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[0*2+0] := T[0, ((K[ 0] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3527</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[14] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3528</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[12] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3529</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[10] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3530</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 9] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3531</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 7] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3532</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 5] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3533</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 3] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3534</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[0*2+1] := T[0, ((K[ 0] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3535</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[14] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3536</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[12] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3537</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[10] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3538</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 9] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3539</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 7] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3540</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 5] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3541</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 3] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3542</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[1*2+0] := T[0, ((K[ 2] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3543</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 0] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3544</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[14] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3545</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[12] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3546</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[11] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3547</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 9] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3548</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 7] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3549</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 5] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3550</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[1*2+1] := T[0, ((K[ 2] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3551</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 0] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3552</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[14] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3553</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[12] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3554</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[11] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3555</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 9] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3556</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 7] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3557</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 5] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3558</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[2*2+0] := T[0, ((K[ 4] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3559</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 2] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3560</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 0] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3561</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[14] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3562</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[13] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3563</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[11] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3564</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 9] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3565</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 7] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3566</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[2*2+1] := T[0, ((K[ 4] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3567</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 2] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3568</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 0] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3569</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[14] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3570</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[13] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3571</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[11] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3572</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 9] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3573</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 7] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3574</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[3*2+0] := T[0, ((K[ 6] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3575</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 4] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3576</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 2] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3577</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 0] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3578</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[15] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3579</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[13] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3580</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[11] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3581</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 9] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3582</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[3*2+1] := T[0, ((K[ 6] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3583</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 4] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3584</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 2] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3585</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 0] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3586</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[15] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3587</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[13] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3588</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[11] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3589</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 9] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3590</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[4*2+0] := T[0, ((K[ 8] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3591</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 6] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3592</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 4] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3593</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 2] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3594</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 1] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3595</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[15] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3596</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[13] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3597</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[11] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3598</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[4*2+1] := T[0, ((K[ 8] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3599</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 6] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3600</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 4] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3601</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 2] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3602</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 1] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3603</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[15] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3604</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[13] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3605</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[11] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3606</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[5*2+0] := T[0, ((K[10] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3607</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 8] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3608</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 6] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3609</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 4] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3610</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 3] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3611</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 1] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3612</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[15] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3613</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[13] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3614</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[5*2+1] := T[0, ((K[10] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3615</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[ 8] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3616</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 6] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3617</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 4] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3618</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 3] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3619</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 1] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3620</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[15] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3621</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[13] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3622</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[6*2+0] := T[0, ((K[12] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3623</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[10] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3624</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 8] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3625</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 6] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3626</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 5] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3627</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 3] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3628</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 1] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3629</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[15] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3630</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[6*2+1] := T[0, ((K[12] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3631</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[10] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3632</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[ 8] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3633</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 6] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3634</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 5] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3635</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 3] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3636</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 1] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3637</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[15] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3638</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[7*2+0] := T[0, ((K[14] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3639</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[12] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3640</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[10] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3641</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 8] shr 23) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3642</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 7] shl &nbsp;1) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3643</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 5] shr &nbsp;7) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3644</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 3] shr 15) and $1fe)] xor</pre></td></tr>
<tr class="nocodegen"><td>3645</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 1] shr 23) and $1fe)];</pre></td></tr>
<tr class="nocodegen"><td>3646</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[7*2+1] := T[0, ((K[14] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3647</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[1, ((K[12] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3648</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[2, ((K[10] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3649</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[3, ((K[ 8] shr 23) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3650</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[4, ((K[ 7] shl &nbsp;1) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3651</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[5, ((K[ 5] shr &nbsp;7) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3652</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[6, ((K[ 3] shr 15) and $1fe)+1] xor</pre></td></tr>
<tr class="nocodegen"><td>3653</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[7, ((K[ 1] shr 23) and $1fe)+1];</pre></td></tr>
<tr class="nocodegen"><td>3654</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3655</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3656</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3657</td><td><pre style="display:inline;"> &nbsp;S, L, K: TWhirlData;</pre></td></tr>
<tr class="nocodegen"><td>3658</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3659</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>3660</td><td><pre style="display:inline;"> &nbsp;Assert(not Odd(Whirlpool_Rounds));</pre></td></tr>
<tr class="nocodegen"><td>3661</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3662</td><td><pre style="display:inline;"> &nbsp;Move(FDigest, K, SizeOf(FDigest));</pre></td></tr>
<tr class="nocodegen"><td>3663</td><td><pre style="display:inline;"> &nbsp;XORBuffers(FDigest, Buffer[0], SizeOf(FDigest), S);</pre></td></tr>
<tr class="nocodegen"><td>3664</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3665</td><td><pre style="display:inline;"> &nbsp;// iterate over all rounds</pre></td></tr>
<tr class="nocodegen"><td>3666</td><td><pre style="display:inline;"> &nbsp;for I := 0 to Whirlpool_Rounds div 2 - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3667</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3668</td><td><pre style="display:inline;"> &nbsp; &nbsp;Whirl(L, K, FTableC);</pre></td></tr>
<tr class="nocodegen"><td>3669</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[0] := L[0] xor PUInt32Array(FTableR)[I*4+0];</pre></td></tr>
<tr class="nocodegen"><td>3670</td><td><pre style="display:inline;"> &nbsp; &nbsp;L[1] := L[1] xor PUInt32Array(FTableR)[I*4+1];</pre></td></tr>
<tr class="nocodegen"><td>3671</td><td><pre style="display:inline;"> &nbsp; &nbsp;Whirl(K, S, FTableC);</pre></td></tr>
<tr class="nocodegen"><td>3672</td><td><pre style="display:inline;"> &nbsp; &nbsp;XORBuffers(L, K, SizeOf(S), S);</pre></td></tr>
<tr class="nocodegen"><td>3673</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3674</td><td><pre style="display:inline;"> &nbsp; &nbsp;Whirl(K, L, FTableC);</pre></td></tr>
<tr class="nocodegen"><td>3675</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[0] := K[0] xor PUInt32Array(FTableR)[I*4+2];</pre></td></tr>
<tr class="nocodegen"><td>3676</td><td><pre style="display:inline;"> &nbsp; &nbsp;K[1] := K[1] xor PUInt32Array(FTableR)[I*4+3];</pre></td></tr>
<tr class="nocodegen"><td>3677</td><td><pre style="display:inline;"> &nbsp; &nbsp;Whirl(L, S, FTableC);</pre></td></tr>
<tr class="nocodegen"><td>3678</td><td><pre style="display:inline;"> &nbsp; &nbsp;XORBuffers(K, L, SizeOf(S), S);</pre></td></tr>
<tr class="nocodegen"><td>3679</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3680</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3681</td><td><pre style="display:inline;"> &nbsp;XORBuffers(S, Buffer[0], SizeOf(FDigest), S);</pre></td></tr>
<tr class="nocodegen"><td>3682</td><td><pre style="display:inline;"> &nbsp;XORBuffers(S, FDigest, SizeOf(FDigest), FDigest);</pre></td></tr>
<tr class="nocodegen"><td>3683</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3684</td><td><pre style="display:inline;">{$ENDIF !THashBaseWhirlpool_asm}</pre></td></tr>
<tr class="nocodegen"><td>3685</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3686</td><td><pre style="display:inline;">procedure THashBaseWhirlpool.DoDone;</pre></td></tr>
<tr class="nocodegen"><td>3687</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3688</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>3689</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3690</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="covered"><td>3691</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $80;</pre></td></tr>
<tr class="covered"><td>3692</td><td><pre style="display:inline;"> &nbsp;FBuffer[FBufferIndex] := FPaddingByte;</pre></td></tr>
<tr class="covered"><td>3693</td><td><pre style="display:inline;"> &nbsp;Inc(FBufferIndex);</pre></td></tr>
<tr class="covered"><td>3694</td><td><pre style="display:inline;"> &nbsp;if FBufferIndex &gt; FBufferSize - 32 then</pre></td></tr>
<tr class="nocodegen"><td>3695</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3696</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>3697</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>3698</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBufferIndex := 0;</pre></td></tr>
<tr class="nocodegen"><td>3699</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3700</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>3701</td><td><pre style="display:inline;"> &nbsp;for I := 31 downto 0 do</pre></td></tr>
<tr class="covered"><td>3702</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBuffer[63 - I] := PByteArray(@FCount)[I];</pre></td></tr>
<tr class="covered"><td>3703</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>3704</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3705</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3706</td><td><pre style="display:inline;">function THashBaseWhirlpool.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>3707</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3708</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>3709</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3710</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3711</td><td><pre style="display:inline;">class function THashBaseWhirlpool.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3712</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3713</td><td><pre style="display:inline;"> &nbsp;Result := 64;</pre></td></tr>
<tr class="covered"><td>3714</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3715</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3716</td><td><pre style="display:inline;">class function THashBaseWhirlpool.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3717</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3718</td><td><pre style="display:inline;"> &nbsp;Result := 64;</pre></td></tr>
<tr class="covered"><td>3719</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3720</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3721</td><td><pre style="display:inline;">{ THash_Whirlpool0 }</pre></td></tr>
<tr class="nocodegen"><td>3722</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3723</td><td><pre style="display:inline;">procedure THash_Whirlpool0.DoInit;</pre></td></tr>
<tr class="covered"><td>3724</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3725</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>3726</td><td><pre style="display:inline;"> &nbsp;FTableC := @Whirlpool_C_U;</pre></td></tr>
<tr class="covered"><td>3727</td><td><pre style="display:inline;"> &nbsp;FTableR := @Whirlpool_RC_U</pre></td></tr>
<tr class="covered"><td>3728</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3729</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3730</td><td><pre style="display:inline;">{ THash_WhirlpoolT }</pre></td></tr>
<tr class="nocodegen"><td>3731</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3732</td><td><pre style="display:inline;">procedure THash_WhirlpoolT.DoInit;</pre></td></tr>
<tr class="covered"><td>3733</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3734</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>3735</td><td><pre style="display:inline;"> &nbsp;FTableC := @Whirlpool_C_T;</pre></td></tr>
<tr class="covered"><td>3736</td><td><pre style="display:inline;"> &nbsp;FTableR := @Whirlpool_RC_T;</pre></td></tr>
<tr class="covered"><td>3737</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3738</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3739</td><td><pre style="display:inline;">{ THash_Whirlpool1_ }</pre></td></tr>
<tr class="nocodegen"><td>3740</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3741</td><td><pre style="display:inline;">procedure THash_Whirlpool1_.DoInit;</pre></td></tr>
<tr class="covered"><td>3742</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3743</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>3744</td><td><pre style="display:inline;"> &nbsp;FTableC := @Whirlpool_C_1;</pre></td></tr>
<tr class="covered"><td>3745</td><td><pre style="display:inline;"> &nbsp;FTableR := @Whirlpool_RC_1;</pre></td></tr>
<tr class="covered"><td>3746</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3747</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3748</td><td><pre style="display:inline;">{ THash_Square }</pre></td></tr>
<tr class="nocodegen"><td>3749</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3750</td><td><pre style="display:inline;">procedure THash_Square.DoInit;</pre></td></tr>
<tr class="covered"><td>3751</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3752</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>3753</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3754</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3755</td><td><pre style="display:inline;">{$IFNDEF THash_Square_asm}</pre></td></tr>
<tr class="nocodegen"><td>3756</td><td><pre style="display:inline;">procedure THash_Square.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3757</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3758</td><td><pre style="display:inline;"> &nbsp;Key: array[0..8, 0..3] of UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3759</td><td><pre style="display:inline;"> &nbsp;A, B, C, D: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3760</td><td><pre style="display:inline;"> &nbsp;AA, BB, CC, DD: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3761</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="nocodegen"><td>3762</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>3763</td><td><pre style="display:inline;"> &nbsp;// Build and expand the Key, Digest include the Key</pre></td></tr>
<tr class="nocodegen"><td>3764</td><td><pre style="display:inline;"> &nbsp;Key[0, 0] := FDigest[0];</pre></td></tr>
<tr class="nocodegen"><td>3765</td><td><pre style="display:inline;"> &nbsp;Key[0, 1] := FDigest[1];</pre></td></tr>
<tr class="nocodegen"><td>3766</td><td><pre style="display:inline;"> &nbsp;Key[0, 2] := FDigest[2];</pre></td></tr>
<tr class="nocodegen"><td>3767</td><td><pre style="display:inline;"> &nbsp;Key[0, 3] := FDigest[3];</pre></td></tr>
<tr class="nocodegen"><td>3768</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3769</td><td><pre style="display:inline;"> &nbsp;for I := 1 to 8 do</pre></td></tr>
<tr class="nocodegen"><td>3770</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3771</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I, 0] := Key[I - 1, 0] xor Key[I - 1, 3] shr 8 xor Key[I - 1, 3] shl 24 xor 1 shl (I - 1);</pre></td></tr>
<tr class="nocodegen"><td>3772</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I, 1] := Key[I - 1, 1] xor Key[I, 0];</pre></td></tr>
<tr class="nocodegen"><td>3773</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I, 2] := Key[I - 1, 2] xor Key[I, 1];</pre></td></tr>
<tr class="nocodegen"><td>3774</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I, 3] := Key[I - 1, 3] xor Key[I, 2];</pre></td></tr>
<tr class="nocodegen"><td>3775</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3776</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I - 1, 0] := Square_PHIr[0, Key[I - 1, 0] &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3777</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[1, Key[I - 1, 0] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3778</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[2, Key[I - 1, 0] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3779</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[3, Key[I - 1, 0] shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="nocodegen"><td>3780</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I - 1, 1] := Square_PHIr[0, Key[I - 1, 1] &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3781</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[1, Key[I - 1, 1] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3782</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[2, Key[I - 1, 1] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3783</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[3, Key[I - 1, 1] shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="nocodegen"><td>3784</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I - 1, 2] := Square_PHIr[0, Key[I - 1, 2] &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3785</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[1, Key[I - 1, 2] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3786</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[2, Key[I - 1, 2] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3787</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[3, Key[I - 1, 2] shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="nocodegen"><td>3788</td><td><pre style="display:inline;"> &nbsp; &nbsp;Key[I - 1, 3] := Square_PHIr[0, Key[I - 1, 3] &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3789</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[1, Key[I - 1, 3] shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3790</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[2, Key[I - 1, 3] shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3791</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Square_PHIr[3, Key[I - 1, 3] shr 24 &nbsp; &nbsp; &nbsp; &nbsp;];</pre></td></tr>
<tr class="nocodegen"><td>3792</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3793</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3794</td><td><pre style="display:inline;"> &nbsp;// Encrypt begin here, same TCipher_Square.Encode</pre></td></tr>
<tr class="nocodegen"><td>3795</td><td><pre style="display:inline;"> &nbsp;A := Buffer[0] xor Key[0, 0];</pre></td></tr>
<tr class="nocodegen"><td>3796</td><td><pre style="display:inline;"> &nbsp;B := Buffer[1] xor Key[0, 1];</pre></td></tr>
<tr class="nocodegen"><td>3797</td><td><pre style="display:inline;"> &nbsp;C := Buffer[2] xor Key[0, 2];</pre></td></tr>
<tr class="nocodegen"><td>3798</td><td><pre style="display:inline;"> &nbsp;D := Buffer[3] xor Key[0, 3];</pre></td></tr>
<tr class="nocodegen"><td>3799</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3800</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 6 do</pre></td></tr>
<tr class="nocodegen"><td>3801</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3802</td><td><pre style="display:inline;"> &nbsp; &nbsp;AA := Square_TE[0, A &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3803</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3804</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3805</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D &nbsp; &nbsp; &nbsp; &nbsp;and $FF] xor Key[I + 1, 0];</pre></td></tr>
<tr class="nocodegen"><td>3806</td><td><pre style="display:inline;"> &nbsp; &nbsp;BB := Square_TE[0, A shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3807</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3808</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C shr &nbsp;8 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3809</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D shr &nbsp;8 and $FF] xor Key[I + 1, 1];</pre></td></tr>
<tr class="nocodegen"><td>3810</td><td><pre style="display:inline;"> &nbsp; &nbsp;CC := Square_TE[0, A shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3811</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3812</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C shr 16 and $FF] xor</pre></td></tr>
<tr class="nocodegen"><td>3813</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D shr 16 and $FF] xor Key[I + 1, 2];</pre></td></tr>
<tr class="nocodegen"><td>3814</td><td><pre style="display:inline;"> &nbsp; &nbsp;DD := Square_TE[0, A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3815</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[1, B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3816</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[2, C shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor</pre></td></tr>
<tr class="nocodegen"><td>3817</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_TE[3, D shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] xor Key[I + 1, 3];</pre></td></tr>
<tr class="nocodegen"><td>3818</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3819</td><td><pre style="display:inline;"> &nbsp; &nbsp;A := AA; B := BB; C := CC; D := DD;</pre></td></tr>
<tr class="nocodegen"><td>3820</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3821</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3822</td><td><pre style="display:inline;"> &nbsp;FDigest[0] := Buffer[0] xor</pre></td></tr>
<tr class="nocodegen"><td>3823</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[A &nbsp; &nbsp; &nbsp; &nbsp;and $FF] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3824</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[B &nbsp; &nbsp; &nbsp; &nbsp;and $FF] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3825</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[C &nbsp; &nbsp; &nbsp; &nbsp;and $FF] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3826</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[D &nbsp; &nbsp; &nbsp; &nbsp;and $FF] shl 24 xor Key[8, 0];</pre></td></tr>
<tr class="nocodegen"><td>3827</td><td><pre style="display:inline;"> &nbsp;FDigest[1] := Buffer[1] xor</pre></td></tr>
<tr class="nocodegen"><td>3828</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[A shr &nbsp;8 and $FF] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3829</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[B shr &nbsp;8 and $FF] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3830</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[C shr &nbsp;8 and $FF] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3831</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[D shr &nbsp;8 and $FF] shl 24 xor Key[8, 1];</pre></td></tr>
<tr class="nocodegen"><td>3832</td><td><pre style="display:inline;"> &nbsp;FDigest[2] := Buffer[2] xor</pre></td></tr>
<tr class="nocodegen"><td>3833</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[A shr 16 and $FF] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3834</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[B shr 16 and $FF] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3835</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[C shr 16 and $FF] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3836</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[D shr 16 and $FF] shl 24 xor Key[8, 2];</pre></td></tr>
<tr class="nocodegen"><td>3837</td><td><pre style="display:inline;"> &nbsp;FDigest[3] := Buffer[3] xor</pre></td></tr>
<tr class="nocodegen"><td>3838</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[A shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] &nbsp; &nbsp; &nbsp; &nbsp;xor</pre></td></tr>
<tr class="nocodegen"><td>3839</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[B shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl &nbsp;8 xor</pre></td></tr>
<tr class="nocodegen"><td>3840</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[C shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 16 xor</pre></td></tr>
<tr class="nocodegen"><td>3841</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Square_SEint[D shr 24 &nbsp; &nbsp; &nbsp; &nbsp;] shl 24 xor Key[8, 3];</pre></td></tr>
<tr class="nocodegen"><td>3842</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3843</td><td><pre style="display:inline;">{$ENDIF !THash_Square_asm}</pre></td></tr>
<tr class="nocodegen"><td>3844</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3845</td><td><pre style="display:inline;">procedure THash_Square.DoDone;</pre></td></tr>
<tr class="nocodegen"><td>3846</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3847</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>3848</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3849</td><td><pre style="display:inline;"> &nbsp;if FPaddingByte = 0 then</pre></td></tr>
<tr class="covered"><td>3850</td><td><pre style="display:inline;"> &nbsp; &nbsp;FPaddingByte := $80;</pre></td></tr>
<tr class="covered"><td>3851</td><td><pre style="display:inline;"> &nbsp;FBuffer[FBufferIndex] := FPaddingByte;</pre></td></tr>
<tr class="covered"><td>3852</td><td><pre style="display:inline;"> &nbsp;Inc(FBufferIndex);</pre></td></tr>
<tr class="covered"><td>3853</td><td><pre style="display:inline;"> &nbsp;if FBufferIndex &gt; FBufferSize - 8 then</pre></td></tr>
<tr class="nocodegen"><td>3854</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3855</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>3856</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>3857</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBufferIndex := 0;</pre></td></tr>
<tr class="nocodegen"><td>3858</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3859</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>3860</td><td><pre style="display:inline;"> &nbsp;for I := 7 downto 0 do</pre></td></tr>
<tr class="covered"><td>3861</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBuffer[15 - I] := PByteArray(@FCount[0])[I];</pre></td></tr>
<tr class="covered"><td>3862</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>3863</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3864</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3865</td><td><pre style="display:inline;">function THash_Square.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>3866</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3867</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>3868</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3869</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3870</td><td><pre style="display:inline;">class function THash_Square.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3871</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3872</td><td><pre style="display:inline;"> &nbsp;Result := 16;</pre></td></tr>
<tr class="covered"><td>3873</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3874</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3875</td><td><pre style="display:inline;">class function THash_Square.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3876</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3877</td><td><pre style="display:inline;"> &nbsp;Result := 16;</pre></td></tr>
<tr class="covered"><td>3878</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3879</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3880</td><td><pre style="display:inline;">{ THashBaseSnefru }</pre></td></tr>
<tr class="nocodegen"><td>3881</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3882</td><td><pre style="display:inline;">procedure THashBaseSnefru.SetRounds(Value: UInt32);</pre></td></tr>
<tr class="covered"><td>3883</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3884</td><td><pre style="display:inline;"> &nbsp;if (Value &lt; 2) or (Value &gt; 8) then</pre></td></tr>
<tr class="covered"><td>3885</td><td><pre style="display:inline;"> &nbsp; &nbsp;Value := 8;</pre></td></tr>
<tr class="covered"><td>3886</td><td><pre style="display:inline;"> &nbsp;FRounds := Value;</pre></td></tr>
<tr class="covered"><td>3887</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3888</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3889</td><td><pre style="display:inline;">procedure THashBaseSnefru.DoInit;</pre></td></tr>
<tr class="covered"><td>3890</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3891</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>3892</td><td><pre style="display:inline;"> &nbsp;SetRounds(FRounds);</pre></td></tr>
<tr class="covered"><td>3893</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3894</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3895</td><td><pre style="display:inline;">function THashBaseSnefru.GetMaxRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>3896</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3897</td><td><pre style="display:inline;"> &nbsp;Result := 8;</pre></td></tr>
<tr class="covered"><td>3898</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3899</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3900</td><td><pre style="display:inline;">function THashBaseSnefru.GetMinRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>3901</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3902</td><td><pre style="display:inline;"> &nbsp;Result := 2;</pre></td></tr>
<tr class="covered"><td>3903</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3904</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3905</td><td><pre style="display:inline;">function THashBaseSnefru.GetRounds: UInt32;</pre></td></tr>
<tr class="covered"><td>3906</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3907</td><td><pre style="display:inline;"> &nbsp;Result := FRounds;</pre></td></tr>
<tr class="covered"><td>3908</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3909</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3910</td><td><pre style="display:inline;">procedure THashBaseSnefru.DoDone;</pre></td></tr>
<tr class="covered"><td>3911</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3912</td><td><pre style="display:inline;"> &nbsp;if FBufferIndex &gt; 0 then</pre></td></tr>
<tr class="nocodegen"><td>3913</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>3914</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>3915</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>3916</td><td><pre style="display:inline;"> &nbsp; &nbsp;FBufferIndex := 0;</pre></td></tr>
<tr class="nocodegen"><td>3917</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>3918</td><td><pre style="display:inline;"> &nbsp;FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);</pre></td></tr>
<tr class="covered"><td>3919</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - 8])^ := SwapUInt32(FCount[1]);</pre></td></tr>
<tr class="covered"><td>3920</td><td><pre style="display:inline;"> &nbsp;PUInt32(@FBuffer[FBufferSize - 4])^ := SwapUInt32(FCount[0]);</pre></td></tr>
<tr class="covered"><td>3921</td><td><pre style="display:inline;"> &nbsp;DoTransform(Pointer(FBuffer));</pre></td></tr>
<tr class="covered"><td>3922</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(FDigest, FDigest, 8);</pre></td></tr>
<tr class="covered"><td>3923</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3924</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3925</td><td><pre style="display:inline;">function THashBaseSnefru.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>3926</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3927</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>3928</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3929</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3930</td><td><pre style="display:inline;">{ THash_Snefru128 }</pre></td></tr>
<tr class="nocodegen"><td>3931</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3932</td><td><pre style="display:inline;">{$IFNDEF THash_Snefru128_asm}</pre></td></tr>
<tr class="nocodegen"><td>3933</td><td><pre style="display:inline;">procedure THash_Snefru128.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3934</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>3935</td><td><pre style="display:inline;"> &nbsp;ShiftTable: array[0..3] of Integer = (16, 8, 16, 24);</pre></td></tr>
<tr class="nocodegen"><td>3936</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3937</td><td><pre style="display:inline;"> &nbsp;I, Index, ByteInWord, T, N, S, S0, S1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3938</td><td><pre style="display:inline;"> &nbsp;D, Box0, Box1: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3939</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>3940</td><td><pre style="display:inline;"> &nbsp;D := @FDigest;</pre></td></tr>
<tr class="nocodegen"><td>3941</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Buffer[0], D[4], 12);</pre></td></tr>
<tr class="nocodegen"><td>3942</td><td><pre style="display:inline;"> &nbsp;Move(D[0], D[16], 16);</pre></td></tr>
<tr class="nocodegen"><td>3943</td><td><pre style="display:inline;"> &nbsp;Box0 := @Snefru_Data[0];</pre></td></tr>
<tr class="nocodegen"><td>3944</td><td><pre style="display:inline;"> &nbsp;Box1 := @Snefru_Data[1];</pre></td></tr>
<tr class="nocodegen"><td>3945</td><td><pre style="display:inline;"> &nbsp;for Index := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>3946</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3947</td><td><pre style="display:inline;"> &nbsp; &nbsp;for ByteInWord := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>3948</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3949</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;I := 0;</pre></td></tr>
<tr class="nocodegen"><td>3950</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;N := D[0];</pre></td></tr>
<tr class="nocodegen"><td>3951</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;while I &lt; 16 do</pre></td></tr>
<tr class="nocodegen"><td>3952</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>3953</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S0 := Box0[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>3954</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;1) and 15; &nbsp; &nbsp;N := D[T] xor S0; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>3955</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 15) and 15; D[T] := D[T] xor S0;</pre></td></tr>
<tr class="nocodegen"><td>3956</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S1 := Box0[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>3957</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;2) and 15; &nbsp; &nbsp;N := D[T] xor S1; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>3958</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 16) and 15; D[T] := D[T] xor S1;</pre></td></tr>
<tr class="nocodegen"><td>3959</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S0 := Box1[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>3960</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;3) and 15; &nbsp; &nbsp;N := D[T] xor S0; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>3961</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 17) and 15; D[T] := D[T] xor S0;</pre></td></tr>
<tr class="nocodegen"><td>3962</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S1 := Box1[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>3963</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;4) and 15; &nbsp; &nbsp;N := D[T] xor S1; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>3964</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 18) and 15; D[T] := D[T] xor S1;</pre></td></tr>
<tr class="nocodegen"><td>3965</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(I, 4);</pre></td></tr>
<tr class="nocodegen"><td>3966</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3967</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := ShiftTable[ByteInWord];</pre></td></tr>
<tr class="nocodegen"><td>3968</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S := 32 - T;</pre></td></tr>
<tr class="nocodegen"><td>3969</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>3970</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;D[I] := D[I] shr T or D[I] shl S;</pre></td></tr>
<tr class="nocodegen"><td>3971</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3972</td><td><pre style="display:inline;"> &nbsp; &nbsp;Box0 := @Box0[512];</pre></td></tr>
<tr class="nocodegen"><td>3973</td><td><pre style="display:inline;"> &nbsp; &nbsp;Box1 := @Box1[512];</pre></td></tr>
<tr class="nocodegen"><td>3974</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>3975</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>3976</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := D[I + 16] xor D[15 - I];</pre></td></tr>
<tr class="nocodegen"><td>3977</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3978</td><td><pre style="display:inline;">{$ENDIF !THash_Snefru128_asm}</pre></td></tr>
<tr class="nocodegen"><td>3979</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3980</td><td><pre style="display:inline;">class function THash_Snefru128.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3981</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3982</td><td><pre style="display:inline;"> &nbsp;Result := 16;</pre></td></tr>
<tr class="covered"><td>3983</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3984</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3985</td><td><pre style="display:inline;">class function THash_Snefru128.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>3986</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>3987</td><td><pre style="display:inline;"> &nbsp;Result := 48</pre></td></tr>
<tr class="covered"><td>3988</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>3989</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3990</td><td><pre style="display:inline;">{ THash_Snefru256 }</pre></td></tr>
<tr class="nocodegen"><td>3991</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>3992</td><td><pre style="display:inline;">{$IFNDEF THash_Snefru256_asm}</pre></td></tr>
<tr class="nocodegen"><td>3993</td><td><pre style="display:inline;">procedure THash_Snefru256.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="nocodegen"><td>3994</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>3995</td><td><pre style="display:inline;"> &nbsp;ShiftTable: array[0..3] of Integer = (16, 8, 16, 24);</pre></td></tr>
<tr class="nocodegen"><td>3996</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>3997</td><td><pre style="display:inline;"> &nbsp;I, Index, ByteInWord, T, N, S, S0, S1: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>3998</td><td><pre style="display:inline;"> &nbsp;D, Box0, Box1: PUInt32Array;</pre></td></tr>
<tr class="nocodegen"><td>3999</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4000</td><td><pre style="display:inline;"> &nbsp;D := @FDigest;</pre></td></tr>
<tr class="nocodegen"><td>4001</td><td><pre style="display:inline;"> &nbsp;SwapUInt32Buffer(Buffer[0], D[8], 8);</pre></td></tr>
<tr class="nocodegen"><td>4002</td><td><pre style="display:inline;"> &nbsp;Move(D[0], D[16], 32);</pre></td></tr>
<tr class="nocodegen"><td>4003</td><td><pre style="display:inline;"> &nbsp;Box0 := @Snefru_Data[0];</pre></td></tr>
<tr class="nocodegen"><td>4004</td><td><pre style="display:inline;"> &nbsp;Box1 := @Snefru_Data[1];</pre></td></tr>
<tr class="nocodegen"><td>4005</td><td><pre style="display:inline;"> &nbsp;for Index := 0 to FRounds - 1 do</pre></td></tr>
<tr class="nocodegen"><td>4006</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4007</td><td><pre style="display:inline;"> &nbsp; &nbsp;for ByteInWord := 0 to 3 do</pre></td></tr>
<tr class="nocodegen"><td>4008</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4009</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;I := 0;</pre></td></tr>
<tr class="nocodegen"><td>4010</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;N := D[0];</pre></td></tr>
<tr class="nocodegen"><td>4011</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;while I &lt; 16 do</pre></td></tr>
<tr class="nocodegen"><td>4012</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4013</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S0 := Box0[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4014</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;1) and 15; &nbsp; &nbsp;N := D[T] xor S0; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>4015</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 15) and 15; D[T] := D[T] xor S0;</pre></td></tr>
<tr class="nocodegen"><td>4016</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S1 := Box0[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4017</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;2) and 15; &nbsp; &nbsp;N := D[T] xor S1; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>4018</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 16) and 15; D[T] := D[T] xor S1;</pre></td></tr>
<tr class="nocodegen"><td>4019</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S0 := Box1[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4020</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;3) and 15; &nbsp; &nbsp;N := D[T] xor S0; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>4021</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 17) and 15; D[T] := D[T] xor S0;</pre></td></tr>
<tr class="nocodegen"><td>4022</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;S1 := Box1[N and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4023</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + &nbsp;4) and 15; &nbsp; &nbsp;N := D[T] xor S1; D[T] := N;</pre></td></tr>
<tr class="nocodegen"><td>4024</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;T := (I + 18) and 15; D[T] := D[T] xor S1;</pre></td></tr>
<tr class="nocodegen"><td>4025</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;Inc(I, 4);</pre></td></tr>
<tr class="nocodegen"><td>4026</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4027</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;T := ShiftTable[ByteInWord];</pre></td></tr>
<tr class="nocodegen"><td>4028</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;S := 32 - T;</pre></td></tr>
<tr class="nocodegen"><td>4029</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;for I := 0 to 15 do</pre></td></tr>
<tr class="nocodegen"><td>4030</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;D[I] := D[I] shr T or D[I] shl S;</pre></td></tr>
<tr class="nocodegen"><td>4031</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4032</td><td><pre style="display:inline;"> &nbsp; &nbsp;Box0 := @Box0[512];</pre></td></tr>
<tr class="nocodegen"><td>4033</td><td><pre style="display:inline;"> &nbsp; &nbsp;Box1 := @Box1[512];</pre></td></tr>
<tr class="nocodegen"><td>4034</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4035</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 7 do</pre></td></tr>
<tr class="nocodegen"><td>4036</td><td><pre style="display:inline;"> &nbsp; &nbsp;D[I] := D[I + 16] xor D[15 - I];</pre></td></tr>
<tr class="nocodegen"><td>4037</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4038</td><td><pre style="display:inline;">{$ENDIF !THash_Snefru256_asm}</pre></td></tr>
<tr class="nocodegen"><td>4039</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4040</td><td><pre style="display:inline;">class function THash_Snefru256.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4041</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4042</td><td><pre style="display:inline;"> &nbsp;Result := 32;</pre></td></tr>
<tr class="covered"><td>4043</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4044</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4045</td><td><pre style="display:inline;">class function THash_Snefru256.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4046</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4047</td><td><pre style="display:inline;"> &nbsp;Result := 32</pre></td></tr>
<tr class="covered"><td>4048</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4049</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4050</td><td><pre style="display:inline;">{ THash_Sapphire }</pre></td></tr>
<tr class="nocodegen"><td>4051</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4052</td><td><pre style="display:inline;">procedure THash_Sapphire.DoInit;</pre></td></tr>
<tr class="nocodegen"><td>4053</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4054</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>4055</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4056</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest, SizeOf(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>4057</td><td><pre style="display:inline;"> &nbsp;FRotor := 1;</pre></td></tr>
<tr class="covered"><td>4058</td><td><pre style="display:inline;"> &nbsp;FRatchet := 3;</pre></td></tr>
<tr class="covered"><td>4059</td><td><pre style="display:inline;"> &nbsp;FAvalanche := 5;</pre></td></tr>
<tr class="covered"><td>4060</td><td><pre style="display:inline;"> &nbsp;FPlain := 7;</pre></td></tr>
<tr class="covered"><td>4061</td><td><pre style="display:inline;"> &nbsp;FCipher := 11;</pre></td></tr>
<tr class="covered"><td>4062</td><td><pre style="display:inline;"> &nbsp;for I := 0 to 255 do</pre></td></tr>
<tr class="covered"><td>4063</td><td><pre style="display:inline;"> &nbsp; &nbsp;FCards[I] := 255 - I;</pre></td></tr>
<tr class="covered"><td>4064</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4065</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4066</td><td><pre style="display:inline;">procedure THash_Sapphire.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="notcovered"><td>4067</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4068</td><td><pre style="display:inline;"> &nbsp;// Empty on purpose: the base class for the hashes declares an abstract</pre></td></tr>
<tr class="nocodegen"><td>4069</td><td><pre style="display:inline;"> &nbsp;// DoTransform method and not providing an override for it would cause a</pre></td></tr>
<tr class="nocodegen"><td>4070</td><td><pre style="display:inline;"> &nbsp;// compiler warning</pre></td></tr>
<tr class="notcovered"><td>4071</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4072</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4073</td><td><pre style="display:inline;">procedure THash_Sapphire.SetDigestSize(Value: UInt8);</pre></td></tr>
<tr class="covered"><td>4074</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4075</td><td><pre style="display:inline;"> &nbsp;if (Value &gt;= 1) and (Value &lt;= 64) then</pre></td></tr>
<tr class="covered"><td>4076</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigestSize := Value</pre></td></tr>
<tr class="nocodegen"><td>4077</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>4078</td><td><pre style="display:inline;"> &nbsp; &nbsp;FDigestSize := DigestSize;</pre></td></tr>
<tr class="covered"><td>4079</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4080</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4081</td><td><pre style="display:inline;">procedure THash_Sapphire.DoDone;</pre></td></tr>
<tr class="nocodegen"><td>4082</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4083</td><td><pre style="display:inline;"> &nbsp;I: Integer;</pre></td></tr>
<tr class="covered"><td>4084</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4085</td><td><pre style="display:inline;"> &nbsp;for I := 255 downto 0 do</pre></td></tr>
<tr class="covered"><td>4086</td><td><pre style="display:inline;"> &nbsp; &nbsp;Calc(I, 1);</pre></td></tr>
<tr class="covered"><td>4087</td><td><pre style="display:inline;"> &nbsp;for I := 0 to DigestSize - 1 do</pre></td></tr>
<tr class="nocodegen"><td>4088</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4089</td><td><pre style="display:inline;"> &nbsp; &nbsp;Calc(#0#0, 1);</pre></td></tr>
<tr class="covered"><td>4090</td><td><pre style="display:inline;"> &nbsp; &nbsp;PByteArray(@FDigest)[I] := FCipher;</pre></td></tr>
<tr class="covered"><td>4091</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4092</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4093</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4094</td><td><pre style="display:inline;">{$IFNDEF THash_Sapphire_asm}</pre></td></tr>
<tr class="nocodegen"><td>4095</td><td><pre style="display:inline;">procedure THash_Sapphire.Calc(const Data; DataSize: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4096</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4097</td><td><pre style="display:inline;"> &nbsp;Cipher, Ratchet, Rotor, Plain, Avalanche, T: UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4098</td><td><pre style="display:inline;"> &nbsp;D: PByte;</pre></td></tr>
<tr class="nocodegen"><td>4099</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4100</td><td><pre style="display:inline;"> &nbsp;D &nbsp; &nbsp; &nbsp; &nbsp; := @Data;</pre></td></tr>
<tr class="nocodegen"><td>4101</td><td><pre style="display:inline;"> &nbsp;Cipher &nbsp; &nbsp;:= FCipher;</pre></td></tr>
<tr class="nocodegen"><td>4102</td><td><pre style="display:inline;"> &nbsp;Ratchet &nbsp; := FRatchet;</pre></td></tr>
<tr class="nocodegen"><td>4103</td><td><pre style="display:inline;"> &nbsp;Rotor &nbsp; &nbsp; := FRotor;</pre></td></tr>
<tr class="nocodegen"><td>4104</td><td><pre style="display:inline;"> &nbsp;Plain &nbsp; &nbsp; := FPlain;</pre></td></tr>
<tr class="nocodegen"><td>4105</td><td><pre style="display:inline;"> &nbsp;Avalanche := FAvalanche;</pre></td></tr>
<tr class="nocodegen"><td>4106</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4107</td><td><pre style="display:inline;"> &nbsp;while DataSize &gt; 0 do</pre></td></tr>
<tr class="nocodegen"><td>4108</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4109</td><td><pre style="display:inline;"> &nbsp; &nbsp;Dec(DataSize);</pre></td></tr>
<tr class="nocodegen"><td>4110</td><td><pre style="display:inline;"> &nbsp; &nbsp;Ratchet := (Ratchet + FCards[Rotor]) and $FF;</pre></td></tr>
<tr class="nocodegen"><td>4111</td><td><pre style="display:inline;"> &nbsp; &nbsp;Rotor := (Rotor + 1) and $FF;</pre></td></tr>
<tr class="nocodegen"><td>4112</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := FCards[Cipher];</pre></td></tr>
<tr class="nocodegen"><td>4113</td><td><pre style="display:inline;"> &nbsp; &nbsp;FCards[Cipher] := FCards[Ratchet];</pre></td></tr>
<tr class="nocodegen"><td>4114</td><td><pre style="display:inline;"> &nbsp; &nbsp;FCards[Ratchet] := FCards[Plain];</pre></td></tr>
<tr class="nocodegen"><td>4115</td><td><pre style="display:inline;"> &nbsp; &nbsp;FCards[Plain] := FCards[Rotor];</pre></td></tr>
<tr class="nocodegen"><td>4116</td><td><pre style="display:inline;"> &nbsp; &nbsp;FCards[Rotor] := T;</pre></td></tr>
<tr class="nocodegen"><td>4117</td><td><pre style="display:inline;"> &nbsp; &nbsp;Avalanche := (Avalanche + FCards[T]) and $FF;</pre></td></tr>
<tr class="nocodegen"><td>4118</td><td><pre style="display:inline;"> &nbsp; &nbsp;T := (FCards[Plain] + FCards[Cipher] + FCards[Avalanche]) and $FF;</pre></td></tr>
<tr class="nocodegen"><td>4119</td><td><pre style="display:inline;"> &nbsp; &nbsp;Plain := D^; Inc(D);</pre></td></tr>
<tr class="nocodegen"><td>4120</td><td><pre style="display:inline;"> &nbsp; &nbsp;Cipher := Plain xor FCards[FCards[T]] xor FCards[(FCards[Ratchet] + FCards[Rotor]) and $FF];</pre></td></tr>
<tr class="nocodegen"><td>4121</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4122</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4123</td><td><pre style="display:inline;"> &nbsp;FCipher &nbsp; &nbsp;:= Cipher;</pre></td></tr>
<tr class="nocodegen"><td>4124</td><td><pre style="display:inline;"> &nbsp;FRatchet &nbsp; := Ratchet;</pre></td></tr>
<tr class="nocodegen"><td>4125</td><td><pre style="display:inline;"> &nbsp;FRotor &nbsp; &nbsp; := Rotor;</pre></td></tr>
<tr class="nocodegen"><td>4126</td><td><pre style="display:inline;"> &nbsp;FPlain &nbsp; &nbsp; := Plain;</pre></td></tr>
<tr class="nocodegen"><td>4127</td><td><pre style="display:inline;"> &nbsp;FAvalanche := Avalanche;</pre></td></tr>
<tr class="nocodegen"><td>4128</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4129</td><td><pre style="display:inline;">{$ENDIF !THash_Sapphire_asm}</pre></td></tr>
<tr class="nocodegen"><td>4130</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4131</td><td><pre style="display:inline;">function THash_Sapphire.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>4132</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4133</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest;</pre></td></tr>
<tr class="covered"><td>4134</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4135</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4136</td><td><pre style="display:inline;">function THash_Sapphire.DigestAsBytes: TBytes;</pre></td></tr>
<tr class="nocodegen"><td>4137</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4138</td><td><pre style="display:inline;"> &nbsp;Size: Integer;</pre></td></tr>
<tr class="covered"><td>4139</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4140</td><td><pre style="display:inline;"> &nbsp;if FDigestSize &gt; 0 then</pre></td></tr>
<tr class="covered"><td>4141</td><td><pre style="display:inline;"> &nbsp; &nbsp;Size := FDigestSize</pre></td></tr>
<tr class="nocodegen"><td>4142</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="notcovered"><td>4143</td><td><pre style="display:inline;"> &nbsp; &nbsp;Size := DigestSize;</pre></td></tr>
<tr class="nocodegen"><td>4144</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4145</td><td><pre style="display:inline;"> &nbsp;SetLength(Result, Size);</pre></td></tr>
<tr class="covered"><td>4146</td><td><pre style="display:inline;"> &nbsp;if Size &lt;&gt; 0 then</pre></td></tr>
<tr class="covered"><td>4147</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(FDigest, Result[0], Size);</pre></td></tr>
<tr class="covered"><td>4148</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4149</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4150</td><td><pre style="display:inline;">class function THash_Sapphire.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4151</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4152</td><td><pre style="display:inline;"> &nbsp;Result := 64;</pre></td></tr>
<tr class="covered"><td>4153</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4154</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4155</td><td><pre style="display:inline;">class function THash_Sapphire.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4156</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4157</td><td><pre style="display:inline;"> &nbsp;Result := 1;</pre></td></tr>
<tr class="covered"><td>4158</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4159</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4160</td><td><pre style="display:inline;">{$IFDEF RESTORE_RANGECHECKS}{$R+}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>4161</td><td><pre style="display:inline;">{$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>4162</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4163</td><td><pre style="display:inline;">{ THash_SHA3_224 }</pre></td></tr>
<tr class="nocodegen"><td>4164</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4165</td><td><pre style="display:inline;">class function THash_SHA3_224.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4166</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4167</td><td><pre style="display:inline;"> &nbsp;Result := 144;</pre></td></tr>
<tr class="covered"><td>4168</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4169</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4170</td><td><pre style="display:inline;">class function THash_SHA3_224.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4171</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4172</td><td><pre style="display:inline;"> &nbsp;Result := 28;</pre></td></tr>
<tr class="covered"><td>4173</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4174</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4175</td><td><pre style="display:inline;">procedure THash_SHA3_224.DoInit;</pre></td></tr>
<tr class="covered"><td>4176</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4177</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4178</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4179</td><td><pre style="display:inline;"> &nbsp;InitSponge(1152, &nbsp;448);</pre></td></tr>
<tr class="covered"><td>4180</td><td><pre style="display:inline;"> &nbsp;FSpongeState.FixedOutputLength := 224;</pre></td></tr>
<tr class="covered"><td>4181</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4182</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4183</td><td><pre style="display:inline;">{ THash_SHA3_256 }</pre></td></tr>
<tr class="nocodegen"><td>4184</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4185</td><td><pre style="display:inline;">class function THash_SHA3_256.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4186</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4187</td><td><pre style="display:inline;"> &nbsp;Result := 136;</pre></td></tr>
<tr class="covered"><td>4188</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4189</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4190</td><td><pre style="display:inline;">class function THash_SHA3_256.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4191</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4192</td><td><pre style="display:inline;"> &nbsp;Result := 32;</pre></td></tr>
<tr class="covered"><td>4193</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4194</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4195</td><td><pre style="display:inline;">procedure THash_SHA3_256.DoInit;</pre></td></tr>
<tr class="covered"><td>4196</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4197</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4198</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4199</td><td><pre style="display:inline;"> &nbsp;InitSponge(1088, &nbsp;512);</pre></td></tr>
<tr class="covered"><td>4200</td><td><pre style="display:inline;"> &nbsp;FSpongeState.fixedOutputLength := 256;</pre></td></tr>
<tr class="covered"><td>4201</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4202</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4203</td><td><pre style="display:inline;">{ THash_SHA3_384 }</pre></td></tr>
<tr class="nocodegen"><td>4204</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4205</td><td><pre style="display:inline;">class function THash_SHA3_384.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4206</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4207</td><td><pre style="display:inline;"> &nbsp;Result := 104;</pre></td></tr>
<tr class="covered"><td>4208</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4209</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4210</td><td><pre style="display:inline;">class function THash_SHA3_384.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4211</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4212</td><td><pre style="display:inline;"> &nbsp;Result := 48;</pre></td></tr>
<tr class="covered"><td>4213</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4214</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4215</td><td><pre style="display:inline;">procedure THash_SHA3_384.DoInit;</pre></td></tr>
<tr class="covered"><td>4216</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4217</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4218</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4219</td><td><pre style="display:inline;"> &nbsp;InitSponge(832, &nbsp;768);</pre></td></tr>
<tr class="covered"><td>4220</td><td><pre style="display:inline;"> &nbsp;FSpongeState.fixedOutputLength := 384;</pre></td></tr>
<tr class="covered"><td>4221</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4222</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4223</td><td><pre style="display:inline;">{ THash_SHA3_512 }</pre></td></tr>
<tr class="nocodegen"><td>4224</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4225</td><td><pre style="display:inline;">class function THash_SHA3_512.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4226</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4227</td><td><pre style="display:inline;"> &nbsp;Result := 72;</pre></td></tr>
<tr class="covered"><td>4228</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4229</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4230</td><td><pre style="display:inline;">class function THash_SHA3_512.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4231</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4232</td><td><pre style="display:inline;"> &nbsp;Result := 64;</pre></td></tr>
<tr class="covered"><td>4233</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4234</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4235</td><td><pre style="display:inline;">procedure THash_SHA3_512.DoInit;</pre></td></tr>
<tr class="covered"><td>4236</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4237</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4238</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4239</td><td><pre style="display:inline;"> &nbsp;InitSponge(576, 1024);</pre></td></tr>
<tr class="covered"><td>4240</td><td><pre style="display:inline;"> &nbsp;FSpongeState.fixedOutputLength := 512;</pre></td></tr>
<tr class="covered"><td>4241</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4242</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4243</td><td><pre style="display:inline;">{ THash_Shake128 }</pre></td></tr>
<tr class="nocodegen"><td>4244</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4245</td><td><pre style="display:inline;">class function THash_Shake128.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4246</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4247</td><td><pre style="display:inline;"> &nbsp;Result := 168;</pre></td></tr>
<tr class="covered"><td>4248</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4249</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4250</td><td><pre style="display:inline;">class function THash_Shake128.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4251</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4252</td><td><pre style="display:inline;"> &nbsp;// 0 because the hash output length is defined via HashSize property at runtime</pre></td></tr>
<tr class="covered"><td>4253</td><td><pre style="display:inline;"> &nbsp;Result := 0;</pre></td></tr>
<tr class="covered"><td>4254</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4255</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4256</td><td><pre style="display:inline;">procedure THash_Shake128.DoInit;</pre></td></tr>
<tr class="covered"><td>4257</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4258</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4259</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4260</td><td><pre style="display:inline;"> &nbsp;InitSponge(1344, 256);</pre></td></tr>
<tr class="covered"><td>4261</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4262</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4263</td><td><pre style="display:inline;">{ THash_Shake256 }</pre></td></tr>
<tr class="nocodegen"><td>4264</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4265</td><td><pre style="display:inline;">class function THash_Shake256.BlockSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4266</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4267</td><td><pre style="display:inline;"> &nbsp;Result := 136;</pre></td></tr>
<tr class="covered"><td>4268</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4269</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4270</td><td><pre style="display:inline;">class function THash_Shake256.DigestSize: UInt32;</pre></td></tr>
<tr class="covered"><td>4271</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4272</td><td><pre style="display:inline;"> &nbsp;// 0 because the hash output length is defined via HashSize property at runtime</pre></td></tr>
<tr class="covered"><td>4273</td><td><pre style="display:inline;"> &nbsp;Result := 0;</pre></td></tr>
<tr class="covered"><td>4274</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4275</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4276</td><td><pre style="display:inline;">procedure THash_Shake256.DoInit;</pre></td></tr>
<tr class="covered"><td>4277</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4278</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4279</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4280</td><td><pre style="display:inline;"> &nbsp;InitSponge(1088, 512);</pre></td></tr>
<tr class="covered"><td>4281</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4282</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4283</td><td><pre style="display:inline;">{ THash_SHA3Base }</pre></td></tr>
<tr class="nocodegen"><td>4284</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4285</td><td><pre style="display:inline;">procedure THash_SHA3Base.InitSponge(Rate, Capacity: UInt16);</pre></td></tr>
<tr class="nocodegen"><td>4286</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4287</td><td><pre style="display:inline;"> &nbsp;OutputLengthBackup : UInt16;</pre></td></tr>
<tr class="covered"><td>4288</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4289</td><td><pre style="display:inline;"> &nbsp;if FOutpLengSet then</pre></td></tr>
<tr class="covered"><td>4290</td><td><pre style="display:inline;"> &nbsp; &nbsp;OutputLengthBackup := FSpongeState.FixedOutputLength</pre></td></tr>
<tr class="nocodegen"><td>4291</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4292</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Suppress compiler warning about potentially uninitialized variable</pre></td></tr>
<tr class="covered"><td>4293</td><td><pre style="display:inline;"> &nbsp; &nbsp;OutputLengthBackup := 0;</pre></td></tr>
<tr class="nocodegen"><td>4294</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4295</td><td><pre style="display:inline;"> &nbsp;FillChar(FSpongeState, SizeOf(FSpongeState), 0);</pre></td></tr>
<tr class="nocodegen"><td>4296</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4297</td><td><pre style="display:inline;"> &nbsp;if (Rate + Capacity &lt;&gt; 1600) or (Rate = 0) or (Rate &gt;= 1600) or</pre></td></tr>
<tr class="nocodegen"><td>4298</td><td><pre style="display:inline;"> &nbsp; &nbsp; ((Rate and 63) &lt;&gt; 0) then</pre></td></tr>
<tr class="notcovered"><td>4299</td><td><pre style="display:inline;"> &nbsp; &nbsp;raise EDECHashException.CreateFmt(sHashInitFailure, [&apos;SHA3&apos;,</pre></td></tr>
<tr class="nocodegen"><td>4300</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &apos;rate: &apos; + IntToStr(Rate) +</pre></td></tr>
<tr class="nocodegen"><td>4301</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &apos; capacity: &apos; + IntToStr(Capacity)]);</pre></td></tr>
<tr class="nocodegen"><td>4302</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4303</td><td><pre style="display:inline;"> &nbsp;FSpongeState.Rate &nbsp; &nbsp; := Rate;</pre></td></tr>
<tr class="covered"><td>4304</td><td><pre style="display:inline;"> &nbsp;FSpongeState.Capacity := Capacity;</pre></td></tr>
<tr class="nocodegen"><td>4305</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4306</td><td><pre style="display:inline;"> &nbsp;if FOutpLengSet then</pre></td></tr>
<tr class="covered"><td>4307</td><td><pre style="display:inline;"> &nbsp; &nbsp;FSpongeState.FixedOutputLength := OutputLengthBackup;</pre></td></tr>
<tr class="covered"><td>4308</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4309</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4310</td><td><pre style="display:inline;">procedure THash_SHA3Base.KeccakAbsorb(var state: TState_B; data: PUInt64; laneCount: Integer);</pre></td></tr>
<tr class="covered"><td>4311</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4312</td><td><pre style="display:inline;"> &nbsp; XORIntoState(TState_L(state), data, laneCount);</pre></td></tr>
<tr class="covered"><td>4313</td><td><pre style="display:inline;"> &nbsp; KeccakPermutation(TState_L(state));</pre></td></tr>
<tr class="covered"><td>4314</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4315</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4316</td><td><pre style="display:inline;">{$IFDEF PUREPASCAL}</pre></td></tr>
<tr class="nocodegen"><td>4317</td><td><pre style="display:inline;">function THash_SHA3Base.RotL(const x: UInt64; c: Integer): UInt64;</pre></td></tr>
<tr class="nocodegen"><td>4318</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4319</td><td><pre style="display:inline;"> &nbsp;Result := (x shl c) or (x shr (64-c));</pre></td></tr>
<tr class="nocodegen"><td>4320</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4321</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4322</td><td><pre style="display:inline;">function THash_SHA3Base.RotL1(var x: UInt64): UInt64;</pre></td></tr>
<tr class="nocodegen"><td>4323</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4324</td><td><pre style="display:inline;"> &nbsp;Result := (x shl 1) or (x shr (64-1));</pre></td></tr>
<tr class="nocodegen"><td>4325</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4326</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4327</td><td><pre style="display:inline;">procedure THash_SHA3Base.KeccakPermutation(var state: TState_L);</pre></td></tr>
<tr class="nocodegen"><td>4328</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4329</td><td><pre style="display:inline;"> &nbsp; A : PUInt64Array;</pre></td></tr>
<tr class="nocodegen"><td>4330</td><td><pre style="display:inline;"> &nbsp; B : array[0..24] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>4331</td><td><pre style="display:inline;"> &nbsp; C0, C1, C2, C3, C4, D0, D1, D2, D3, D4: UInt64;</pre></td></tr>
<tr class="nocodegen"><td>4332</td><td><pre style="display:inline;"> &nbsp; i : Integer;</pre></td></tr>
<tr class="nocodegen"><td>4333</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4334</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4335</td><td><pre style="display:inline;"> &nbsp; A := PUInt64Array(@state);</pre></td></tr>
<tr class="nocodegen"><td>4336</td><td><pre style="display:inline;"> &nbsp; for i := 0 to 23 do begin</pre></td></tr>
<tr class="nocodegen"><td>4337</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C0 := A[00] xor A[05] xor A[10] xor A[15] xor A[20];</pre></td></tr>
<tr class="nocodegen"><td>4338</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C1 := A[01] xor A[06] xor A[11] xor A[16] xor A[21];</pre></td></tr>
<tr class="nocodegen"><td>4339</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C2 := A[02] xor A[07] xor A[12] xor A[17] xor A[22];</pre></td></tr>
<tr class="nocodegen"><td>4340</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C3 := A[03] xor A[08] xor A[13] xor A[18] xor A[23];</pre></td></tr>
<tr class="nocodegen"><td>4341</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;C4 := A[04] xor A[09] xor A[14] xor A[19] xor A[24];</pre></td></tr>
<tr class="nocodegen"><td>4342</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4343</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D0 := RotL1(C0) xor C3;</pre></td></tr>
<tr class="nocodegen"><td>4344</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D1 := RotL1(C1) xor C4;</pre></td></tr>
<tr class="nocodegen"><td>4345</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D2 := RotL1(C2) xor C0;</pre></td></tr>
<tr class="nocodegen"><td>4346</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D3 := RotL1(C3) xor C1;</pre></td></tr>
<tr class="nocodegen"><td>4347</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;D4 := RotL1(C4) xor C2;</pre></td></tr>
<tr class="nocodegen"><td>4348</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4349</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[00] := A[00] xor D1;</pre></td></tr>
<tr class="nocodegen"><td>4350</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[01] := RotL(A[06] xor D2, 44);</pre></td></tr>
<tr class="nocodegen"><td>4351</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[02] := RotL(A[12] xor D3, 43);</pre></td></tr>
<tr class="nocodegen"><td>4352</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[03] := RotL(A[18] xor D4, 21);</pre></td></tr>
<tr class="nocodegen"><td>4353</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[04] := RotL(A[24] xor D0, 14);</pre></td></tr>
<tr class="nocodegen"><td>4354</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[05] := RotL(A[03] xor D4, 28);</pre></td></tr>
<tr class="nocodegen"><td>4355</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[06] := RotL(A[09] xor D0, 20);</pre></td></tr>
<tr class="nocodegen"><td>4356</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[07] := RotL(A[10] xor D1, 3);</pre></td></tr>
<tr class="nocodegen"><td>4357</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[08] := RotL(A[16] xor D2, 45);</pre></td></tr>
<tr class="nocodegen"><td>4358</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[09] := RotL(A[22] xor D3, 61);</pre></td></tr>
<tr class="nocodegen"><td>4359</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[10] := RotL(A[01] xor D2, 1);</pre></td></tr>
<tr class="nocodegen"><td>4360</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[11] := RotL(A[07] xor D3, 6);</pre></td></tr>
<tr class="nocodegen"><td>4361</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[12] := RotL(A[13] xor D4, 25);</pre></td></tr>
<tr class="nocodegen"><td>4362</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[13] := RotL(A[19] xor D0, 8);</pre></td></tr>
<tr class="nocodegen"><td>4363</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[14] := RotL(A[20] xor D1, 18);</pre></td></tr>
<tr class="nocodegen"><td>4364</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[15] := RotL(A[04] xor D0, 27);</pre></td></tr>
<tr class="nocodegen"><td>4365</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[16] := RotL(A[05] xor D1, 36);</pre></td></tr>
<tr class="nocodegen"><td>4366</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[17] := RotL(A[11] xor D2, 10);</pre></td></tr>
<tr class="nocodegen"><td>4367</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[18] := RotL(A[17] xor D3, 15);</pre></td></tr>
<tr class="nocodegen"><td>4368</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[19] := RotL(A[23] xor D4, 56);</pre></td></tr>
<tr class="nocodegen"><td>4369</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[20] := RotL(A[02] xor D3, 62);</pre></td></tr>
<tr class="nocodegen"><td>4370</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[21] := RotL(A[08] xor D4, 55);</pre></td></tr>
<tr class="nocodegen"><td>4371</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[22] := RotL(A[14] xor D0, 39);</pre></td></tr>
<tr class="nocodegen"><td>4372</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[23] := RotL(A[15] xor D1, 41);</pre></td></tr>
<tr class="nocodegen"><td>4373</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;B[24] := RotL(A[21] xor D2, 2);</pre></td></tr>
<tr class="nocodegen"><td>4374</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4375</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[00] := B[00] xor ((not B[01]) and B[02]);</pre></td></tr>
<tr class="nocodegen"><td>4376</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[01] := B[01] xor ((not B[02]) and B[03]);</pre></td></tr>
<tr class="nocodegen"><td>4377</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[02] := B[02] xor ((not B[03]) and B[04]);</pre></td></tr>
<tr class="nocodegen"><td>4378</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[03] := B[03] xor ((not B[04]) and B[00]);</pre></td></tr>
<tr class="nocodegen"><td>4379</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[04] := B[04] xor ((not B[00]) and B[01]);</pre></td></tr>
<tr class="nocodegen"><td>4380</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[05] := B[05] xor ((not B[06]) and B[07]);</pre></td></tr>
<tr class="nocodegen"><td>4381</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[06] := B[06] xor ((not B[07]) and B[08]);</pre></td></tr>
<tr class="nocodegen"><td>4382</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[07] := B[07] xor ((not B[08]) and B[09]);</pre></td></tr>
<tr class="nocodegen"><td>4383</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[08] := B[08] xor ((not B[09]) and B[05]);</pre></td></tr>
<tr class="nocodegen"><td>4384</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[09] := B[09] xor ((not B[05]) and B[06]);</pre></td></tr>
<tr class="nocodegen"><td>4385</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[10] := B[10] xor ((not B[11]) and B[12]);</pre></td></tr>
<tr class="nocodegen"><td>4386</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[11] := B[11] xor ((not B[12]) and B[13]);</pre></td></tr>
<tr class="nocodegen"><td>4387</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[12] := B[12] xor ((not B[13]) and B[14]);</pre></td></tr>
<tr class="nocodegen"><td>4388</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[13] := B[13] xor ((not B[14]) and B[10]);</pre></td></tr>
<tr class="nocodegen"><td>4389</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[14] := B[14] xor ((not B[10]) and B[11]);</pre></td></tr>
<tr class="nocodegen"><td>4390</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[15] := B[15] xor ((not B[16]) and B[17]);</pre></td></tr>
<tr class="nocodegen"><td>4391</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[16] := B[16] xor ((not B[17]) and B[18]);</pre></td></tr>
<tr class="nocodegen"><td>4392</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[17] := B[17] xor ((not B[18]) and B[19]);</pre></td></tr>
<tr class="nocodegen"><td>4393</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[18] := B[18] xor ((not B[19]) and B[15]);</pre></td></tr>
<tr class="nocodegen"><td>4394</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[19] := B[19] xor ((not B[15]) and B[16]);</pre></td></tr>
<tr class="nocodegen"><td>4395</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[20] := B[20] xor ((not B[21]) and B[22]);</pre></td></tr>
<tr class="nocodegen"><td>4396</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[21] := B[21] xor ((not B[22]) and B[23]);</pre></td></tr>
<tr class="nocodegen"><td>4397</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[22] := B[22] xor ((not B[23]) and B[24]);</pre></td></tr>
<tr class="nocodegen"><td>4398</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[23] := B[23] xor ((not B[24]) and B[20]);</pre></td></tr>
<tr class="nocodegen"><td>4399</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[24] := B[24] xor ((not B[20]) and B[21]);</pre></td></tr>
<tr class="nocodegen"><td>4400</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4401</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[00] := A[00] xor cRoundConstants[i];</pre></td></tr>
<tr class="nocodegen"><td>4402</td><td><pre style="display:inline;"> &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>4403</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4404</td><td><pre style="display:inline;">{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>4405</td><td><pre style="display:inline;">// Must be procedural as otherwise the parameters get passed in different</pre></td></tr>
<tr class="nocodegen"><td>4406</td><td><pre style="display:inline;">// CPU registers and the complete ASM code would have needed to be rewritten.</pre></td></tr>
<tr class="nocodegen"><td>4407</td><td><pre style="display:inline;">procedure KeccakPermutationKernel(B, A, C : Pointer);</pre></td></tr>
<tr class="nocodegen"><td>4408</td><td><pre style="display:inline;">asm</pre></td></tr>
<tr class="nocodegen"><td>4409</td><td><pre style="display:inline;"> &nbsp;{$IFDEF X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>4410</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$INCLUDE DECHash.sha3_mmx.inc}</pre></td></tr>
<tr class="nocodegen"><td>4411</td><td><pre style="display:inline;"> &nbsp;{$ELSE}</pre></td></tr>
<tr class="nocodegen"><td>4412</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$INCLUDE DECHash.sha3_x64.inc}</pre></td></tr>
<tr class="nocodegen"><td>4413</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="covered"><td>4414</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4415</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4416</td><td><pre style="display:inline;">procedure THash_SHA3Base.KeccakPermutation(var state: TState_L);</pre></td></tr>
<tr class="nocodegen"><td>4417</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4418</td><td><pre style="display:inline;"> &nbsp; A : PUInt64Array;</pre></td></tr>
<tr class="nocodegen"><td>4419</td><td><pre style="display:inline;"> &nbsp; B : array [0..24] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>4420</td><td><pre style="display:inline;"> &nbsp; C : array [0..4] of UInt64;</pre></td></tr>
<tr class="nocodegen"><td>4421</td><td><pre style="display:inline;"> &nbsp; i : Integer;</pre></td></tr>
<tr class="nocodegen"><td>4422</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4423</td><td><pre style="display:inline;"> &nbsp;{$IFDEF X86ASM}</pre></td></tr>
<tr class="nocodegen"><td>4424</td><td><pre style="display:inline;"> &nbsp;procedure EMMS;</pre></td></tr>
<tr class="covered"><td>4425</td><td><pre style="display:inline;"> &nbsp;asm</pre></td></tr>
<tr class="nocodegen"><td>4426</td><td><pre style="display:inline;"> &nbsp; &nbsp;// This operation marks the x87 FPU data registers (which are aliased to the</pre></td></tr>
<tr class="nocodegen"><td>4427</td><td><pre style="display:inline;"> &nbsp; &nbsp;// MMX technology registers) as available for use by x87 FPU floating-point</pre></td></tr>
<tr class="nocodegen"><td>4428</td><td><pre style="display:inline;"> &nbsp; &nbsp;// instructions.</pre></td></tr>
<tr class="covered"><td>4429</td><td><pre style="display:inline;"> &nbsp; &nbsp;emms</pre></td></tr>
<tr class="covered"><td>4430</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4431</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>4432</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4433</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4434</td><td><pre style="display:inline;"> &nbsp; A := PUInt64Array(@state);</pre></td></tr>
<tr class="covered"><td>4435</td><td><pre style="display:inline;"> &nbsp; for i:=0 to 23 do begin</pre></td></tr>
<tr class="covered"><td>4436</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;KeccakPermutationKernel(@B, A, @C);</pre></td></tr>
<tr class="covered"><td>4437</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;A[00] := A[00] xor cRoundConstants[i];</pre></td></tr>
<tr class="covered"><td>4438</td><td><pre style="display:inline;"> &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>4439</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4440</td><td><pre style="display:inline;"> &nbsp; {$IFDEF X86ASM}</pre></td></tr>
<tr class="covered"><td>4441</td><td><pre style="display:inline;"> &nbsp; EMMS;</pre></td></tr>
<tr class="nocodegen"><td>4442</td><td><pre style="display:inline;"> &nbsp; {$ENDIF}</pre></td></tr>
<tr class="covered"><td>4443</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4444</td><td><pre style="display:inline;">{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>4445</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4446</td><td><pre style="display:inline;">procedure THash_SHA3Base.PadAndSwitchToSqueezingPhase;</pre></td></tr>
<tr class="nocodegen"><td>4447</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4448</td><td><pre style="display:inline;"> &nbsp;i: integer;</pre></td></tr>
<tr class="covered"><td>4449</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4450</td><td><pre style="display:inline;"> &nbsp;// Note: the bits are numbered from 0 = LSB to 7 = MSB</pre></td></tr>
<tr class="covered"><td>4451</td><td><pre style="display:inline;"> &nbsp;if (FSpongeState.BitsInQueue + 1 = FSpongeState.Rate) then</pre></td></tr>
<tr class="nocodegen"><td>4452</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4453</td><td><pre style="display:inline;"> &nbsp; &nbsp;i := FSpongeState.BitsInQueue div 8;</pre></td></tr>
<tr class="covered"><td>4454</td><td><pre style="display:inline;"> &nbsp; &nbsp;FSpongeState.DataQueue[i] := FSpongeState.DataQueue[i] or</pre></td></tr>
<tr class="nocodegen"><td>4455</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1 shl (FSpongeState.BitsInQueue and 7));</pre></td></tr>
<tr class="covered"><td>4456</td><td><pre style="display:inline;"> &nbsp; &nbsp;AbsorbQueue;</pre></td></tr>
<tr class="covered"><td>4457</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FSpongeState.DataQueue, FSpongeState.Rate div 8, 0);</pre></td></tr>
<tr class="nocodegen"><td>4458</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>4459</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4460</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4461</td><td><pre style="display:inline;"> &nbsp; &nbsp;i := FSpongeState.BitsInQueue div 8;</pre></td></tr>
<tr class="covered"><td>4462</td><td><pre style="display:inline;"> &nbsp; &nbsp;FillChar(FSpongeState.DataQueue[(FSpongeState.BitsInQueue+7) div 8],</pre></td></tr>
<tr class="nocodegen"><td>4463</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FSpongeState.Rate div 8 - (FSpongeState.BitsInQueue+7) div 8, 0);</pre></td></tr>
<tr class="covered"><td>4464</td><td><pre style="display:inline;"> &nbsp; &nbsp;FSpongeState.DataQueue[i] := FSpongeState.DataQueue[i] or</pre></td></tr>
<tr class="nocodegen"><td>4465</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1 shl (FSpongeState.BitsInQueue and 7));</pre></td></tr>
<tr class="nocodegen"><td>4466</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4467</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4468</td><td><pre style="display:inline;"> &nbsp;i := (FSpongeState.Rate-1) div 8;</pre></td></tr>
<tr class="covered"><td>4469</td><td><pre style="display:inline;"> &nbsp;FSpongeState.DataQueue[i] := FSpongeState.DataQueue[i] or</pre></td></tr>
<tr class="nocodegen"><td>4470</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1 shl ((FSpongeState.Rate-1) and 7));</pre></td></tr>
<tr class="covered"><td>4471</td><td><pre style="display:inline;"> &nbsp;AbsorbQueue;</pre></td></tr>
<tr class="covered"><td>4472</td><td><pre style="display:inline;"> &nbsp;ExtractFromState(@FSpongeState.DataQueue,</pre></td></tr>
<tr class="nocodegen"><td>4473</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TState_L(FSpongeState.State),</pre></td></tr>
<tr class="nocodegen"><td>4474</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FSpongeState.Rate div 64);</pre></td></tr>
<tr class="covered"><td>4475</td><td><pre style="display:inline;"> &nbsp;FSpongeState.bitsAvailableForSqueezing := FSpongeState.Rate;</pre></td></tr>
<tr class="covered"><td>4476</td><td><pre style="display:inline;"> &nbsp;FSpongeState.SqueezeActive := true;</pre></td></tr>
<tr class="covered"><td>4477</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4478</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4479</td><td><pre style="display:inline;">procedure THash_SHA3Base.Squeeze(var Output: TSHA3Digest; OutputLength: Int32);</pre></td></tr>
<tr class="nocodegen"><td>4480</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4481</td><td><pre style="display:inline;"> &nbsp;i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: Int32;</pre></td></tr>
<tr class="nocodegen"><td>4482</td><td><pre style="display:inline;"> &nbsp;PartialBlock : Int16;</pre></td></tr>
<tr class="covered"><td>4483</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4484</td><td><pre style="display:inline;"> &nbsp;if not FSpongeState.SqueezeActive then</pre></td></tr>
<tr class="covered"><td>4485</td><td><pre style="display:inline;"> &nbsp; &nbsp;PadAndSwitchToSqueezingPhase;</pre></td></tr>
<tr class="nocodegen"><td>4486</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4487</td><td><pre style="display:inline;"> &nbsp;// Only multiple of 8 bits are allowed, truncation must be done at user level</pre></td></tr>
<tr class="covered"><td>4488</td><td><pre style="display:inline;"> &nbsp;if OutputLength and 7 &lt;&gt; 0 then</pre></td></tr>
<tr class="notcovered"><td>4489</td><td><pre style="display:inline;"> &nbsp; &nbsp;raise EDECHashException.CreateFmt(sSHA3AbsorbFailure,</pre></td></tr>
<tr class="nocodegen"><td>4490</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [OutputLength, &apos;true&apos;]);</pre></td></tr>
<tr class="nocodegen"><td>4491</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4492</td><td><pre style="display:inline;"> &nbsp;i := 0;</pre></td></tr>
<tr class="covered"><td>4493</td><td><pre style="display:inline;"> &nbsp;while i &lt; OutputLength do</pre></td></tr>
<tr class="nocodegen"><td>4494</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4495</td><td><pre style="display:inline;"> &nbsp; &nbsp;if FSpongeState.bitsAvailableForSqueezing = 0 then</pre></td></tr>
<tr class="nocodegen"><td>4496</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4497</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;KeccakPermutation(TState_L(FSpongeState.State));</pre></td></tr>
<tr class="covered"><td>4498</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;ExtractFromState(@FSpongeState.DataQueue, TState_L(FSpongeState.State),</pre></td></tr>
<tr class="nocodegen"><td>4499</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FSpongeState.Rate div 64);</pre></td></tr>
<tr class="covered"><td>4500</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;FSpongeState.bitsAvailableForSqueezing := FSpongeState.Rate;</pre></td></tr>
<tr class="nocodegen"><td>4501</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4502</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4503</td><td><pre style="display:inline;"> &nbsp; &nbsp;PartialBlock := FSpongeState.bitsAvailableForSqueezing;</pre></td></tr>
<tr class="covered"><td>4504</td><td><pre style="display:inline;"> &nbsp; &nbsp;if PartialBlock &gt; OutputLength - i then</pre></td></tr>
<tr class="covered"><td>4505</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;PartialBlock := OutputLength - i;</pre></td></tr>
<tr class="nocodegen"><td>4506</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4507</td><td><pre style="display:inline;"> &nbsp; &nbsp;move(FSpongeState.DataQueue[(FSpongeState.Rate - FSpongeState.bitsAvailableForSqueezing) div 8],</pre></td></tr>
<tr class="nocodegen"><td>4508</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; output[i div 8], PartialBlock div 8);</pre></td></tr>
<tr class="covered"><td>4509</td><td><pre style="display:inline;"> &nbsp; &nbsp;dec(FSpongeState.bitsAvailableForSqueezing, PartialBlock);</pre></td></tr>
<tr class="covered"><td>4510</td><td><pre style="display:inline;"> &nbsp; &nbsp;inc(i, PartialBlock);</pre></td></tr>
<tr class="nocodegen"><td>4511</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4512</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4513</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4514</td><td><pre style="display:inline;">procedure THash_SHA3Base.XORIntoState(var state: TState_L; pI: PUInt64; laneCount: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4515</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4516</td><td><pre style="display:inline;"> &nbsp; pS: PUInt64;</pre></td></tr>
<tr class="nocodegen"><td>4517</td><td><pre style="display:inline;"> &nbsp; i: Integer;</pre></td></tr>
<tr class="covered"><td>4518</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4519</td><td><pre style="display:inline;"> &nbsp; pS := @state[0];</pre></td></tr>
<tr class="covered"><td>4520</td><td><pre style="display:inline;"> &nbsp; for i:=laneCount-1 downto 0 do begin</pre></td></tr>
<tr class="covered"><td>4521</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;pS^ := pS^ xor pI^;</pre></td></tr>
<tr class="covered"><td>4522</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(pI);</pre></td></tr>
<tr class="covered"><td>4523</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(pS);</pre></td></tr>
<tr class="covered"><td>4524</td><td><pre style="display:inline;"> &nbsp; end;</pre></td></tr>
<tr class="covered"><td>4525</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4526</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4527</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4528</td><td><pre style="display:inline;">procedure THash_SHA3Base.Absorb(Data: PBABytes; DatabitLen: Int32);</pre></td></tr>
<tr class="nocodegen"><td>4529</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4530</td><td><pre style="display:inline;"> &nbsp;i, j, wholeBlocks, partialBlock: Integer;</pre></td></tr>
<tr class="nocodegen"><td>4531</td><td><pre style="display:inline;"> &nbsp;partialByte: Integer;</pre></td></tr>
<tr class="nocodegen"><td>4532</td><td><pre style="display:inline;"> &nbsp;curData: PUInt64;</pre></td></tr>
<tr class="covered"><td>4533</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4534</td><td><pre style="display:inline;"> &nbsp;// if a number of bits which cannot be divided by 8 without reminder is in the</pre></td></tr>
<tr class="nocodegen"><td>4535</td><td><pre style="display:inline;"> &nbsp;// queue or algorithm is already in squeezing state</pre></td></tr>
<tr class="covered"><td>4536</td><td><pre style="display:inline;"> &nbsp;if (FSpongeState.BitsInQueue and 7 &lt;&gt; 0) or FSpongeState.SqueezeActive then</pre></td></tr>
<tr class="nocodegen"><td>4537</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="notcovered"><td>4538</td><td><pre style="display:inline;"> &nbsp; &nbsp;raise EDECHashException.CreateFmt(sSHA3AbsorbFailure,</pre></td></tr>
<tr class="nocodegen"><td>4539</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [FSpongeState.BitsInQueue,</pre></td></tr>
<tr class="nocodegen"><td>4540</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BoolToStr(FSpongeState.SqueezeActive, true)]);</pre></td></tr>
<tr class="nocodegen"><td>4541</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4542</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4543</td><td><pre style="display:inline;"> &nbsp;i := 0;</pre></td></tr>
<tr class="nocodegen"><td>4544</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4545</td><td><pre style="display:inline;"> &nbsp;while i &lt; databitlen do</pre></td></tr>
<tr class="nocodegen"><td>4546</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4547</td><td><pre style="display:inline;"> &nbsp; &nbsp; if ((FSpongeState.BitsInQueue = 0) and (databitlen &gt;= FSpongeState.Rate) and</pre></td></tr>
<tr class="nocodegen"><td>4548</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;(i &lt;= (databitlen - FSpongeState.Rate))) then</pre></td></tr>
<tr class="nocodegen"><td>4549</td><td><pre style="display:inline;"> &nbsp; &nbsp; begin</pre></td></tr>
<tr class="covered"><td>4550</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; wholeBlocks := (databitlen-i) div FSpongeState.Rate;</pre></td></tr>
<tr class="covered"><td>4551</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; curData := @data^[i div 8];</pre></td></tr>
<tr class="covered"><td>4552</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; j := 0;</pre></td></tr>
<tr class="covered"><td>4553</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; while j &lt; wholeBlocks do</pre></td></tr>
<tr class="nocodegen"><td>4554</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; begin</pre></td></tr>
<tr class="covered"><td>4555</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; KeccakAbsorb(FSpongeState.State, curData, FSpongeState.Rate div 64);</pre></td></tr>
<tr class="covered"><td>4556</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Inc(j);</pre></td></tr>
<tr class="covered"><td>4557</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Inc(PByte(curData), FSpongeState.Rate div 8);</pre></td></tr>
<tr class="nocodegen"><td>4558</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; end;</pre></td></tr>
<tr class="covered"><td>4559</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; Inc(i, wholeBlocks * FSpongeState.Rate);</pre></td></tr>
<tr class="nocodegen"><td>4560</td><td><pre style="display:inline;"> &nbsp; &nbsp; end</pre></td></tr>
<tr class="nocodegen"><td>4561</td><td><pre style="display:inline;"> &nbsp; &nbsp; else</pre></td></tr>
<tr class="nocodegen"><td>4562</td><td><pre style="display:inline;"> &nbsp; &nbsp; begin</pre></td></tr>
<tr class="covered"><td>4563</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; partialBlock := databitlen - i;</pre></td></tr>
<tr class="covered"><td>4564</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; if partialBlock + FSpongeState.BitsInQueue &gt; FSpongeState.Rate then</pre></td></tr>
<tr class="notcovered"><td>4565</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; partialBlock := FSpongeState.Rate - FSpongeState.BitsInQueue;</pre></td></tr>
<tr class="nocodegen"><td>4566</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4567</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; partialByte := partialBlock and 7;</pre></td></tr>
<tr class="covered"><td>4568</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; Dec(partialBlock, partialByte);</pre></td></tr>
<tr class="covered"><td>4569</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; Move(data^[i div 8], FSpongeState.DataQueue[FSpongeState.BitsInQueue div 8], partialBlock div 8);</pre></td></tr>
<tr class="covered"><td>4570</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; Inc(FSpongeState.BitsInQueue, partialBlock);</pre></td></tr>
<tr class="covered"><td>4571</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; Inc(i, partialBlock);</pre></td></tr>
<tr class="covered"><td>4572</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; if FSpongeState.BitsInQueue=FSpongeState.Rate then</pre></td></tr>
<tr class="covered"><td>4573</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AbsorbQueue;</pre></td></tr>
<tr class="nocodegen"><td>4574</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4575</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; if partialByte &gt; 0 then</pre></td></tr>
<tr class="nocodegen"><td>4576</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; begin</pre></td></tr>
<tr class="nocodegen"><td>4577</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; FSpongeState.DataQueue[FSpongeState.BitsInQueue div 8] :=</pre></td></tr>
<tr class="covered"><td>4578</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data^[i div 8] and ((1 shl partialByte)-1);</pre></td></tr>
<tr class="nocodegen"><td>4579</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4580</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Inc(FSpongeState.BitsInQueue, partialByte);</pre></td></tr>
<tr class="covered"><td>4581</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; Inc(i, partialByte);</pre></td></tr>
<tr class="nocodegen"><td>4582</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>4583</td><td><pre style="display:inline;"> &nbsp; &nbsp; end;</pre></td></tr>
<tr class="nocodegen"><td>4584</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4585</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4586</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4587</td><td><pre style="display:inline;">procedure THash_SHA3Base.AbsorbQueue;</pre></td></tr>
<tr class="covered"><td>4588</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4589</td><td><pre style="display:inline;"> &nbsp;// state.bitsInQueue is assumed to be equal to state.rat</pre></td></tr>
<tr class="covered"><td>4590</td><td><pre style="display:inline;"> &nbsp;KeccakAbsorb(FSpongeState.State, @FSpongeState.DataQueue, FSpongeState.Rate div 64);</pre></td></tr>
<tr class="covered"><td>4591</td><td><pre style="display:inline;"> &nbsp;FSpongeState.BitsInQueue := 0;</pre></td></tr>
<tr class="covered"><td>4592</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4593</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4594</td><td><pre style="display:inline;">procedure THash_SHA3Base.Calc(const Data; DataSize: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4595</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4596</td><td><pre style="display:inline;"> &nbsp;DataPtr &nbsp; : PBABytes;</pre></td></tr>
<tr class="nocodegen"><td>4597</td><td><pre style="display:inline;"> &nbsp;RoundSize : UInt32;</pre></td></tr>
<tr class="nocodegen"><td>4598</td><td><pre style="display:inline;">const</pre></td></tr>
<tr class="nocodegen"><td>4599</td><td><pre style="display:inline;"> &nbsp;// Maximum number of bytes one can process in one round</pre></td></tr>
<tr class="nocodegen"><td>4600</td><td><pre style="display:inline;"> &nbsp;MaxRoundSize = MaxInt div 8;</pre></td></tr>
<tr class="covered"><td>4601</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4602</td><td><pre style="display:inline;"> &nbsp;// due to the way the inherited calc is constructed it must not be called here!</pre></td></tr>
<tr class="covered"><td>4603</td><td><pre style="display:inline;"> &nbsp;if (DataSize &gt; 0) then</pre></td></tr>
<tr class="nocodegen"><td>4604</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4605</td><td><pre style="display:inline;"> &nbsp; &nbsp;DataPtr := PBABytes(@Data);</pre></td></tr>
<tr class="nocodegen"><td>4606</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4607</td><td><pre style="display:inline;"> &nbsp; &nbsp;while (UInt32(DataSize) &gt; 0) do</pre></td></tr>
<tr class="nocodegen"><td>4608</td><td><pre style="display:inline;"> &nbsp; &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4609</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;RoundSize := DataSize;</pre></td></tr>
<tr class="covered"><td>4610</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;if (RoundSize &gt; MaxRoundSize) then</pre></td></tr>
<tr class="notcovered"><td>4611</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp;RoundSize := MaxRoundSize;</pre></td></tr>
<tr class="nocodegen"><td>4612</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4613</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Absorb(DataPtr, RoundSize * 8);</pre></td></tr>
<tr class="covered"><td>4614</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Dec(DataSize, RoundSize);</pre></td></tr>
<tr class="covered"><td>4615</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(DataPtr, RoundSize);</pre></td></tr>
<tr class="nocodegen"><td>4616</td><td><pre style="display:inline;"> &nbsp; &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4617</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4618</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4619</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4620</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4621</td><td><pre style="display:inline;">constructor THash_SHA3Base.Create;</pre></td></tr>
<tr class="covered"><td>4622</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4623</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4624</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4625</td><td><pre style="display:inline;"> &nbsp;FOutpLengSet := false;</pre></td></tr>
<tr class="covered"><td>4626</td><td><pre style="display:inline;"> &nbsp;SetLength(FDigest, 64);</pre></td></tr>
<tr class="covered"><td>4627</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4628</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4629</td><td><pre style="display:inline;">function THash_SHA3Base.Digest: PByteArray;</pre></td></tr>
<tr class="covered"><td>4630</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4631</td><td><pre style="display:inline;"> &nbsp;Result := @FDigest[0];</pre></td></tr>
<tr class="covered"><td>4632</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4633</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4634</td><td><pre style="display:inline;">procedure THash_SHA3Base.DoDone;</pre></td></tr>
<tr class="covered"><td>4635</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4636</td><td><pre style="display:inline;"> &nbsp;FinalBit_LSB(FFinalByte, FFinalByteLength, FDigest);</pre></td></tr>
<tr class="covered"><td>4637</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4638</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4639</td><td><pre style="display:inline;">procedure THash_SHA3Base.DoInit;</pre></td></tr>
<tr class="covered"><td>4640</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4641</td><td><pre style="display:inline;"> &nbsp;inherited;</pre></td></tr>
<tr class="nocodegen"><td>4642</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4643</td><td><pre style="display:inline;"> &nbsp;FillChar(FDIgest[0], Length(FDigest), 0);</pre></td></tr>
<tr class="covered"><td>4644</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4645</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4646</td><td><pre style="display:inline;">procedure THash_SHA3Base.DoUpdate(Data: Pointer; DataBitLen: Int32);</pre></td></tr>
<tr class="nocodegen"><td>4647</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4648</td><td><pre style="display:inline;"> &nbsp;LastByte: Byte;</pre></td></tr>
<tr class="covered"><td>4649</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4650</td><td><pre style="display:inline;"> &nbsp;// No partial byte</pre></td></tr>
<tr class="covered"><td>4651</td><td><pre style="display:inline;"> &nbsp;if DataBitLen and 7 = 0 then</pre></td></tr>
<tr class="covered"><td>4652</td><td><pre style="display:inline;"> &nbsp; &nbsp;Absorb(Data, DataBitLen)</pre></td></tr>
<tr class="nocodegen"><td>4653</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4654</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4655</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Data contains a partial byte. Calculate the whole bytes first then the</pre></td></tr>
<tr class="nocodegen"><td>4656</td><td><pre style="display:inline;"> &nbsp; &nbsp;// partial one.</pre></td></tr>
<tr class="covered"><td>4657</td><td><pre style="display:inline;"> &nbsp; &nbsp;Absorb(Data, DataBitLen - (DataBitLen and 7));</pre></td></tr>
<tr class="nocodegen"><td>4658</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4659</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Align the last partial byte to the least significant bits</pre></td></tr>
<tr class="covered"><td>4660</td><td><pre style="display:inline;"> &nbsp; &nbsp;LastByte := PBABytes(Data)^[DatabitLen div 8] shr (8 - (DataBitLen and 7));</pre></td></tr>
<tr class="covered"><td>4661</td><td><pre style="display:inline;"> &nbsp; &nbsp;Absorb(@LastByte, DataBitLen and 7);</pre></td></tr>
<tr class="nocodegen"><td>4662</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4663</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4664</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4665</td><td><pre style="display:inline;">procedure THash_SHA3Base.ExtractFromState(outp: Pointer; const state: TState_L; laneCount: Integer);</pre></td></tr>
<tr class="nocodegen"><td>4666</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4667</td><td><pre style="display:inline;"> &nbsp; pI, pS: PUInt64;</pre></td></tr>
<tr class="nocodegen"><td>4668</td><td><pre style="display:inline;"> &nbsp; i: Integer;</pre></td></tr>
<tr class="covered"><td>4669</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4670</td><td><pre style="display:inline;"> &nbsp; pI := outp;</pre></td></tr>
<tr class="covered"><td>4671</td><td><pre style="display:inline;"> &nbsp; pS := @state[0];</pre></td></tr>
<tr class="covered"><td>4672</td><td><pre style="display:inline;"> &nbsp; for i := laneCount - 1 downto 0 do</pre></td></tr>
<tr class="nocodegen"><td>4673</td><td><pre style="display:inline;"> &nbsp; begin</pre></td></tr>
<tr class="covered"><td>4674</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;pI^ := pS^;</pre></td></tr>
<tr class="covered"><td>4675</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(pI);</pre></td></tr>
<tr class="covered"><td>4676</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp;Inc(pS);</pre></td></tr>
<tr class="covered"><td>4677</td><td><pre style="display:inline;"> &nbsp; end;</pre></td></tr>
<tr class="covered"><td>4678</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4679</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4680</td><td><pre style="display:inline;">procedure THash_SHA3Base.FinalBit_LSB(Bits: Byte; Bitlen: UInt16;</pre></td></tr>
<tr class="nocodegen"><td>4681</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var Hashvalue: TSHA3Digest);</pre></td></tr>
<tr class="nocodegen"><td>4682</td><td><pre style="display:inline;">var</pre></td></tr>
<tr class="nocodegen"><td>4683</td><td><pre style="display:inline;"> &nbsp;WorkingBitLen : Int16;</pre></td></tr>
<tr class="nocodegen"><td>4684</td><td><pre style="display:inline;"> &nbsp;lw : UInt16;</pre></td></tr>
<tr class="covered"><td>4685</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4686</td><td><pre style="display:inline;"> &nbsp;// normalize Bitlen and Bits (zero high bits)</pre></td></tr>
<tr class="covered"><td>4687</td><td><pre style="display:inline;"> &nbsp;Bitlen := Bitlen and 7;</pre></td></tr>
<tr class="covered"><td>4688</td><td><pre style="display:inline;"> &nbsp;if Bitlen = 0 then</pre></td></tr>
<tr class="covered"><td>4689</td><td><pre style="display:inline;"> &nbsp; &nbsp;lw := 0</pre></td></tr>
<tr class="nocodegen"><td>4690</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="covered"><td>4691</td><td><pre style="display:inline;"> &nbsp; &nbsp;lw := Bits and pred(word(1) shl Bitlen);</pre></td></tr>
<tr class="nocodegen"><td>4692</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4693</td><td><pre style="display:inline;"> &nbsp;// &apos;append&apos; (in LSB language) the domain separation bits</pre></td></tr>
<tr class="nocodegen"><td>4694</td><td><pre style="display:inline;"> &nbsp;//if (FSpongeState.FixedOutputLength = 0) then</pre></td></tr>
<tr class="covered"><td>4695</td><td><pre style="display:inline;"> &nbsp;if self.ClassParent = THash_ShakeBase then</pre></td></tr>
<tr class="nocodegen"><td>4696</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="covered"><td>4697</td><td><pre style="display:inline;"> &nbsp; &nbsp;lw := lw or (word($F) shl Bitlen);</pre></td></tr>
<tr class="covered"><td>4698</td><td><pre style="display:inline;"> &nbsp; &nbsp;WorkingBitLen := Bitlen+4;</pre></td></tr>
<tr class="nocodegen"><td>4699</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>4700</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4701</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4702</td><td><pre style="display:inline;"> &nbsp; &nbsp;// SHA3: append two bits 01</pre></td></tr>
<tr class="covered"><td>4703</td><td><pre style="display:inline;"> &nbsp; &nbsp;lw := lw or (word($2) shl Bitlen);</pre></td></tr>
<tr class="covered"><td>4704</td><td><pre style="display:inline;"> &nbsp; &nbsp;WorkingBitLen := Bitlen+2;</pre></td></tr>
<tr class="nocodegen"><td>4705</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="nocodegen"><td>4706</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4707</td><td><pre style="display:inline;"> &nbsp;// update state with final bits</pre></td></tr>
<tr class="covered"><td>4708</td><td><pre style="display:inline;"> &nbsp;if WorkingBitLen &lt; 9 then</pre></td></tr>
<tr class="nocodegen"><td>4709</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4710</td><td><pre style="display:inline;"> &nbsp; &nbsp;// 0..8 bits, one call to update</pre></td></tr>
<tr class="covered"><td>4711</td><td><pre style="display:inline;"> &nbsp; &nbsp;lw := lw shl (8-WorkingBitLen);</pre></td></tr>
<tr class="covered"><td>4712</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoUpdate(@lw, WorkingBitLen);</pre></td></tr>
<tr class="nocodegen"><td>4713</td><td><pre style="display:inline;"> &nbsp; &nbsp;// squeeze the digits from the sponge</pre></td></tr>
<tr class="covered"><td>4714</td><td><pre style="display:inline;"> &nbsp; &nbsp;Squeeze(Hashvalue, FSpongeState.FixedOutputLength);</pre></td></tr>
<tr class="nocodegen"><td>4715</td><td><pre style="display:inline;"> &nbsp;end</pre></td></tr>
<tr class="nocodegen"><td>4716</td><td><pre style="display:inline;"> &nbsp;else</pre></td></tr>
<tr class="nocodegen"><td>4717</td><td><pre style="display:inline;"> &nbsp;begin</pre></td></tr>
<tr class="nocodegen"><td>4718</td><td><pre style="display:inline;"> &nbsp; &nbsp;// More than 8 bits, first a regular update with low byte</pre></td></tr>
<tr class="covered"><td>4719</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoUpdate(@lw, 8);</pre></td></tr>
<tr class="nocodegen"><td>4720</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4721</td><td><pre style="display:inline;"> &nbsp; &nbsp;// Finally update remaining last bits</pre></td></tr>
<tr class="covered"><td>4722</td><td><pre style="display:inline;"> &nbsp; &nbsp;dec(WorkingBitLen,8);</pre></td></tr>
<tr class="covered"><td>4723</td><td><pre style="display:inline;"> &nbsp; &nbsp;lw := lw shr WorkingBitLen;</pre></td></tr>
<tr class="covered"><td>4724</td><td><pre style="display:inline;"> &nbsp; &nbsp;DoUpdate(@lw, WorkingBitLen);</pre></td></tr>
<tr class="nocodegen"><td>4725</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4726</td><td><pre style="display:inline;"> &nbsp; &nbsp;Squeeze(Hashvalue, FSpongeState.FixedOutputLength);</pre></td></tr>
<tr class="nocodegen"><td>4727</td><td><pre style="display:inline;"> &nbsp;end;</pre></td></tr>
<tr class="covered"><td>4728</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4729</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4730</td><td><pre style="display:inline;">procedure THash_SHA3Base.DoTransform(Buffer: PUInt32Array);</pre></td></tr>
<tr class="notcovered"><td>4731</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4732</td><td><pre style="display:inline;">// Empty on purpose as calculation is implemented differently for SHA3. Needed</pre></td></tr>
<tr class="nocodegen"><td>4733</td><td><pre style="display:inline;">// to suppress the compiler warning that a class with an abstract method is created</pre></td></tr>
<tr class="notcovered"><td>4734</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4735</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4736</td><td><pre style="display:inline;">{ THash_ShakeBase }</pre></td></tr>
<tr class="nocodegen"><td>4737</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4738</td><td><pre style="display:inline;">function THash_ShakeBase.GetHashSize: UInt16;</pre></td></tr>
<tr class="notcovered"><td>4739</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="nocodegen"><td>4740</td><td><pre style="display:inline;"> &nbsp;// divided by 8 since this field is in bits</pre></td></tr>
<tr class="notcovered"><td>4741</td><td><pre style="display:inline;"> &nbsp;Result := FSpongeState.FixedOutputLength shr 3;</pre></td></tr>
<tr class="notcovered"><td>4742</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4743</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4744</td><td><pre style="display:inline;">procedure THash_ShakeBase.SetHashSize(const Value: UInt16);</pre></td></tr>
<tr class="covered"><td>4745</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4746</td><td><pre style="display:inline;"> &nbsp;if (Value = 0) then</pre></td></tr>
<tr class="covered"><td>4747</td><td><pre style="display:inline;"> &nbsp; &nbsp;raise EDECHashException.CreateResFmt(@sHashInitFailure,</pre></td></tr>
<tr class="nocodegen"><td>4748</td><td><pre style="display:inline;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [GetShortClassName, sHashOutputLength0]);</pre></td></tr>
<tr class="nocodegen"><td>4749</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4750</td><td><pre style="display:inline;"> &nbsp;// multiplied with 8 since this field is in bits</pre></td></tr>
<tr class="covered"><td>4751</td><td><pre style="display:inline;"> &nbsp;FSpongeState.FixedOutputLength := Value * 8;</pre></td></tr>
<tr class="nocodegen"><td>4752</td><td><pre style="display:inline;"> &nbsp;// This flag tells the initialization of the algorithm that</pre></td></tr>
<tr class="nocodegen"><td>4753</td><td><pre style="display:inline;"> &nbsp;// FixedOutputLength needs to be preserved</pre></td></tr>
<tr class="covered"><td>4754</td><td><pre style="display:inline;"> &nbsp;FOutpLengSet := true;</pre></td></tr>
<tr class="nocodegen"><td>4755</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4756</td><td><pre style="display:inline;"> &nbsp;SetLength(FDigest, Value);</pre></td></tr>
<tr class="covered"><td>4757</td><td><pre style="display:inline;"> &nbsp;FillChar(FDigest[0], Length(FDigest), #0);</pre></td></tr>
<tr class="covered"><td>4758</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4759</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4760</td><td><pre style="display:inline;">function THash_ShakeBase.DigestAsBytes: TBytes;</pre></td></tr>
<tr class="covered"><td>4761</td><td><pre style="display:inline;">begin</pre></td></tr>
<tr class="covered"><td>4762</td><td><pre style="display:inline;"> &nbsp;SetLength(Result, FSpongeState.FixedOutputLength shr 3);</pre></td></tr>
<tr class="covered"><td>4763</td><td><pre style="display:inline;"> &nbsp;if FSpongeState.FixedOutputLength &gt; 0 then</pre></td></tr>
<tr class="covered"><td>4764</td><td><pre style="display:inline;"> &nbsp; &nbsp;Move(Digest^, Result[0], Length(Result));</pre></td></tr>
<tr class="covered"><td>4765</td><td><pre style="display:inline;">end;</pre></td></tr>
<tr class="nocodegen"><td>4766</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4767</td><td><pre style="display:inline;">initialization</pre></td></tr>
<tr class="nocodegen"><td>4768</td><td><pre style="display:inline;"> &nbsp;// Define the has returned by ValidHash if passing nil as parameter</pre></td></tr>
<tr class="covered"><td>4769</td><td><pre style="display:inline;"> &nbsp;SetDefaultHashClass(THash_SHA256);</pre></td></tr>
<tr class="nocodegen"><td>4770</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4771</td><td><pre style="display:inline;"> &nbsp;{$IFNDEF ManualRegisterHashClasses}</pre></td></tr>
<tr class="covered"><td>4772</td><td><pre style="display:inline;"> &nbsp;THash_MD2.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4773</td><td><pre style="display:inline;"> &nbsp;THash_MD4.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4774</td><td><pre style="display:inline;"> &nbsp;THash_MD5.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4775</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD128.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4776</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD160.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4777</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD256.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4778</td><td><pre style="display:inline;"> &nbsp;THash_RipeMD320.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4779</td><td><pre style="display:inline;"> &nbsp;THash_SHA0.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4780</td><td><pre style="display:inline;"> &nbsp;THash_SHA1.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4781</td><td><pre style="display:inline;"> &nbsp;THash_SHA224.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4782</td><td><pre style="display:inline;"> &nbsp;THash_SHA256.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4783</td><td><pre style="display:inline;"> &nbsp;THash_SHA384.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4784</td><td><pre style="display:inline;"> &nbsp;THash_SHA512.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4785</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_224.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4786</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_256.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4787</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_384.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4788</td><td><pre style="display:inline;"> &nbsp;THash_SHA3_512.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4789</td><td><pre style="display:inline;"> &nbsp;THash_Shake128.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4790</td><td><pre style="display:inline;"> &nbsp;THash_Shake256.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4791</td><td><pre style="display:inline;"> &nbsp;THash_Haval128.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4792</td><td><pre style="display:inline;"> &nbsp;THash_Haval160.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4793</td><td><pre style="display:inline;"> &nbsp;THash_Haval192.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4794</td><td><pre style="display:inline;"> &nbsp;THash_Haval224.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4795</td><td><pre style="display:inline;"> &nbsp;THash_Haval256.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4796</td><td><pre style="display:inline;"> &nbsp;THash_Tiger.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4797</td><td><pre style="display:inline;"> &nbsp;THash_Panama.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4798</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4799</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$IFDEF OLD_WHIRLPOOL_NAMES}</pre></td></tr>
<tr class="nocodegen"><td>4800</td><td><pre style="display:inline;"> &nbsp; &nbsp;THash_Whirlpool.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4801</td><td><pre style="display:inline;"> &nbsp; &nbsp;THash_Whirlpool1.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4802</td><td><pre style="display:inline;"> &nbsp; &nbsp;THash_Whirlpool1New.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4803</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ELSE}</pre></td></tr>
<tr class="covered"><td>4804</td><td><pre style="display:inline;"> &nbsp; &nbsp;THash_Whirlpool1.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4805</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>4806</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4807</td><td><pre style="display:inline;"> &nbsp;THash_Whirlpool0.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4808</td><td><pre style="display:inline;"> &nbsp;THash_WhirlpoolT.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4809</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4810</td><td><pre style="display:inline;"> &nbsp;THash_Square.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4811</td><td><pre style="display:inline;"> &nbsp;THash_Snefru128.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4812</td><td><pre style="display:inline;"> &nbsp;THash_Snefru256.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="covered"><td>4813</td><td><pre style="display:inline;"> &nbsp;THash_Sapphire.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4814</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4815</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$IFDEF OLD_SHA_NAME}</pre></td></tr>
<tr class="nocodegen"><td>4816</td><td><pre style="display:inline;"> &nbsp; &nbsp;THash_SHA.RegisterClass(TDECHash.ClassList);</pre></td></tr>
<tr class="nocodegen"><td>4817</td><td><pre style="display:inline;"> &nbsp; &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>4818</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="nocodegen"><td>4819</td><td><pre style="display:inline;"> &nbsp;{$ENDIF}</pre></td></tr>
<tr class="nocodegen"><td>4820</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4821</td><td><pre style="display:inline;">finalization</pre></td></tr>
<tr class="nocodegen"><td>4822</td><td><pre style="display:inline;"> &nbsp;// No need to unregister the hash classes, as the list is being freed</pre></td></tr>
<tr class="nocodegen"><td>4823</td><td><pre style="display:inline;"> &nbsp;// in finalization of DECHashBase unit</pre></td></tr>
<tr class="nocodegen"><td>4824</td><td><pre style="display:inline;"></pre></td></tr>
<tr class="covered"><td>4825</td><td><pre style="display:inline;">end.</pre></td></tr>
</table>
</body>
</html>
