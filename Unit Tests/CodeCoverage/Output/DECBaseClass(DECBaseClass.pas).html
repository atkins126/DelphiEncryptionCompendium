<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
body {max-width: max-content;margin: auto;}
table {border-spacing:0;}
table, td, th {border: 0;}
td, th {background: white; margin: 0; padding: .5em 1em}
table small { color: #777; }
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: consolas,courier,monospace; font-size: 10pt;}
thead, th {background: #808C98; color: white; }
table th small { color: #ddd; }
th[idx] {cursor: pointer; user-select: none;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: calc(min(80em, 95vw));}
table.s tr td {padding: .1em .5em; white-space: pre-wrap;}
table.s tr td:first-child {text-align: right; font-weight: bold; vertical-align: top}
table.s tr.notcovered td {background: #ddf;}
table.s tr.nocodegen td {background: #ffe;}
table.s tr.covered td {background: #cfc;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum td { background-position: 50%; background-repeat: no-repeat; background-size: 90% 70%; }
table.sum tr:nth-child(odd) td { background-color: #f4f4f4}
table.sum tr:hover td, tr:hover td a { filter: invert(10%) }
table.sum tr th {text-align:left; border: .5px solid #5d4e4c; height: 1em}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
table.sum thead th { position: sticky; top:0; }
table.sum thead tr + tr th { position: sticky; top: calc(2.5em - 2px); }
table.sum tfoot th { position: sticky; bottom:0; }
table.sum tfoot th+th {text-align: right;}
table.sum a, table.sum a:visited {color: #5d4e4c; text-decoration: none;}
#nav {position: fixed;overflow: visible;left: min(calc(50% + 41em), calc(100% - 6em));padding: .1em .5em .1em .2em;background: white;box-shadow: 1px 1px 3px #888;}
#nav div {opacity: .3; user-select: none; pointer-events: none;}
#nav div.active {opacity: 1;	cursor: pointer;	pointer-events: initial;}
#nav div.active:hover {color: #00A;}
</style>
</head>
<body>
<p>Coverage report for <bold>DECBaseClass (..\..\Source\DECBaseClass.pas)</bold>.</p>
<p>Generated at 30.11.2022 22:06:19 by <a href="https://github.com/DelphiCodeCoverage/DelphiCodeCoverage" target="_blank" title="DelphiCodeCoverage on GitHub">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p>Statistics for ..\..\Source\DECBaseClass.pas</p>
<table class="o"><tr><td>Number of lines covered<td>62<td rowspan=3 style="background: conic-gradient(#9fe098 100%, #eee 100%);width: 4.5em; border-radius: 50%"><tr><td>Number of lines with code gen<td>62<tr><td>Line coverage<td>100<small>.0</small>&nbsp;%</table>
<br><br>
<div id="nav"><div id="nav-prev">&#x25b2; Prev</div><div id="nav-next">&#x25bc; Next</div></div>
<table class="s">
<tr class="nocodegen"><td>1<td>{*****************************************************************************
<tr class="nocodegen"><td>2<td>The DEC team (see file NOTICE.txt) licenses this file
<tr class="nocodegen"><td>3<td>to you under the Apache License, Version 2.0 (the
<tr class="nocodegen"><td>4<td>&quot;License&quot;); you may not use this file except in compliance
<tr class="nocodegen"><td>5<td>with the License. A copy of this licence is found in the root directory
<tr class="nocodegen"><td>6<td>of this project in the file LICENCE.txt or alternatively at
<tr class="nocodegen"><td>7<td>
<tr class="nocodegen"><td>8<td>  http://www.apache.org/licenses/LICENSE-2.0
<tr class="nocodegen"><td>9<td>
<tr class="nocodegen"><td>10<td>Unless required by applicable law or agreed to in writing,
<tr class="nocodegen"><td>11<td>software distributed under the License is distributed on an
<tr class="nocodegen"><td>12<td>&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<tr class="nocodegen"><td>13<td>KIND, either express or implied.  See the License for the
<tr class="nocodegen"><td>14<td>specific language governing permissions and limitations
<tr class="nocodegen"><td>15<td>under the License.
<tr class="nocodegen"><td>16<td>*****************************************************************************}
<tr class="nocodegen"><td>17<td>
<tr class="nocodegen"><td>18<td>unit DECBaseClass;
<tr class="nocodegen"><td>19<td>
<tr class="nocodegen"><td>20<td>interface
<tr class="nocodegen"><td>21<td>
<tr class="nocodegen"><td>22<td>{$INCLUDE DECOptions.inc}
<tr class="nocodegen"><td>23<td>
<tr class="nocodegen"><td>24<td>uses
<tr class="nocodegen"><td>25<td>  {$IFDEF FPC}
<tr class="nocodegen"><td>26<td>  SysUtils, Classes,
<tr class="nocodegen"><td>27<td>  {$ELSE}
<tr class="nocodegen"><td>28<td>  System.SysUtils, System.Classes,
<tr class="nocodegen"><td>29<td>  {$ENDIF}
<tr class="nocodegen"><td>30<td>  Generics.Collections;
<tr class="nocodegen"><td>31<td>
<tr class="nocodegen"><td>32<td>type
<tr class="nocodegen"><td>33<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>34<td>  ///   Class type for the base class from which all other DEC classes inherit
<tr class="nocodegen"><td>35<td>  ///   in order to be able to create lists of classes, pick an entry of such a
<tr class="nocodegen"><td>36<td>  ///   list and construct an object out of it
<tr class="nocodegen"><td>37<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>38<td>  TDECClass = class of TDECObject;
<tr class="nocodegen"><td>39<td>
<tr class="nocodegen"><td>40<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>41<td>  ///   Type of a single entry in the class list.
<tr class="nocodegen"><td>42<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>43<td>  TClassListEntry = TPair&lt;Int64, TDECClass&gt;;
<tr class="nocodegen"><td>44<td>
<tr class="nocodegen"><td>45<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>46<td>  ///   Generic list of DEC classes with the identity as key
<tr class="nocodegen"><td>47<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>48<td>  TDECClassList = class(TDictionary&lt;Int64, TDECClass&gt;)
<tr class="nocodegen"><td>49<td>  strict private
<tr class="nocodegen"><td>50<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>51<td>    ///   Checks if a given class type has the same short class name as given
<tr class="nocodegen"><td>52<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>53<td>    /// &lt;param name=&quot;Name&quot;&gt;
<tr class="nocodegen"><td>54<td>    ///   Short class name, e.g. HEXL
<tr class="nocodegen"><td>55<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>56<td>    /// &lt;param name=&quot;ClassType&quot;&gt;
<tr class="nocodegen"><td>57<td>    ///   Class reference to check against
<tr class="nocodegen"><td>58<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>59<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>60<td>    ///   true if the class reference is for the given short name
<tr class="nocodegen"><td>61<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>62<td>    function DoFindNameShort(const Name: string; const ClassType: TDECClass): Boolean;
<tr class="nocodegen"><td>63<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>64<td>    ///   Checks if a given class type has the same long class name as given
<tr class="nocodegen"><td>65<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>66<td>    /// &lt;param name=&quot;Name&quot;&gt;
<tr class="nocodegen"><td>67<td>    ///   Long class name, e.g. TFormat_HEXL
<tr class="nocodegen"><td>68<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>69<td>    /// &lt;param name=&quot;ClassType&quot;&gt;
<tr class="nocodegen"><td>70<td>    ///   Class reference to check against
<tr class="nocodegen"><td>71<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>72<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>73<td>    ///   true if the class reference is for the given long name
<tr class="nocodegen"><td>74<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>75<td>    function DoFindNameLong(const Name: string; const ClassType: TClass): Boolean;
<tr class="nocodegen"><td>76<td>  public
<tr class="nocodegen"><td>77<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>78<td>    ///   Tries to find a class type by its name
<tr class="nocodegen"><td>79<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>80<td>    /// &lt;param name=&quot;Name&quot;&gt;
<tr class="nocodegen"><td>81<td>    ///   Name to look for in the list
<tr class="nocodegen"><td>82<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>83<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>84<td>    ///   Returns the class type if found. if it could not be found a
<tr class="nocodegen"><td>85<td>    ///   EDECClassNotRegisteredException will be thrown
<tr class="nocodegen"><td>86<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>87<td>    /// &lt;exception cref=&quot;EDECClassNotRegisteredException&quot;&gt;
<tr class="nocodegen"><td>88<td>    ///   Exception raised if the class specified by &lt;c&gt;Name&lt;/c&gt; is not found
<tr class="nocodegen"><td>89<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>90<td>    function ClassByName(const Name: string): TDECClass;
<tr class="nocodegen"><td>91<td>
<tr class="nocodegen"><td>92<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>93<td>    ///   Tries to find a class type by its numeric identity DEC assigned to it.
<tr class="nocodegen"><td>94<td>    ///   Useful for file headers, so they can easily encode numerically which
<tr class="nocodegen"><td>95<td>    ///   cipher class was being used.
<tr class="nocodegen"><td>96<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>97<td>    /// &lt;param name=&quot;Identity&quot;&gt;
<tr class="nocodegen"><td>98<td>    ///   Identity to look for
<tr class="nocodegen"><td>99<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>100<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>101<td>    ///   Returns the class type of the class with the specified identity value
<tr class="nocodegen"><td>102<td>    ///   or throws an EDECClassNotRegisteredException exception if no class
<tr class="nocodegen"><td>103<td>    ///   with the given identity has been found
<tr class="nocodegen"><td>104<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>105<td>    /// &lt;exception cref=&quot;EDECClassNotRegisteredException&quot;&gt;
<tr class="nocodegen"><td>106<td>    ///   Exception raised if the class specified by &lt;c&gt;Identity&lt;/c&gt; is not found
<tr class="nocodegen"><td>107<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>108<td>    function ClassByIdentity(Identity: Int64): TDECClass;
<tr class="nocodegen"><td>109<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>110<td>    ///   Returns a list of all classes registered in this list
<tr class="nocodegen"><td>111<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>112<td>    /// &lt;param name=&quot;List&quot;&gt;
<tr class="nocodegen"><td>113<td>    ///   List where the registered classes shall be added to. The string is the
<tr class="nocodegen"><td>114<td>    ///   long class name, the object the class reference. The list is being
<tr class="nocodegen"><td>115<td>    ///   cleared first and when an uncreated list is given nothing is being done
<tr class="nocodegen"><td>116<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>117<td>    procedure GetClassList(List: TStrings);
<tr class="nocodegen"><td>118<td>  end;
<tr class="nocodegen"><td>119<td>
<tr class="nocodegen"><td>120<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>121<td>  ///   Parent class of all cryptography and hash implementations
<tr class="nocodegen"><td>122<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>123<td>  TDECObject = class(TInterfacedObject)
<tr class="nocodegen"><td>124<td>  public
<tr class="nocodegen"><td>125<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>126<td>    ///   Overrideable but otherwise empty constructor (calls his parent
<tr class="nocodegen"><td>127<td>    ///   constructor or course)
<tr class="nocodegen"><td>128<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>129<td>    constructor Create; virtual;
<tr class="nocodegen"><td>130<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>131<td>    ///   This function creates a unique Signature for each class using the
<tr class="nocodegen"><td>132<td>    ///   following naming scheme:
<tr class="nocodegen"><td>133<td>    ///
<tr class="nocodegen"><td>134<td>    ///   'Z' repeated n times (to fill space of 256 chars) + DEC ClassName
<tr class="nocodegen"><td>135<td>    ///
<tr class="nocodegen"><td>136<td>    ///   The CRC32 of the generated Signature is used as our unique Identity
<tr class="nocodegen"><td>137<td>    ///
<tr class="nocodegen"><td>138<td>    ///   Important Note:
<tr class="nocodegen"><td>139<td>    ///   DEC 5.2 introduced a bug which breaks backward compatibility with
<tr class="nocodegen"><td>140<td>    ///   DEC 5.1 by using String instead of AnsiString. This leads to different
<tr class="nocodegen"><td>141<td>    ///   Identities when using Unicode capable Delphi Versions (Delphi 2009+).
<tr class="nocodegen"><td>142<td>    ///
<tr class="nocodegen"><td>143<td>    ///   To restore the *wrong* behavior of DEC 5.2 enable the DEC52_IDENTITY option
<tr class="nocodegen"><td>144<td>    ///   in the configuration file DECOptions.inc.
<tr class="nocodegen"><td>145<td>    ///
<tr class="nocodegen"><td>146<td>    ///   With this and all future versions we will keep backward compatibility.
<tr class="nocodegen"><td>147<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>148<td>    class function Identity: Int64;
<tr class="nocodegen"><td>149<td>    {$IFDEF X86ASM}
<tr class="nocodegen"><td>150<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>151<td>    ///   Override FreeInstance to fill allocated Object with zeros, that is
<tr class="nocodegen"><td>152<td>    ///   safer for any access to invalid Pointers of released Objects.
<tr class="nocodegen"><td>153<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>154<td>    procedure FreeInstance; override;
<tr class="nocodegen"><td>155<td>    {$ENDIF X86ASM}
<tr class="nocodegen"><td>156<td>
<tr class="nocodegen"><td>157<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>158<td>    ///   Registers this class type in the list of DEC classes (ClassList).
<tr class="nocodegen"><td>159<td>    ///   Trying to register an already registered class will raise an exception.
<tr class="nocodegen"><td>160<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>161<td>    /// &lt;param name=&quot;ClassList&quot;&gt;
<tr class="nocodegen"><td>162<td>    ///   List to which the own class type shall be added. This allows subclasses
<tr class="nocodegen"><td>163<td>    ///   to have their own lists
<tr class="nocodegen"><td>164<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>165<td>    class procedure RegisterClass(ClassList : TDECClassList);
<tr class="nocodegen"><td>166<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>167<td>    ///   Removes tthis class type from the list of registered DEC classes
<tr class="nocodegen"><td>168<td>    ///   (ClassList). Trying to unregister a non registered class is a do nothing
<tr class="nocodegen"><td>169<td>    ///   operation.
<tr class="nocodegen"><td>170<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>171<td>    /// &lt;param name=&quot;ClassList&quot;&gt;
<tr class="nocodegen"><td>172<td>    ///   List from which the own class type shall be removed. This allows
<tr class="nocodegen"><td>173<td>    ///   subclasses to have their own lists
<tr class="nocodegen"><td>174<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>175<td>    class procedure UnregisterClass(ClassList : TDECClassList);
<tr class="nocodegen"><td>176<td>
<tr class="nocodegen"><td>177<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>178<td>    ///   Returns short Classname of any DEC derrived class. This is the part
<tr class="nocodegen"><td>179<td>    ///   of the class name after the _ so for THash_RipeMD160 it will be RipeMD160.
<tr class="nocodegen"><td>180<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>181<td>    /// &lt;param name=&quot;ClassName&quot;&gt;
<tr class="nocodegen"><td>182<td>    ///   Complete class name
<tr class="nocodegen"><td>183<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>184<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>185<td>    ///   Short class name
<tr class="nocodegen"><td>186<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>187<td>    class function GetShortClassNameFromName(const ClassName: string): string;
<tr class="nocodegen"><td>188<td>
<tr class="nocodegen"><td>189<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>190<td>    ///   Returns short Classname of any DEC derrived class type. This is the part
<tr class="nocodegen"><td>191<td>    ///   of the class name after the _ so for THash_RipeMD160 it will be RipeMD160.
<tr class="nocodegen"><td>192<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>193<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>194<td>    ///   Short class name or empty string if ClassType is nil.
<tr class="nocodegen"><td>195<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>196<td>    class function GetShortClassName: string;
<tr class="nocodegen"><td>197<td>  end;
<tr class="nocodegen"><td>198<td>
<tr class="nocodegen"><td>199<td>var
<tr class="nocodegen"><td>200<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>201<td>  ///   default used for generating class identities
<tr class="nocodegen"><td>202<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>203<td>  IdentityBase: Int64 = $25844852;
<tr class="nocodegen"><td>204<td>
<tr class="nocodegen"><td>205<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>206<td>  ///   Size in bytes used for buffering data read from or written to a stream
<tr class="nocodegen"><td>207<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>208<td>  StreamBufferSize: Integer = 8192;
<tr class="nocodegen"><td>209<td>
<tr class="nocodegen"><td>210<td>  {$IFDEF NEXTGEN}
<tr class="nocodegen"><td>211<td>  EmptyStr: string = '';
<tr class="nocodegen"><td>212<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>213<td>  ///   Pointer to an empty string. For non Nextgen platforms declared in SysUtils
<tr class="nocodegen"><td>214<td>  ///   for backwards compatibility only. Here declared for NextGen only and
<tr class="nocodegen"><td>215<td>  ///   should get replaced
<tr class="nocodegen"><td>216<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>217<td>  NullStr: PString = @EmptyStr;
<tr class="nocodegen"><td>218<td>  {$ENDIF}
<tr class="nocodegen"><td>219<td>
<tr class="nocodegen"><td>220<td>implementation
<tr class="nocodegen"><td>221<td>
<tr class="nocodegen"><td>222<td>uses
<tr class="nocodegen"><td>223<td>  DECTypes, DECCRC;
<tr class="nocodegen"><td>224<td>
<tr class="nocodegen"><td>225<td>resourcestring
<tr class="nocodegen"><td>226<td>  sClassNotRegistered = 'Class %s is not registered';
<tr class="nocodegen"><td>227<td>  sWrongIdentity      = 'Another class &quot;%s&quot; with the same identity as &quot;%s&quot; has already been registered';
<tr class="nocodegen"><td>228<td>
<tr class="nocodegen"><td>229<td>constructor TDECObject.Create;
<tr class="covered"><td>230<td>begin
<tr class="covered"><td>231<td>  inherited Create;
<tr class="covered"><td>232<td>end;
<tr class="nocodegen"><td>233<td>
<tr class="nocodegen"><td>234<td>class function TDECObject.Identity: Int64;
<tr class="nocodegen"><td>235<td>var
<tr class="nocodegen"><td>236<td>  Signature: {$IFDEF DEC52_IDENTITY}string{$ELSE !DEC52_IDENTITY}RawByteString{$ENDIF !DEC52_IDENTITY};
<tr class="covered"><td>237<td>begin
<tr class="nocodegen"><td>238<td>  {$IFDEF DEC52_IDENTITY}
<tr class="nocodegen"><td>239<td>  Signature := StringOfChar(#$5A, 256 - Length(ClassName)) + UpperCase(ClassName);
<tr class="nocodegen"><td>240<td>    {$IF CompilerVersion &gt;= 24.0}
<tr class="nocodegen"><td>241<td>    Result := CRC32(IdentityBase, Signature[Low(Signature)],
<tr class="nocodegen"><td>242<td>                                  Length(Signature) * SizeOf(Signature[Low(Signature)]));
<tr class="nocodegen"><td>243<td>    {$ELSE}
<tr class="nocodegen"><td>244<td>    Result := CRC32(IdentityBase, Signature[Low(Signature)],
<tr class="nocodegen"><td>245<td>                                  Length(Signature) * SizeOf(Signature[1]));
<tr class="nocodegen"><td>246<td>    {$IFEND}
<tr class="nocodegen"><td>247<td>  {$ELSE !DEC52_IDENTITY}
<tr class="covered"><td>248<td>  Signature := RawByteString(StringOfChar(#$5A, 256 - Length(ClassName)) + UpperCase(ClassName));
<tr class="nocodegen"><td>249<td>    {$IF CompilerVersion &gt;= 24.0}
<tr class="covered"><td>250<td>    Result := CRC32(IdentityBase, Signature[Low(Signature)],
<tr class="nocodegen"><td>251<td>                                  Length(Signature) * SizeOf(Signature[Low(Signature)]));
<tr class="nocodegen"><td>252<td>    {$ELSE}
<tr class="nocodegen"><td>253<td>    Result := CRC32(IdentityBase, Signature[1],
<tr class="nocodegen"><td>254<td>                                  Length(Signature) * SizeOf(Signature[1]));
<tr class="nocodegen"><td>255<td>    {$IFEND}
<tr class="nocodegen"><td>256<td>  {$ENDIF !DEC52_IDENTITY}
<tr class="covered"><td>257<td>end;
<tr class="nocodegen"><td>258<td>
<tr class="nocodegen"><td>259<td>class procedure TDECObject.RegisterClass(ClassList : TDECClassList);
<tr class="covered"><td>260<td>begin
<tr class="covered"><td>261<td>  ClassList.Add(Identity, self);
<tr class="covered"><td>262<td>end;
<tr class="nocodegen"><td>263<td>
<tr class="nocodegen"><td>264<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>265<td>procedure TDECObject.FreeInstance;
<tr class="nocodegen"><td>266<td>// Override FreeInstance to fill allocated Object with zeros, that is
<tr class="nocodegen"><td>267<td>// safer for any access to invalid Pointers of released Objects
<tr class="nocodegen"><td>268<td>asm
<tr class="nocodegen"><td>269<td>      PUSH    EBX
<tr class="nocodegen"><td>270<td>      PUSH    EDI
<tr class="nocodegen"><td>271<td>      MOV     EBX,EAX
<tr class="nocodegen"><td>272<td>      CALL    TObject.CleanupInstance
<tr class="nocodegen"><td>273<td>      MOV     EAX,[EBX]
<tr class="nocodegen"><td>274<td>      CALL    TObject.InstanceSize
<tr class="nocodegen"><td>275<td>      MOV     ECX,EAX
<tr class="nocodegen"><td>276<td>      MOV     EDI,EBX
<tr class="nocodegen"><td>277<td>      XOR     EAX,EAX
<tr class="nocodegen"><td>278<td>      REP     STOSB
<tr class="nocodegen"><td>279<td>      MOV     EAX,EBX
<tr class="nocodegen"><td>280<td>      CALL    System.@FreeMem
<tr class="nocodegen"><td>281<td>      POP     EDI
<tr class="nocodegen"><td>282<td>      POP     EBX
<tr class="nocodegen"><td>283<td>end;
<tr class="nocodegen"><td>284<td>{$ENDIF X86ASM}
<tr class="nocodegen"><td>285<td>
<tr class="nocodegen"><td>286<td>class procedure TDECObject.UnregisterClass(ClassList : TDECClassList);
<tr class="covered"><td>287<td>begin
<tr class="covered"><td>288<td>  ClassList.Remove(Identity);
<tr class="covered"><td>289<td>end;
<tr class="nocodegen"><td>290<td>
<tr class="nocodegen"><td>291<td>class function TDECObject.GetShortClassName: string;
<tr class="covered"><td>292<td>begin
<tr class="covered"><td>293<td>  Result := GetShortClassNameFromName(self.ClassName);
<tr class="covered"><td>294<td>end;
<tr class="nocodegen"><td>295<td>
<tr class="nocodegen"><td>296<td>class function TDECObject.GetShortClassNameFromName(const ClassName: string): string;
<tr class="nocodegen"><td>297<td>var
<tr class="nocodegen"><td>298<td>  i: Integer;
<tr class="covered"><td>299<td>begin
<tr class="covered"><td>300<td>  Result := ClassName;
<tr class="covered"><td>301<td>  i := Pos('_', Result);
<tr class="covered"><td>302<td>  if i &gt; 0 then
<tr class="covered"><td>303<td>    Delete(Result, 1, i);
<tr class="covered"><td>304<td>end;
<tr class="nocodegen"><td>305<td>
<tr class="nocodegen"><td>306<td>{ TDECClassList }
<tr class="nocodegen"><td>307<td>
<tr class="nocodegen"><td>308<td>function TDECClassList.DoFindNameShort(const Name: string; const ClassType: TDECClass): Boolean;
<tr class="covered"><td>309<td>begin
<tr class="covered"><td>310<td>  Result := CompareText(ClassType.GetShortClassName, Name) = 0;
<tr class="covered"><td>311<td>end;
<tr class="nocodegen"><td>312<td>
<tr class="nocodegen"><td>313<td>function TDECClassList.DoFindNameLong(const Name: string; const ClassType: TClass): Boolean;
<tr class="nocodegen"><td>314<td>var
<tr class="nocodegen"><td>315<td>  s: string;
<tr class="covered"><td>316<td>begin
<tr class="covered"><td>317<td>  s := Name;
<tr class="covered"><td>318<td>  Result := CompareText(ClassType.ClassName, Name) = 0;
<tr class="covered"><td>319<td>end;
<tr class="nocodegen"><td>320<td>
<tr class="nocodegen"><td>321<td>function TDECClassList.ClassByIdentity(Identity: Int64): TDECClass;
<tr class="covered"><td>322<td>begin
<tr class="covered"><td>323<td>  try
<tr class="covered"><td>324<td>    Result := Items[Identity];
<tr class="nocodegen"><td>325<td>  except
<tr class="nocodegen"><td>326<td>    On EListError do
<tr class="covered"><td>327<td>      raise EDECClassNotRegisteredException.CreateResFmt(@sClassNotRegistered,
<tr class="nocodegen"><td>328<td>                                                         [IntToHEX(Identity, 8)]);
<tr class="nocodegen"><td>329<td>  end;
<tr class="covered"><td>330<td>end;
<tr class="nocodegen"><td>331<td>
<tr class="nocodegen"><td>332<td>function TDECClassList.ClassByName(const Name: string): TDECClass;
<tr class="nocodegen"><td>333<td>var
<tr class="nocodegen"><td>334<td>  FindNameShort : Boolean;
<tr class="nocodegen"><td>335<td>  Pair          : TPair&lt;Int64, TDECCLass&gt;;
<tr class="covered"><td>336<td>begin
<tr class="covered"><td>337<td>  Result := nil;
<tr class="nocodegen"><td>338<td>
<tr class="covered"><td>339<td>  if Length(Name) &gt; 0 then
<tr class="nocodegen"><td>340<td>  begin
<tr class="covered"><td>341<td>    FindNameShort := TDECClass.GetShortClassNameFromName(Name) = Name;
<tr class="nocodegen"><td>342<td>
<tr class="covered"><td>343<td>    for Pair in self do
<tr class="nocodegen"><td>344<td>    begin
<tr class="covered"><td>345<td>      if FindNameShort then
<tr class="nocodegen"><td>346<td>      begin
<tr class="covered"><td>347<td>        if DoFindNameShort(Name, Pair.Value) then
<tr class="nocodegen"><td>348<td>        begin
<tr class="covered"><td>349<td>          result := Pair.Value;
<tr class="covered"><td>350<td>          break;
<tr class="nocodegen"><td>351<td>        end;
<tr class="nocodegen"><td>352<td>      end
<tr class="nocodegen"><td>353<td>      else
<tr class="covered"><td>354<td>        if DoFindNameLong(Name, Pair.Value) then
<tr class="nocodegen"><td>355<td>        begin
<tr class="covered"><td>356<td>          result := Pair.Value;
<tr class="covered"><td>357<td>          break;
<tr class="nocodegen"><td>358<td>        end;
<tr class="covered"><td>359<td>    end;
<tr class="nocodegen"><td>360<td>  end;
<tr class="nocodegen"><td>361<td>
<tr class="covered"><td>362<td>  if Result = nil then
<tr class="covered"><td>363<td>    raise EDECClassNotRegisteredException.CreateResFmt(@sClassNotRegistered, [Name]);
<tr class="covered"><td>364<td>end;
<tr class="nocodegen"><td>365<td>
<tr class="nocodegen"><td>366<td>procedure TDECClassList.GetClassList(List: TStrings);
<tr class="nocodegen"><td>367<td>var
<tr class="nocodegen"><td>368<td>  Pair : TPair&lt;Int64, TDECCLass&gt;;
<tr class="covered"><td>369<td>begin
<tr class="covered"><td>370<td>  if List &lt;&gt; nil then
<tr class="covered"><td>371<td>  try
<tr class="covered"><td>372<td>    List.BeginUpdate;
<tr class="covered"><td>373<td>    List.Clear;
<tr class="nocodegen"><td>374<td>
<tr class="covered"><td>375<td>    for Pair in self do
<tr class="covered"><td>376<td>      List.AddObject(Pair.Value.ClassName, TObject(Pair.Value));
<tr class="nocodegen"><td>377<td>
<tr class="nocodegen"><td>378<td>  finally
<tr class="covered"><td>379<td>    List.EndUpdate;
<tr class="nocodegen"><td>380<td>  end;
<tr class="covered"><td>381<td>end;
<tr class="nocodegen"><td>382<td>
<tr class="covered"><td>383<td>initialization
<tr class="nocodegen"><td>384<td>
<tr class="covered"><td>385<td>finalization
<tr class="nocodegen"><td>386<td>
<tr class="covered"><td>387<td>end.
</table>
<script>(function () {
var starts = [],prev = document.getElementById("nav-prev"),next = document.getElementById("nav-next");
(function () {
var p;
document.querySelectorAll("table.s tr").forEach(r => {
if (r.classList.contains("notcovered")) {
if (!p) starts.push(r);
p = r;
} else { p = null }
})
})();
function findPrev() {
var y = prev.getBoundingClientRect().top - 4;
for (var i=starts.length-1; i>=0; i--) {
if (starts[i].getBoundingClientRect().top < y) return starts[i]
}
}
function findNext() {
var y = next.getBoundingClientRect().top + 4;
for (var i=0; i<starts.length; i++) {
if (starts[i].getBoundingClientRect().top > y) return starts[i];
}
}
function onScroll() {
prev.setAttribute("class", findPrev() ? "active" : "");
next.setAttribute("class", findNext() ? "active" : "");
onScroll.pending = 0;
}
document.addEventListener("scroll", function() {
if (!onScroll.pending) { onScroll.pending = requestAnimationFrame(onScroll) }
});
onScroll();
function scrollTo(row) {
if (row) window.scrollTo({ behavior: "smooth", top: window.scrollY+row.getBoundingClientRect().top-prev.getBoundingClientRect().top });
}
next.addEventListener("click", () => scrollTo(findNext()) );
prev.addEventListener("click", () => scrollTo(findPrev()) );
})();</script>
<script>
const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
const comparer = (idx, asc) => (a, b) => ((v1, v2) =>!isNaN(parseFloat(v1 || "-")) && !isNaN(parseFloat(v2 || "-")) ? parseFloat(v1)-parseFloat(v2) : v1.toString().localeCompare(v2))(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));
document.querySelectorAll("thead th[idx]").forEach(th => th.addEventListener("click", (() => {
	const table = th.closest("table").querySelector("tbody");
	Array.from(table.querySelectorAll("tr"))
		.sort(comparer(+th.getAttribute("idx"), this.asc = !this.asc))
		.forEach(tr => table.appendChild(tr) );
	})));
</script>
</body>
</html>
