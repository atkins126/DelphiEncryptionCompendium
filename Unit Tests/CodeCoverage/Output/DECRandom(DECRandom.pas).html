<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
body {max-width: max-content;margin: auto;}
table {border-spacing:0;}
table, td, th {border: 0;}
td, th {background: white; margin: 0; padding: .5em 1em}
table small { color: #777; }
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: consolas,courier,monospace; font-size: 10pt;}
thead, th {background: #808C98; color: white; }
table th small { color: #ddd; }
th[idx] {cursor: pointer; user-select: none;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: calc(min(80em, 95vw));}
table.s tr td {padding: .1em .5em; white-space: pre-wrap;}
table.s tr td:first-child {text-align: right; font-weight: bold; vertical-align: top}
table.s tr.notcovered td {background: #ddf;}
table.s tr.nocodegen td {background: #ffe;}
table.s tr.covered td {background: #cfc;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum td { background-position: 50%; background-repeat: no-repeat; background-size: 90% 70%; }
table.sum tr:nth-child(odd) td { background-color: #f4f4f4}
table.sum tr:hover td, tr:hover td a { filter: invert(10%) }
table.sum tr th {text-align:left; border: .5px solid #5d4e4c; height: 1em}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
table.sum thead th { position: sticky; top:0; }
table.sum thead tr + tr th { position: sticky; top: calc(2.5em - 2px); }
table.sum tfoot th { position: sticky; bottom:0; }
table.sum tfoot th+th {text-align: right;}
table.sum a, table.sum a:visited {color: #5d4e4c; text-decoration: none;}
#nav {position: fixed;overflow: visible;left: min(calc(50% + 41em), calc(100% - 6em));padding: .1em .5em .1em .2em;background: white;box-shadow: 1px 1px 3px #888;}
#nav div {opacity: .3; user-select: none; pointer-events: none;}
#nav div.active {opacity: 1;	cursor: pointer;	pointer-events: initial;}
#nav div.active:hover {color: #00A;}
</style>
</head>
<body>
<p>Coverage report for <bold>DECRandom (..\..\Source\DECRandom.pas)</bold>.</p>
<p>Generated at 30.11.2022 22:06:19 by <a href="https://github.com/DelphiCodeCoverage/DelphiCodeCoverage" target="_blank" title="DelphiCodeCoverage on GitHub">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p>Statistics for ..\..\Source\DECRandom.pas</p>
<table class="o"><tr><td>Number of lines covered<td>91<td rowspan=3 style="background: conic-gradient(#9fe098 96%, #eee 96%);width: 4.5em; border-radius: 50%"><tr><td>Number of lines with code gen<td>94<tr><td>Line coverage<td>96<small>.8</small>&nbsp;%</table>
<br><br>
<div id="nav"><div id="nav-prev">&#x25b2; Prev</div><div id="nav-next">&#x25bc; Next</div></div>
<table class="s">
<tr class="nocodegen"><td>1<td>{*****************************************************************************
<tr class="nocodegen"><td>2<td>  The DEC team (see file NOTICE.txt) licenses this file
<tr class="nocodegen"><td>3<td>  to you under the Apache License, Version 2.0 (the
<tr class="nocodegen"><td>4<td>  &quot;License&quot;); you may not use this file except in compliance
<tr class="nocodegen"><td>5<td>  with the License. A copy of this licence is found in the root directory
<tr class="nocodegen"><td>6<td>  of this project in the file LICENCE.txt or alternatively at
<tr class="nocodegen"><td>7<td>
<tr class="nocodegen"><td>8<td>    http://www.apache.org/licenses/LICENSE-2.0
<tr class="nocodegen"><td>9<td>
<tr class="nocodegen"><td>10<td>  Unless required by applicable law or agreed to in writing,
<tr class="nocodegen"><td>11<td>  software distributed under the License is distributed on an
<tr class="nocodegen"><td>12<td>  &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<tr class="nocodegen"><td>13<td>  KIND, either express or implied.  See the License for the
<tr class="nocodegen"><td>14<td>  specific language governing permissions and limitations
<tr class="nocodegen"><td>15<td>  under the License.
<tr class="nocodegen"><td>16<td>*****************************************************************************}
<tr class="nocodegen"><td>17<td>
<tr class="nocodegen"><td>18<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>19<td>///   Secure Pseudo Random Number Generator based on Yarrow. If used without
<tr class="nocodegen"><td>20<td>///   doing anything special for initialization a repeatable generator will be
<tr class="nocodegen"><td>21<td>///   initialized always using the same start value.
<tr class="nocodegen"><td>22<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>23<td>unit DECRandom;
<tr class="nocodegen"><td>24<td>
<tr class="nocodegen"><td>25<td>interface
<tr class="nocodegen"><td>26<td>
<tr class="nocodegen"><td>27<td>{$INCLUDE DECOptions.inc}
<tr class="nocodegen"><td>28<td>
<tr class="nocodegen"><td>29<td>uses
<tr class="nocodegen"><td>30<td>  {$IFDEF FPC}
<tr class="nocodegen"><td>31<td>  SysUtils,
<tr class="nocodegen"><td>32<td>  {$ELSE}
<tr class="nocodegen"><td>33<td>  System.SysUtils,
<tr class="nocodegen"><td>34<td>  {$ENDIF}
<tr class="nocodegen"><td>35<td>  DECHashBase, DECHash;
<tr class="nocodegen"><td>36<td>
<tr class="nocodegen"><td>37<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>38<td>///   Create a seed for the random number generator from system time and
<tr class="nocodegen"><td>39<td>///   PerformanceCounter.
<tr class="nocodegen"><td>40<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>41<td>/// &lt;remarks&gt;
<tr class="nocodegen"><td>42<td>///   Avoid initializing the seed using this fuction if you can as it is not
<tr class="nocodegen"><td>43<td>///   really secure. Use RandomBuffer instead and provide user generated input
<tr class="nocodegen"><td>44<td>///   as Buffer value but ensure that this is not uniform e.g. not a buffer only
<tr class="nocodegen"><td>45<td>///   containing $00 all over or something like this.
<tr class="nocodegen"><td>46<td>/// &lt;/remarks&gt;
<tr class="nocodegen"><td>47<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>48<td>///   Created seed value
<tr class="nocodegen"><td>49<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>50<td>function RandomSystemTime: Int64;
<tr class="nocodegen"><td>51<td>
<tr class="nocodegen"><td>52<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>53<td>///   Fills the provided buffer with random values. If the DoRandomBuffer
<tr class="nocodegen"><td>54<td>///   variable is assigned (which is usually the case because DoBuffer is
<tr class="nocodegen"><td>55<td>///   assigned to it in initialization of this unit) the hash based algorithm
<tr class="nocodegen"><td>56<td>///   in DoBuffer will be used, otherwise the weaker one in DoRndBuffer.
<tr class="nocodegen"><td>57<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>58<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>59<td>///   Buffer to be filled with random values
<tr class="nocodegen"><td>60<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>61<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>62<td>///   Size of the buffer in byte
<tr class="nocodegen"><td>63<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>64<td>procedure RandomBuffer(out Buffer; Size: Integer);
<tr class="nocodegen"><td>65<td>
<tr class="nocodegen"><td>66<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>67<td>///   Creates a buffer of the specified size filled with random bytes
<tr class="nocodegen"><td>68<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>69<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>70<td>///   Size of the buffer to be created in bytes
<tr class="nocodegen"><td>71<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>72<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>73<td>///   Buffer of the specified size in bytes filled with random data
<tr class="nocodegen"><td>74<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>75<td>function RandomBytes(Size: Integer): TBytes;
<tr class="nocodegen"><td>76<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>77<td>///   Creates a RawByteString of the specified length filled with random bytes.
<tr class="nocodegen"><td>78<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>79<td>/// &lt;remarks&gt;
<tr class="nocodegen"><td>80<td>///   This function is deprecated. Better use RandomBytes where ever possible!
<tr class="nocodegen"><td>81<td>/// &lt;/remarks&gt;
<tr class="nocodegen"><td>82<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>83<td>///   Length of the string to be created in bytes
<tr class="nocodegen"><td>84<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>85<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>86<td>///   String of the specified length in bytes filled with random data
<tr class="nocodegen"><td>87<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>88<td>function RandomRawByteString(Size: Integer): RawByteString; deprecated 'please use RandomBytes now';
<tr class="nocodegen"><td>89<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>90<td>///   Creates a random UInt32 value
<tr class="nocodegen"><td>91<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>92<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>93<td>///   Random value
<tr class="nocodegen"><td>94<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>95<td>function RandomLong: UInt32;
<tr class="nocodegen"><td>96<td>
<tr class="nocodegen"><td>97<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>98<td>///   If the default value of the global DoRandomSeed variable is kept, this
<tr class="nocodegen"><td>99<td>///   procedure initializes a repeatable or a non repeatable seed,
<tr class="nocodegen"><td>100<td>///   depending on the parameters specified. Otherwise the alternative DoRandomSeed
<tr class="nocodegen"><td>101<td>///   implementation is called. The FRndSeed variable is initialized with the
<tr class="nocodegen"><td>102<td>///   seed value generated.
<tr class="nocodegen"><td>103<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>104<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>105<td>///   If a repeatable seed is to be initialized, the contents of this buffer is
<tr class="nocodegen"><td>106<td>///   a parameter to the seed generation and a buffer containing at least Size
<tr class="nocodegen"><td>107<td>///   bytes needs to be passed.
<tr class="nocodegen"><td>108<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>109<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>110<td>///   If Size is &gt; 0 a repeatable seed is initialized. If Size is 0 the
<tr class="nocodegen"><td>111<td>///   internal seed variable FRndSeed is initialized with 0. If Size is
<tr class="nocodegen"><td>112<td>///   less than 0 the internal FRndSeed variable is initialized with
<tr class="nocodegen"><td>113<td>///   a value derrived from current system time/performance counter using
<tr class="nocodegen"><td>114<td>///   RandomSystemTime.
<tr class="nocodegen"><td>115<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>116<td>procedure RandomSeed(const Buffer; Size: Integer); overload;
<tr class="nocodegen"><td>117<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>118<td>///   Creates a seed (starting) value for the random number generator. If the
<tr class="nocodegen"><td>119<td>///   default value of the global DoRandomSeed variable is kept, a non repeatable
<tr class="nocodegen"><td>120<td>///   seed based on RandomSystemTime (based on system time and potentially
<tr class="nocodegen"><td>121<td>///   QueryPerformanceCounter) is created and assigned to the internal FRndSeed
<tr class="nocodegen"><td>122<td>///   variable.
<tr class="nocodegen"><td>123<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>124<td>procedure RandomSeed; overload;
<tr class="nocodegen"><td>125<td>
<tr class="nocodegen"><td>126<td>type
<tr class="nocodegen"><td>127<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>128<td>  ///   Type for the random buffer generation
<tr class="nocodegen"><td>129<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>130<td>  /// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>131<td>  ///   Buffer in which the random bytes shall be written. The buffer needs to
<tr class="nocodegen"><td>132<td>  ///   exist and must be of at least Size bytes length.
<tr class="nocodegen"><td>133<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>134<td>  /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>135<td>  ///   Length of the buffer to be filled in Byte.
<tr class="nocodegen"><td>136<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>137<td>  TRandomBufferProc = procedure(out Buffer; Size: Integer) register;
<tr class="nocodegen"><td>138<td>
<tr class="nocodegen"><td>139<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>140<td>  ///   Type for an initialization procedure for a seed
<tr class="nocodegen"><td>141<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>142<td>  /// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>143<td>  ///   Buffer from which the random bytes shall be taken. The buffer needs to
<tr class="nocodegen"><td>144<td>  ///   exist and must be of at least Size bytes length.
<tr class="nocodegen"><td>145<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>146<td>  /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>147<td>  ///   Length of the buffer in Byte.
<tr class="nocodegen"><td>148<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>149<td>  TRandomSeedProc = procedure(const Buffer; Size: Integer); register;
<tr class="nocodegen"><td>150<td>
<tr class="nocodegen"><td>151<td>var
<tr class="nocodegen"><td>152<td>  // secure PRNG initialized by this unit
<tr class="nocodegen"><td>153<td>
<tr class="nocodegen"><td>154<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>155<td>  ///   This variable allows overriding the random number generation procedure
<tr class="nocodegen"><td>156<td>  ///   used for data buffers. By default it is initialized to point to DoBuffer,
<tr class="nocodegen"><td>157<td>  ///   which is a DECRandom internal procedure.
<tr class="nocodegen"><td>158<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>159<td>  /// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>160<td>  ///   Buffer in which the random bytes shall be written. The buffer needs to
<tr class="nocodegen"><td>161<td>  ///   exist and must be of at least Size bytes length.
<tr class="nocodegen"><td>162<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>163<td>  /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>164<td>  ///   Length of the buffer to be filled in Byte.
<tr class="nocodegen"><td>165<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>166<td>  DoRandomBuffer: TRandomBufferProc = nil;
<tr class="nocodegen"><td>167<td>
<tr class="nocodegen"><td>168<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>169<td>  ///   This variable allows overriding the seed value generation procedure.
<tr class="nocodegen"><td>170<td>  ///   By default it is initialized with the DECRandom internal procedure DoSeed.
<tr class="nocodegen"><td>171<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>172<td>  DoRandomSeed: TRandomSeedProc = nil;
<tr class="nocodegen"><td>173<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>174<td>  ///   Defines the hash-algorithm used for generatin seed values or hashed buffers
<tr class="nocodegen"><td>175<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>176<td>  RandomClass: TDECHashClass = THash_SHA256;
<tr class="nocodegen"><td>177<td>
<tr class="nocodegen"><td>178<td>implementation
<tr class="nocodegen"><td>179<td>
<tr class="nocodegen"><td>180<td>uses
<tr class="nocodegen"><td>181<td>  {$IFDEF DELPHI_2010_UP}
<tr class="nocodegen"><td>182<td>    System.Diagnostics
<tr class="nocodegen"><td>183<td>  {$ELSE}
<tr class="nocodegen"><td>184<td>    {$IFDEF FPC}
<tr class="nocodegen"><td>185<td>      {$IFDEF MSWINDOWS}
<tr class="nocodegen"><td>186<td>      Windows
<tr class="nocodegen"><td>187<td>      {$ELSE}
<tr class="nocodegen"><td>188<td>      LclIntf
<tr class="nocodegen"><td>189<td>      {$ENDIF}
<tr class="nocodegen"><td>190<td>    {$ELSE}
<tr class="nocodegen"><td>191<td>    Winapi.Windows
<tr class="nocodegen"><td>192<td>    {$ENDIF}
<tr class="nocodegen"><td>193<td>  {$ENDIF}
<tr class="nocodegen"><td>194<td>  ;
<tr class="nocodegen"><td>195<td>
<tr class="nocodegen"><td>196<td>{$IFOPT Q+}{$DEFINE RESTORE_OVERFLOWCHECKS}{$Q-}{$ENDIF}
<tr class="nocodegen"><td>197<td>{$IFOPT R+}{$DEFINE RESTORE_RANGECHECKS}{$R-}{$ENDIF}
<tr class="nocodegen"><td>198<td>
<tr class="nocodegen"><td>199<td>var
<tr class="nocodegen"><td>200<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>201<td>  ///   A sequence of values which over time will be random by replacing each
<tr class="nocodegen"><td>202<td>  ///   value with a derived value generated by applying the hash algorithm.
<tr class="nocodegen"><td>203<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>204<td>  FRegister: array[0..127] of Byte;
<tr class="nocodegen"><td>205<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>206<td>  ///   The hash used to generate derived values stored in FRegister is calculated
<tr class="nocodegen"><td>207<td>  ///   using this counter as input and this counter additionaly defines the index
<tr class="nocodegen"><td>208<td>  ///   in FRegister where the value will be stored. The counter can assume higher
<tr class="nocodegen"><td>209<td>  ///   values than the lngth of FRegister. The index calculation takes this into
<tr class="nocodegen"><td>210<td>  ///   account.
<tr class="nocodegen"><td>211<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>212<td>  FCounter: Cardinal;
<tr class="nocodegen"><td>213<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>214<td>  ///   Object instance for the hash generation algorithm used. The object is
<tr class="nocodegen"><td>215<td>  ///   created the first time it is needed and freed in finalization of this unit.
<tr class="nocodegen"><td>216<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>217<td>  FHash: TDECHash = nil;
<tr class="nocodegen"><td>218<td>
<tr class="nocodegen"><td>219<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>220<td>  ///   Seed value, stores the last generated random number as start value for
<tr class="nocodegen"><td>221<td>  ///   the next randum number generation
<tr class="nocodegen"><td>222<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>223<td>  FRndSeed: Cardinal = 0;
<tr class="nocodegen"><td>224<td>
<tr class="nocodegen"><td>225<td>function RandomSystemTime: Int64;
<tr class="nocodegen"><td>226<td>type
<tr class="nocodegen"><td>227<td>  TInt64Rec = packed record
<tr class="nocodegen"><td>228<td>    Lo, Hi: UInt32;
<tr class="nocodegen"><td>229<td>  end;
<tr class="nocodegen"><td>230<td>var
<tr class="nocodegen"><td>231<td>  {$IF defined(MSWINDOWS) and not defined(DELPHI_2010_UP)}
<tr class="nocodegen"><td>232<td>  SysTime: TSystemTime;
<tr class="nocodegen"><td>233<td>  {$ELSE}
<tr class="nocodegen"><td>234<td>  Hour, Minute, Second, Milliseconds: Word;
<tr class="nocodegen"><td>235<td>  {$IFEND}
<tr class="nocodegen"><td>236<td>  Counter: TInt64Rec;
<tr class="nocodegen"><td>237<td>  Time: Cardinal;
<tr class="covered"><td>238<td>begin
<tr class="nocodegen"><td>239<td>  {$IF defined(MSWINDOWS) and not defined(DELPHI_2010_UP)}
<tr class="nocodegen"><td>240<td>  GetSystemTime(SysTime);
<tr class="nocodegen"><td>241<td>  Time := ((Cardinal(SysTime.wHour) * 60 + SysTime.wMinute) * 60 + SysTime.wSecond) * 1000 + SysTime.wMilliseconds;
<tr class="nocodegen"><td>242<td>  QueryPerformanceCounter(Int64(Counter));
<tr class="nocodegen"><td>243<td>  {$ELSE}
<tr class="covered"><td>244<td>  DecodeTime(Now, Hour, Minute, Second, Milliseconds);
<tr class="covered"><td>245<td>  Time := ((Cardinal(Hour) * 60 + Minute) * 60 + Second) * 1000 + Milliseconds;
<tr class="nocodegen"><td>246<td>    {$IFDEF DELPHI_2010_UP}
<tr class="covered"><td>247<td>    Int64(Counter) := TStopWatch.GetTimeStamp; // uses System.Diagnostics
<tr class="nocodegen"><td>248<td>    {$ELSE}
<tr class="nocodegen"><td>249<td>      {$IFDEF FPC}
<tr class="nocodegen"><td>250<td>      Int64(Counter) := LclIntf.GetTickCount * 10000 {TicksPerMillisecond}; // uses LclIntf
<tr class="nocodegen"><td>251<td>      {$ENDIF}
<tr class="nocodegen"><td>252<td>    {$ENDIF}
<tr class="nocodegen"><td>253<td>  {$IFEND}
<tr class="nocodegen"><td>254<td>
<tr class="covered"><td>255<td>  Result := Time + Counter.Hi;
<tr class="covered"><td>256<td>  Inc(Result, Ord(Result &lt; Time)); // add &quot;carry flag&quot;
<tr class="covered"><td>257<td>  Inc(Result, Counter.Lo);
<tr class="covered"><td>258<td>end;
<tr class="nocodegen"><td>259<td>
<tr class="nocodegen"><td>260<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>261<td>///   Simplistic algorithm for filling a buffer with random numbers. This
<tr class="nocodegen"><td>262<td>///   algorithm is directly dependant on the seed passed, which by internal use
<tr class="nocodegen"><td>263<td>///   will normally be FRndSeed.
<tr class="nocodegen"><td>264<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>265<td>/// &lt;param name=&quot;Seed&quot;&gt;
<tr class="nocodegen"><td>266<td>///   Seed value as starting value
<tr class="nocodegen"><td>267<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>268<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>269<td>///   Buffer which shall be filled with random bytes
<tr class="nocodegen"><td>270<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>271<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>272<td>///   Size of the buffer in byte
<tr class="nocodegen"><td>273<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>274<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>275<td>///   New seed value after calculating the random number for the last byte in
<tr class="nocodegen"><td>276<td>///   the buffer.
<tr class="nocodegen"><td>277<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>278<td>function DoRndBuffer(Seed: Cardinal; out Buffer; Size: Integer): Cardinal;
<tr class="nocodegen"><td>279<td>// comparable to Delphi Random() function
<tr class="nocodegen"><td>280<td>var
<tr class="nocodegen"><td>281<td>  P: PByte;
<tr class="covered"><td>282<td>begin
<tr class="covered"><td>283<td>  Result := Seed;
<tr class="covered"><td>284<td>  P := @Buffer;
<tr class="covered"><td>285<td>  if P &lt;&gt; nil then
<tr class="nocodegen"><td>286<td>  begin
<tr class="covered"><td>287<td>    while Size &gt; 0 do
<tr class="nocodegen"><td>288<td>    begin
<tr class="covered"><td>289<td>      Result := Result * $08088405 + 1;
<tr class="covered"><td>290<td>      P^ := Byte(Result shr 24);
<tr class="covered"><td>291<td>      Inc(P);
<tr class="covered"><td>292<td>      Dec(Size);
<tr class="nocodegen"><td>293<td>    end;
<tr class="nocodegen"><td>294<td>  end;
<tr class="covered"><td>295<td>end;
<tr class="nocodegen"><td>296<td>
<tr class="nocodegen"><td>297<td>procedure RandomBuffer(out Buffer; Size: Integer);
<tr class="covered"><td>298<td>begin
<tr class="covered"><td>299<td>  if Assigned(DoRandomBuffer) then
<tr class="covered"><td>300<td>    DoRandomBuffer(Buffer, Size)
<tr class="nocodegen"><td>301<td>  else
<tr class="covered"><td>302<td>    FRndSeed := DoRndBuffer(FRndSeed, Buffer, Size);
<tr class="covered"><td>303<td>end;
<tr class="nocodegen"><td>304<td>
<tr class="nocodegen"><td>305<td>function RandomBytes(Size: Integer): TBytes;
<tr class="covered"><td>306<td>begin
<tr class="covered"><td>307<td>  SetLength(Result, Size);
<tr class="covered"><td>308<td>  RandomBuffer(Result[0], Size);
<tr class="covered"><td>309<td>end;
<tr class="nocodegen"><td>310<td>
<tr class="nocodegen"><td>311<td>function RandomRawByteString(Size: Integer): RawByteString;
<tr class="nocodegen"><td>312<td>begin
<tr class="nocodegen"><td>313<td>  SetLength(Result, Size);
<tr class="nocodegen"><td>314<td>  {$IF CompilerVersion &gt;= 24.0}
<tr class="nocodegen"><td>315<td>  RandomBuffer(Result[Low(Result)], Size);
<tr class="nocodegen"><td>316<td>  {$ELSE}
<tr class="nocodegen"><td>317<td>  RandomBuffer(Result[1], Size);
<tr class="nocodegen"><td>318<td>  {$IFEND}
<tr class="nocodegen"><td>319<td>end;
<tr class="nocodegen"><td>320<td>
<tr class="nocodegen"><td>321<td>function RandomLong: UInt32;
<tr class="covered"><td>322<td>begin
<tr class="covered"><td>323<td>  RandomBuffer(Result, SizeOf(Result));
<tr class="covered"><td>324<td>end;
<tr class="nocodegen"><td>325<td>
<tr class="nocodegen"><td>326<td>procedure RandomSeed(const Buffer; Size: Integer);
<tr class="covered"><td>327<td>begin
<tr class="covered"><td>328<td>  if Assigned(DoRandomSeed) then
<tr class="covered"><td>329<td>    DoRandomSeed(Buffer, Size)
<tr class="nocodegen"><td>330<td>  else
<tr class="nocodegen"><td>331<td>  begin
<tr class="covered"><td>332<td>    if Size &gt;= 0 then
<tr class="nocodegen"><td>333<td>    begin
<tr class="covered"><td>334<td>      FRndSeed := 0;
<tr class="covered"><td>335<td>      while Size &gt; 0 do
<tr class="nocodegen"><td>336<td>      begin
<tr class="covered"><td>337<td>        Dec(Size);
<tr class="covered"><td>338<td>        FRndSeed := (FRndSeed shl 8 + FRndSeed shr 24) xor TByteArray(Buffer)[Size]
<tr class="nocodegen"><td>339<td>      end;
<tr class="nocodegen"><td>340<td>    end
<tr class="nocodegen"><td>341<td>    else
<tr class="notcovered"><td>342<td>      FRndSeed := RandomSystemTime;
<tr class="nocodegen"><td>343<td>  end;
<tr class="covered"><td>344<td>end;
<tr class="nocodegen"><td>345<td>
<tr class="nocodegen"><td>346<td>procedure RandomSeed;
<tr class="covered"><td>347<td>begin
<tr class="covered"><td>348<td>  RandomSeed('', -1);
<tr class="covered"><td>349<td>end;
<tr class="nocodegen"><td>350<td>
<tr class="nocodegen"><td>351<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>352<td>///   Generate one random byte and modify FCounter and FRegister
<tr class="nocodegen"><td>353<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>354<td>function DoGenerateRandomByte: Byte;
<tr class="covered"><td>355<td>begin
<tr class="covered"><td>356<td>  if FHash = nil then
<tr class="covered"><td>357<td>    FHash := RandomClass.Create;
<tr class="nocodegen"><td>358<td>
<tr class="covered"><td>359<td>  FHash.Init;
<tr class="covered"><td>360<td>  FHash.Calc(FCounter, SizeOf(FCounter));
<tr class="covered"><td>361<td>  FHash.Calc(FRegister, SizeOf(FRegister));
<tr class="covered"><td>362<td>  FHash.Done;
<tr class="nocodegen"><td>363<td>
<tr class="covered"><td>364<td>  FRegister[FCounter mod SizeOf(FRegister)] := FRegister[FCounter mod SizeOf(FRegister)] xor FHash.DigestAsBytes[0];
<tr class="covered"><td>365<td>  Inc(FCounter);
<tr class="nocodegen"><td>366<td>
<tr class="covered"><td>367<td>  Result := FHash.DigestAsBytes[1]; // no real predictable dependency to above FHash.Digest[0] !
<tr class="covered"><td>368<td>end;
<tr class="nocodegen"><td>369<td>
<tr class="nocodegen"><td>370<td>procedure DoBuffer(out Buffer; Size: Integer);
<tr class="nocodegen"><td>371<td>var
<tr class="nocodegen"><td>372<td>  i: Integer;
<tr class="covered"><td>373<td>begin
<tr class="covered"><td>374<td>  for i := 0 to Size - 1 do
<tr class="covered"><td>375<td>    TByteArray(Buffer)[i] := DoGenerateRandomByte;
<tr class="covered"><td>376<td>end;
<tr class="nocodegen"><td>377<td>
<tr class="nocodegen"><td>378<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>379<td>///   Initializes a repeatable or a non repeatable seed, depending on the
<tr class="nocodegen"><td>380<td>///   parameters specified
<tr class="nocodegen"><td>381<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>382<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>383<td>///   If a repeatable seed is to be initialized, the contents of this buffer is
<tr class="nocodegen"><td>384<td>///   a parameter to the seed generation and a buffer containing at least Size
<tr class="nocodegen"><td>385<td>///   bytes needs to be passed.
<tr class="nocodegen"><td>386<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>387<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>388<td>///   If Size is &gt;= 0 a repeatable seed is initialized, otherwise a non repeatable
<tr class="nocodegen"><td>389<td>///   based on system time
<tr class="nocodegen"><td>390<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>391<td>procedure DoSeed(const Buffer; Size: Integer);
<tr class="nocodegen"><td>392<td>var
<tr class="nocodegen"><td>393<td>  i: Integer;
<tr class="nocodegen"><td>394<td>  t: Cardinal;
<tr class="covered"><td>395<td>begin
<tr class="covered"><td>396<td>  if Size &gt;= 0 then
<tr class="nocodegen"><td>397<td>  begin
<tr class="nocodegen"><td>398<td>    // initalize a repeatable Seed
<tr class="covered"><td>399<td>    FillChar(FRegister, SizeOf(FRegister), 0);
<tr class="covered"><td>400<td>    FCounter := 0;
<tr class="covered"><td>401<td>    for i := 0 to Size - 1 do
<tr class="notcovered"><td>402<td>      FRegister[i mod SizeOf(FRegister)] := FRegister[i mod SizeOf(FRegister)] xor TByteArray(Buffer)[i];
<tr class="nocodegen"><td>403<td>  end
<tr class="nocodegen"><td>404<td>  else
<tr class="nocodegen"><td>405<td>  begin
<tr class="nocodegen"><td>406<td>    // ! ATTENTION !
<tr class="nocodegen"><td>407<td>    // Initalizes a non-repeatable Seed based on Timers, which is not secure
<tr class="nocodegen"><td>408<td>    // and inpredictable. The user should call RandomSeed(Data, SizeOf(Data))
<tr class="nocodegen"><td>409<td>    // instead, where Date contains i.e. user generated (Human) input.
<tr class="covered"><td>410<td>    t := RandomSystemTime;
<tr class="covered"><td>411<td>    for i := Low(FRegister) to High(FRegister) do
<tr class="nocodegen"><td>412<td>    begin
<tr class="covered"><td>413<td>      FRegister[i] := FRegister[i] xor Byte(t);
<tr class="covered"><td>414<td>      t := t shl 1 or t shr 31;
<tr class="covered"><td>415<td>    end;
<tr class="nocodegen"><td>416<td>  end;
<tr class="covered"><td>417<td>  for i := Low(FRegister) to High(FRegister) do
<tr class="covered"><td>418<td>    DoGenerateRandomByte;
<tr class="covered"><td>419<td>  FCounter := 0;
<tr class="covered"><td>420<td>end;
<tr class="nocodegen"><td>421<td>
<tr class="nocodegen"><td>422<td>procedure DoInit;
<tr class="covered"><td>423<td>begin
<tr class="covered"><td>424<td>  DoRandomBuffer := DoBuffer;
<tr class="covered"><td>425<td>  DoRandomSeed := DoSeed;
<tr class="covered"><td>426<td>  DoSeed('', 0);
<tr class="covered"><td>427<td>end;
<tr class="nocodegen"><td>428<td>
<tr class="nocodegen"><td>429<td>procedure DoDone;
<tr class="covered"><td>430<td>begin
<tr class="covered"><td>431<td>  try
<tr class="covered"><td>432<td>    if FHash &lt;&gt; nil then
<tr class="covered"><td>433<td>      FHash.Free;
<tr class="nocodegen"><td>434<td>  except
<tr class="notcovered"><td>435<td>  end;
<tr class="covered"><td>436<td>  FHash := nil;
<tr class="nocodegen"><td>437<td>
<tr class="covered"><td>438<td>  FreeAndNil(FHash);
<tr class="covered"><td>439<td>  FillChar(FRegister, SizeOf(FRegister), 0);
<tr class="covered"><td>440<td>  FCounter := 0;
<tr class="covered"><td>441<td>end;
<tr class="nocodegen"><td>442<td>
<tr class="nocodegen"><td>443<td>{$IFDEF RESTORE_RANGECHECKS}{$R+}{$ENDIF}
<tr class="nocodegen"><td>444<td>{$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}
<tr class="nocodegen"><td>445<td>
<tr class="covered"><td>446<td>initialization
<tr class="nocodegen"><td>447<td>  {$DEFINE AUTO_PRNG}
<tr class="nocodegen"><td>448<td>
<tr class="covered"><td>449<td>  DoInit;
<tr class="nocodegen"><td>450<td>
<tr class="nocodegen"><td>451<td>  {$IFDEF AUTO_PRNG} // see DECOptions.inc
<tr class="covered"><td>452<td>  RandomSeed;
<tr class="nocodegen"><td>453<td>  {$ENDIF AUTO_PRNG}
<tr class="nocodegen"><td>454<td>
<tr class="covered"><td>455<td>finalization
<tr class="covered"><td>456<td>  DoDone;
<tr class="nocodegen"><td>457<td>
<tr class="covered"><td>458<td>end.
</table>
<script>(function () {
var starts = [],prev = document.getElementById("nav-prev"),next = document.getElementById("nav-next");
(function () {
var p;
document.querySelectorAll("table.s tr").forEach(r => {
if (r.classList.contains("notcovered")) {
if (!p) starts.push(r);
p = r;
} else { p = null }
})
})();
function findPrev() {
var y = prev.getBoundingClientRect().top - 4;
for (var i=starts.length-1; i>=0; i--) {
if (starts[i].getBoundingClientRect().top < y) return starts[i]
}
}
function findNext() {
var y = next.getBoundingClientRect().top + 4;
for (var i=0; i<starts.length; i++) {
if (starts[i].getBoundingClientRect().top > y) return starts[i];
}
}
function onScroll() {
prev.setAttribute("class", findPrev() ? "active" : "");
next.setAttribute("class", findNext() ? "active" : "");
onScroll.pending = 0;
}
document.addEventListener("scroll", function() {
if (!onScroll.pending) { onScroll.pending = requestAnimationFrame(onScroll) }
});
onScroll();
function scrollTo(row) {
if (row) window.scrollTo({ behavior: "smooth", top: window.scrollY+row.getBoundingClientRect().top-prev.getBoundingClientRect().top });
}
next.addEventListener("click", () => scrollTo(findNext()) );
prev.addEventListener("click", () => scrollTo(findPrev()) );
})();</script>
<script>
const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
const comparer = (idx, asc) => (a, b) => ((v1, v2) =>!isNaN(parseFloat(v1 || "-")) && !isNaN(parseFloat(v2 || "-")) ? parseFloat(v1)-parseFloat(v2) : v1.toString().localeCompare(v2))(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));
document.querySelectorAll("thead th[idx]").forEach(th => th.addEventListener("click", (() => {
	const table = th.closest("table").querySelector("tbody");
	Array.from(table.querySelectorAll("tr"))
		.sort(comparer(+th.getAttribute("idx"), this.asc = !this.asc))
		.forEach(tr => table.appendChild(tr) );
	})));
</script>
</body>
</html>
