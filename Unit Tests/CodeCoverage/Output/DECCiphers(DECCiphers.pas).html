<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
body {max-width: max-content;margin: auto;}
table {border-spacing:0;}
table, td, th {border: 0;}
td, th {background: white; margin: 0; padding: .5em 1em}
table small { color: #777; }
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: consolas,courier,monospace; font-size: 10pt;}
thead, th {background: #808C98; color: white; }
table th small { color: #ddd; }
th[idx] {cursor: pointer; user-select: none;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: calc(min(80em, 95vw));}
table.s tr td {padding: .1em .5em; white-space: pre-wrap;}
table.s tr td:first-child {text-align: right; font-weight: bold; vertical-align: top}
table.s tr.notcovered td {background: #ddf;}
table.s tr.nocodegen td {background: #ffe;}
table.s tr.covered td {background: #cfc;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum td { background-position: 50%; background-repeat: no-repeat; background-size: 90% 70%; }
table.sum tr:nth-child(odd) td { background-color: #f4f4f4}
table.sum tr:hover td, tr:hover td a { filter: invert(10%) }
table.sum tr th {text-align:left; border: .5px solid #5d4e4c; height: 1em}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
table.sum thead th { position: sticky; top:0; }
table.sum thead tr + tr th { position: sticky; top: calc(2.5em - 2px); }
table.sum tfoot th { position: sticky; bottom:0; }
table.sum tfoot th+th {text-align: right;}
table.sum a, table.sum a:visited {color: #5d4e4c; text-decoration: none;}
#nav {position: fixed;overflow: visible;left: min(calc(50% + 41em), calc(100% - 6em));padding: .1em .5em .1em .2em;background: white;box-shadow: 1px 1px 3px #888;}
#nav div {opacity: .3; user-select: none; pointer-events: none;}
#nav div.active {opacity: 1;	cursor: pointer;	pointer-events: initial;}
#nav div.active:hover {color: #00A;}
</style>
</head>
<body>
<p>Coverage report for <bold>DECCiphers (..\..\Source\DECCiphers.pas)</bold>.</p>
<p>Generated at 30.11.2022 22:06:19 by <a href="https://github.com/DelphiCodeCoverage/DelphiCodeCoverage" target="_blank" title="DelphiCodeCoverage on GitHub">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p>Statistics for ..\..\Source\DECCiphers.pas</p>
<table class="o"><tr><td>Number of lines covered<td>3147<td rowspan=3 style="background: conic-gradient(#9fe098 96%, #eee 96%);width: 4.5em; border-radius: 50%"><tr><td>Number of lines with code gen<td>3257<tr><td>Line coverage<td>96<small>.6</small>&nbsp;%</table>
<br><br>
<div id="nav"><div id="nav-prev">&#x25b2; Prev</div><div id="nav-next">&#x25bc; Next</div></div>
<table class="s">
<tr class="nocodegen"><td>1<td>{*****************************************************************************
<tr class="nocodegen"><td>2<td>  The DEC team (see file NOTICE.txt) licenses this file
<tr class="nocodegen"><td>3<td>  to you under the Apache License, Version 2.0 (the
<tr class="nocodegen"><td>4<td>  &quot;License&quot;); you may not use this file except in compliance
<tr class="nocodegen"><td>5<td>  with the License. A copy of this licence is found in the root directory
<tr class="nocodegen"><td>6<td>  of this project in the file LICENCE.txt or alternatively at
<tr class="nocodegen"><td>7<td>
<tr class="nocodegen"><td>8<td>    http://www.apache.org/licenses/LICENSE-2.0
<tr class="nocodegen"><td>9<td>
<tr class="nocodegen"><td>10<td>  Unless required by applicable law or agreed to in writing,
<tr class="nocodegen"><td>11<td>  software distributed under the License is distributed on an
<tr class="nocodegen"><td>12<td>  &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<tr class="nocodegen"><td>13<td>  KIND, either express or implied.  See the License for the
<tr class="nocodegen"><td>14<td>  specific language governing permissions and limitations
<tr class="nocodegen"><td>15<td>  under the License.
<tr class="nocodegen"><td>16<td>*****************************************************************************}
<tr class="nocodegen"><td>17<td>unit DECCiphers;
<tr class="nocodegen"><td>18<td>
<tr class="nocodegen"><td>19<td>interface
<tr class="nocodegen"><td>20<td>
<tr class="nocodegen"><td>21<td>{$INCLUDE DECOptions.inc}
<tr class="nocodegen"><td>22<td>
<tr class="nocodegen"><td>23<td>uses
<tr class="nocodegen"><td>24<td>  DECCipherBase, DECCipherFormats, DECUtil, DECTypes;
<tr class="nocodegen"><td>25<td>
<tr class="nocodegen"><td>26<td>type
<tr class="nocodegen"><td>27<td>  // Cipher Classes
<tr class="nocodegen"><td>28<td>
<tr class="nocodegen"><td>29<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>30<td>  ///   Null cipher, doesn't encrypt, only copy
<tr class="nocodegen"><td>31<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>32<td>  TCipher_Null          = class;
<tr class="nocodegen"><td>33<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>34<td>  ///   A block based encryption algorithm with 32 to 448 bit key length
<tr class="nocodegen"><td>35<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>36<td>  TCipher_Blowfish      = class;
<tr class="nocodegen"><td>37<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>38<td>  ///   AES Round 2 Final Candidate
<tr class="nocodegen"><td>39<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>40<td>  TCipher_Twofish       = class;
<tr class="nocodegen"><td>41<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>42<td>  ///   International Data Encryption Algorithm, formerly patentet,
<tr class="nocodegen"><td>43<td>  ///   now patent free. The algorithm is no longer to be really recommended due
<tr class="nocodegen"><td>44<td>  ///   to some classes of weak keys and other successfull attacks.
<tr class="nocodegen"><td>45<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>46<td>  TCipher_IDEA          = class;
<tr class="nocodegen"><td>47<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>48<td>  ///   Carlisle Adams and Stafford Tavares, 256 bit key length
<tr class="nocodegen"><td>49<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>50<td>  TCipher_Cast256       = class;
<tr class="nocodegen"><td>51<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>52<td>  ///   AES Round 2 Final Candidate
<tr class="nocodegen"><td>53<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>54<td>  TCipher_Mars          = class;
<tr class="nocodegen"><td>55<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>56<td>  ///   Streamcipher in as Block Cipher
<tr class="nocodegen"><td>57<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>58<td>  TCipher_RC4           = class;
<tr class="nocodegen"><td>59<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>60<td>  ///   AES Round 2 Final Candidate
<tr class="nocodegen"><td>61<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>62<td>  TCipher_RC6           = class;
<tr class="nocodegen"><td>63<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>64<td>  ///   AES Round 2 Final Candidate
<tr class="nocodegen"><td>65<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>66<td>  TCipher_Rijndael      = class;
<tr class="nocodegen"><td>67<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>68<td>  ///   AES winner = TCipher_Rijndael
<tr class="nocodegen"><td>69<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>70<td>  TCipher_AES           = class;
<tr class="nocodegen"><td>71<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>72<td>  ///   A block cipher invented by Joan Daemen and Vincent Rijmen. The design,
<tr class="nocodegen"><td>73<td>  ///   published in 1997, is a forerunner to Rijndael, which has been adopted
<tr class="nocodegen"><td>74<td>  ///   as the Advanced Encryption Standard. Square was introduced together with
<tr class="nocodegen"><td>75<td>  ///   a new form of cryptanalysis discovered by Lars Knudsen, called the
<tr class="nocodegen"><td>76<td>  ///   &quot;Square attack&quot;.
<tr class="nocodegen"><td>77<td>  ///   The structure of Square is a substitution-permutation network with eight
<tr class="nocodegen"><td>78<td>  ///   rounds, operating on 128-bit blocks and using a 128-bit key.
<tr class="nocodegen"><td>79<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>80<td>  /// &lt;remarks&gt;
<tr class="nocodegen"><td>81<td>  ///   If possible use TCipher_AES instead
<tr class="nocodegen"><td>82<td>  /// &lt;/remarks&gt;
<tr class="nocodegen"><td>83<td>  TCipher_Square        = class;
<tr class="nocodegen"><td>84<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>85<td>  ///   Stream Cipher in Blockmode (on UInt32), very fast
<tr class="nocodegen"><td>86<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>87<td>  TCipher_SCOP          = class;
<tr class="nocodegen"><td>88<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>89<td>  ///   Stream Cipher in Blockmode (on UInt32), very fast.
<tr class="nocodegen"><td>90<td>  ///   Wrong old version from DEC 5.2. Use only for backwards compatibility!
<tr class="nocodegen"><td>91<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>92<td>  TCipher_SCOP_DEC52    = class;
<tr class="nocodegen"><td>93<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>94<td>  ///   Stream Cipher, eq. design from German ENIGMA Machine
<tr class="nocodegen"><td>95<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>96<td>  TCipher_Sapphire      = class;
<tr class="nocodegen"><td>97<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>98<td>  ///   Single DES  8 byte Blocksize,  8 byte Keysize,  56 bits relevant.
<tr class="nocodegen"><td>99<td>  ///   Considered to be too weak nowadays. Included for compatibility reasons.
<tr class="nocodegen"><td>100<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>101<td>  TCipher_1DES          = class;
<tr class="nocodegen"><td>102<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>103<td>  ///   Double DES  8 byte Blocksize, 16 byte Keysize, 112 bits relevant
<tr class="nocodegen"><td>104<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>105<td>  TCipher_2DES          = class;
<tr class="nocodegen"><td>106<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>107<td>  ///   Triple DES  8 byte Blocksize, 24 byte Keysize, 168 bits relevant
<tr class="nocodegen"><td>108<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>109<td>  TCipher_3DES          = class;
<tr class="nocodegen"><td>110<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>111<td>  ///   Triple DES 16 byte Blocksize, 16 byte Keysize, 112 bits relevant
<tr class="nocodegen"><td>112<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>113<td>  TCipher_2DDES         = class;
<tr class="nocodegen"><td>114<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>115<td>  ///   Triple DES 16 byte Blocksize, 24 byte Keysize, 168 bits relevant
<tr class="nocodegen"><td>116<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>117<td>  TCipher_3DDES         = class;
<tr class="nocodegen"><td>118<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>119<td>  ///   Triple DES 24 byte Blocksize, 24 byte Keysize, 168 bits relevant
<tr class="nocodegen"><td>120<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>121<td>  TCipher_3TDES         = class;
<tr class="nocodegen"><td>122<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>123<td>  ///   A 1994 developed block cipher using a 96 bit key. 3-Way, is vulnerable
<tr class="nocodegen"><td>124<td>  ///   to related key cryptanalysis.
<tr class="nocodegen"><td>125<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>126<td>  TCipher_3Way          = class;
<tr class="nocodegen"><td>127<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>128<td>  ///   Carlisle Adams and Stafford Tavares, 128 bit key length
<tr class="nocodegen"><td>129<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>130<td>  TCipher_Cast128       = class;
<tr class="nocodegen"><td>131<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>132<td>  ///   Russian Cipher
<tr class="nocodegen"><td>133<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>134<td>  TCipher_Gost          = class;
<tr class="nocodegen"><td>135<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>136<td>  ///   Alias/new name for Gost cipher
<tr class="nocodegen"><td>137<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>138<td>  TCipher_Magma         = class;
<tr class="nocodegen"><td>139<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>140<td>  ///   Misty1 is a block cipher developed 1995 by Mitsubishi. It is free only for
<tr class="nocodegen"><td>141<td>  ///   academical and non-profit works in RFC 2994. it is otherwise patented.
<tr class="nocodegen"><td>142<td>  ///   In 2015 it got broken via integral cryptoanalysis.
<tr class="nocodegen"><td>143<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>144<td>  TCipher_Misty         = class;
<tr class="nocodegen"><td>145<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>146<td>  ///   A 1996 block cipher with a key length of 120 bit. It can be broken with
<tr class="nocodegen"><td>147<td>  ///   a relatively low number of ciphertext/plaintext queries.
<tr class="nocodegen"><td>148<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>149<td>  TCipher_NewDES        = class;
<tr class="nocodegen"><td>150<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>151<td>  ///   Camelia, a 128 bit block cipher.
<tr class="nocodegen"><td>152<td>  ///   Specification: https://info.isl.ntt.co.jp/crypt/eng/camellia/dl/01espec.pdf
<tr class="nocodegen"><td>153<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>154<td>  TCipher_Q128          = class;
<tr class="nocodegen"><td>155<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>156<td>  ///   Rivest Cipher 2, a 1987 developed cipher with a default keysize of 64 bit
<tr class="nocodegen"><td>157<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>158<td>  TCipher_RC2           = class;
<tr class="nocodegen"><td>159<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>160<td>  ///   Rivest Cipher 5, a 1994 developed cipher with emphasis on speed and low
<tr class="nocodegen"><td>161<td>  ///   size in order to make it efficient on embedded hardware as well. Key sizes
<tr class="nocodegen"><td>162<td>  ///   of up to 2048 bits are possible but 128 bits are suggested. The algorithm
<tr class="nocodegen"><td>163<td>  ///   was patented in the US up to 2015.
<tr class="nocodegen"><td>164<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>165<td>  TCipher_RC5           = class;
<tr class="nocodegen"><td>166<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>167<td>  ///   SAFER = Secure And Fast Encryption Routine
<tr class="nocodegen"><td>168<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>169<td>  TCipher_SAFER         = class;
<tr class="nocodegen"><td>170<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>171<td>  ///   A 1996 published block cipher with a key size of 128 bits. It was
<tr class="nocodegen"><td>172<td>  ///   identified as one of the predecessors of Rijndael
<tr class="nocodegen"><td>173<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>174<td>  TCipher_Shark         = class;
<tr class="nocodegen"><td>175<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>176<td>  ///   A 1996 published block cipher with a key size of 128 bits. It was
<tr class="nocodegen"><td>177<td>  ///   identified as one of the predecessors of Rijndael
<tr class="nocodegen"><td>178<td>  ///   Wrong old version from DEC 5.2. Use only for backwards compatibility!
<tr class="nocodegen"><td>179<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>180<td>  TCipher_Shark_DEC52   = class;
<tr class="nocodegen"><td>181<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>182<td>  ///   A NSA developed and 1998 published block cipher with a key length of
<tr class="nocodegen"><td>183<td>  ///   80 bit. Soon after publication various weaknesses have been identified.
<tr class="nocodegen"><td>184<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>185<td>  TCipher_Skipjack      = class;
<tr class="nocodegen"><td>186<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>187<td>  ///   Tiny Encryption Algorithm
<tr class="nocodegen"><td>188<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>189<td>  TCipher_TEA           = class;
<tr class="nocodegen"><td>190<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>191<td>  ///   Tiny Encryption Algorithm, 1st extended Version
<tr class="nocodegen"><td>192<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>193<td>  TCipher_XTEA          = class;
<tr class="nocodegen"><td>194<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>195<td>  ///   = TCipher_XTEA (kept for backward compatibility)
<tr class="nocodegen"><td>196<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>197<td>  TCipher_TEAN          = class;
<tr class="nocodegen"><td>198<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>199<td>  ///   Tiny Encryption Algorithm, 1st extended Version.
<tr class="nocodegen"><td>200<td>  ///   Wrong old version from DEC 5.2. Use only for backwards compatibility!
<tr class="nocodegen"><td>201<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>202<td>  TCipher_XTEA_DEC52    = class;
<tr class="nocodegen"><td>203<td>
<tr class="nocodegen"><td>204<td>  // Definitions needed for Skipjack algorithm
<tr class="nocodegen"><td>205<td>  PSkipjackTab = ^TSkipjackTab;
<tr class="nocodegen"><td>206<td>  TSkipjackTab = array[0..255] of Byte;
<tr class="nocodegen"><td>207<td>
<tr class="nocodegen"><td>208<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>209<td>  ///   A do nothing cipher, usefull for debugging and development purposes. Do
<tr class="nocodegen"><td>210<td>  ///   not use it for actual encryption as it will not encrypt anything at all!
<tr class="nocodegen"><td>211<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>212<td>  TCipher_Null = class(TDECFormattedCipher)
<tr class="nocodegen"><td>213<td>  protected
<tr class="nocodegen"><td>214<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>215<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>216<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>217<td>  public
<tr class="nocodegen"><td>218<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>219<td>    ///   Provides meta data about the cipher algorithm used like key size.
<tr class="nocodegen"><td>220<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>221<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>222<td>  end;
<tr class="nocodegen"><td>223<td>
<tr class="nocodegen"><td>224<td>  TCipher_Blowfish = class(TDECFormattedCipher)
<tr class="nocodegen"><td>225<td>  protected
<tr class="nocodegen"><td>226<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>227<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>228<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>229<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>230<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>231<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>232<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>233<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>234<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>235<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>236<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>237<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>238<td>  public
<tr class="nocodegen"><td>239<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>240<td>  end;
<tr class="nocodegen"><td>241<td>
<tr class="nocodegen"><td>242<td>  TCipher_Twofish = class(TDECFormattedCipher)
<tr class="nocodegen"><td>243<td>  protected
<tr class="nocodegen"><td>244<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>245<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>246<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>247<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>248<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>249<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>250<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>251<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>252<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>253<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>254<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>255<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>256<td>  public
<tr class="nocodegen"><td>257<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>258<td>  end;
<tr class="nocodegen"><td>259<td>
<tr class="nocodegen"><td>260<td>  TCipher_IDEA = class(TDECFormattedCipher)
<tr class="nocodegen"><td>261<td>  protected
<tr class="nocodegen"><td>262<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>263<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>264<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>265<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>266<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>267<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>268<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>269<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>270<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>271<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>272<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>273<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>274<td>  public
<tr class="nocodegen"><td>275<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>276<td>  end;
<tr class="nocodegen"><td>277<td>
<tr class="nocodegen"><td>278<td>  TCipher_Cast256 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>279<td>  protected
<tr class="nocodegen"><td>280<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>281<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>282<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>283<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>284<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>285<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>286<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>287<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>288<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>289<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>290<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>291<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>292<td>  public
<tr class="nocodegen"><td>293<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>294<td>  end;
<tr class="nocodegen"><td>295<td>
<tr class="nocodegen"><td>296<td>  TCipher_Mars = class(TDECFormattedCipher)
<tr class="nocodegen"><td>297<td>  protected
<tr class="nocodegen"><td>298<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>299<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>300<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>301<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>302<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>303<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>304<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>305<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>306<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>307<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>308<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>309<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>310<td>  public
<tr class="nocodegen"><td>311<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>312<td>  end;
<tr class="nocodegen"><td>313<td>
<tr class="nocodegen"><td>314<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>315<td>  ///   This is a well known stream cipher. In February 2015 its use in context
<tr class="nocodegen"><td>316<td>  ///   of TLS has been forbidden due to severe security issues.
<tr class="nocodegen"><td>317<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>318<td>  TCipher_RC4 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>319<td>  protected
<tr class="nocodegen"><td>320<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>321<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>322<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>323<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>324<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>325<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>326<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>327<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>328<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>329<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>330<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>331<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>332<td>  public
<tr class="nocodegen"><td>333<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>334<td>  end;
<tr class="nocodegen"><td>335<td>
<tr class="nocodegen"><td>336<td>  TCipher_RC6 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>337<td>  private
<tr class="nocodegen"><td>338<td>    FRounds: Integer;
<tr class="nocodegen"><td>339<td>    procedure SetRounds(Value: Integer);
<tr class="nocodegen"><td>340<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>341<td>    ///   Limits the number of rounds used to a minimum or maximum value,
<tr class="nocodegen"><td>342<td>    ///   depending on the current value. If FRounds is 0 it will be set to 20.
<tr class="nocodegen"><td>343<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>344<td>    procedure LimitRounds; inline;
<tr class="nocodegen"><td>345<td>  protected
<tr class="nocodegen"><td>346<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>347<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>348<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>349<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>350<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>351<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>352<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>353<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>354<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>355<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>356<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>357<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>358<td>  public
<tr class="nocodegen"><td>359<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>360<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>361<td>    ///   Sets the number of rounds/times the algorithm is being applied to the
<tr class="nocodegen"><td>362<td>    ///   data. Range should be 16-24 and default is 20 rounds.
<tr class="nocodegen"><td>363<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>364<td>    property Rounds: Integer read FRounds write SetRounds;
<tr class="nocodegen"><td>365<td>  end;
<tr class="nocodegen"><td>366<td>
<tr class="nocodegen"><td>367<td>  TCipher_Rijndael = class(TDECFormattedCipher)
<tr class="nocodegen"><td>368<td>  private
<tr class="nocodegen"><td>369<td>    FRounds: Integer;
<tr class="nocodegen"><td>370<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>371<td>    ///   Calculates the key used for encoding. Implemented is the &quot;new AES
<tr class="nocodegen"><td>372<td>    ///   conform key scheduling&quot;.
<tr class="nocodegen"><td>373<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>374<td>    /// &lt;param name=&quot;KeySize&quot;&gt;
<tr class="nocodegen"><td>375<td>    ///   Length of the key in byte, but here the AES variant is relevant rather
<tr class="nocodegen"><td>376<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>377<td>    procedure BuildEncodeKey(KeySize:Integer); inline;
<tr class="nocodegen"><td>378<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>379<td>    ///   Calculates the key used for decoding. Implemented is the &quot;new AES
<tr class="nocodegen"><td>380<td>    ///   conform key scheduling&quot;.
<tr class="nocodegen"><td>381<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>382<td>    procedure BuildDecodeKey; inline;
<tr class="nocodegen"><td>383<td>  protected
<tr class="nocodegen"><td>384<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>385<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>386<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>387<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>388<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>389<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>390<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>391<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>392<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>393<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>394<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>395<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>396<td>  public
<tr class="nocodegen"><td>397<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>398<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>399<td>    ///   Gets the number of rounds/times the algorithm is being applied to the
<tr class="nocodegen"><td>400<td>    ///   data. The number of rounds depends on the key size.
<tr class="nocodegen"><td>401<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>402<td>    property Rounds: Integer read FRounds;
<tr class="nocodegen"><td>403<td>  end;
<tr class="nocodegen"><td>404<td>
<tr class="nocodegen"><td>405<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>406<td>  ///   Generic implementation. The bit length one gets depends on the length
<tr class="nocodegen"><td>407<td>  ///   of the key defined via Init.
<tr class="nocodegen"><td>408<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>409<td>  TCipher_AES = class(TCipher_Rijndael);
<tr class="nocodegen"><td>410<td>
<tr class="nocodegen"><td>411<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>412<td>  ///   128 Bit variant of the algorithm. Specifying a longer key leads to a
<tr class="nocodegen"><td>413<td>  ///   EDECCipherException exception
<tr class="nocodegen"><td>414<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>415<td>  /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>416<td>  ///   Exception raised if called with a key length longer than 128 bit.
<tr class="nocodegen"><td>417<td>  /// &lt;/exception&gt;
<tr class="nocodegen"><td>418<td>  TCipher_AES128 = class(TCipher_AES)
<tr class="nocodegen"><td>419<td>  protected
<tr class="nocodegen"><td>420<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>421<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>422<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>423<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>424<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>425<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>426<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>427<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>428<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>429<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>430<td>  public
<tr class="nocodegen"><td>431<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>432<td>  end;
<tr class="nocodegen"><td>433<td>
<tr class="nocodegen"><td>434<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>435<td>  ///   192 Bit variant of the algorithm. Specifying a longer key leads to a
<tr class="nocodegen"><td>436<td>  ///   EDECCipherException exception
<tr class="nocodegen"><td>437<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>438<td>  /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>439<td>  ///   Exception raised if called with a key length longer than 192 bit.
<tr class="nocodegen"><td>440<td>  /// &lt;/exception&gt;
<tr class="nocodegen"><td>441<td>  TCipher_AES192 = class(TCipher_AES)
<tr class="nocodegen"><td>442<td>  protected
<tr class="nocodegen"><td>443<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>444<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>445<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>446<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>447<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>448<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>449<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>450<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>451<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>452<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>453<td>  public
<tr class="nocodegen"><td>454<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>455<td>  end;
<tr class="nocodegen"><td>456<td>
<tr class="nocodegen"><td>457<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>458<td>  ///   256 Bit variant of the algorithm. Specifying a longer key leads to a
<tr class="nocodegen"><td>459<td>  ///   EDECCipherException exception
<tr class="nocodegen"><td>460<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>461<td>  /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>462<td>  ///   Exception raised if called with a key length longer than 256 bit.
<tr class="nocodegen"><td>463<td>  /// &lt;/exception&gt;
<tr class="nocodegen"><td>464<td>  TCipher_AES256 = class(TCipher_AES)
<tr class="nocodegen"><td>465<td>  protected
<tr class="nocodegen"><td>466<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>467<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>468<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>469<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>470<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>471<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>472<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>473<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>474<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>475<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>476<td>  public
<tr class="nocodegen"><td>477<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>478<td>  end;
<tr class="nocodegen"><td>479<td>
<tr class="nocodegen"><td>480<td>  TCipher_Square = class(TDECFormattedCipher)
<tr class="nocodegen"><td>481<td>  protected
<tr class="nocodegen"><td>482<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>483<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>484<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>485<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>486<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>487<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>488<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>489<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>490<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>491<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>492<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>493<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>494<td>  public
<tr class="nocodegen"><td>495<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>496<td>  end;
<tr class="nocodegen"><td>497<td>
<tr class="nocodegen"><td>498<td>  TCipher_SCOP = class(TDECFormattedCipher)
<tr class="nocodegen"><td>499<td>  protected
<tr class="nocodegen"><td>500<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>501<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>502<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>503<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>504<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>505<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>506<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>507<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>508<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>509<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>510<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>511<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>512<td>  public
<tr class="nocodegen"><td>513<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>514<td>  end;
<tr class="nocodegen"><td>515<td>
<tr class="nocodegen"><td>516<td>  /// &lt;remarks&gt;
<tr class="nocodegen"><td>517<td>  ///   Do only use if backwards compatibility with old code is necessary as
<tr class="nocodegen"><td>518<td>  ///   this implementation is faulty!
<tr class="nocodegen"><td>519<td>  /// &lt;/remarks&gt;
<tr class="nocodegen"><td>520<td>  TCipher_SCOP_DEC52 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>521<td>  protected
<tr class="nocodegen"><td>522<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>523<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>524<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>525<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>526<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>527<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>528<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>529<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>530<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>531<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>532<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>533<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>534<td>  public
<tr class="nocodegen"><td>535<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>536<td>  end;
<tr class="nocodegen"><td>537<td>
<tr class="nocodegen"><td>538<td>  TCipher_Sapphire = class(TDECFormattedCipher)
<tr class="nocodegen"><td>539<td>  protected
<tr class="nocodegen"><td>540<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>541<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>542<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>543<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>544<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>545<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>546<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>547<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>548<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>549<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>550<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>551<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>552<td>  public
<tr class="nocodegen"><td>553<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>554<td>  end;
<tr class="nocodegen"><td>555<td>
<tr class="nocodegen"><td>556<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>557<td>  ///   Base class for all DES based ciphers to fix issues with calling
<tr class="nocodegen"><td>558<td>  ///   inherited in DoInit, as all other DES based classes did inherit from
<tr class="nocodegen"><td>559<td>  ///   TCipher_1DES and inherited called the DoInit of that as well...
<tr class="nocodegen"><td>560<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>561<td>  TCipher_DESBase = class(TDECFormattedCipher)
<tr class="nocodegen"><td>562<td>  strict protected
<tr class="nocodegen"><td>563<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>564<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>565<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>566<td>    /// &lt;param name=&quot;Data&quot;&gt;
<tr class="nocodegen"><td>567<td>    ///   Key for the current block to be encrypted/decrypted?
<tr class="nocodegen"><td>568<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>569<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>570<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>571<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>572<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>573<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>574<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>575<td>    /// &lt;param name=&quot;Reverse&quot;&gt;
<tr class="nocodegen"><td>576<td>    ///   Defines whether some internal calculation needs to be based from the
<tr class="nocodegen"><td>577<td>    ///   start index or the highest index  (= reverse)
<tr class="nocodegen"><td>578<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>579<td>    procedure DoInitKey(const Data: array of Byte; Key: PUInt32Array; Reverse: Boolean);
<tr class="nocodegen"><td>580<td>  end;
<tr class="nocodegen"><td>581<td>
<tr class="nocodegen"><td>582<td>  TCipher_1DES = class(TCipher_DESBase)
<tr class="nocodegen"><td>583<td>  protected
<tr class="nocodegen"><td>584<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>585<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>586<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>587<td>  public
<tr class="nocodegen"><td>588<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>589<td>  end;
<tr class="nocodegen"><td>590<td>
<tr class="nocodegen"><td>591<td>  TCipher_2DES = class(TCipher_DESBase)
<tr class="nocodegen"><td>592<td>  protected
<tr class="nocodegen"><td>593<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>594<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>595<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>596<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>597<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>598<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>599<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>600<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>601<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>602<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>603<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>604<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>605<td>  public
<tr class="nocodegen"><td>606<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>607<td>  end;
<tr class="nocodegen"><td>608<td>
<tr class="nocodegen"><td>609<td>  TCipher_3DES = class(TCipher_DESBase)
<tr class="nocodegen"><td>610<td>  protected
<tr class="nocodegen"><td>611<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>612<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>613<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>614<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>615<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>616<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>617<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>618<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>619<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>620<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>621<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>622<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>623<td>  public
<tr class="nocodegen"><td>624<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>625<td>  end;
<tr class="nocodegen"><td>626<td>
<tr class="nocodegen"><td>627<td>  TCipher_2DDES = class(TCipher_2DES)
<tr class="nocodegen"><td>628<td>  protected
<tr class="nocodegen"><td>629<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>630<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>631<td>  public
<tr class="nocodegen"><td>632<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>633<td>  end;
<tr class="nocodegen"><td>634<td>
<tr class="nocodegen"><td>635<td>  TCipher_3DDES = class(TCipher_3DES)
<tr class="nocodegen"><td>636<td>  protected
<tr class="nocodegen"><td>637<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>638<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>639<td>  public
<tr class="nocodegen"><td>640<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>641<td>  end;
<tr class="nocodegen"><td>642<td>
<tr class="nocodegen"><td>643<td>  TCipher_3TDES = class(TCipher_3DES)
<tr class="nocodegen"><td>644<td>  protected
<tr class="nocodegen"><td>645<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>646<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>647<td>  public
<tr class="nocodegen"><td>648<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>649<td>  end;
<tr class="nocodegen"><td>650<td>
<tr class="nocodegen"><td>651<td>  TCipher_3Way = class(TDECFormattedCipher)
<tr class="nocodegen"><td>652<td>  protected
<tr class="nocodegen"><td>653<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>654<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>655<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>656<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>657<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>658<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>659<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>660<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>661<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>662<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>663<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>664<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>665<td>  public
<tr class="nocodegen"><td>666<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>667<td>  end;
<tr class="nocodegen"><td>668<td>
<tr class="nocodegen"><td>669<td>  TCipher_Cast128 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>670<td>  private
<tr class="nocodegen"><td>671<td>    FRounds: Integer;
<tr class="nocodegen"><td>672<td>  protected
<tr class="nocodegen"><td>673<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>674<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>675<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>676<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>677<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>678<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>679<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>680<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>681<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>682<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>683<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>684<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>685<td>  public
<tr class="nocodegen"><td>686<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>687<td>  end;
<tr class="nocodegen"><td>688<td>
<tr class="nocodegen"><td>689<td>  TCipher_Gost = class(TDECFormattedCipher)
<tr class="nocodegen"><td>690<td>  protected
<tr class="nocodegen"><td>691<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>692<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>693<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>694<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>695<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>696<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>697<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>698<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>699<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>700<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>701<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>702<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>703<td>  public
<tr class="nocodegen"><td>704<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>705<td>  end;
<tr class="nocodegen"><td>706<td>
<tr class="nocodegen"><td>707<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>708<td>  ///   Alias for Gost
<tr class="nocodegen"><td>709<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>710<td>  TCipher_Magma = class(TCipher_Gost);
<tr class="nocodegen"><td>711<td>
<tr class="nocodegen"><td>712<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>713<td>  ///   Do no longer use this algorithm if possible, as it got broken in 2015
<tr class="nocodegen"><td>714<td>  ///   by crypto analysis.
<tr class="nocodegen"><td>715<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>716<td>  TCipher_Misty = class(TDECFormattedCipher)
<tr class="nocodegen"><td>717<td>  protected
<tr class="nocodegen"><td>718<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>719<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>720<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>721<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>722<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>723<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>724<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>725<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>726<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>727<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>728<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>729<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>730<td>  public
<tr class="nocodegen"><td>731<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>732<td>  end;
<tr class="nocodegen"><td>733<td>
<tr class="nocodegen"><td>734<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>735<td>  ///   While this algorithm resembles the Data Encryption Standard (DES),
<tr class="nocodegen"><td>736<td>  ///   it is easier to implement in software and is supposed to be more secure.
<tr class="nocodegen"><td>737<td>  ///   It is not to be confused with another algorithm - known by the same
<tr class="nocodegen"><td>738<td>  ///   name - which is simply DES without the initial and final permutations.
<tr class="nocodegen"><td>739<td>  ///   The NewDES here is a completely different algorithm.
<tr class="nocodegen"><td>740<td>  ///
<tr class="nocodegen"><td>741<td>  ///   Be aware though that recent crypto analysis shows that this algorithm is
<tr class="nocodegen"><td>742<td>  ///   less safe than DES and thus not to be recommended for use!
<tr class="nocodegen"><td>743<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>744<td>  TCipher_NewDES = class(TDECFormattedCipher)
<tr class="nocodegen"><td>745<td>  protected
<tr class="nocodegen"><td>746<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>747<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>748<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>749<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>750<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>751<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>752<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>753<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>754<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>755<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>756<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>757<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>758<td>  public
<tr class="nocodegen"><td>759<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>760<td>  end;
<tr class="nocodegen"><td>761<td>
<tr class="nocodegen"><td>762<td>  TCipher_Q128 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>763<td>  protected
<tr class="nocodegen"><td>764<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>765<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>766<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>767<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>768<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>769<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>770<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>771<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>772<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>773<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>774<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>775<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>776<td>  public
<tr class="nocodegen"><td>777<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>778<td>  end;
<tr class="nocodegen"><td>779<td>
<tr class="nocodegen"><td>780<td>  TCipher_RC2 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>781<td>  protected
<tr class="nocodegen"><td>782<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>783<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>784<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>785<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>786<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>787<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>788<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>789<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>790<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>791<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>792<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>793<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>794<td>  public
<tr class="nocodegen"><td>795<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>796<td>  end;
<tr class="nocodegen"><td>797<td>
<tr class="nocodegen"><td>798<td>  TCipher_RC5 = class(TDECFormattedCipher)
<tr class="nocodegen"><td>799<td>  private
<tr class="nocodegen"><td>800<td>    FRounds: Integer;
<tr class="nocodegen"><td>801<td>    procedure SetRounds(Value: Integer);
<tr class="nocodegen"><td>802<td>  protected
<tr class="nocodegen"><td>803<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>804<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>805<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>806<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>807<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>808<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>809<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>810<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>811<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>812<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>813<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>814<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>815<td>  public
<tr class="nocodegen"><td>816<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>817<td>
<tr class="nocodegen"><td>818<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>819<td>    ///   Sets the number of rounds/times the algorithm is being applied to the
<tr class="nocodegen"><td>820<td>    ///   data. Allowed range is 0-255, if you can choose we recommend a
<tr class="nocodegen"><td>821<td>    ///   value &gt; 16.
<tr class="nocodegen"><td>822<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>823<td>    property Rounds: Integer read FRounds write SetRounds;
<tr class="nocodegen"><td>824<td>  end;
<tr class="nocodegen"><td>825<td>
<tr class="nocodegen"><td>826<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>827<td>  ///  svK40     SAFER K-40    Keysize is 40bit  -&gt;  5 Byte
<tr class="nocodegen"><td>828<td>  ///  svK64     SAFER K-64    Keysize is 64bit  -&gt;  8 Byte
<tr class="nocodegen"><td>829<td>  ///  svK128    SAFER K-128   KeySize is 128bit -&gt; 16 Byte
<tr class="nocodegen"><td>830<td>  ///  svSK40    SAFER SK-40   Stronger Version from K-40 with better Key Scheduling
<tr class="nocodegen"><td>831<td>  ///  svSK64    SAFER SK-64   Stronger Version from K-64 with better Key Scheduling
<tr class="nocodegen"><td>832<td>  ///  svSK128   SAFER SK-128  Stronger Version from K-128 with better Key Scheduling
<tr class="nocodegen"><td>833<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>834<td>  TSAFERVersion = (svSK128, svSK64, svSK40, svK128, svK64, svK40);
<tr class="nocodegen"><td>835<td>
<tr class="nocodegen"><td>836<td>  TCipher_SAFER = class(TDECFormattedCipher)
<tr class="nocodegen"><td>837<td>  private
<tr class="nocodegen"><td>838<td>    FRounds: Integer;
<tr class="nocodegen"><td>839<td>    FVersion: TSAFERVersion;
<tr class="nocodegen"><td>840<td>    procedure SetRounds(Value: Integer);
<tr class="nocodegen"><td>841<td>    procedure SetVersion(Value: TSAFERVersion);
<tr class="nocodegen"><td>842<td>  protected
<tr class="nocodegen"><td>843<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>844<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>845<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>846<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>847<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>848<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>849<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>850<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>851<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>852<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>853<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>854<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>855<td>  public
<tr class="nocodegen"><td>856<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>857<td>
<tr class="nocodegen"><td>858<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>859<td>    ///   Sets the number of rounds/times the algorithm is being applied to the
<tr class="nocodegen"><td>860<td>    ///   data. Range should be 4-13 and default is 5, 6, 10 or 8 rounds
<tr class="nocodegen"><td>861<td>    ///   depending on the version
<tr class="nocodegen"><td>862<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>863<td>    property Rounds: Integer read FRounds write SetRounds;
<tr class="nocodegen"><td>864<td>    property Version: TSAFERVersion read FVersion write SetVersion;
<tr class="nocodegen"><td>865<td>  end;
<tr class="nocodegen"><td>866<td>
<tr class="nocodegen"><td>867<td>  {$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>868<td>  PLong64 = ^TLong64;
<tr class="nocodegen"><td>869<td>  TLong64  = packed record
<tr class="nocodegen"><td>870<td>    L, R: UInt32;
<tr class="nocodegen"><td>871<td>  end;
<tr class="nocodegen"><td>872<td>
<tr class="nocodegen"><td>873<td>  PLong64Array = ^TLong64Array;
<tr class="nocodegen"><td>874<td>  TLong64Array = array[0..1023] of TLong64;
<tr class="nocodegen"><td>875<td>  {$ENDIF}
<tr class="nocodegen"><td>876<td>
<tr class="nocodegen"><td>877<td>  TLogArray = array[0..255] of Byte;
<tr class="nocodegen"><td>878<td>
<tr class="nocodegen"><td>879<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>880<td>  ///   Base class for both Shark implementations
<tr class="nocodegen"><td>881<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>882<td>  TCipher_SharkBase = class(TDECFormattedCipher)
<tr class="nocodegen"><td>883<td>  strict protected
<tr class="nocodegen"><td>884<td>    {$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>885<td>    function Transform(A: TLong64; Log, ALog: TLogArray): TLong64;
<tr class="nocodegen"><td>886<td>    function Shark(D: TLong64; K: PLong64): TLong64;
<tr class="nocodegen"><td>887<td>    {$ELSE}
<tr class="nocodegen"><td>888<td>    function Transform(A: UInt64; Log, ALog: TLogArray): UInt64;
<tr class="nocodegen"><td>889<td>    function SharkEncode(D: UInt64; K: PUInt64): UInt64;
<tr class="nocodegen"><td>890<td>    {$ENDIF}
<tr class="nocodegen"><td>891<td>
<tr class="nocodegen"><td>892<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>893<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>894<td>  public
<tr class="nocodegen"><td>895<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>896<td>  end;
<tr class="nocodegen"><td>897<td>
<tr class="nocodegen"><td>898<td>  TCipher_Shark = class(TCipher_SharkBase)
<tr class="nocodegen"><td>899<td>  protected
<tr class="nocodegen"><td>900<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>901<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>902<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>903<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>904<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>905<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>906<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>907<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>908<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>909<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>910<td>  public
<tr class="nocodegen"><td>911<td>
<tr class="nocodegen"><td>912<td>  end;
<tr class="nocodegen"><td>913<td>
<tr class="nocodegen"><td>914<td>  /// &lt;remarks&gt;
<tr class="nocodegen"><td>915<td>  ///   Do only use if backwards compatibility with old code is necessary as
<tr class="nocodegen"><td>916<td>  ///   this implementation is faulty!
<tr class="nocodegen"><td>917<td>  /// &lt;/remarks&gt;
<tr class="nocodegen"><td>918<td>  TCipher_Shark_DEC52 = class(TCipher_SharkBase)
<tr class="nocodegen"><td>919<td>  protected
<tr class="nocodegen"><td>920<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>921<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>922<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>923<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>924<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>925<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>926<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>927<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>928<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>929<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>930<td>  end;
<tr class="nocodegen"><td>931<td>
<tr class="nocodegen"><td>932<td>  TCipher_Skipjack = class(TDECFormattedCipher)
<tr class="nocodegen"><td>933<td>  strict private
<tr class="nocodegen"><td>934<td>    procedure SkipjackIncCheck(var ATab: PSkipjackTab; AMin: PSkipjackTab; AMax: PByte); inline;
<tr class="nocodegen"><td>935<td>    procedure SkipjackDecCheck(var ATab: PSkipjackTab; AMin: PByte; AMax: PSkipjackTab); inline;
<tr class="nocodegen"><td>936<td>  protected
<tr class="nocodegen"><td>937<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>938<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>939<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>940<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>941<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>942<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>943<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>944<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>945<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>946<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>947<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>948<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>949<td>  public
<tr class="nocodegen"><td>950<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>951<td>  end;
<tr class="nocodegen"><td>952<td>
<tr class="nocodegen"><td>953<td>  TCipher_TEA = class(TDECFormattedCipher)
<tr class="nocodegen"><td>954<td>  private
<tr class="nocodegen"><td>955<td>    FRounds: Integer;
<tr class="nocodegen"><td>956<td>    procedure SetRounds(Value: Integer);
<tr class="nocodegen"><td>957<td>  protected
<tr class="nocodegen"><td>958<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>959<td>    ///   Initialize the key, based on the key passed in
<tr class="nocodegen"><td>960<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>961<td>    /// &lt;param name=&quot;Key&quot;&gt;
<tr class="nocodegen"><td>962<td>    ///   Encryption/Decryption key to be used
<tr class="nocodegen"><td>963<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>964<td>    /// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>965<td>    ///   Size of the key passed in bytes.
<tr class="nocodegen"><td>966<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>967<td>    procedure DoInit(const Key; Size: Integer); override;
<tr class="nocodegen"><td>968<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>969<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>970<td>  public
<tr class="nocodegen"><td>971<td>    class function Context: TCipherContext; override;
<tr class="nocodegen"><td>972<td>
<tr class="nocodegen"><td>973<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>974<td>    ///   16 - 256 Rounds, 16 (default) is sufficient, 64 is the official
<tr class="nocodegen"><td>975<td>    ///   recommendation. If a value outside the range of 16 to 256 is assigned
<tr class="nocodegen"><td>976<td>    ///   it will be limited to that range.
<tr class="nocodegen"><td>977<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>978<td>    property Rounds: Integer read FRounds write SetRounds;
<tr class="nocodegen"><td>979<td>  end;
<tr class="nocodegen"><td>980<td>
<tr class="nocodegen"><td>981<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>982<td>  ///   XTEA is an improved version of the TEA algorithm.
<tr class="nocodegen"><td>983<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>984<td>  /// &lt;remarks&gt;
<tr class="nocodegen"><td>985<td>  ///   In DEC V5.2 at least and in former commits of DEC 6.0 development version
<tr class="nocodegen"><td>986<td>  ///   this algorithm was broken due to differences in brackets and thus returned
<tr class="nocodegen"><td>987<td>  ///   a different result. It is unclear why nobody reported this as bug yet
<tr class="nocodegen"><td>988<td>  ///   but be aware that if you need the old variant for compatibility reasons
<tr class="nocodegen"><td>989<td>  ///   you need a commit from before 3rd December 2020.
<tr class="nocodegen"><td>990<td>  /// &lt;/remarks&gt;
<tr class="nocodegen"><td>991<td>  TCipher_XTEA = class(TCipher_TEA)
<tr class="nocodegen"><td>992<td>  protected
<tr class="nocodegen"><td>993<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>994<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>995<td>  end;
<tr class="nocodegen"><td>996<td>
<tr class="nocodegen"><td>997<td>  TCipher_TEAN = class(TCipher_XTEA);
<tr class="nocodegen"><td>998<td>
<tr class="nocodegen"><td>999<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1000<td>  ///   XTEA is an improved version of the TEA algorithm. This version is the
<tr class="nocodegen"><td>1001<td>  ///   old faulty one from DEC 5.2. Use only if necessary for compatibility
<tr class="nocodegen"><td>1002<td>  ///    reasons!
<tr class="nocodegen"><td>1003<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1004<td>  /// &lt;remarks&gt;
<tr class="nocodegen"><td>1005<td>  ///   In DEC V5.2 at least and in former commits of DEC 6.0 development version
<tr class="nocodegen"><td>1006<td>  ///   this algorithm was broken due to differences in brackets and thus returned
<tr class="nocodegen"><td>1007<td>  ///   a different result. It is unclear why nobody reported this as bug yet
<tr class="nocodegen"><td>1008<td>  ///   but be aware that if you need the old variant for compatibility reasons
<tr class="nocodegen"><td>1009<td>  ///   you need a commit from before 3rd December 2020.
<tr class="nocodegen"><td>1010<td>  /// &lt;/remarks&gt;
<tr class="nocodegen"><td>1011<td>  TCipher_XTEA_DEC52 = class(TCipher_TEA)
<tr class="nocodegen"><td>1012<td>  protected
<tr class="nocodegen"><td>1013<td>    procedure DoEncode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>1014<td>    procedure DoDecode(Source, Dest: Pointer; Size: Integer); override;
<tr class="nocodegen"><td>1015<td>  end;
<tr class="nocodegen"><td>1016<td>
<tr class="nocodegen"><td>1017<td>implementation
<tr class="nocodegen"><td>1018<td>
<tr class="nocodegen"><td>1019<td>{$IFOPT Q+}{$DEFINE RESTORE_OVERFLOWCHECKS}{$Q-}{$ENDIF}
<tr class="nocodegen"><td>1020<td>{$IFOPT R+}{$DEFINE RESTORE_RANGECHECKS}{$R-}{$ENDIF}
<tr class="nocodegen"><td>1021<td>
<tr class="nocodegen"><td>1022<td>uses
<tr class="nocodegen"><td>1023<td>  {$IFDEF FPC}
<tr class="nocodegen"><td>1024<td>  SysUtils,
<tr class="nocodegen"><td>1025<td>  {$ELSE}
<tr class="nocodegen"><td>1026<td>  System.SysUtils,
<tr class="nocodegen"><td>1027<td>  {$ENDIF}
<tr class="nocodegen"><td>1028<td>  DECData, DECDataCipher;
<tr class="nocodegen"><td>1029<td>
<tr class="nocodegen"><td>1030<td>{ TCipher_Null }
<tr class="nocodegen"><td>1031<td>
<tr class="nocodegen"><td>1032<td>class function TCipher_Null.Context: TCipherContext;
<tr class="covered"><td>1033<td>begin
<tr class="covered"><td>1034<td>  Result.KeySize                     := 0;
<tr class="covered"><td>1035<td>  Result.BlockSize                   := 1;
<tr class="covered"><td>1036<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>1037<td>  Result.AdditionalBufferSize        := 0;
<tr class="covered"><td>1038<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>1039<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>1040<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>1041<td>  Result.CipherType                  := [ctNull, ctSymmetric];
<tr class="covered"><td>1042<td>end;
<tr class="nocodegen"><td>1043<td>
<tr class="nocodegen"><td>1044<td>procedure TCipher_Null.DoInit(const Key; Size: Integer);
<tr class="covered"><td>1045<td>begin
<tr class="nocodegen"><td>1046<td>  inherited;
<tr class="covered"><td>1047<td>end;
<tr class="nocodegen"><td>1048<td>
<tr class="nocodegen"><td>1049<td>procedure TCipher_Null.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>1050<td>begin
<tr class="covered"><td>1051<td>  if Source &lt;&gt; Dest then
<tr class="covered"><td>1052<td>    Move(Source^, Dest^, Size);
<tr class="covered"><td>1053<td>end;
<tr class="nocodegen"><td>1054<td>
<tr class="nocodegen"><td>1055<td>procedure TCipher_Null.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>1056<td>begin
<tr class="covered"><td>1057<td>  if Source &lt;&gt; Dest then
<tr class="covered"><td>1058<td>    Move(Source^, Dest^, Size);
<tr class="covered"><td>1059<td>end;
<tr class="nocodegen"><td>1060<td>
<tr class="nocodegen"><td>1061<td>{ TCipher_Blowfish }
<tr class="nocodegen"><td>1062<td>
<tr class="nocodegen"><td>1063<td>class function TCipher_Blowfish.Context: TCipherContext;
<tr class="covered"><td>1064<td>begin
<tr class="covered"><td>1065<td>  Result.KeySize                     := 56;
<tr class="covered"><td>1066<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>1067<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>1068<td>  Result.AdditionalBufferSize        := SizeOf(Blowfish_Data) + SizeOf(Blowfish_Key);
<tr class="covered"><td>1069<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>1070<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>1071<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>1072<td>  Result.CipherType := [ctSymmetric, ctBlock];
<tr class="covered"><td>1073<td>end;
<tr class="nocodegen"><td>1074<td>
<tr class="nocodegen"><td>1075<td>procedure TCipher_Blowfish.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>1076<td>var
<tr class="nocodegen"><td>1077<td>  I, J: Integer;
<tr class="nocodegen"><td>1078<td>  B: array[0..1] of UInt32;
<tr class="nocodegen"><td>1079<td>  K: PByteArray;
<tr class="nocodegen"><td>1080<td>  P: PUInt32Array;
<tr class="nocodegen"><td>1081<td>  S: PBlowfish;
<tr class="covered"><td>1082<td>begin
<tr class="covered"><td>1083<td>  K := @Key;
<tr class="covered"><td>1084<td>  S := FAdditionalBuffer;
<tr class="covered"><td>1085<td>  P := Pointer(PByte(FAdditionalBuffer) + SizeOf(Blowfish_Data)); // for Pointer Math
<tr class="nocodegen"><td>1086<td>
<tr class="covered"><td>1087<td>  Move(Blowfish_Data, S^, SizeOf(Blowfish_Data));
<tr class="covered"><td>1088<td>  Move(Blowfish_Key, P^, Sizeof(Blowfish_Key));
<tr class="covered"><td>1089<td>  J := 0;
<tr class="covered"><td>1090<td>  if Size &gt; 0 then
<tr class="covered"><td>1091<td>    for I := 0 to 17 do
<tr class="nocodegen"><td>1092<td>    begin
<tr class="covered"><td>1093<td>      P[I] := P[I] xor (K[(J + 0) mod Size] shl 24 +
<tr class="nocodegen"><td>1094<td>                        K[(J + 1) mod Size] shl 16 +
<tr class="nocodegen"><td>1095<td>                        K[(J + 2) mod Size] shl  8 +
<tr class="nocodegen"><td>1096<td>                        K[(J + 3) mod Size] shl  0);
<tr class="covered"><td>1097<td>      J := (J + 4) mod Size;
<tr class="covered"><td>1098<td>    end;
<tr class="covered"><td>1099<td>  FillChar(B, SizeOf(B), 0);
<tr class="nocodegen"><td>1100<td>
<tr class="covered"><td>1101<td>  for I := 0 to 8 do
<tr class="nocodegen"><td>1102<td>  begin
<tr class="covered"><td>1103<td>    DoEncode(@B, @B, SizeOf(B));
<tr class="covered"><td>1104<td>    P[I * 2 + 0] := SwapUInt32(B[0]);
<tr class="covered"><td>1105<td>    P[I * 2 + 1] := SwapUInt32(B[1]);
<tr class="covered"><td>1106<td>  end;
<tr class="covered"><td>1107<td>  for I := 0 to 3 do
<tr class="covered"><td>1108<td>    for J := 0 to 127 do
<tr class="nocodegen"><td>1109<td>    begin
<tr class="covered"><td>1110<td>      DoEncode(@B, @B, SizeOf(B));
<tr class="covered"><td>1111<td>      S[I, J * 2 + 0] := SwapUInt32(B[0]);
<tr class="covered"><td>1112<td>      S[I, J * 2 + 1] := SwapUInt32(B[1]);
<tr class="covered"><td>1113<td>    end;
<tr class="covered"><td>1114<td>  FillChar(B, SizeOf(B), 0);
<tr class="nocodegen"><td>1115<td>
<tr class="nocodegen"><td>1116<td>  inherited;
<tr class="covered"><td>1117<td>end;
<tr class="nocodegen"><td>1118<td>
<tr class="nocodegen"><td>1119<td>procedure TCipher_Blowfish.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>1120<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>1121<td>// Source = EDX, Dest = ECX, Size on Stack
<tr class="nocodegen"><td>1122<td>asm
<tr class="nocodegen"><td>1123<td>        PUSH   EDI
<tr class="nocodegen"><td>1124<td>        PUSH   ESI
<tr class="nocodegen"><td>1125<td>        PUSH   EBX
<tr class="nocodegen"><td>1126<td>        PUSH   EBP
<tr class="nocodegen"><td>1127<td>        PUSH   ECX
<tr class="nocodegen"><td>1128<td>        MOV    ESI,[EAX].TCipher_Blowfish.FAdditionalBuffer
<tr class="nocodegen"><td>1129<td>        MOV    EBX,[EDX + 0]     // A
<tr class="nocodegen"><td>1130<td>        MOV    EBP,[EDX + 4]     // B
<tr class="nocodegen"><td>1131<td>        BSWAP  EBX               // CPU &gt;= 486
<tr class="nocodegen"><td>1132<td>        BSWAP  EBP
<tr class="nocodegen"><td>1133<td>        XOR    EBX,[ESI + 4 * 256 * 4]
<tr class="nocodegen"><td>1134<td>        XOR    EDI,EDI
<tr class="nocodegen"><td>1135<td>@@1:    MOV    EAX,EBX
<tr class="nocodegen"><td>1136<td>        SHR    EBX,16
<tr class="nocodegen"><td>1137<td>        MOVZX  ECX,BH
<tr class="nocodegen"><td>1138<td>        AND    EBX,0FFh
<tr class="nocodegen"><td>1139<td>        MOV    ECX,[ESI + ECX * 4 + 1024 * 0]
<tr class="nocodegen"><td>1140<td>        MOV    EBX,[ESI + EBX * 4 + 1024 * 1]
<tr class="nocodegen"><td>1141<td>        MOVZX  EDX,AH
<tr class="nocodegen"><td>1142<td>        ADD    EBX,ECX
<tr class="nocodegen"><td>1143<td>        MOVZX  ECX,AL
<tr class="nocodegen"><td>1144<td>        MOV    EDX,[ESI + EDX * 4 + 1024 * 2]
<tr class="nocodegen"><td>1145<td>        MOV    ECX,[ESI + ECX * 4 + 1024 * 3]
<tr class="nocodegen"><td>1146<td>        XOR    EBX,EDX
<tr class="nocodegen"><td>1147<td>        XOR    EBP,[ESI + 4 * 256 * 4 + 4 + EDI * 4]
<tr class="nocodegen"><td>1148<td>        ADD    EBX,ECX
<tr class="nocodegen"><td>1149<td>        INC    EDI
<tr class="nocodegen"><td>1150<td>        XOR    EBX,EBP
<tr class="nocodegen"><td>1151<td>        TEST   EDI,010h
<tr class="nocodegen"><td>1152<td>        MOV    EBP,EAX
<tr class="nocodegen"><td>1153<td>        JZ     @@1
<tr class="nocodegen"><td>1154<td>        POP    EAX
<tr class="nocodegen"><td>1155<td>        XOR    EBP,[ESI + 4 * 256 * 4 + 17 * 4]
<tr class="nocodegen"><td>1156<td>        BSWAP  EBX
<tr class="nocodegen"><td>1157<td>        BSWAP  EBP
<tr class="nocodegen"><td>1158<td>        MOV    [EAX + 4],EBX
<tr class="nocodegen"><td>1159<td>        MOV    [EAX + 0],EBP
<tr class="nocodegen"><td>1160<td>        POP    EBP
<tr class="nocodegen"><td>1161<td>        POP    EBX
<tr class="nocodegen"><td>1162<td>        POP    ESI
<tr class="nocodegen"><td>1163<td>        POP    EDI
<tr class="nocodegen"><td>1164<td>end;
<tr class="nocodegen"><td>1165<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>1166<td>var
<tr class="nocodegen"><td>1167<td>  I, A, B: UInt32;
<tr class="nocodegen"><td>1168<td>  P: PUInt32Array;
<tr class="nocodegen"><td>1169<td>  D: PBlowfish;
<tr class="covered"><td>1170<td>begin
<tr class="nocodegen"><td>1171<td>  Assert(Size = Context.BlockSize, 'Size of ' + IntToStr(Size) + ' does not equal '+
<tr class="covered"><td>1172<td>                                   'block size of ' + IntToStr(Context.BlockSize));
<tr class="nocodegen"><td>1173<td>
<tr class="covered"><td>1174<td>  D := Pointer(FAdditionalBuffer);
<tr class="covered"><td>1175<td>  P := Pointer(PByte(FAdditionalBuffer) + SizeOf(Blowfish_Data)); // for Pointer Math
<tr class="covered"><td>1176<td>  A := SwapUInt32(PUInt32Array(Source)[0]) xor P[0]; P := @P[1];
<tr class="covered"><td>1177<td>  B := SwapUInt32(PUInt32Array(Source)[1]);
<tr class="covered"><td>1178<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>1179<td>  begin
<tr class="nocodegen"><td>1180<td>    {$IFOPT Q+}The following code requires overflow checks being off!{$ENDIF}
<tr class="nocodegen"><td>1181<td>
<tr class="covered"><td>1182<td>    B := B xor P[0] xor (D[0, A shr 24        ] +
<tr class="nocodegen"><td>1183<td>                         D[1, A shr 16 and $FF] xor
<tr class="nocodegen"><td>1184<td>                         D[2, A shr  8 and $FF] +
<tr class="nocodegen"><td>1185<td>                         D[3, A        and $FF]);
<tr class="nocodegen"><td>1186<td>
<tr class="covered"><td>1187<td>    A := A xor P[1] xor (D[0, B shr 24        ] +
<tr class="nocodegen"><td>1188<td>                         D[1, B shr 16 and $FF] xor
<tr class="nocodegen"><td>1189<td>                         D[2, B shr  8 and $FF] +
<tr class="nocodegen"><td>1190<td>                         D[3, B        and $FF]);
<tr class="covered"><td>1191<td>    P := @P[2];
<tr class="covered"><td>1192<td>  end;
<tr class="covered"><td>1193<td>  PUInt32Array(Dest)[0] := SwapUInt32(B xor P[0]);
<tr class="covered"><td>1194<td>  PUInt32Array(Dest)[1] := SwapUInt32(A);
<tr class="covered"><td>1195<td>end;
<tr class="nocodegen"><td>1196<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>1197<td>
<tr class="nocodegen"><td>1198<td>procedure TCipher_Blowfish.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>1199<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>1200<td>asm
<tr class="nocodegen"><td>1201<td>        PUSH   EDI
<tr class="nocodegen"><td>1202<td>        PUSH   ESI
<tr class="nocodegen"><td>1203<td>        PUSH   EBX
<tr class="nocodegen"><td>1204<td>        PUSH   EBP
<tr class="nocodegen"><td>1205<td>        PUSH   ECX
<tr class="nocodegen"><td>1206<td>        MOV    ESI,[EAX].TCipher_Blowfish.FAdditionalBuffer
<tr class="nocodegen"><td>1207<td>        MOV    EBX,[EDX + 0]     // A
<tr class="nocodegen"><td>1208<td>        MOV    EBP,[EDX + 4]     // B
<tr class="nocodegen"><td>1209<td>        BSWAP  EBX
<tr class="nocodegen"><td>1210<td>        BSWAP  EBP
<tr class="nocodegen"><td>1211<td>        XOR    EBX,[ESI + 4 * 256 * 4 + 17 * 4]
<tr class="nocodegen"><td>1212<td>        MOV    EDI,16
<tr class="nocodegen"><td>1213<td>@@1:    MOV    EAX,EBX
<tr class="nocodegen"><td>1214<td>        SHR    EBX,16
<tr class="nocodegen"><td>1215<td>        MOVZX  ECX,BH
<tr class="nocodegen"><td>1216<td>        MOVZX  EDX,BL
<tr class="nocodegen"><td>1217<td>        MOV    EBX,[ESI + ECX * 4 + 1024 * 0]
<tr class="nocodegen"><td>1218<td>        MOV    EDX,[ESI + EDX * 4 + 1024 * 1]
<tr class="nocodegen"><td>1219<td>        MOVZX  ECX,AH
<tr class="nocodegen"><td>1220<td>        LEA    EBX,[EBX + EDX]
<tr class="nocodegen"><td>1221<td>        MOVZX  EDX,AL
<tr class="nocodegen"><td>1222<td>        MOV    ECX,[ESI + ECX * 4 + 1024 * 2]
<tr class="nocodegen"><td>1223<td>        MOV    EDX,[ESI + EDX * 4 + 1024 * 3]
<tr class="nocodegen"><td>1224<td>        XOR    EBX,ECX
<tr class="nocodegen"><td>1225<td>        XOR    EBP,[ESI + 4 * 256 * 4 + EDI * 4]
<tr class="nocodegen"><td>1226<td>        LEA    EBX,[EBX + EDX]
<tr class="nocodegen"><td>1227<td>        XOR    EBX,EBP
<tr class="nocodegen"><td>1228<td>        DEC    EDI
<tr class="nocodegen"><td>1229<td>        MOV    EBP,EAX
<tr class="nocodegen"><td>1230<td>        JNZ    @@1
<tr class="nocodegen"><td>1231<td>        POP    EAX
<tr class="nocodegen"><td>1232<td>        XOR    EBP,[ESI + 4 * 256 * 4]
<tr class="nocodegen"><td>1233<td>        BSWAP  EBX
<tr class="nocodegen"><td>1234<td>        BSWAP  EBP
<tr class="nocodegen"><td>1235<td>        MOV    [EAX + 0],EBP
<tr class="nocodegen"><td>1236<td>        MOV    [EAX + 4],EBX
<tr class="nocodegen"><td>1237<td>        POP    EBP
<tr class="nocodegen"><td>1238<td>        POP    EBX
<tr class="nocodegen"><td>1239<td>        POP    ESI
<tr class="nocodegen"><td>1240<td>        POP    EDI
<tr class="nocodegen"><td>1241<td>end;
<tr class="nocodegen"><td>1242<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>1243<td>var
<tr class="nocodegen"><td>1244<td>  I, A, B: UInt32;
<tr class="nocodegen"><td>1245<td>  P: PUInt32Array;
<tr class="nocodegen"><td>1246<td>  D: PBlowfish;
<tr class="covered"><td>1247<td>begin
<tr class="covered"><td>1248<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>1249<td>
<tr class="covered"><td>1250<td>  D := Pointer(FAdditionalBuffer);
<tr class="covered"><td>1251<td>  P := Pointer(PByte(FAdditionalBuffer) + SizeOf(Blowfish_Data) + SizeOf(Blowfish_Key) - SizeOf(Int32));
<tr class="covered"><td>1252<td>  A := SwapUInt32(PUInt32Array(Source)[0]) xor P[0];
<tr class="covered"><td>1253<td>  B := SwapUInt32(PUInt32Array(Source)[1]);
<tr class="covered"><td>1254<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>1255<td>  begin
<tr class="covered"><td>1256<td>    Dec(PUInt32(P), 2);
<tr class="covered"><td>1257<td>    B := B xor P[1] xor (D[0, A shr 24        ] +
<tr class="nocodegen"><td>1258<td>                         D[1, A shr 16 and $FF] xor
<tr class="nocodegen"><td>1259<td>                         D[2, A shr  8 and $FF] +
<tr class="nocodegen"><td>1260<td>                         D[3, A        and $FF]);
<tr class="covered"><td>1261<td>    A := A xor P[0] xor (D[0, B shr 24        ] +
<tr class="nocodegen"><td>1262<td>                         D[1, B shr 16 and $FF] xor
<tr class="nocodegen"><td>1263<td>                         D[2, B shr  8 and $FF] +
<tr class="nocodegen"><td>1264<td>                         D[3, B        and $FF]);
<tr class="covered"><td>1265<td>  end;
<tr class="covered"><td>1266<td>  Dec(PUInt32(P));
<tr class="covered"><td>1267<td>  PUInt32Array(Dest)[0] := SwapUInt32(B xor P[0]);
<tr class="covered"><td>1268<td>  PUInt32Array(Dest)[1] := SwapUInt32(A);
<tr class="covered"><td>1269<td>end;
<tr class="nocodegen"><td>1270<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>1271<td>
<tr class="nocodegen"><td>1272<td>{ TCipher_Twofish }
<tr class="nocodegen"><td>1273<td>
<tr class="nocodegen"><td>1274<td>type
<tr class="nocodegen"><td>1275<td>  PTwofishBox = ^TTwofishBox;
<tr class="nocodegen"><td>1276<td>  TTwofishBox = array[0..3, 0..255] of UInt32;
<tr class="nocodegen"><td>1277<td>
<tr class="nocodegen"><td>1278<td>  TLongRec = record
<tr class="nocodegen"><td>1279<td>    case Integer of
<tr class="nocodegen"><td>1280<td>      0: (L: UInt32);
<tr class="nocodegen"><td>1281<td>      1: (A, B, C, D: Byte);
<tr class="nocodegen"><td>1282<td>    end;
<tr class="nocodegen"><td>1283<td>
<tr class="nocodegen"><td>1284<td>class function TCipher_Twofish.Context: TCipherContext;
<tr class="covered"><td>1285<td>begin
<tr class="covered"><td>1286<td>  Result.KeySize                     := 32;
<tr class="covered"><td>1287<td>  Result.BufferSize                  := 16;
<tr class="covered"><td>1288<td>  Result.BlockSize                   := 16;
<tr class="covered"><td>1289<td>  Result.AdditionalBufferSize        := 4256;
<tr class="covered"><td>1290<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>1291<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>1292<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>1293<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>1294<td>end;
<tr class="nocodegen"><td>1295<td>
<tr class="nocodegen"><td>1296<td>procedure TCipher_Twofish.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>1297<td>var
<tr class="nocodegen"><td>1298<td>  BoxKey: array[0..3] of TLongRec;
<tr class="nocodegen"><td>1299<td>  SubKey: PUInt32Array;
<tr class="nocodegen"><td>1300<td>  Box: PTwofishBox;
<tr class="nocodegen"><td>1301<td>
<tr class="nocodegen"><td>1302<td>  procedure SetupKey;
<tr class="nocodegen"><td>1303<td>
<tr class="nocodegen"><td>1304<td>    function Encode(K0, K1: Integer): Integer;
<tr class="nocodegen"><td>1305<td>    var
<tr class="nocodegen"><td>1306<td>      R, I, J, G2, G3: Integer;
<tr class="nocodegen"><td>1307<td>      B: byte;
<tr class="covered"><td>1308<td>    begin
<tr class="covered"><td>1309<td>      R := 0;
<tr class="covered"><td>1310<td>      for I := 0 to 1 do
<tr class="nocodegen"><td>1311<td>      begin
<tr class="covered"><td>1312<td>        if I &lt;&gt; 0 then
<tr class="covered"><td>1313<td>          R := R xor K0
<tr class="nocodegen"><td>1314<td>        else
<tr class="covered"><td>1315<td>          R := R xor K1;
<tr class="covered"><td>1316<td>        for J := 0 to 3 do
<tr class="nocodegen"><td>1317<td>        begin
<tr class="covered"><td>1318<td>          B := R shr 24;
<tr class="covered"><td>1319<td>          if B and $80 &lt;&gt; 0 then
<tr class="covered"><td>1320<td>            G2 := (B shl 1 xor $014D) and $FF
<tr class="nocodegen"><td>1321<td>          else
<tr class="covered"><td>1322<td>            G2 := B shl 1 and $FF;
<tr class="covered"><td>1323<td>          if B and 1 &lt;&gt; 0 then
<tr class="covered"><td>1324<td>            G3 := (B shr 1 and $7F) xor $014D shr 1 xor G2
<tr class="nocodegen"><td>1325<td>          else
<tr class="covered"><td>1326<td>            G3 := (B shr 1 and $7F) xor G2;
<tr class="covered"><td>1327<td>          R := R shl 8 xor G3 shl 24 xor G2 shl 16 xor G3 shl 8 xor B;
<tr class="covered"><td>1328<td>        end;
<tr class="covered"><td>1329<td>      end;
<tr class="covered"><td>1330<td>      Result := R;
<tr class="covered"><td>1331<td>    end;
<tr class="nocodegen"><td>1332<td>
<tr class="nocodegen"><td>1333<td>    function F32(X: Integer; K: array of Integer): Integer;
<tr class="nocodegen"><td>1334<td>    var
<tr class="nocodegen"><td>1335<td>      A, B, C, D: UInt32;
<tr class="covered"><td>1336<td>    begin
<tr class="covered"><td>1337<td>      A := X        and $FF;
<tr class="covered"><td>1338<td>      B := X shr  8 and $FF;
<tr class="covered"><td>1339<td>      C := X shr 16 and $FF;
<tr class="covered"><td>1340<td>      D := X shr 24;
<tr class="covered"><td>1341<td>      if Size = 32 then
<tr class="nocodegen"><td>1342<td>      begin
<tr class="notcovered"><td>1343<td>        A := Twofish_8x8[1, A] xor K[3]        and $FF;
<tr class="notcovered"><td>1344<td>        B := Twofish_8x8[0, B] xor K[3] shr  8 and $FF;
<tr class="notcovered"><td>1345<td>        C := Twofish_8x8[0, C] xor K[3] shr 16 and $FF;
<tr class="notcovered"><td>1346<td>        D := Twofish_8x8[1, D] xor K[3] shr 24;
<tr class="nocodegen"><td>1347<td>      end;
<tr class="covered"><td>1348<td>      if Size &gt;= 24 then
<tr class="nocodegen"><td>1349<td>      begin
<tr class="notcovered"><td>1350<td>        A := Twofish_8x8[1, A] xor K[2]        and $FF;
<tr class="notcovered"><td>1351<td>        B := Twofish_8x8[1, B] xor K[2] shr  8 and $FF;
<tr class="notcovered"><td>1352<td>        C := Twofish_8x8[0, C] xor K[2] shr 16 and $FF;
<tr class="notcovered"><td>1353<td>        D := Twofish_8x8[0, D] xor K[2] shr 24;
<tr class="nocodegen"><td>1354<td>      end;
<tr class="covered"><td>1355<td>      A := Twofish_8x8[0, A] xor K[1]        and $FF;
<tr class="covered"><td>1356<td>      B := Twofish_8x8[1, B] xor K[1] shr  8 and $FF;
<tr class="covered"><td>1357<td>      C := Twofish_8x8[0, C] xor K[1] shr 16 and $FF;
<tr class="covered"><td>1358<td>      D := Twofish_8x8[1, D] xor K[1] shr 24;
<tr class="nocodegen"><td>1359<td>
<tr class="covered"><td>1360<td>      A := Twofish_8x8[0, A] xor K[0]        and $FF;
<tr class="covered"><td>1361<td>      B := Twofish_8x8[0, B] xor K[0] shr  8 and $FF;
<tr class="covered"><td>1362<td>      C := Twofish_8x8[1, C] xor K[0] shr 16 and $FF;
<tr class="covered"><td>1363<td>      D := Twofish_8x8[1, D] xor K[0] shr 24;
<tr class="nocodegen"><td>1364<td>
<tr class="covered"><td>1365<td>      Result := Twofish_Data[0, A] xor Twofish_Data[1, B] xor
<tr class="nocodegen"><td>1366<td>                Twofish_Data[2, C] xor Twofish_Data[3, D];
<tr class="covered"><td>1367<td>    end;
<tr class="nocodegen"><td>1368<td>
<tr class="nocodegen"><td>1369<td>  var
<tr class="nocodegen"><td>1370<td>    I, J, A, B: Integer;
<tr class="nocodegen"><td>1371<td>    E, O: array[0..3] of Integer;
<tr class="nocodegen"><td>1372<td>    K: array[0..7] of Integer;
<tr class="covered"><td>1373<td>  begin
<tr class="covered"><td>1374<td>    FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>1375<td>    Move(Key, K, Size);
<tr class="covered"><td>1376<td>    if Size &lt;= 16 then
<tr class="covered"><td>1377<td>      Size := 16
<tr class="nocodegen"><td>1378<td>    else
<tr class="notcovered"><td>1379<td>    if Size &lt;= 24 then
<tr class="notcovered"><td>1380<td>      Size := 24
<tr class="nocodegen"><td>1381<td>    else
<tr class="notcovered"><td>1382<td>      Size := 32;
<tr class="covered"><td>1383<td>    J := Size shr 3 - 1;
<tr class="covered"><td>1384<td>    for I := 0 to J do
<tr class="nocodegen"><td>1385<td>    begin
<tr class="covered"><td>1386<td>      E[I] := K[I shl 1];
<tr class="covered"><td>1387<td>      O[I] := K[I shl 1 + 1];
<tr class="covered"><td>1388<td>      BoxKey[J].L := Encode(E[I], O[I]);
<tr class="covered"><td>1389<td>      Dec(J);
<tr class="covered"><td>1390<td>    end;
<tr class="covered"><td>1391<td>    J := 0;
<tr class="covered"><td>1392<td>    for I := 0 to 19 do
<tr class="nocodegen"><td>1393<td>    begin
<tr class="covered"><td>1394<td>      A := F32(J, E);
<tr class="covered"><td>1395<td>      B := F32(J + $01010101, O);
<tr class="covered"><td>1396<td>      B := B shl 8 or B shr 24;
<tr class="covered"><td>1397<td>      SubKey[I shl 1] := A + B;
<tr class="covered"><td>1398<td>      B := A + B shl 1;     // here buggy instead shr 1 it's correct shl 1
<tr class="covered"><td>1399<td>      SubKey[I shl 1 + 1] := B shl 9 or B shr 23;
<tr class="covered"><td>1400<td>      Inc(J, $02020202);
<tr class="covered"><td>1401<td>    end;
<tr class="covered"><td>1402<td>  end;
<tr class="nocodegen"><td>1403<td>
<tr class="nocodegen"><td>1404<td>  procedure DoXOR(D, S: PUInt32Array; Value: UInt32);
<tr class="nocodegen"><td>1405<td>  var
<tr class="nocodegen"><td>1406<td>    I: UInt32;
<tr class="covered"><td>1407<td>  begin
<tr class="covered"><td>1408<td>    Value := (Value and $FF) * $01010101;
<tr class="covered"><td>1409<td>    for I := 0 to 63 do
<tr class="covered"><td>1410<td>      D[I] := S[I] xor Value;
<tr class="covered"><td>1411<td>  end;
<tr class="nocodegen"><td>1412<td>
<tr class="nocodegen"><td>1413<td>  procedure SetupBox128;
<tr class="nocodegen"><td>1414<td>  var
<tr class="nocodegen"><td>1415<td>    L: array[0..255] of Byte;
<tr class="nocodegen"><td>1416<td>    A, I: Integer;
<tr class="covered"><td>1417<td>  begin
<tr class="covered"><td>1418<td>    DoXOR(@L, @Twofish_8x8[0], BoxKey[1].L);
<tr class="covered"><td>1419<td>    A := BoxKey[0].A;
<tr class="covered"><td>1420<td>    for I := 0 to 255 do
<tr class="covered"><td>1421<td>      Box[0, I] := Twofish_Data[0, Twofish_8x8[0, L[I]] xor A];
<tr class="covered"><td>1422<td>    DoXOR(@L, @Twofish_8x8[1], BoxKey[1].L shr 8);
<tr class="covered"><td>1423<td>    A := BoxKey[0].B;
<tr class="covered"><td>1424<td>    for I := 0 to 255 do
<tr class="covered"><td>1425<td>      Box[1, I] := Twofish_Data[1, Twofish_8x8[0, L[I]] xor A];
<tr class="covered"><td>1426<td>    DoXOR(@L, @Twofish_8x8[0], BoxKey[1].L shr 16);
<tr class="covered"><td>1427<td>    A := BoxKey[0].C;
<tr class="covered"><td>1428<td>    for I := 0 to 255 do
<tr class="covered"><td>1429<td>      Box[2, I] := Twofish_Data[2, Twofish_8x8[1, L[I]] xor A];
<tr class="covered"><td>1430<td>    DoXOR(@L, @Twofish_8x8[1], BoxKey[1].L shr 24);
<tr class="covered"><td>1431<td>    A := BoxKey[0].D;
<tr class="covered"><td>1432<td>    for I := 0 to 255 do
<tr class="covered"><td>1433<td>      Box[3, I] := Twofish_Data[3, Twofish_8x8[1, L[I]] xor A];
<tr class="covered"><td>1434<td>  end;
<tr class="nocodegen"><td>1435<td>
<tr class="nocodegen"><td>1436<td>  procedure SetupBox192;
<tr class="nocodegen"><td>1437<td>  var
<tr class="nocodegen"><td>1438<td>    L: array[0..255] of Byte;
<tr class="nocodegen"><td>1439<td>    A, B, I: Integer;
<tr class="notcovered"><td>1440<td>  begin
<tr class="notcovered"><td>1441<td>    DoXOR(@L, @Twofish_8x8[1], BoxKey[2].L);
<tr class="notcovered"><td>1442<td>    A := BoxKey[0].A;
<tr class="notcovered"><td>1443<td>    B := BoxKey[1].A;
<tr class="notcovered"><td>1444<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1445<td>      Box[0, I] := Twofish_Data[0, Twofish_8x8[0, Twofish_8x8[0, L[I]] xor B] xor A];
<tr class="notcovered"><td>1446<td>    DoXOR(@L, @Twofish_8x8[1], BoxKey[2].L shr 8);
<tr class="notcovered"><td>1447<td>    A := BoxKey[0].B;
<tr class="notcovered"><td>1448<td>    B := BoxKey[1].B;
<tr class="notcovered"><td>1449<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1450<td>      Box[1, I] := Twofish_Data[1, Twofish_8x8[0, Twofish_8x8[1, L[I]] xor B] xor A];
<tr class="notcovered"><td>1451<td>    DoXOR(@L, @Twofish_8x8[0], BoxKey[2].L shr 16);
<tr class="notcovered"><td>1452<td>    A := BoxKey[0].C;
<tr class="notcovered"><td>1453<td>    B := BoxKey[1].C;
<tr class="notcovered"><td>1454<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1455<td>      Box[2, I] := Twofish_Data[2, Twofish_8x8[1, Twofish_8x8[0, L[I]] xor B] xor A];
<tr class="notcovered"><td>1456<td>    DoXOR(@L ,@Twofish_8x8[0], BoxKey[2].L shr 24);
<tr class="notcovered"><td>1457<td>    A := BoxKey[0].D;
<tr class="notcovered"><td>1458<td>    B := BoxKey[1].D;
<tr class="notcovered"><td>1459<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1460<td>      Box[3, I] := Twofish_Data[3, Twofish_8x8[1, Twofish_8x8[1, L[I]] xor B] xor A];
<tr class="notcovered"><td>1461<td>  end;
<tr class="nocodegen"><td>1462<td>
<tr class="nocodegen"><td>1463<td>  procedure SetupBox256;
<tr class="nocodegen"><td>1464<td>  var
<tr class="nocodegen"><td>1465<td>    L: array[0..255] of Byte;
<tr class="nocodegen"><td>1466<td>    K: array[0..255] of Byte;
<tr class="nocodegen"><td>1467<td>    A, B, I: Integer;
<tr class="notcovered"><td>1468<td>  begin
<tr class="notcovered"><td>1469<td>    DoXOR(@K, @Twofish_8x8[1], BoxKey[3].L);
<tr class="notcovered"><td>1470<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1471<td>      L[I] := Twofish_8x8[1, K[I]];
<tr class="notcovered"><td>1472<td>    DoXOR(@L, @L, BoxKey[2].L);
<tr class="notcovered"><td>1473<td>    A := BoxKey[0].A;
<tr class="notcovered"><td>1474<td>    B := BoxKey[1].A;
<tr class="notcovered"><td>1475<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1476<td>      Box[0, I] := Twofish_Data[0, Twofish_8x8[0, Twofish_8x8[0, L[I]] xor B] xor A];
<tr class="notcovered"><td>1477<td>    DoXOR(@K, @Twofish_8x8[0], BoxKey[3].L shr 8);
<tr class="notcovered"><td>1478<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1479<td>      L[I] := Twofish_8x8[1, K[I]];
<tr class="notcovered"><td>1480<td>    DoXOR(@L, @L, BoxKey[2].L shr 8);
<tr class="notcovered"><td>1481<td>    A := BoxKey[0].B;
<tr class="notcovered"><td>1482<td>    B := BoxKey[1].B;
<tr class="notcovered"><td>1483<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1484<td>      Box[1, I] := Twofish_Data[1, Twofish_8x8[0, Twofish_8x8[1, L[I]] xor B] xor A];
<tr class="notcovered"><td>1485<td>    DoXOR(@K, @Twofish_8x8[0], BoxKey[3].L shr 16);
<tr class="notcovered"><td>1486<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1487<td>      L[I] := Twofish_8x8[0, K[I]];
<tr class="notcovered"><td>1488<td>    DoXOR(@L, @L, BoxKey[2].L shr 16);
<tr class="notcovered"><td>1489<td>    A := BoxKey[0].C;
<tr class="notcovered"><td>1490<td>    B := BoxKey[1].C;
<tr class="notcovered"><td>1491<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1492<td>      Box[2, I] := Twofish_Data[2, Twofish_8x8[1, Twofish_8x8[0, L[I]] xor B] xor A];
<tr class="notcovered"><td>1493<td>    DoXOR(@K, @Twofish_8x8[1], BoxKey[3].L shr 24);
<tr class="notcovered"><td>1494<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1495<td>      L[I] := Twofish_8x8[0, K[I]];
<tr class="notcovered"><td>1496<td>    DoXOR(@L, @L, BoxKey[2].L shr 24);
<tr class="notcovered"><td>1497<td>    A := BoxKey[0].D;
<tr class="notcovered"><td>1498<td>    B := BoxKey[1].D;
<tr class="notcovered"><td>1499<td>    for I := 0 to 255 do
<tr class="notcovered"><td>1500<td>      Box[3, I] := Twofish_Data[3, Twofish_8x8[1, Twofish_8x8[1, L[I]] xor B] xor A];
<tr class="notcovered"><td>1501<td>  end;
<tr class="nocodegen"><td>1502<td>
<tr class="covered"><td>1503<td>begin
<tr class="covered"><td>1504<td>  SubKey := FAdditionalBuffer;
<tr class="covered"><td>1505<td>  Box    := @SubKey[40];
<tr class="covered"><td>1506<td>  SetupKey;
<tr class="covered"><td>1507<td>  if Size = 16 then
<tr class="covered"><td>1508<td>    SetupBox128
<tr class="nocodegen"><td>1509<td>  else
<tr class="notcovered"><td>1510<td>  if Size = 24 then
<tr class="notcovered"><td>1511<td>    SetupBox192
<tr class="nocodegen"><td>1512<td>  else
<tr class="notcovered"><td>1513<td>    SetupBox256;
<tr class="nocodegen"><td>1514<td>
<tr class="nocodegen"><td>1515<td>  inherited;
<tr class="covered"><td>1516<td>end;
<tr class="nocodegen"><td>1517<td>
<tr class="nocodegen"><td>1518<td>procedure TCipher_Twofish.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>1519<td>var
<tr class="nocodegen"><td>1520<td>  S: PUInt32Array;
<tr class="nocodegen"><td>1521<td>  Box: PTwofishBox;
<tr class="nocodegen"><td>1522<td>  I, X, Y: UInt32;
<tr class="nocodegen"><td>1523<td>  A, B, C, D: TLongRec;
<tr class="covered"><td>1524<td>begin
<tr class="covered"><td>1525<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>1526<td>
<tr class="covered"><td>1527<td>  S   := FAdditionalBuffer;
<tr class="covered"><td>1528<td>  A.L := PUInt32Array(Source)[0] xor S[0];
<tr class="covered"><td>1529<td>  B.L := PUInt32Array(Source)[1] xor S[1];
<tr class="covered"><td>1530<td>  C.L := PUInt32Array(Source)[2] xor S[2];
<tr class="covered"><td>1531<td>  D.L := PUInt32Array(Source)[3] xor S[3];
<tr class="nocodegen"><td>1532<td>
<tr class="covered"><td>1533<td>  Box := @S[40];
<tr class="covered"><td>1534<td>  S   := @S[8];
<tr class="covered"><td>1535<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>1536<td>  begin
<tr class="covered"><td>1537<td>    X := Box[0, A.A] xor Box[1, A.B] xor Box[2, A.C] xor Box[3, A.D];
<tr class="covered"><td>1538<td>    Y := Box[1, B.A] xor Box[2, B.B] xor Box[3, B.C] xor Box[0, B.D];
<tr class="covered"><td>1539<td>    D.L := D.L shl 1 or D.L shr 31;
<tr class="covered"><td>1540<td>    C.L := C.L xor (X + Y       + S[0]);
<tr class="covered"><td>1541<td>    D.L := D.L xor (X + Y shl 1 + S[1]);
<tr class="covered"><td>1542<td>    C.L := C.L shr 1 or C.L shl 31;
<tr class="nocodegen"><td>1543<td>
<tr class="covered"><td>1544<td>    X := Box[0, C.A] xor Box[1, C.B] xor Box[2, C.C] xor Box[3, C.D];
<tr class="covered"><td>1545<td>    Y := Box[1, D.A] xor Box[2, D.B] xor Box[3, D.C] xor Box[0, D.D];
<tr class="covered"><td>1546<td>    B.L := B.L shl 1 or B.L shr 31;
<tr class="covered"><td>1547<td>    A.L := A.L xor (X + Y       + S[2]);
<tr class="covered"><td>1548<td>    B.L := B.L xor (X + Y shl 1 + S[3]);
<tr class="covered"><td>1549<td>    A.L := A.L shr 1 or A.L shl 31;
<tr class="nocodegen"><td>1550<td>
<tr class="covered"><td>1551<td>    S := @S[4];
<tr class="covered"><td>1552<td>  end;
<tr class="covered"><td>1553<td>  S := FAdditionalBuffer;
<tr class="covered"><td>1554<td>  PUInt32Array(Dest)[0] := C.L xor S[4];
<tr class="covered"><td>1555<td>  PUInt32Array(Dest)[1] := D.L xor S[5];
<tr class="covered"><td>1556<td>  PUInt32Array(Dest)[2] := A.L xor S[6];
<tr class="covered"><td>1557<td>  PUInt32Array(Dest)[3] := B.L xor S[7];
<tr class="covered"><td>1558<td>end;
<tr class="nocodegen"><td>1559<td>
<tr class="nocodegen"><td>1560<td>procedure TCipher_Twofish.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>1561<td>var
<tr class="nocodegen"><td>1562<td>  S: PUInt32Array;
<tr class="nocodegen"><td>1563<td>  Box: PTwofishBox;
<tr class="nocodegen"><td>1564<td>  I, X, Y: UInt32;
<tr class="nocodegen"><td>1565<td>  A, B, C, D: TLongRec;
<tr class="covered"><td>1566<td>begin
<tr class="covered"><td>1567<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>1568<td>
<tr class="covered"><td>1569<td>  S := FAdditionalBuffer;
<tr class="covered"><td>1570<td>  Box := @S[40];
<tr class="covered"><td>1571<td>  C.L := PUInt32Array(Source)[0] xor S[4];
<tr class="covered"><td>1572<td>  D.L := PUInt32Array(Source)[1] xor S[5];
<tr class="covered"><td>1573<td>  A.L := PUInt32Array(Source)[2] xor S[6];
<tr class="covered"><td>1574<td>  B.L := PUInt32Array(Source)[3] xor S[7];
<tr class="covered"><td>1575<td>  S := @S[36];
<tr class="covered"><td>1576<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>1577<td>  begin
<tr class="covered"><td>1578<td>    X := Box[0, C.A] xor Box[1, C.B] xor Box[2, C.C] xor Box[3, C.D];
<tr class="covered"><td>1579<td>    Y := Box[0, D.D] xor Box[1, D.A] xor Box[2, D.B] xor Box[3, D.C];
<tr class="covered"><td>1580<td>    A.L := A.L shl 1 or A.L shr 31;
<tr class="covered"><td>1581<td>    B.L := B.L xor (X + Y shl 1 + S[3]);
<tr class="covered"><td>1582<td>    A.L := A.L xor (X + Y       + S[2]);
<tr class="covered"><td>1583<td>    B.L := B.L shr 1 or B.L shl 31;
<tr class="nocodegen"><td>1584<td>
<tr class="covered"><td>1585<td>    X := Box[0, A.A] xor Box[1, A.B] xor Box[2, A.C] xor Box[3, A.D];
<tr class="covered"><td>1586<td>    Y := Box[0, B.D] xor Box[1, B.A] xor Box[2, B.B] xor Box[3, B.C];
<tr class="covered"><td>1587<td>    C.L := C.L shl 1 or C.L shr 31;
<tr class="covered"><td>1588<td>    D.L := D.L xor (X + Y shl 1 + S[1]);
<tr class="covered"><td>1589<td>    C.L := C.L xor (X + Y       + S[0]);
<tr class="covered"><td>1590<td>    D.L := D.L shr 1 or D.L shl 31;
<tr class="nocodegen"><td>1591<td>
<tr class="covered"><td>1592<td>    Dec(PUInt32(S), 4);
<tr class="covered"><td>1593<td>  end;
<tr class="covered"><td>1594<td>  S := FAdditionalBuffer;
<tr class="covered"><td>1595<td>  PUInt32Array(Dest)[0] := A.L xor S[0];
<tr class="covered"><td>1596<td>  PUInt32Array(Dest)[1] := B.L xor S[1];
<tr class="covered"><td>1597<td>  PUInt32Array(Dest)[2] := C.L xor S[2];
<tr class="covered"><td>1598<td>  PUInt32Array(Dest)[3] := D.L xor S[3];
<tr class="covered"><td>1599<td>end;
<tr class="nocodegen"><td>1600<td>
<tr class="nocodegen"><td>1601<td>{ TCipher_IDEA }
<tr class="nocodegen"><td>1602<td>
<tr class="nocodegen"><td>1603<td>class function TCipher_IDEA.Context: TCipherContext;
<tr class="covered"><td>1604<td>begin
<tr class="covered"><td>1605<td>  Result.KeySize                     := 16;
<tr class="covered"><td>1606<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>1607<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>1608<td>  Result.AdditionalBufferSize        := 208;
<tr class="covered"><td>1609<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>1610<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>1611<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>1612<td>  Result.CipherType := [ctSymmetric, ctBlock];
<tr class="covered"><td>1613<td>end;
<tr class="nocodegen"><td>1614<td>
<tr class="nocodegen"><td>1615<td>procedure TCipher_IDEA.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>1616<td>
<tr class="nocodegen"><td>1617<td>  function IDEAInv(X: Word): Word;
<tr class="nocodegen"><td>1618<td>  var
<tr class="nocodegen"><td>1619<td>    A, B, C, D: Word;
<tr class="covered"><td>1620<td>  begin
<tr class="covered"><td>1621<td>    if X &lt;= 1 then
<tr class="nocodegen"><td>1622<td>    begin
<tr class="covered"><td>1623<td>      Result := X;
<tr class="covered"><td>1624<td>      Exit;
<tr class="nocodegen"><td>1625<td>    end;
<tr class="covered"><td>1626<td>    A := 1;
<tr class="covered"><td>1627<td>    B := $10001 div X;
<tr class="covered"><td>1628<td>    C := $10001 mod X;
<tr class="covered"><td>1629<td>    while C &lt;&gt; 1 do
<tr class="nocodegen"><td>1630<td>    begin
<tr class="covered"><td>1631<td>      D := X div C;
<tr class="covered"><td>1632<td>      X := X mod C;
<tr class="covered"><td>1633<td>      Inc(A, B * D);
<tr class="covered"><td>1634<td>      if X = 1 then
<tr class="nocodegen"><td>1635<td>      begin
<tr class="covered"><td>1636<td>        Result := A;
<tr class="covered"><td>1637<td>        Exit;
<tr class="nocodegen"><td>1638<td>      end;
<tr class="covered"><td>1639<td>      D := C div X;
<tr class="covered"><td>1640<td>      C := C mod X;
<tr class="covered"><td>1641<td>      Inc(B, A * D);
<tr class="nocodegen"><td>1642<td>    end;
<tr class="covered"><td>1643<td>    Result := 1 - B;
<tr class="covered"><td>1644<td>  end;
<tr class="nocodegen"><td>1645<td>
<tr class="nocodegen"><td>1646<td>var
<tr class="nocodegen"><td>1647<td>  I: Integer;
<tr class="nocodegen"><td>1648<td>  E: PWordArray;
<tr class="nocodegen"><td>1649<td>  A, B, C: Word;
<tr class="nocodegen"><td>1650<td>  K, D: PWordArray;
<tr class="covered"><td>1651<td>begin
<tr class="covered"><td>1652<td>  E := FAdditionalBuffer;
<tr class="covered"><td>1653<td>  Move(Key, E^, Size);
<tr class="covered"><td>1654<td>  for I := 0 to 7 do
<tr class="covered"><td>1655<td>    E[I] := Swap(E[I]);
<tr class="covered"><td>1656<td>  for I := 0 to 39 do
<tr class="covered"><td>1657<td>    E[I + 8] := E[I and not 7 + (I + 1) and 7] shl 9 or
<tr class="covered"><td>1658<td>                E[I and not 7 + (I + 2) and 7] shr 7;
<tr class="covered"><td>1659<td>  for I := 41 to 44 do
<tr class="covered"><td>1660<td>    E[I + 7] := E[I] shl 9 or E[I + 1] shr 7;
<tr class="covered"><td>1661<td>  K  := E;
<tr class="covered"><td>1662<td>  D  := @E[100];
<tr class="covered"><td>1663<td>  A  := IDEAInv(K[0]);
<tr class="covered"><td>1664<td>  B  := 0 - K[1];
<tr class="covered"><td>1665<td>  C  := 0 - K[2];
<tr class="covered"><td>1666<td>  D[3] := IDEAInv(K[3]);
<tr class="covered"><td>1667<td>  D[2] := C;
<tr class="covered"><td>1668<td>  D[1] := B;
<tr class="covered"><td>1669<td>  D[0] := A;
<tr class="covered"><td>1670<td>  Inc(PWord(K), 4);
<tr class="covered"><td>1671<td>  for I := 1 to 8 do
<tr class="nocodegen"><td>1672<td>  begin
<tr class="covered"><td>1673<td>    Dec(PWord(D), 6);
<tr class="covered"><td>1674<td>    A    := K[0];
<tr class="covered"><td>1675<td>    D[5] := K[1];
<tr class="covered"><td>1676<td>    D[4] := A;
<tr class="covered"><td>1677<td>    A    := IDEAInv(K[2]);
<tr class="covered"><td>1678<td>    B    := 0 - K[3];
<tr class="covered"><td>1679<td>    C    := 0 - K[4];
<tr class="covered"><td>1680<td>    D[3] := IDEAInv(K[5]);
<tr class="covered"><td>1681<td>    D[2] := B;
<tr class="covered"><td>1682<td>    D[1] := C;
<tr class="covered"><td>1683<td>    D[0] := A;
<tr class="covered"><td>1684<td>    Inc(PWord(K), 6);
<tr class="covered"><td>1685<td>  end;
<tr class="covered"><td>1686<td>  A    := D[2];
<tr class="covered"><td>1687<td>  D[2] := D[1];
<tr class="covered"><td>1688<td>  D[1] := A;
<tr class="nocodegen"><td>1689<td>
<tr class="nocodegen"><td>1690<td>  inherited;
<tr class="covered"><td>1691<td>end;
<tr class="nocodegen"><td>1692<td>
<tr class="nocodegen"><td>1693<td>function IDEAMul(X, Y: UInt32): UInt32;
<tr class="nocodegen"><td>1694<td>{$IF defined(X86ASM) or defined(X64ASM)}
<tr class="nocodegen"><td>1695<td>asm
<tr class="nocodegen"><td>1696<td>    {$IFDEF X64ASM}
<tr class="nocodegen"><td>1697<td>       MOV    EAX,ECX
<tr class="nocodegen"><td>1698<td>    {$ENDIF X64ASM}
<tr class="nocodegen"><td>1699<td>       AND    EAX,0FFFFh
<tr class="nocodegen"><td>1700<td>       JZ     @@1
<tr class="nocodegen"><td>1701<td>       AND    EDX,0FFFFh
<tr class="nocodegen"><td>1702<td>       JZ     @@1
<tr class="nocodegen"><td>1703<td>       MUL    EDX
<tr class="nocodegen"><td>1704<td>       MOV    EDX,EAX
<tr class="nocodegen"><td>1705<td>       MOV    ECX,EAX
<tr class="nocodegen"><td>1706<td>       SHR    EDX,16
<tr class="nocodegen"><td>1707<td>       SUB    EAX,EDX
<tr class="nocodegen"><td>1708<td>       SUB    CX,AX
<tr class="nocodegen"><td>1709<td>       ADC    EAX,0
<tr class="nocodegen"><td>1710<td>       RET
<tr class="nocodegen"><td>1711<td>@@1:   LEA    EAX,[EAX + EDX - 1]
<tr class="nocodegen"><td>1712<td>       NEG    EAX
<tr class="nocodegen"><td>1713<td>end;
<tr class="nocodegen"><td>1714<td>{$ELSE}
<tr class="covered"><td>1715<td>begin
<tr class="covered"><td>1716<td>  X := X and $FFFF;
<tr class="covered"><td>1717<td>  if X &lt;&gt; 0 then
<tr class="nocodegen"><td>1718<td>  begin
<tr class="covered"><td>1719<td>    Y := Y and $FFFF;
<tr class="covered"><td>1720<td>    if Y &lt;&gt; 0 then
<tr class="nocodegen"><td>1721<td>    begin
<tr class="covered"><td>1722<td>      X := X * Y;
<tr class="covered"><td>1723<td>      Result := X - (X shr 16);
<tr class="covered"><td>1724<td>      if Word(X) &lt; Word(Result) then // carry flag check for &quot;sub cx,ax&quot;
<tr class="covered"><td>1725<td>        Inc(Result);
<tr class="covered"><td>1726<td>      Exit;
<tr class="nocodegen"><td>1727<td>    end;
<tr class="nocodegen"><td>1728<td>  end;
<tr class="covered"><td>1729<td>  Result := -(X + Y - 1);
<tr class="covered"><td>1730<td>end;
<tr class="nocodegen"><td>1731<td>{$IFEND}
<tr class="nocodegen"><td>1732<td>
<tr class="nocodegen"><td>1733<td>procedure IDEACipher(Source, Dest: PUInt32Array; Key: PWordArray);
<tr class="nocodegen"><td>1734<td>var
<tr class="nocodegen"><td>1735<td>  I: UInt32;
<tr class="nocodegen"><td>1736<td>  X, Y, A, B, C, D: UInt32;
<tr class="covered"><td>1737<td>begin
<tr class="covered"><td>1738<td>  I := SwapUInt32(Source[0]);
<tr class="covered"><td>1739<td>  A := I shr 16;
<tr class="covered"><td>1740<td>  B := I and $FFFF;
<tr class="covered"><td>1741<td>  I := SwapUInt32(Source[1]);
<tr class="covered"><td>1742<td>  C := I shr 16;
<tr class="covered"><td>1743<td>  D := I and $FFFF;
<tr class="covered"><td>1744<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>1745<td>  begin
<tr class="covered"><td>1746<td>    A := IDEAMul(A, Key[0]);
<tr class="covered"><td>1747<td>    Inc(B, Key[1]);
<tr class="covered"><td>1748<td>    Inc(C, Key[2]);
<tr class="covered"><td>1749<td>    D := IDEAMul(D, Key[3]);
<tr class="covered"><td>1750<td>    Y := C xor A;
<tr class="covered"><td>1751<td>    Y := IDEAMul(Y, Key[4]);
<tr class="covered"><td>1752<td>    X := B xor D + Y;
<tr class="covered"><td>1753<td>    X := IDEAMul(X, Key[5]);
<tr class="covered"><td>1754<td>    Inc(Y, X);
<tr class="covered"><td>1755<td>    A := A xor X;
<tr class="covered"><td>1756<td>    D := D xor Y;
<tr class="covered"><td>1757<td>    Y := B xor Y;
<tr class="covered"><td>1758<td>    B := C xor X;
<tr class="covered"><td>1759<td>    C := Y;
<tr class="covered"><td>1760<td>    Key := @Key[6];
<tr class="covered"><td>1761<td>  end;
<tr class="covered"><td>1762<td>  Dest[0] := SwapUInt32(IDEAMul(A, Key[0]) shl 16 or (C + Key[1]) and $FFFF);
<tr class="covered"><td>1763<td>  Dest[1] := SwapUInt32((B + Key[2]) shl 16 or IDEAMul(D, Key[3]) and $FFFF);
<tr class="covered"><td>1764<td>end;
<tr class="nocodegen"><td>1765<td>
<tr class="nocodegen"><td>1766<td>procedure TCipher_IDEA.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>1767<td>begin
<tr class="covered"><td>1768<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>1769<td>
<tr class="covered"><td>1770<td>  IDEACipher(Source, Dest, FAdditionalBuffer);
<tr class="covered"><td>1771<td>end;
<tr class="nocodegen"><td>1772<td>
<tr class="nocodegen"><td>1773<td>procedure TCipher_IDEA.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>1774<td>begin
<tr class="covered"><td>1775<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>1776<td>
<tr class="covered"><td>1777<td>  IDEACipher(Source, Dest, @PUInt32Array(FAdditionalBuffer)[26]);
<tr class="covered"><td>1778<td>end;
<tr class="nocodegen"><td>1779<td>
<tr class="nocodegen"><td>1780<td>{ TCipher_Cast256 }
<tr class="nocodegen"><td>1781<td>
<tr class="nocodegen"><td>1782<td>class function TCipher_Cast256.Context: TCipherContext;
<tr class="covered"><td>1783<td>begin
<tr class="covered"><td>1784<td>  Result.KeySize                     := 32;
<tr class="covered"><td>1785<td>  Result.BlockSize                   := 16;
<tr class="covered"><td>1786<td>  Result.BufferSize                  := 16;
<tr class="covered"><td>1787<td>  Result.AdditionalBufferSize        := 384;
<tr class="covered"><td>1788<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>1789<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>1790<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>1791<td>  Result.CipherType := [ctSymmetric, ctBlock];
<tr class="covered"><td>1792<td>end;
<tr class="nocodegen"><td>1793<td>
<tr class="nocodegen"><td>1794<td>procedure TCipher_Cast256.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>1795<td>var
<tr class="nocodegen"><td>1796<td>  X: array[0..7] of UInt32;
<tr class="nocodegen"><td>1797<td>  M, R, I, J, T: UInt32;
<tr class="nocodegen"><td>1798<td>  K: PUInt32Array;
<tr class="covered"><td>1799<td>begin
<tr class="covered"><td>1800<td>  FillChar(X, SizeOf(X), 0);
<tr class="covered"><td>1801<td>  Move(Key, X, Size);
<tr class="covered"><td>1802<td>  SwapUInt32Buffer(X, X, 8);
<tr class="covered"><td>1803<td>  K := FAdditionalBuffer;
<tr class="covered"><td>1804<td>  M := $5A827999;
<tr class="covered"><td>1805<td>  R := 19;
<tr class="covered"><td>1806<td>  for I := 0 to 11 do
<tr class="nocodegen"><td>1807<td>  begin
<tr class="covered"><td>1808<td>    for J := 0 to 1 do
<tr class="nocodegen"><td>1809<td>    begin
<tr class="covered"><td>1810<td>      T := M + X[7];
<tr class="covered"><td>1811<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1812<td>      X[6] := X[6] xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1813<td>                        Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1814<td>                        Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>1815<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1816<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1817<td>      Inc(R, 17);
<tr class="covered"><td>1818<td>      T := M xor X[6];
<tr class="covered"><td>1819<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1820<td>      X[5] := X[5] xor (Cast256_Data[0, T shr 24] -
<tr class="nocodegen"><td>1821<td>                        Cast256_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>1822<td>                        Cast256_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>1823<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1824<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1825<td>      Inc(R, 17);
<tr class="covered"><td>1826<td>      T := M - X[5];
<tr class="covered"><td>1827<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1828<td>      X[4] := X[4] xor (Cast256_Data[0, T shr 24] +
<tr class="nocodegen"><td>1829<td>                        Cast256_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>1830<td>                        Cast256_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>1831<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1832<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1833<td>      Inc(R, 17);
<tr class="covered"><td>1834<td>      T := M + X[4];
<tr class="covered"><td>1835<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1836<td>      X[3] := X[3] xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1837<td>                        Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1838<td>                        Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>1839<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1840<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1841<td>      Inc(R, 17);
<tr class="covered"><td>1842<td>      T := M xor X[3];
<tr class="covered"><td>1843<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1844<td>      X[2] := X[2] xor (Cast256_Data[0, T shr 24] -
<tr class="nocodegen"><td>1845<td>                        Cast256_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>1846<td>                        Cast256_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>1847<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1848<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1849<td>      Inc(R, 17);
<tr class="covered"><td>1850<td>      T := M - X[2];
<tr class="covered"><td>1851<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1852<td>      X[1] := X[1] xor (Cast256_Data[0, T shr 24] +
<tr class="nocodegen"><td>1853<td>                        Cast256_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>1854<td>                        Cast256_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>1855<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1856<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1857<td>      Inc(R, 17);
<tr class="covered"><td>1858<td>      T := M + X[1];
<tr class="covered"><td>1859<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1860<td>      X[0] := X[0] xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1861<td>                        Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1862<td>                        Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>1863<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1864<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1865<td>      Inc(R, 17);
<tr class="covered"><td>1866<td>      T := M xor X[0];
<tr class="covered"><td>1867<td>      T := T shl R or T shr (32 - R);
<tr class="covered"><td>1868<td>      X[7] := X[7] xor (Cast256_Data[0, T shr 24] -
<tr class="nocodegen"><td>1869<td>                        Cast256_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>1870<td>                        Cast256_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>1871<td>                        Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1872<td>      Inc(M, $6ED9EBA1);
<tr class="covered"><td>1873<td>      Inc(R, 17);
<tr class="covered"><td>1874<td>    end;
<tr class="covered"><td>1875<td>    if I &lt; 6 then
<tr class="nocodegen"><td>1876<td>    begin
<tr class="covered"><td>1877<td>      K[48] := X[0] and $1F;
<tr class="covered"><td>1878<td>      K[49] := X[2] and $1F;
<tr class="covered"><td>1879<td>      K[50] := X[4] and $1F;
<tr class="covered"><td>1880<td>      K[51] := X[6] and $1F;
<tr class="covered"><td>1881<td>      K[0] := X[7];
<tr class="covered"><td>1882<td>      K[1] := X[5];
<tr class="covered"><td>1883<td>      K[2] := X[3];
<tr class="covered"><td>1884<td>      K[3] := X[1];
<tr class="nocodegen"><td>1885<td>    end
<tr class="nocodegen"><td>1886<td>    else
<tr class="nocodegen"><td>1887<td>    begin
<tr class="covered"><td>1888<td>      K[48] := X[6] and $1F;
<tr class="covered"><td>1889<td>      K[49] := X[4] and $1F;
<tr class="covered"><td>1890<td>      K[50] := X[2] and $1F;
<tr class="covered"><td>1891<td>      K[51] := X[0] and $1F;
<tr class="covered"><td>1892<td>      K[0] := X[1];
<tr class="covered"><td>1893<td>      K[1] := X[3];
<tr class="covered"><td>1894<td>      K[2] := X[5];
<tr class="covered"><td>1895<td>      K[3] := X[7];
<tr class="nocodegen"><td>1896<td>    end;
<tr class="covered"><td>1897<td>    K := @K[4];
<tr class="covered"><td>1898<td>  end;
<tr class="covered"><td>1899<td>  ProtectBuffer(X, SizeOf(X));
<tr class="nocodegen"><td>1900<td>
<tr class="nocodegen"><td>1901<td>  inherited;
<tr class="covered"><td>1902<td>end;
<tr class="nocodegen"><td>1903<td>
<tr class="nocodegen"><td>1904<td>procedure TCipher_Cast256.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>1905<td>var
<tr class="nocodegen"><td>1906<td>  I, T, A, B, C, D: UInt32;
<tr class="nocodegen"><td>1907<td>  K: PUInt32Array;
<tr class="covered"><td>1908<td>begin
<tr class="covered"><td>1909<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>1910<td>
<tr class="covered"><td>1911<td>  K := FAdditionalBuffer;
<tr class="covered"><td>1912<td>  SwapUInt32Buffer(Source^, Dest^, 4);
<tr class="covered"><td>1913<td>  A := PUInt32Array(Dest)[0];
<tr class="covered"><td>1914<td>  B := PUInt32Array(Dest)[1];
<tr class="covered"><td>1915<td>  C := PUInt32Array(Dest)[2];
<tr class="covered"><td>1916<td>  D := PUInt32Array(Dest)[3];
<tr class="covered"><td>1917<td>  for I := 0 to 5 do
<tr class="nocodegen"><td>1918<td>  begin
<tr class="covered"><td>1919<td>    T := K[0] + D;
<tr class="covered"><td>1920<td>    T := T shl K[48] or T shr (32 - K[48]);
<tr class="covered"><td>1921<td>    C := C xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1922<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1923<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>1924<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1925<td>    T := K[1] xor C;
<tr class="covered"><td>1926<td>    T := T shl K[49] or T shr (32 - K[49]);
<tr class="covered"><td>1927<td>    B := B xor (Cast256_Data[0, T shr 24] -
<tr class="nocodegen"><td>1928<td>                Cast256_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>1929<td>                Cast256_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>1930<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1931<td>    T := K[2] - B;
<tr class="covered"><td>1932<td>    T := T shl K[50] or T shr (32 - K[50]);
<tr class="covered"><td>1933<td>    A := A xor (Cast256_Data[0, T shr 24] +
<tr class="nocodegen"><td>1934<td>                Cast256_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>1935<td>                Cast256_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>1936<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1937<td>    T := K[3] + A;
<tr class="covered"><td>1938<td>    T := T shl K[51] or T shr (32 - K[51]);
<tr class="covered"><td>1939<td>    D := D xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1940<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1941<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>1942<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1943<td>    K := @K[4];
<tr class="covered"><td>1944<td>  end;
<tr class="covered"><td>1945<td>  for I := 0 to 5 do
<tr class="nocodegen"><td>1946<td>  begin
<tr class="covered"><td>1947<td>    T := K[0] + A;
<tr class="covered"><td>1948<td>    T := T shl K[48] or T shr (32 - K[48]);
<tr class="covered"><td>1949<td>    D := D xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1950<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1951<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>1952<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1953<td>    T := K[1] - B;
<tr class="covered"><td>1954<td>    T := T shl K[49] or T shr (32 - K[49]);
<tr class="covered"><td>1955<td>    A := A xor (Cast256_Data[0, T shr 24] +
<tr class="nocodegen"><td>1956<td>                Cast256_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>1957<td>                Cast256_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>1958<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1959<td>    T := K[2] xor C;
<tr class="covered"><td>1960<td>    T := T shl K[50] or T shr (32 - K[50]);
<tr class="covered"><td>1961<td>    B := B xor (Cast256_Data[0, T shr 24] -
<tr class="nocodegen"><td>1962<td>                Cast256_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>1963<td>                Cast256_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>1964<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1965<td>    T := K[3] + D;
<tr class="covered"><td>1966<td>    T := T shl K[51] or T shr (32 - K[51]);
<tr class="covered"><td>1967<td>    C := C xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1968<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1969<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>1970<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>1971<td>    K := @K[4];
<tr class="covered"><td>1972<td>  end;
<tr class="covered"><td>1973<td>  PUInt32Array(Dest)[0] := A;
<tr class="covered"><td>1974<td>  PUInt32Array(Dest)[1] := B;
<tr class="covered"><td>1975<td>  PUInt32Array(Dest)[2] := C;
<tr class="covered"><td>1976<td>  PUInt32Array(Dest)[3] := D;
<tr class="covered"><td>1977<td>  SwapUInt32Buffer(Dest^, Dest^, 4);
<tr class="covered"><td>1978<td>end;
<tr class="nocodegen"><td>1979<td>
<tr class="nocodegen"><td>1980<td>procedure TCipher_Cast256.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>1981<td>var
<tr class="nocodegen"><td>1982<td>  I, T, A, B, C, D: UInt32;
<tr class="nocodegen"><td>1983<td>  K: PUInt32Array;
<tr class="covered"><td>1984<td>begin
<tr class="covered"><td>1985<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>1986<td>
<tr class="covered"><td>1987<td>  K := @PUInt32Array(FAdditionalBuffer)[44];
<tr class="covered"><td>1988<td>  SwapUInt32Buffer(Source^, Dest^, 4);
<tr class="covered"><td>1989<td>  A := PUInt32Array(Dest)[0];
<tr class="covered"><td>1990<td>  B := PUInt32Array(Dest)[1];
<tr class="covered"><td>1991<td>  C := PUInt32Array(Dest)[2];
<tr class="covered"><td>1992<td>  D := PUInt32Array(Dest)[3];
<tr class="covered"><td>1993<td>  for I := 0 to 5 do
<tr class="nocodegen"><td>1994<td>  begin
<tr class="covered"><td>1995<td>    T := K[3] + D;
<tr class="covered"><td>1996<td>    T := T shl K[51] or T shr (32 - K[51]);
<tr class="covered"><td>1997<td>    C := C xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>1998<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>1999<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>2000<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2001<td>    T := K[2] xor C;
<tr class="covered"><td>2002<td>    T := T shl K[50] or T shr (32 - K[50]);
<tr class="covered"><td>2003<td>    B := B xor (Cast256_Data[0, T shr 24] -
<tr class="nocodegen"><td>2004<td>                Cast256_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>2005<td>                Cast256_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>2006<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2007<td>    T := K[1] - B;
<tr class="covered"><td>2008<td>    T := T shl K[49] or T shr (32 - K[49]);
<tr class="covered"><td>2009<td>    A := A xor (Cast256_Data[0, T shr 24] +
<tr class="nocodegen"><td>2010<td>                Cast256_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>2011<td>                Cast256_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>2012<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2013<td>    T := K[0] + A;
<tr class="covered"><td>2014<td>    T := T shl K[48] or T shr (32 - K[48]);
<tr class="covered"><td>2015<td>    D := D xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>2016<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>2017<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>2018<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2019<td>    Dec(PUInt32(K), 4);
<tr class="covered"><td>2020<td>  end;
<tr class="covered"><td>2021<td>  for I := 0 to 5 do
<tr class="nocodegen"><td>2022<td>  begin
<tr class="covered"><td>2023<td>    T := K[3] + A;
<tr class="covered"><td>2024<td>    T := T shl K[51] or T shr (32 - K[51]);
<tr class="covered"><td>2025<td>    D := D xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>2026<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>2027<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>2028<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2029<td>    T := K[2] - B;
<tr class="covered"><td>2030<td>    T := T shl K[50] or T shr (32 - K[50]);
<tr class="covered"><td>2031<td>    A := A xor (Cast256_Data[0, T shr 24] +
<tr class="nocodegen"><td>2032<td>                Cast256_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>2033<td>                Cast256_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>2034<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2035<td>    T := K[1] xor C;
<tr class="covered"><td>2036<td>    T := T shl K[49] or T shr (32 - K[49]);
<tr class="covered"><td>2037<td>    B := B xor (Cast256_Data[0, T shr 24] -
<tr class="nocodegen"><td>2038<td>                Cast256_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>2039<td>                Cast256_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>2040<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2041<td>    T := K[0] + D;
<tr class="covered"><td>2042<td>    T := T shl K[48] or T shr (32 - K[48]);
<tr class="covered"><td>2043<td>    C := C xor (Cast256_Data[0, T shr 24] xor
<tr class="nocodegen"><td>2044<td>                Cast256_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>2045<td>                Cast256_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>2046<td>                Cast256_Data[3, T and $FF]);
<tr class="covered"><td>2047<td>    Dec(PUInt32(K), 4);
<tr class="covered"><td>2048<td>  end;
<tr class="covered"><td>2049<td>  PUInt32Array(Dest)[0] := A;
<tr class="covered"><td>2050<td>  PUInt32Array(Dest)[1] := B;
<tr class="covered"><td>2051<td>  PUInt32Array(Dest)[2] := C;
<tr class="covered"><td>2052<td>  PUInt32Array(Dest)[3] := D;
<tr class="covered"><td>2053<td>  SwapUInt32Buffer(Dest^, Dest^, 4);
<tr class="covered"><td>2054<td>end;
<tr class="nocodegen"><td>2055<td>
<tr class="nocodegen"><td>2056<td>{ TCipher_Mars }
<tr class="nocodegen"><td>2057<td>
<tr class="nocodegen"><td>2058<td>class function TCipher_Mars.Context: TCipherContext;
<tr class="covered"><td>2059<td>begin
<tr class="covered"><td>2060<td>  Result.KeySize                     := 56;
<tr class="covered"><td>2061<td>  Result.BlockSize                   := 16;
<tr class="covered"><td>2062<td>  Result.BufferSize                  := 16;
<tr class="covered"><td>2063<td>  Result.AdditionalBufferSize        := 160;
<tr class="covered"><td>2064<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>2065<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>2066<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>2067<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>2068<td>end;
<tr class="nocodegen"><td>2069<td>
<tr class="nocodegen"><td>2070<td>procedure TCipher_Mars.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>2071<td>var
<tr class="nocodegen"><td>2072<td>  B: PUInt32Array;
<tr class="nocodegen"><td>2073<td>
<tr class="nocodegen"><td>2074<td>  function FixKey(K, R: UInt32): UInt32;
<tr class="nocodegen"><td>2075<td>  var
<tr class="nocodegen"><td>2076<td>    M1, M2: UInt32;
<tr class="nocodegen"><td>2077<td>    I: UInt32;
<tr class="covered"><td>2078<td>  begin
<tr class="covered"><td>2079<td>    I := K and 3;
<tr class="covered"><td>2080<td>    K := K or 3;
<tr class="covered"><td>2081<td>    M1 := not K xor (K shl 1);
<tr class="covered"><td>2082<td>    M2 := M1 and (M1 shl 1);
<tr class="covered"><td>2083<td>    M2 := M2 and (M2 shl 2);
<tr class="covered"><td>2084<td>    M2 := M2 and (M2 shl 4);
<tr class="covered"><td>2085<td>    M2 := M2 and (M1 shl 8);
<tr class="covered"><td>2086<td>    M2 := M2 and $FFFFFE00;
<tr class="covered"><td>2087<td>    if M2 = 0 then
<tr class="nocodegen"><td>2088<td>    begin
<tr class="covered"><td>2089<td>      Result := K;
<tr class="covered"><td>2090<td>      Exit;
<tr class="nocodegen"><td>2091<td>    end;
<tr class="covered"><td>2092<td>    M1 := M2 or (M2 shr 1);
<tr class="covered"><td>2093<td>    M1 := M1 or (M1 shr 2);
<tr class="covered"><td>2094<td>    M1 := M1 or (M2 shr 4);
<tr class="covered"><td>2095<td>    M1 := M1 or (M1 shr 5);
<tr class="covered"><td>2096<td>    M1 := M1 and ((not K xor (K shl 1)) and (not K xor (K shr 1)) and $7FFFFFFC);
<tr class="covered"><td>2097<td>    Result := K xor ((B[265 + I] shl R or B[265 + I] shr (32 - R)) and M1);
<tr class="covered"><td>2098<td>  end;
<tr class="nocodegen"><td>2099<td>
<tr class="nocodegen"><td>2100<td>var
<tr class="nocodegen"><td>2101<td>  T: array[0..14] of UInt32;
<tr class="nocodegen"><td>2102<td>  I, J, L: UInt32;
<tr class="nocodegen"><td>2103<td>  U: UInt32;
<tr class="nocodegen"><td>2104<td>  K: PUInt32Array;
<tr class="covered"><td>2105<td>begin
<tr class="covered"><td>2106<td>  K := FAdditionalBuffer;
<tr class="covered"><td>2107<td>  B := @Mars_Data;
<tr class="covered"><td>2108<td>  FillChar(T, SizeOf(T), 0);
<tr class="covered"><td>2109<td>  Move(Key, T, Size);
<tr class="covered"><td>2110<td>  Size := Size div 4;
<tr class="covered"><td>2111<td>  T[Size] := Size;
<tr class="covered"><td>2112<td>  for J := 0 to 3 do
<tr class="nocodegen"><td>2113<td>  begin
<tr class="covered"><td>2114<td>    for I := 0 to 14 do
<tr class="nocodegen"><td>2115<td>    begin
<tr class="covered"><td>2116<td>      U := T[(I + 8) mod 15] xor T[(I + 13) mod 15];
<tr class="covered"><td>2117<td>      T[I] := T[I] xor (U shl 3 or U shr 29) xor (I * 4 + J);
<tr class="covered"><td>2118<td>    end;
<tr class="covered"><td>2119<td>    for L := 0 to 3 do
<tr class="nocodegen"><td>2120<td>    begin
<tr class="covered"><td>2121<td>      for I := 0 to 14 do
<tr class="nocodegen"><td>2122<td>      begin
<tr class="covered"><td>2123<td>        Inc(T[I], B[T[(I + 14) mod 15] and $1FF]);
<tr class="covered"><td>2124<td>        T[I] := T[I] shl 9 or T[I] shr 23;
<tr class="covered"><td>2125<td>      end;
<tr class="covered"><td>2126<td>    end;
<tr class="covered"><td>2127<td>    for I := 0 to 9 do
<tr class="covered"><td>2128<td>      K[(J * 10) + I] := T[(I * 4) mod 15];
<tr class="covered"><td>2129<td>  end;
<tr class="covered"><td>2130<td>  I := 5;
<tr class="nocodegen"><td>2131<td>  repeat
<tr class="covered"><td>2132<td>    K[I] := FixKey(K[I], K[I - 1]);
<tr class="covered"><td>2133<td>    Inc(I, 2);
<tr class="covered"><td>2134<td>  until I &gt;= 37;
<tr class="nocodegen"><td>2135<td>
<tr class="nocodegen"><td>2136<td>  inherited;
<tr class="covered"><td>2137<td>end;
<tr class="nocodegen"><td>2138<td>
<tr class="nocodegen"><td>2139<td>procedure TCipher_Mars.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>2140<td>var
<tr class="nocodegen"><td>2141<td>  K: PUInt32Array;
<tr class="nocodegen"><td>2142<td>  I, L, R, A, B, C, D: UInt32;
<tr class="covered"><td>2143<td>begin
<tr class="covered"><td>2144<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>2145<td>
<tr class="covered"><td>2146<td>  K := FAdditionalBuffer;
<tr class="covered"><td>2147<td>  A := PUInt32Array(Source)[0] + K[0];
<tr class="covered"><td>2148<td>  B := PUInt32Array(Source)[1] + K[1];
<tr class="covered"><td>2149<td>  C := PUInt32Array(Source)[2] + K[2];
<tr class="covered"><td>2150<td>  D := PUInt32Array(Source)[3] + K[3];
<tr class="covered"><td>2151<td>  K := @K[4];
<tr class="covered"><td>2152<td>  for I := 0 to 1 do
<tr class="nocodegen"><td>2153<td>  begin
<tr class="covered"><td>2154<td>    B := B xor Mars_Data[A and $FF] + Mars_Data[A shr 8 and $FF + 256];
<tr class="covered"><td>2155<td>    Inc(C, Mars_Data[A shr 16 and $FF]);
<tr class="covered"><td>2156<td>    D := D xor Mars_Data[A shr 24 + 256];
<tr class="covered"><td>2157<td>    A := (A shr 24 or A shl 8) + D;
<tr class="nocodegen"><td>2158<td>
<tr class="covered"><td>2159<td>    C := C xor Mars_Data[B and $FF] + Mars_Data[B shr 8 and $FF + 256];
<tr class="covered"><td>2160<td>    Inc(D, Mars_Data[B shr 16 and $FF]);
<tr class="covered"><td>2161<td>    A := A xor Mars_Data[B shr 24 + 256];
<tr class="covered"><td>2162<td>    B := (B shr 24 or B shl 8) + C;
<tr class="nocodegen"><td>2163<td>
<tr class="covered"><td>2164<td>    D := D xor Mars_Data[C and $FF] + Mars_Data[C shr 8 and $FF + 256];
<tr class="covered"><td>2165<td>    Inc(A, Mars_Data[C shr 16 and $FF]);
<tr class="covered"><td>2166<td>    B := B xor Mars_Data[C shr 24 + 256];
<tr class="covered"><td>2167<td>    C := C shr 24 or C shl 8;
<tr class="nocodegen"><td>2168<td>
<tr class="covered"><td>2169<td>    A := A xor Mars_Data[D and $FF] + Mars_Data[D shr 8 and $FF + 256];
<tr class="covered"><td>2170<td>    Inc(B, Mars_Data[D shr 16 and $FF]);
<tr class="covered"><td>2171<td>    C := C xor Mars_Data[D shr 24 + 256];
<tr class="covered"><td>2172<td>    D := D shr 24 or D shl 8;
<tr class="covered"><td>2173<td>  end;
<tr class="nocodegen"><td>2174<td>
<tr class="covered"><td>2175<td>  for I := 0 to 3 do
<tr class="nocodegen"><td>2176<td>  begin
<tr class="covered"><td>2177<td>    L := A + K[0];
<tr class="covered"><td>2178<td>    A := A shl 13 or A shr 19;
<tr class="covered"><td>2179<td>    R := A * K[1];
<tr class="covered"><td>2180<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2181<td>    Inc(C, L shl R or L shr (32 - R));
<tr class="covered"><td>2182<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2183<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2184<td>    L := L xor R;
<tr class="covered"><td>2185<td>    L := L shl R or L shr (32 - R);
<tr class="nocodegen"><td>2186<td>
<tr class="covered"><td>2187<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2188<td>    begin
<tr class="covered"><td>2189<td>      Inc(B, L);
<tr class="covered"><td>2190<td>      D := D xor R;
<tr class="nocodegen"><td>2191<td>    end
<tr class="nocodegen"><td>2192<td>    else
<tr class="nocodegen"><td>2193<td>    begin
<tr class="covered"><td>2194<td>      Inc(D, L);
<tr class="covered"><td>2195<td>      B := B xor R;
<tr class="nocodegen"><td>2196<td>    end;
<tr class="covered"><td>2197<td>    L := B + K[2];
<tr class="covered"><td>2198<td>    B := B shl 13 or B shr 19;
<tr class="covered"><td>2199<td>    R := B * K[3];
<tr class="covered"><td>2200<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2201<td>    Inc(D, L shl R or L shr (32 - R));
<tr class="covered"><td>2202<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2203<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2204<td>    L := L xor R;
<tr class="covered"><td>2205<td>    L := L shl R or L shr (32 - R);
<tr class="covered"><td>2206<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2207<td>    begin
<tr class="covered"><td>2208<td>      Inc(C, L);
<tr class="covered"><td>2209<td>      A := A xor R;
<tr class="nocodegen"><td>2210<td>    end
<tr class="nocodegen"><td>2211<td>    else
<tr class="nocodegen"><td>2212<td>    begin
<tr class="covered"><td>2213<td>      Inc(A, L);
<tr class="covered"><td>2214<td>      C := C xor R;
<tr class="nocodegen"><td>2215<td>    end;
<tr class="covered"><td>2216<td>    L := C + K[4];
<tr class="covered"><td>2217<td>    C := C shl 13 or C shr 19;
<tr class="covered"><td>2218<td>    R := C * K[5];
<tr class="covered"><td>2219<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2220<td>    Inc(A, L shl R or L shr (32 - R));
<tr class="covered"><td>2221<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2222<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2223<td>    L := L xor R;
<tr class="covered"><td>2224<td>    L := L shl R or L shr (32 - R);
<tr class="covered"><td>2225<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2226<td>    begin
<tr class="covered"><td>2227<td>      Inc(D, L);
<tr class="covered"><td>2228<td>      B := B xor R;
<tr class="nocodegen"><td>2229<td>    end
<tr class="nocodegen"><td>2230<td>    else
<tr class="nocodegen"><td>2231<td>    begin
<tr class="covered"><td>2232<td>      Inc(B, L);
<tr class="covered"><td>2233<td>      D := D xor R;
<tr class="nocodegen"><td>2234<td>    end;
<tr class="covered"><td>2235<td>    L := D + K[6];
<tr class="covered"><td>2236<td>    D := D shl 13 or D shr 19;
<tr class="covered"><td>2237<td>    R := D * K[7];
<tr class="covered"><td>2238<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2239<td>    Inc(B, L shl R or L shr (32 - R));
<tr class="covered"><td>2240<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2241<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2242<td>    L := L xor R;
<tr class="covered"><td>2243<td>    L := L shl R or L shr (32 - R);
<tr class="covered"><td>2244<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2245<td>    begin
<tr class="covered"><td>2246<td>      Inc(A, L);
<tr class="covered"><td>2247<td>      C := C xor R;
<tr class="nocodegen"><td>2248<td>    end
<tr class="nocodegen"><td>2249<td>    else
<tr class="nocodegen"><td>2250<td>    begin
<tr class="covered"><td>2251<td>      Inc(C, L);
<tr class="covered"><td>2252<td>      A := A xor R;
<tr class="nocodegen"><td>2253<td>    end;
<tr class="covered"><td>2254<td>    K := @K[8];
<tr class="covered"><td>2255<td>  end;
<tr class="covered"><td>2256<td>  for I := 0 to 1 do
<tr class="nocodegen"><td>2257<td>  begin
<tr class="covered"><td>2258<td>    B := B xor Mars_Data[A and $FF + 256];
<tr class="covered"><td>2259<td>    Dec(C, Mars_Data[A shr 24]);
<tr class="covered"><td>2260<td>    D := D - Mars_Data[A shr 16 and $FF + 256] xor Mars_Data[A shr 8 and $FF];
<tr class="covered"><td>2261<td>    A := A shl 24 or A shr 8;
<tr class="covered"><td>2262<td>    C := C xor Mars_Data[B and $FF + 256];
<tr class="covered"><td>2263<td>    Dec(D, Mars_Data[B shr 24]);
<tr class="covered"><td>2264<td>    A := A - Mars_Data[B shr 16 and $FF + 256] xor Mars_Data[B shr 8 and $FF];
<tr class="covered"><td>2265<td>    B := B shl 24 or B shr 8;
<tr class="covered"><td>2266<td>    Dec(C, B);
<tr class="covered"><td>2267<td>    D := D xor Mars_Data[C and $FF + 256];
<tr class="covered"><td>2268<td>    Dec(A, Mars_Data[C shr 24]);
<tr class="covered"><td>2269<td>    B := B - Mars_Data[C shr 16 and $FF + 256] xor Mars_Data[C shr 8 and $FF];
<tr class="covered"><td>2270<td>    C := C shl 24 or C shr 8;
<tr class="covered"><td>2271<td>    Dec(D, A);
<tr class="covered"><td>2272<td>    A := A xor Mars_Data[D and $FF + 256];
<tr class="covered"><td>2273<td>    Dec(B, Mars_Data[D shr 24]);
<tr class="covered"><td>2274<td>    C := C - Mars_Data[D shr 16 and $FF + 256] xor Mars_Data[D shr 8 and $FF];
<tr class="covered"><td>2275<td>    D := D shl 24 or D shr 8;
<tr class="covered"><td>2276<td>  end;
<tr class="covered"><td>2277<td>  PUInt32Array(Dest)[0] := A - K[0];
<tr class="covered"><td>2278<td>  PUInt32Array(Dest)[1] := B - K[1];
<tr class="covered"><td>2279<td>  PUInt32Array(Dest)[2] := C - K[2];
<tr class="covered"><td>2280<td>  PUInt32Array(Dest)[3] := D - K[3];
<tr class="covered"><td>2281<td>end;
<tr class="nocodegen"><td>2282<td>
<tr class="nocodegen"><td>2283<td>procedure TCipher_Mars.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>2284<td>var
<tr class="nocodegen"><td>2285<td>  K: PUInt32Array;
<tr class="nocodegen"><td>2286<td>  I, L, R, A, B, C, D: UInt32;
<tr class="covered"><td>2287<td>begin
<tr class="covered"><td>2288<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>2289<td>
<tr class="covered"><td>2290<td>  K := @PUInt32Array(FAdditionalBuffer)[28];
<tr class="covered"><td>2291<td>  A := PUInt32Array(Source)[0] + K[8];
<tr class="covered"><td>2292<td>  B := PUInt32Array(Source)[1] + K[9];
<tr class="covered"><td>2293<td>  C := PUInt32Array(Source)[2] + K[10];
<tr class="covered"><td>2294<td>  D := PUInt32Array(Source)[3] + K[11];
<tr class="covered"><td>2295<td>  for I := 0 to 1 do
<tr class="nocodegen"><td>2296<td>  begin
<tr class="covered"><td>2297<td>    D := D shr 24 or D shl 8;
<tr class="covered"><td>2298<td>    C := C xor Mars_Data[D shr 8 and $FF] + Mars_Data[D shr 16 and $FF + 256];
<tr class="covered"><td>2299<td>    Inc(B, Mars_Data[D shr 24]);
<tr class="covered"><td>2300<td>    A := A xor Mars_Data[D and $FF + 256];
<tr class="covered"><td>2301<td>    Inc(D, A);
<tr class="covered"><td>2302<td>    C := C shr 24 or C shl 8;
<tr class="covered"><td>2303<td>    B := B xor Mars_Data[C shr 8 and $FF] + Mars_Data[C shr 16 and $FF + 256];
<tr class="covered"><td>2304<td>    Inc(A, Mars_Data[C shr 24]);
<tr class="covered"><td>2305<td>    D := D xor Mars_Data[C and $FF + 256];
<tr class="covered"><td>2306<td>    Inc(C, B);
<tr class="covered"><td>2307<td>    B := B shr 24 or B shl 8;
<tr class="covered"><td>2308<td>    A := A xor Mars_Data[B shr 8 and $FF] + Mars_Data[B shr 16 and $FF + 256];
<tr class="covered"><td>2309<td>    Inc(D, Mars_Data[B shr 24]);
<tr class="covered"><td>2310<td>    C := C xor Mars_Data[B and $FF + 256];
<tr class="covered"><td>2311<td>    A := A shr 24 or A shl 8;
<tr class="covered"><td>2312<td>    D := D xor Mars_Data[A shr 8 and $FF] + Mars_Data[A shr 16 and $FF + 256];
<tr class="covered"><td>2313<td>    Inc(C, Mars_Data[A shr 24]);
<tr class="covered"><td>2314<td>    B := B xor Mars_Data[A and $FF + 256];
<tr class="covered"><td>2315<td>  end;
<tr class="covered"><td>2316<td>  for I := 0 to 3 do
<tr class="nocodegen"><td>2317<td>  begin
<tr class="covered"><td>2318<td>    R := D * K[7];
<tr class="covered"><td>2319<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2320<td>    D := D shr 13 or D shl 19;
<tr class="covered"><td>2321<td>    L := D + K[6];
<tr class="covered"><td>2322<td>    Dec(B, L shl R or L shr (32 - R));
<tr class="covered"><td>2323<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2324<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2325<td>    L := L xor R;
<tr class="covered"><td>2326<td>    L := L shl R or L shr (32 - R);
<tr class="covered"><td>2327<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2328<td>    begin
<tr class="covered"><td>2329<td>      Dec(C, L);
<tr class="covered"><td>2330<td>      A := A xor R;
<tr class="nocodegen"><td>2331<td>    end
<tr class="nocodegen"><td>2332<td>    else
<tr class="nocodegen"><td>2333<td>    begin
<tr class="covered"><td>2334<td>      Dec(A, L);
<tr class="covered"><td>2335<td>      C := C xor R;
<tr class="nocodegen"><td>2336<td>    end;
<tr class="covered"><td>2337<td>    R := C * K[5];
<tr class="covered"><td>2338<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2339<td>    C := C shr 13 or C shl 19;
<tr class="covered"><td>2340<td>    L := C + K[4];
<tr class="covered"><td>2341<td>    Dec(A, L shl R or L shr (32 - R));
<tr class="covered"><td>2342<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2343<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2344<td>    L := L xor R;
<tr class="covered"><td>2345<td>    L := L shl R or L shr (32 - R);
<tr class="covered"><td>2346<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2347<td>    begin
<tr class="covered"><td>2348<td>      Dec(B, L);
<tr class="covered"><td>2349<td>      D := D xor R;
<tr class="nocodegen"><td>2350<td>    end
<tr class="nocodegen"><td>2351<td>    else
<tr class="nocodegen"><td>2352<td>    begin
<tr class="covered"><td>2353<td>      Dec(D, L);
<tr class="covered"><td>2354<td>      B := B xor R;
<tr class="nocodegen"><td>2355<td>    end;
<tr class="covered"><td>2356<td>    R := B * K[3];
<tr class="covered"><td>2357<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2358<td>    B := B shr 13 or B shl 19;
<tr class="covered"><td>2359<td>    L := B + K[2];
<tr class="covered"><td>2360<td>    Dec(D, L shl R or L shr (32 - R));
<tr class="covered"><td>2361<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2362<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2363<td>    L := L xor R;
<tr class="covered"><td>2364<td>    L := L shl R or L shr (32 - R);
<tr class="covered"><td>2365<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2366<td>    begin
<tr class="covered"><td>2367<td>      Dec(A, L);
<tr class="covered"><td>2368<td>      C := C xor R;
<tr class="nocodegen"><td>2369<td>    end
<tr class="nocodegen"><td>2370<td>    else
<tr class="nocodegen"><td>2371<td>    begin
<tr class="covered"><td>2372<td>      Dec(C, L);
<tr class="covered"><td>2373<td>      A := A xor R;
<tr class="nocodegen"><td>2374<td>    end;
<tr class="covered"><td>2375<td>    R := A * K[1];
<tr class="covered"><td>2376<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2377<td>    A := A shr 13 or A shl 19;
<tr class="covered"><td>2378<td>    L := A + K[0];
<tr class="covered"><td>2379<td>    Dec(C, L shl R or L shr (32 - R));
<tr class="covered"><td>2380<td>    L := Mars_Data[L and $1FF] xor R;
<tr class="covered"><td>2381<td>    R := R shl 5 or R shr 27;
<tr class="covered"><td>2382<td>    L := L xor R;
<tr class="covered"><td>2383<td>    L := L shl R or L shr (32 - R);
<tr class="covered"><td>2384<td>    if I &lt;= 1 then
<tr class="nocodegen"><td>2385<td>    begin
<tr class="covered"><td>2386<td>      Dec(D, L);
<tr class="covered"><td>2387<td>      B := B xor R;
<tr class="nocodegen"><td>2388<td>    end
<tr class="nocodegen"><td>2389<td>    else
<tr class="nocodegen"><td>2390<td>    begin
<tr class="covered"><td>2391<td>      Dec(B, L);
<tr class="covered"><td>2392<td>      D := D xor R;
<tr class="nocodegen"><td>2393<td>    end;
<tr class="covered"><td>2394<td>    Dec(PUInt32(K), 8);
<tr class="covered"><td>2395<td>  end;
<tr class="covered"><td>2396<td>  for I := 0 to 1 do
<tr class="nocodegen"><td>2397<td>  begin
<tr class="covered"><td>2398<td>    D := D shl 24 or D shr 8;
<tr class="covered"><td>2399<td>    C := C xor Mars_Data[D shr 24 + 256];
<tr class="covered"><td>2400<td>    Dec(B, Mars_Data[D shr 16 and $FF]);
<tr class="covered"><td>2401<td>    A := A - Mars_Data[D shr 8 and $FF + 256] xor Mars_Data[D and $FF];
<tr class="covered"><td>2402<td>    C := C shl 24 or C shr 8;
<tr class="covered"><td>2403<td>    B := B xor Mars_Data[C shr 24 + 256];
<tr class="covered"><td>2404<td>    Dec(A, Mars_Data[C shr 16 and $FF]);
<tr class="covered"><td>2405<td>    D := D - Mars_Data[C shr 8 and $FF + 256] xor Mars_Data[C and $FF];
<tr class="covered"><td>2406<td>    Dec(B, C);
<tr class="covered"><td>2407<td>    B := B shl 24 or B shr 8;
<tr class="covered"><td>2408<td>    A := A xor Mars_Data[B shr 24 + 256];
<tr class="covered"><td>2409<td>    Dec(D, Mars_Data[B shr 16 and $FF]);
<tr class="covered"><td>2410<td>    C := C - Mars_Data[B shr 8 and $FF + 256] xor Mars_Data[B and $FF];
<tr class="covered"><td>2411<td>    Dec(A, D);
<tr class="covered"><td>2412<td>    A := A shl 24 or A shr 8;
<tr class="covered"><td>2413<td>    D := D xor Mars_Data[A shr 24 + 256];
<tr class="covered"><td>2414<td>    Dec(C, Mars_Data[A shr 16 and $FF]);
<tr class="covered"><td>2415<td>    B := B - Mars_Data[A shr 8 and $FF + 256] xor Mars_Data[A and $FF];
<tr class="covered"><td>2416<td>  end;
<tr class="covered"><td>2417<td>  PUInt32Array(Dest)[0] := A - K[4];
<tr class="covered"><td>2418<td>  PUInt32Array(Dest)[1] := B - K[5];
<tr class="covered"><td>2419<td>  PUInt32Array(Dest)[2] := C - K[6];
<tr class="covered"><td>2420<td>  PUInt32Array(Dest)[3] := D - K[7];
<tr class="covered"><td>2421<td>end;
<tr class="nocodegen"><td>2422<td>
<tr class="nocodegen"><td>2423<td>{ TCipher_RC4 }
<tr class="nocodegen"><td>2424<td>
<tr class="nocodegen"><td>2425<td>class function TCipher_RC4.Context: TCipherContext;
<tr class="covered"><td>2426<td>begin
<tr class="covered"><td>2427<td>  Result.KeySize                     := 256;
<tr class="covered"><td>2428<td>  Result.BlockSize                   := 1;
<tr class="covered"><td>2429<td>  Result.BufferSize                  := 16;
<tr class="covered"><td>2430<td>  Result.AdditionalBufferSize        := 256 + 2;
<tr class="covered"><td>2431<td>  Result.NeedsAdditionalBufferBackup := true;
<tr class="covered"><td>2432<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>2433<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>2434<td>  Result.CipherType                  := [ctSymmetric, ctStream];
<tr class="covered"><td>2435<td>end;
<tr class="nocodegen"><td>2436<td>
<tr class="nocodegen"><td>2437<td>procedure TCipher_RC4.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>2438<td>var
<tr class="nocodegen"><td>2439<td>  K: array[0..255] of Byte;
<tr class="nocodegen"><td>2440<td>  D: PByteArray;
<tr class="nocodegen"><td>2441<td>  I, J, T: Byte;
<tr class="covered"><td>2442<td>begin
<tr class="covered"><td>2443<td>  D := FAdditionalBuffer;
<tr class="covered"><td>2444<td>  for I := 0 to 255 do
<tr class="nocodegen"><td>2445<td>  begin
<tr class="covered"><td>2446<td>    D[I] := I;
<tr class="covered"><td>2447<td>    if Size &gt; 0 then
<tr class="covered"><td>2448<td>      K[I] := TByteArray(Key)[I mod Size];
<tr class="covered"><td>2449<td>  end;
<tr class="covered"><td>2450<td>  J := 0;
<tr class="covered"><td>2451<td>  for I := 0 to 255 do
<tr class="nocodegen"><td>2452<td>  begin
<tr class="covered"><td>2453<td>    J := J + D[I] + K[I];
<tr class="covered"><td>2454<td>    T := D[I];
<tr class="covered"><td>2455<td>    D[I] := D[J];
<tr class="covered"><td>2456<td>    D[J] := T;
<tr class="covered"><td>2457<td>  end;
<tr class="covered"><td>2458<td>  D[256] := 0;
<tr class="covered"><td>2459<td>  D[257] := 0;
<tr class="covered"><td>2460<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>2461<td>
<tr class="nocodegen"><td>2462<td>  inherited;
<tr class="covered"><td>2463<td>end;
<tr class="nocodegen"><td>2464<td>
<tr class="nocodegen"><td>2465<td>procedure TCipher_RC4.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>2466<td>var
<tr class="nocodegen"><td>2467<td>  D: PByteArray;
<tr class="nocodegen"><td>2468<td>  S: Integer;
<tr class="nocodegen"><td>2469<td>  T, I, J: Byte;
<tr class="covered"><td>2470<td>begin
<tr class="covered"><td>2471<td>  D := FAdditionalBuffer;
<tr class="covered"><td>2472<td>  I := D[256];
<tr class="covered"><td>2473<td>  J := D[257];
<tr class="covered"><td>2474<td>  for S := 0 to Size - 1 do
<tr class="nocodegen"><td>2475<td>  begin
<tr class="covered"><td>2476<td>    Inc(I);
<tr class="covered"><td>2477<td>    T := D[I];
<tr class="covered"><td>2478<td>    Inc(J, T);
<tr class="covered"><td>2479<td>    D[I] := D[J];
<tr class="covered"><td>2480<td>    D[J] := T;
<tr class="covered"><td>2481<td>    PByteArray(Dest)[S] := PByteArray(Source)[S] xor D[Byte(D[I] + T)];
<tr class="covered"><td>2482<td>  end;
<tr class="covered"><td>2483<td>  D[256] := I;
<tr class="covered"><td>2484<td>  D[257] := J;
<tr class="covered"><td>2485<td>end;
<tr class="nocodegen"><td>2486<td>
<tr class="nocodegen"><td>2487<td>procedure TCipher_RC4.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>2488<td>begin
<tr class="covered"><td>2489<td>  DoEncode(Source, Dest, Size);
<tr class="covered"><td>2490<td>end;
<tr class="nocodegen"><td>2491<td>
<tr class="nocodegen"><td>2492<td>{ TCipher_RC6 }
<tr class="nocodegen"><td>2493<td>
<tr class="nocodegen"><td>2494<td>class function TCipher_RC6.Context: TCipherContext;
<tr class="covered"><td>2495<td>begin
<tr class="covered"><td>2496<td>  Result.KeySize                     := 256;
<tr class="covered"><td>2497<td>  Result.BlockSize                   := 16;
<tr class="covered"><td>2498<td>  Result.BufferSize                  := 16;
<tr class="covered"><td>2499<td>  Result.AdditionalBufferSize        := 272;
<tr class="covered"><td>2500<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>2501<td>  Result.MinRounds                   := 16;
<tr class="covered"><td>2502<td>  Result.MaxRounds                   := 24;
<tr class="covered"><td>2503<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>2504<td>end;
<tr class="nocodegen"><td>2505<td>
<tr class="nocodegen"><td>2506<td>procedure TCipher_RC6.SetRounds(Value: Integer);
<tr class="covered"><td>2507<td>begin
<tr class="covered"><td>2508<td>  if Value &lt; Context.MinRounds then
<tr class="covered"><td>2509<td>    Value := Context.MinRounds
<tr class="nocodegen"><td>2510<td>  else
<tr class="covered"><td>2511<td>  if Value &gt; Context.MaxRounds then
<tr class="covered"><td>2512<td>    Value := Context.MaxRounds;
<tr class="covered"><td>2513<td>  if Value &lt;&gt; FRounds then
<tr class="nocodegen"><td>2514<td>  begin
<tr class="covered"><td>2515<td>    if not (FState in [csNew, csInitialized, csDone]) then
<tr class="notcovered"><td>2516<td>      Done;
<tr class="covered"><td>2517<td>    FRounds := Value;
<tr class="nocodegen"><td>2518<td>  end;
<tr class="covered"><td>2519<td>end;
<tr class="nocodegen"><td>2520<td>
<tr class="nocodegen"><td>2521<td>procedure TCipher_RC6.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>2522<td>var
<tr class="nocodegen"><td>2523<td>  K: array[0..63] of UInt32;
<tr class="nocodegen"><td>2524<td>  D: PUInt32Array;
<tr class="nocodegen"><td>2525<td>  I, J, L, A, B, Z, T: UInt32;
<tr class="covered"><td>2526<td>begin
<tr class="covered"><td>2527<td>  LimitRounds;
<tr class="nocodegen"><td>2528<td>
<tr class="covered"><td>2529<td>  D := FAdditionalBuffer;
<tr class="covered"><td>2530<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>2531<td>  Move(Key, K, Size);
<tr class="covered"><td>2532<td>  L := Size shr 2;
<tr class="covered"><td>2533<td>  if Size and 3 &lt;&gt; 0 then
<tr class="covered"><td>2534<td>    Inc(L);
<tr class="covered"><td>2535<td>  if L &lt;= 0 then
<tr class="notcovered"><td>2536<td>    L := 1;
<tr class="covered"><td>2537<td>  J := $B7E15163;
<tr class="covered"><td>2538<td>  for I := 0 to (FRounds + 2) * 2 do
<tr class="nocodegen"><td>2539<td>  begin
<tr class="covered"><td>2540<td>    D[I] := J;
<tr class="covered"><td>2541<td>    Inc(J, $9E3779B9);
<tr class="covered"><td>2542<td>  end;
<tr class="covered"><td>2543<td>  if L &gt; UInt32(FRounds + 2) * 2 then
<tr class="notcovered"><td>2544<td>    Z := L * 3
<tr class="nocodegen"><td>2545<td>  else
<tr class="covered"><td>2546<td>    Z := (FRounds + 2) * 6;
<tr class="covered"><td>2547<td>  I := 0;
<tr class="covered"><td>2548<td>  J := 0;
<tr class="covered"><td>2549<td>  A := 0;
<tr class="covered"><td>2550<td>  B := 0;
<tr class="covered"><td>2551<td>  for Z := Z downto 1 do
<tr class="nocodegen"><td>2552<td>  begin
<tr class="covered"><td>2553<td>    A := A + B + D[I];
<tr class="covered"><td>2554<td>    A := A shl 3 or A shr 29;
<tr class="covered"><td>2555<td>    D[I] := A;
<tr class="covered"><td>2556<td>    T := A + B;
<tr class="covered"><td>2557<td>    B := T + K[J];
<tr class="covered"><td>2558<td>    B := B shl T or B shr (32 - T);
<tr class="covered"><td>2559<td>    K[J] := B;
<tr class="covered"><td>2560<td>    I := (I + 1) mod (UInt32(FRounds + 2) * 2);
<tr class="covered"><td>2561<td>    J := (J + 1) mod L;
<tr class="covered"><td>2562<td>  end;
<tr class="covered"><td>2563<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>2564<td>
<tr class="nocodegen"><td>2565<td>  inherited;
<tr class="covered"><td>2566<td>end;
<tr class="nocodegen"><td>2567<td>
<tr class="nocodegen"><td>2568<td>procedure TCipher_RC6.LimitRounds;
<tr class="covered"><td>2569<td>begin
<tr class="covered"><td>2570<td>  if FRounds = 0 then
<tr class="covered"><td>2571<td>    FRounds := 20
<tr class="nocodegen"><td>2572<td>  else
<tr class="notcovered"><td>2573<td>  if FRounds &lt; 16 then
<tr class="notcovered"><td>2574<td>    FRounds := 16
<tr class="nocodegen"><td>2575<td>  else
<tr class="notcovered"><td>2576<td>  if FRounds &gt; 24 then
<tr class="notcovered"><td>2577<td>    FRounds := 24;
<tr class="notcovered"><td>2578<td>end;
<tr class="nocodegen"><td>2579<td>
<tr class="nocodegen"><td>2580<td>procedure TCipher_RC6.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>2581<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>2582<td>asm
<tr class="nocodegen"><td>2583<td>      PUSH  EBX
<tr class="nocodegen"><td>2584<td>      PUSH  ESI
<tr class="nocodegen"><td>2585<td>      PUSH  EDI
<tr class="nocodegen"><td>2586<td>      PUSH  EBP
<tr class="nocodegen"><td>2587<td>      PUSH  ECX
<tr class="nocodegen"><td>2588<td>      MOV   EBP,[EAX].TCipher_RC6.FRounds           // Rounds
<tr class="nocodegen"><td>2589<td>      MOV   ESI,[EAX].TCipher_RC6.FAdditionalBuffer // Key
<tr class="nocodegen"><td>2590<td>      MOV   EAX,[EDX +  0]    // A
<tr class="nocodegen"><td>2591<td>      MOV   EBX,[EDX +  4]    // B
<tr class="nocodegen"><td>2592<td>      MOV   EDI,[EDX +  8]    // C
<tr class="nocodegen"><td>2593<td>      MOV   EDX,[EDX + 12]    // D
<tr class="nocodegen"><td>2594<td>      ADD   EBX,[ESI + 0]     // Inc(B, K[0])
<tr class="nocodegen"><td>2595<td>      ADD   EDX,[ESI + 4]     // Inc(D, K[1])
<tr class="nocodegen"><td>2596<td>      ADD   ESI,8             // Inc(PInteger(K), 2)
<tr class="nocodegen"><td>2597<td>@@1:  LEA   ECX,[EBX * 2 + 1] // ECX := B * 2 + 1
<tr class="nocodegen"><td>2598<td>      IMUL  ECX,EBX           // ECX := ECX * B
<tr class="nocodegen"><td>2599<td>      ROL   ECX,5             // T := ROL(B * (B * 2 + 1), 5)
<tr class="nocodegen"><td>2600<td>      PUSH  ECX               // save T
<tr class="nocodegen"><td>2601<td>      XOR   EAX,ECX           // A := A xor T
<tr class="nocodegen"><td>2602<td>      LEA   ECX,[EDX * 2 + 1] // ECX := D * 2 + 1
<tr class="nocodegen"><td>2603<td>      IMUL  ECX,EDX           // ECX := ECX * D
<tr class="nocodegen"><td>2604<td>      ROL   ECX,5             // U := ROL(D * (D * 2 + 1), 5)
<tr class="nocodegen"><td>2605<td>      XOR   EDI,ECX           // C := C xor U
<tr class="nocodegen"><td>2606<td>      ROL   EAX,CL            // A := ROL(A xor T, U)
<tr class="nocodegen"><td>2607<td>      POP   ECX               // restore T
<tr class="nocodegen"><td>2608<td>      ADD   EAX,[ESI + 0]     // Inc(A, K[0])
<tr class="nocodegen"><td>2609<td>      ROL   EDI,CL            // C := ROL(C xor U, T)
<tr class="nocodegen"><td>2610<td>      MOV   ECX,EAX           // T := A
<tr class="nocodegen"><td>2611<td>      ADD   EDI,[ESI + 4]     // Inc(C, K[1])
<tr class="nocodegen"><td>2612<td>      MOV   EAX,EBX           // A := B
<tr class="nocodegen"><td>2613<td>      MOV   EBX,EDI           // B := C
<tr class="nocodegen"><td>2614<td>      MOV   EDI,EDX           // C := D
<tr class="nocodegen"><td>2615<td>      DEC   EBP
<tr class="nocodegen"><td>2616<td>      MOV   EDX,ECX           // D := T;
<tr class="nocodegen"><td>2617<td>      LEA   ESI,[ESI + 8]     // Inc(PInteger(K), 2)
<tr class="nocodegen"><td>2618<td>      JNZ   @@1
<tr class="nocodegen"><td>2619<td>      ADD   EAX,[ESI + 0]     // Inc(A, K[0])
<tr class="nocodegen"><td>2620<td>      ADD   EDI,[ESI + 4]     // Inc(C, K[1])
<tr class="nocodegen"><td>2621<td>      POP   ECX
<tr class="nocodegen"><td>2622<td>      MOV   [ECX +  0],EAX    // A
<tr class="nocodegen"><td>2623<td>      MOV   [ECX +  4],EBX    // B
<tr class="nocodegen"><td>2624<td>      MOV   [ECX +  8],EDI    // C
<tr class="nocodegen"><td>2625<td>      MOV   [ECX + 12],EDX    // D
<tr class="nocodegen"><td>2626<td>      POP   EBP
<tr class="nocodegen"><td>2627<td>      POP   EDI
<tr class="nocodegen"><td>2628<td>      POP   ESI
<tr class="nocodegen"><td>2629<td>      POP   EBX
<tr class="nocodegen"><td>2630<td>end;
<tr class="nocodegen"><td>2631<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>2632<td>var
<tr class="nocodegen"><td>2633<td>  K: PUInt32Array;
<tr class="nocodegen"><td>2634<td>  I, T, U, A, B, C, D: UInt32;
<tr class="covered"><td>2635<td>begin
<tr class="covered"><td>2636<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>2637<td>
<tr class="covered"><td>2638<td>  K := Pointer(FAdditionalBuffer);
<tr class="covered"><td>2639<td>  A := PUInt32Array(Source)[0];
<tr class="covered"><td>2640<td>  B := PUInt32Array(Source)[1] + K[0];
<tr class="covered"><td>2641<td>  C := PUInt32Array(Source)[2];
<tr class="covered"><td>2642<td>  D := PUInt32Array(Source)[3] + K[1];
<tr class="covered"><td>2643<td>  for I := 1 to FRounds do
<tr class="nocodegen"><td>2644<td>  begin
<tr class="covered"><td>2645<td>    K := @K[2];
<tr class="covered"><td>2646<td>    T := B * (B + B + 1);
<tr class="covered"><td>2647<td>    T := T shl 5 or T shr 27;
<tr class="covered"><td>2648<td>    U := D * (D + D + 1);
<tr class="covered"><td>2649<td>    U := U shl 5 or U shr 27;
<tr class="covered"><td>2650<td>    A := A xor T;
<tr class="covered"><td>2651<td>    A := A shl U or A shr (32 - U) + K[0];
<tr class="covered"><td>2652<td>    C := C xor U;
<tr class="covered"><td>2653<td>    C := C shl T or C shr (32 - T) + K[1];
<tr class="covered"><td>2654<td>    T := A; A := B; B := C; C := D; D := T;
<tr class="covered"><td>2655<td>  end;
<tr class="covered"><td>2656<td>  PUInt32Array(Dest)[0] := A + K[2];
<tr class="covered"><td>2657<td>  PUInt32Array(Dest)[1] := B;
<tr class="covered"><td>2658<td>  PUInt32Array(Dest)[2] := C + K[3];
<tr class="covered"><td>2659<td>  PUInt32Array(Dest)[3] := D;
<tr class="covered"><td>2660<td>end;
<tr class="nocodegen"><td>2661<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>2662<td>
<tr class="nocodegen"><td>2663<td>procedure TCipher_RC6.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>2664<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>2665<td>asm
<tr class="nocodegen"><td>2666<td>      PUSH  EBX
<tr class="nocodegen"><td>2667<td>      PUSH  ESI
<tr class="nocodegen"><td>2668<td>      PUSH  EDI
<tr class="nocodegen"><td>2669<td>      PUSH  EBP
<tr class="nocodegen"><td>2670<td>      PUSH  ECX
<tr class="nocodegen"><td>2671<td>      MOV   EBP,[EAX].TCipher_RC6.FRounds           // Rounds
<tr class="nocodegen"><td>2672<td>      MOV   ESI,[EAX].TCipher_RC6.FAdditionalBuffer // Key
<tr class="nocodegen"><td>2673<td>      LEA   ESI,[ESI + EBP * 8]                     // Key[FRounds * 2]
<tr class="nocodegen"><td>2674<td>      MOV   EAX,[EDX +  0]    // A
<tr class="nocodegen"><td>2675<td>      MOV   EBX,[EDX +  4]    // B
<tr class="nocodegen"><td>2676<td>      MOV   EDI,[EDX +  8]    // C
<tr class="nocodegen"><td>2677<td>      MOV   EDX,[EDX + 12]    // D
<tr class="nocodegen"><td>2678<td>      SUB   EDI,[ESI + 12]    // Dec(C, K[3])
<tr class="nocodegen"><td>2679<td>      SUB   EAX,[ESI +  8]    // Dec(A, K[2])
<tr class="nocodegen"><td>2680<td>@@1:  MOV   ECX,EAX           // T := A
<tr class="nocodegen"><td>2681<td>      SUB   EDX,[ESI + 0]     // Dec(A, K[0])
<tr class="nocodegen"><td>2682<td>      MOV   EAX,EDX           // A := D
<tr class="nocodegen"><td>2683<td>      MOV   EDX,EDI           // D := C
<tr class="nocodegen"><td>2684<td>      SUB   EBX,[ESI + 4]     // Dec(C, K[1])
<tr class="nocodegen"><td>2685<td>      MOV   EDI,EBX           // C := B
<tr class="nocodegen"><td>2686<td>      MOV   EBX,ECX           // B := T;
<tr class="nocodegen"><td>2687<td>      LEA   ECX,[EDX * 2 + 1] // ECX := D * 2 + 1
<tr class="nocodegen"><td>2688<td>      IMUL  ECX,EDX           // ECX := ECX * D
<tr class="nocodegen"><td>2689<td>      ROL   ECX,5             // U := ROL(D * (D * 2 + 1), 5)
<tr class="nocodegen"><td>2690<td>      PUSH  ECX               // save U
<tr class="nocodegen"><td>2691<td>      ROR   EAX,CL            // A := ROR(A - K[0], U)
<tr class="nocodegen"><td>2692<td>      LEA   ECX,[EBX * 2 + 1] // ECX := B * 2 + 1
<tr class="nocodegen"><td>2693<td>      IMUL  ECX,EBX           // ECX := ECX * B
<tr class="nocodegen"><td>2694<td>      ROL   ECX,5             // T := ROL(B * (B * 2 + 1), 5)
<tr class="nocodegen"><td>2695<td>      XOR   EAX,ECX           // A := A xor T
<tr class="nocodegen"><td>2696<td>      ROR   EDI,CL            // C := ROR(C - K[1], T)
<tr class="nocodegen"><td>2697<td>      POP   ECX               // restore U
<tr class="nocodegen"><td>2698<td>      XOR   EDI,ECX           // C := C xor U
<tr class="nocodegen"><td>2699<td>      DEC   EBP
<tr class="nocodegen"><td>2700<td>      LEA   ESI,[ESI - 8]     // Dec(PInteger(K), 2)
<tr class="nocodegen"><td>2701<td>      JNZ   @@1
<tr class="nocodegen"><td>2702<td>      SUB   EBX,[ESI + 0]     // Dec(B, K[0])
<tr class="nocodegen"><td>2703<td>      SUB   EDX,[ESI + 4]     // Inc(D, K[1])
<tr class="nocodegen"><td>2704<td>      POP   ECX
<tr class="nocodegen"><td>2705<td>      MOV   [ECX +  0],EAX    // A
<tr class="nocodegen"><td>2706<td>      MOV   [ECX +  4],EBX    // B
<tr class="nocodegen"><td>2707<td>      MOV   [ECX +  8],EDI    // C
<tr class="nocodegen"><td>2708<td>      MOV   [ECX + 12],EDX    // D
<tr class="nocodegen"><td>2709<td>      POP   EBP
<tr class="nocodegen"><td>2710<td>      POP   EDI
<tr class="nocodegen"><td>2711<td>      POP   ESI
<tr class="nocodegen"><td>2712<td>      POP   EBX
<tr class="nocodegen"><td>2713<td>end;
<tr class="nocodegen"><td>2714<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>2715<td>var
<tr class="nocodegen"><td>2716<td>  I, U, T, A, B, C, D: UInt32;
<tr class="nocodegen"><td>2717<td>  K: PUInt32Array;
<tr class="covered"><td>2718<td>begin
<tr class="covered"><td>2719<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>2720<td>
<tr class="covered"><td>2721<td>  K := @PUInt32Array(FAdditionalBuffer)[FRounds * 2];
<tr class="covered"><td>2722<td>  A := PUInt32Array(Source)[0] - K[2];
<tr class="covered"><td>2723<td>  B := PUInt32Array(Source)[1];
<tr class="covered"><td>2724<td>  C := PUInt32Array(Source)[2] - K[3];
<tr class="covered"><td>2725<td>  D := PUInt32Array(Source)[3];
<tr class="nocodegen"><td>2726<td>
<tr class="covered"><td>2727<td>  for I := 1 to FRounds do
<tr class="nocodegen"><td>2728<td>  begin
<tr class="covered"><td>2729<td>    T := A; A := D; D := C; C := B; B := T;
<tr class="covered"><td>2730<td>    U := D * (D + D + 1);
<tr class="covered"><td>2731<td>    U := U shl 5 or U shr 27;
<tr class="covered"><td>2732<td>    T := B * (B + B + 1);
<tr class="covered"><td>2733<td>    T := T shl 5 or T shr 27;
<tr class="covered"><td>2734<td>    C := C - K[1];
<tr class="covered"><td>2735<td>    C := C shr T or C shl (32 - T) xor U;
<tr class="covered"><td>2736<td>    A := A - K[0];
<tr class="covered"><td>2737<td>    A := A shr U or A shl (32 - U) xor T;
<tr class="covered"><td>2738<td>    Dec(PUInt32(K), 2);
<tr class="covered"><td>2739<td>  end;
<tr class="nocodegen"><td>2740<td>
<tr class="covered"><td>2741<td>  PUInt32Array(Dest)[0] := A;
<tr class="covered"><td>2742<td>  PUInt32Array(Dest)[1] := B - K[0];
<tr class="covered"><td>2743<td>  PUInt32Array(Dest)[2] := C;
<tr class="covered"><td>2744<td>  PUInt32Array(Dest)[3] := D - K[1];
<tr class="covered"><td>2745<td>end;
<tr class="nocodegen"><td>2746<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>2747<td>
<tr class="nocodegen"><td>2748<td>{ TCipher_Rijndael }
<tr class="nocodegen"><td>2749<td>
<tr class="nocodegen"><td>2750<td>class function TCipher_Rijndael.Context: TCipherContext;
<tr class="nocodegen"><td>2751<td>const
<tr class="nocodegen"><td>2752<td>  // don't change this!
<tr class="nocodegen"><td>2753<td>  Rijndael_Blocks =  4;
<tr class="nocodegen"><td>2754<td>  Rijndael_Rounds = 14;
<tr class="covered"><td>2755<td>begin
<tr class="covered"><td>2756<td>  Result.KeySize                     := 32;
<tr class="covered"><td>2757<td>  Result.BlockSize                   := Rijndael_Blocks * 4;
<tr class="covered"><td>2758<td>  Result.BufferSize                  := Rijndael_Blocks * 4;
<tr class="covered"><td>2759<td>  Result.AdditionalBufferSize        := (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(UInt32) * 2;
<tr class="covered"><td>2760<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>2761<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>2762<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>2763<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>2764<td>end;
<tr class="nocodegen"><td>2765<td>
<tr class="nocodegen"><td>2766<td>procedure TCipher_Rijndael.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>2767<td>{$REGION OldKeyShedule}
<tr class="nocodegen"><td>2768<td>{
<tr class="nocodegen"><td>2769<td>  // Old Rijndael Key Scheduling:
<tr class="nocodegen"><td>2770<td>
<tr class="nocodegen"><td>2771<td>  procedure BuildEncodeKey;
<tr class="nocodegen"><td>2772<td>  const
<tr class="nocodegen"><td>2773<td>    RND_Data: array[0..29] of Byte = (
<tr class="nocodegen"><td>2774<td>      $01, $02, $04, $08, $10, $20, $40, $80, $1B, $36, $6C, $D8, $AB, $4D, $9A,
<tr class="nocodegen"><td>2775<td>      $2F, $5E, $BC, $63, $C6, $97, $35, $6A, $D4, $B3, $7D, $FA, $EF, $C5, $91
<tr class="nocodegen"><td>2776<td>    );
<tr class="nocodegen"><td>2777<td>  var
<tr class="nocodegen"><td>2778<td>    T, R: Integer;
<tr class="nocodegen"><td>2779<td>
<tr class="nocodegen"><td>2780<td>    procedure NextRounds;
<tr class="nocodegen"><td>2781<td>    var
<tr class="nocodegen"><td>2782<td>      J: Integer;
<tr class="nocodegen"><td>2783<td>    begin
<tr class="nocodegen"><td>2784<td>      J := 0;
<tr class="nocodegen"><td>2785<td>      while (J &lt; FRounds - 6) and (R &lt;= FRounds) do
<tr class="nocodegen"><td>2786<td>      begin
<tr class="nocodegen"><td>2787<td>        while (J &lt; FRounds - 6) and (T &lt; Rijndael_Blocks) do
<tr class="nocodegen"><td>2788<td>        begin
<tr class="nocodegen"><td>2789<td>          PUInt32Array(FBuffer)[R * Rijndael_Blocks + T] := K[J];
<tr class="nocodegen"><td>2790<td>          Inc(J);
<tr class="nocodegen"><td>2791<td>          Inc(T);
<tr class="nocodegen"><td>2792<td>        end;
<tr class="nocodegen"><td>2793<td>        if T = Rijndael_Blocks then
<tr class="nocodegen"><td>2794<td>        begin
<tr class="nocodegen"><td>2795<td>          T := 0;
<tr class="nocodegen"><td>2796<td>          Inc(R);
<tr class="nocodegen"><td>2797<td>        end;
<tr class="nocodegen"><td>2798<td>      end;
<tr class="nocodegen"><td>2799<td>    end;
<tr class="nocodegen"><td>2800<td>
<tr class="nocodegen"><td>2801<td>  var
<tr class="nocodegen"><td>2802<td>    RND: PByte;
<tr class="nocodegen"><td>2803<td>    B: PByte;
<tr class="nocodegen"><td>2804<td>    I: Integer;
<tr class="nocodegen"><td>2805<td>  begin
<tr class="nocodegen"><td>2806<td>    R := 0;
<tr class="nocodegen"><td>2807<td>    T := 0;
<tr class="nocodegen"><td>2808<td>    RND := @RND_Data;
<tr class="nocodegen"><td>2809<td>    NextRounds;
<tr class="nocodegen"><td>2810<td>    while R &lt;= FRounds do
<tr class="nocodegen"><td>2811<td>    begin
<tr class="nocodegen"><td>2812<td>      B  := @K;
<tr class="nocodegen"><td>2813<td>      B^ := B^ xor Rijndael_S[0, K[FRounds - 7] shr  8 and $FF] xor RND^; Inc(B);
<tr class="nocodegen"><td>2814<td>      B^ := B^ xor Rijndael_S[0, K[FRounds - 7] shr 16 and $FF];          Inc(B);
<tr class="nocodegen"><td>2815<td>      B^ := B^ xor Rijndael_S[0, K[FRounds - 7] shr 24];                  Inc(B);
<tr class="nocodegen"><td>2816<td>      B^ := B^ xor Rijndael_S[0, K[FRounds - 7] and $FF];
<tr class="nocodegen"><td>2817<td>      Inc(RND);
<tr class="nocodegen"><td>2818<td>      if FRounds = 14 then
<tr class="nocodegen"><td>2819<td>      begin
<tr class="nocodegen"><td>2820<td>        for I := 1 to 7 do
<tr class="nocodegen"><td>2821<td>          K[I] := K[I] xor K[I - 1];
<tr class="nocodegen"><td>2822<td>        B  := @K[4];
<tr class="nocodegen"><td>2823<td>        B^ := B^ xor Rijndael_S[0, K[3] and $FF];         Inc(B);
<tr class="nocodegen"><td>2824<td>        B^ := B^ xor Rijndael_S[0, K[3] shr  8 and $FF];  Inc(B);
<tr class="nocodegen"><td>2825<td>        B^ := B^ xor Rijndael_S[0, K[3] shr 16 and $FF];  Inc(B);
<tr class="nocodegen"><td>2826<td>        B^ := B^ xor Rijndael_S[0, K[3] shr 24];
<tr class="nocodegen"><td>2827<td>        for I := 5 to 7 do
<tr class="nocodegen"><td>2828<td>          K[I] := K[I] xor K[I - 1];
<tr class="nocodegen"><td>2829<td>      end
<tr class="nocodegen"><td>2830<td>      else
<tr class="nocodegen"><td>2831<td>        for I := 1 to FRounds - 7 do
<tr class="nocodegen"><td>2832<td>          K[I] := K[I] xor K[I - 1];
<tr class="nocodegen"><td>2833<td>      NextRounds;
<tr class="nocodegen"><td>2834<td>    end;
<tr class="nocodegen"><td>2835<td>  end;
<tr class="nocodegen"><td>2836<td>
<tr class="nocodegen"><td>2837<td>  procedure BuildDecodeKey;
<tr class="nocodegen"><td>2838<td>  var
<tr class="nocodegen"><td>2839<td>    I: Integer;
<tr class="nocodegen"><td>2840<td>    D: PUInt32;
<tr class="nocodegen"><td>2841<td>  begin
<tr class="nocodegen"><td>2842<td>    D := Pointer(PAnsiChar(FBuffer) + FBufferSize shr 1); // for Pointer Math
<tr class="nocodegen"><td>2843<td>    Move(FBuffer^, D^, FBufferSize shr 1);
<tr class="nocodegen"><td>2844<td>    Inc(D, 4);
<tr class="nocodegen"><td>2845<td>    for I := 0 to FRounds * 4 - 5 do
<tr class="nocodegen"><td>2846<td>    begin
<tr class="nocodegen"><td>2847<td>      D^ :=  Rijndael_Key[D^ and $FF] xor
<tr class="nocodegen"><td>2848<td>            (Rijndael_Key[D^ shr  8 and $FF] shl  8 or Rijndael_Key[D^ shr  8 and $FF] shr 24) xor
<tr class="nocodegen"><td>2849<td>            (Rijndael_Key[D^ shr 16 and $FF] shl 16 or Rijndael_Key[D^ shr 16 and $FF] shr 16) xor
<tr class="nocodegen"><td>2850<td>            (Rijndael_Key[D^ shr 24]         shl 24 or Rijndael_Key[D^ shr 24]          shr 8);
<tr class="nocodegen"><td>2851<td>      Inc(D);
<tr class="nocodegen"><td>2852<td>    end;
<tr class="nocodegen"><td>2853<td>  end; }
<tr class="nocodegen"><td>2854<td>{$ENDREGION}
<tr class="nocodegen"><td>2855<td>
<tr class="covered"><td>2856<td>begin
<tr class="covered"><td>2857<td>  if Size &lt;= 16 then
<tr class="covered"><td>2858<td>    FRounds := 10
<tr class="nocodegen"><td>2859<td>  else
<tr class="covered"><td>2860<td>  if Size &lt;= 24 then
<tr class="covered"><td>2861<td>    FRounds := 12
<tr class="nocodegen"><td>2862<td>  else
<tr class="covered"><td>2863<td>    FRounds := 14;
<tr class="covered"><td>2864<td>  FillChar(FAdditionalBuffer^, 32, 0);
<tr class="covered"><td>2865<td>  Move(Key, FAdditionalBuffer^, Size);
<tr class="covered"><td>2866<td>  BuildEncodeKey(Size);
<tr class="covered"><td>2867<td>  BuildDecodeKey;
<tr class="nocodegen"><td>2868<td>
<tr class="nocodegen"><td>2869<td>  inherited;
<tr class="covered"><td>2870<td>end;
<tr class="nocodegen"><td>2871<td>
<tr class="nocodegen"><td>2872<td>procedure TCipher_Rijndael.BuildEncodeKey(KeySize:Integer);
<tr class="nocodegen"><td>2873<td>var
<tr class="nocodegen"><td>2874<td>  I: Integer;
<tr class="nocodegen"><td>2875<td>  T: UInt32;
<tr class="nocodegen"><td>2876<td>  P: PUInt32Array;
<tr class="covered"><td>2877<td>begin
<tr class="covered"><td>2878<td>  P := FAdditionalBuffer;
<tr class="covered"><td>2879<td>  if KeySize &lt;= 16 then
<tr class="nocodegen"><td>2880<td>  begin
<tr class="covered"><td>2881<td>    for I := 0 to 9 do
<tr class="nocodegen"><td>2882<td>    begin
<tr class="covered"><td>2883<td>      T := P[3];
<tr class="covered"><td>2884<td>      P[4] := Rijndael_S[0, T shr  8 and $FF]        xor
<tr class="nocodegen"><td>2885<td>              Rijndael_S[0, T shr 16 and $FF] shl  8 xor
<tr class="nocodegen"><td>2886<td>              Rijndael_S[0, T shr 24        ] shl 16 xor
<tr class="nocodegen"><td>2887<td>              Rijndael_S[0, T        and $FF] shl 24 xor P[0] xor RijndaelEncryptionSheduleConst[I];
<tr class="covered"><td>2888<td>      P[5] := P[1] xor P[4];
<tr class="covered"><td>2889<td>      P[6] := P[2] xor P[5];
<tr class="covered"><td>2890<td>      P[7] := P[3] xor P[6];
<tr class="covered"><td>2891<td>      P    := @P[4];
<tr class="covered"><td>2892<td>    end;
<tr class="nocodegen"><td>2893<td>  end
<tr class="nocodegen"><td>2894<td>  else
<tr class="covered"><td>2895<td>    if KeySize &lt;= 24 then
<tr class="nocodegen"><td>2896<td>    begin
<tr class="covered"><td>2897<td>      for I := 0 to 7 do
<tr class="nocodegen"><td>2898<td>      begin
<tr class="covered"><td>2899<td>        T := P[5];
<tr class="covered"><td>2900<td>        P[6] := Rijndael_S[0, T shr  8 and $FF]        xor
<tr class="nocodegen"><td>2901<td>                Rijndael_S[0, T shr 16 and $FF] shl  8 xor
<tr class="nocodegen"><td>2902<td>                Rijndael_S[0, T shr 24        ] shl 16 xor
<tr class="nocodegen"><td>2903<td>                Rijndael_S[0, T        and $FF] shl 24 xor P[0] xor RijndaelEncryptionSheduleConst[I];
<tr class="covered"><td>2904<td>        P[7] := P[1] xor P[6];
<tr class="covered"><td>2905<td>        P[8] := P[2] xor P[7];
<tr class="covered"><td>2906<td>        P[9] := P[3] xor P[8];
<tr class="covered"><td>2907<td>        if I = 7 then
<tr class="nocodegen"><td>2908<td>          Break;
<tr class="covered"><td>2909<td>        P[10] := P[4] xor P[9];
<tr class="covered"><td>2910<td>        P[11] := P[5] xor P[10];
<tr class="covered"><td>2911<td>        P     := @P[6];
<tr class="covered"><td>2912<td>      end;
<tr class="nocodegen"><td>2913<td>    end
<tr class="nocodegen"><td>2914<td>    else
<tr class="nocodegen"><td>2915<td>    begin
<tr class="covered"><td>2916<td>      for I :=0 to 6 do
<tr class="nocodegen"><td>2917<td>      begin
<tr class="covered"><td>2918<td>        T := P[7];
<tr class="covered"><td>2919<td>        P[8] := Rijndael_S[0, T shr  8 and $FF]        xor
<tr class="nocodegen"><td>2920<td>                Rijndael_S[0, T shr 16 and $FF] shl  8 xor
<tr class="nocodegen"><td>2921<td>                Rijndael_S[0, T shr 24        ] shl 16 xor
<tr class="nocodegen"><td>2922<td>                Rijndael_S[0, T        and $FF] shl 24 xor P[0] xor RijndaelEncryptionSheduleConst[I];
<tr class="covered"><td>2923<td>        P[9] := P[1] xor P[8];
<tr class="covered"><td>2924<td>        P[10] := P[2] xor P[9];
<tr class="covered"><td>2925<td>        P[11] := P[3] xor P[10];
<tr class="covered"><td>2926<td>        if I = 6 then
<tr class="nocodegen"><td>2927<td>          Break;
<tr class="covered"><td>2928<td>        T := P[11];
<tr class="covered"><td>2929<td>        P[12] := Rijndael_S[0, T        and $FF]        xor
<tr class="nocodegen"><td>2930<td>                 Rijndael_S[0, T shr  8 and $FF] shl  8 xor
<tr class="nocodegen"><td>2931<td>                 Rijndael_S[0, T shr 16 and $FF] shl 16 xor
<tr class="nocodegen"><td>2932<td>                 Rijndael_S[0, T shr 24        ] shl 24 xor P[4];
<tr class="covered"><td>2933<td>        P[13] := P[5] xor P[12];
<tr class="covered"><td>2934<td>        P[14] := P[6] xor P[13];
<tr class="covered"><td>2935<td>        P[15] := P[7] xor P[14];
<tr class="covered"><td>2936<td>        P     := @P[8];
<tr class="covered"><td>2937<td>      end;
<tr class="nocodegen"><td>2938<td>    end;
<tr class="covered"><td>2939<td>end;
<tr class="nocodegen"><td>2940<td>
<tr class="nocodegen"><td>2941<td>procedure TCipher_Rijndael.BuildDecodeKey;
<tr class="nocodegen"><td>2942<td>var
<tr class="nocodegen"><td>2943<td>  P: PUInt32;
<tr class="nocodegen"><td>2944<td>  I: Integer;
<tr class="covered"><td>2945<td>begin
<tr class="covered"><td>2946<td>  P := Pointer(PByte(FAdditionalBuffer) + FAdditionalBufferSize shr 1); // for Pointer Math
<tr class="covered"><td>2947<td>  Move(FAdditionalBuffer^, P^, FAdditionalBufferSize shr 1);
<tr class="covered"><td>2948<td>  Inc(P, 4);
<tr class="covered"><td>2949<td>  for I := 0 to FRounds * 4 - 5 do
<tr class="nocodegen"><td>2950<td>  begin
<tr class="covered"><td>2951<td>    P^ := Rijndael_T[4, Rijndael_S[0, P^        and $FF]] xor
<tr class="nocodegen"><td>2952<td>          Rijndael_T[5, Rijndael_S[0, P^ shr  8 and $FF]] xor
<tr class="nocodegen"><td>2953<td>          Rijndael_T[6, Rijndael_S[0, P^ shr 16 and $FF]] xor
<tr class="nocodegen"><td>2954<td>          Rijndael_T[7, Rijndael_S[0, P^ shr 24        ]];
<tr class="covered"><td>2955<td>    Inc(P);
<tr class="covered"><td>2956<td>  end;
<tr class="covered"><td>2957<td>end;
<tr class="nocodegen"><td>2958<td>
<tr class="nocodegen"><td>2959<td>procedure TCipher_Rijndael.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>2960<td>var
<tr class="nocodegen"><td>2961<td>  P: PUInt32Array;
<tr class="nocodegen"><td>2962<td>  I: Integer;
<tr class="nocodegen"><td>2963<td>  A2, B2, C2, D2: UInt32;
<tr class="nocodegen"><td>2964<td>  A1, B1, C1, D1: UInt32;
<tr class="covered"><td>2965<td>begin
<tr class="covered"><td>2966<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>2967<td>
<tr class="covered"><td>2968<td>  P  := FAdditionalBuffer;
<tr class="covered"><td>2969<td>  A1 := PUInt32Array(Source)[0];
<tr class="covered"><td>2970<td>  B1 := PUInt32Array(Source)[1];
<tr class="covered"><td>2971<td>  C1 := PUInt32Array(Source)[2];
<tr class="covered"><td>2972<td>  D1 := PUInt32Array(Source)[3];
<tr class="nocodegen"><td>2973<td>
<tr class="covered"><td>2974<td>  for I := 2 to FRounds do
<tr class="nocodegen"><td>2975<td>  begin
<tr class="covered"><td>2976<td>    A2 := A1 xor P[0];
<tr class="covered"><td>2977<td>    B2 := B1 xor P[1];
<tr class="covered"><td>2978<td>    C2 := C1 xor P[2];
<tr class="covered"><td>2979<td>    D2 := D1 xor P[3];
<tr class="nocodegen"><td>2980<td>
<tr class="covered"><td>2981<td>    A1 := Rijndael_T[0, A2        and $FF] xor
<tr class="nocodegen"><td>2982<td>          Rijndael_T[1, B2 shr  8 and $FF] xor
<tr class="nocodegen"><td>2983<td>          Rijndael_T[2, C2 shr 16 and $FF] xor
<tr class="nocodegen"><td>2984<td>          Rijndael_T[3, D2 shr 24        ];
<tr class="covered"><td>2985<td>    B1 := Rijndael_T[0, B2        and $FF] xor
<tr class="nocodegen"><td>2986<td>          Rijndael_T[1, C2 shr  8 and $FF] xor
<tr class="nocodegen"><td>2987<td>          Rijndael_T[2, D2 shr 16 and $FF] xor
<tr class="nocodegen"><td>2988<td>          Rijndael_T[3, A2 shr 24        ];
<tr class="covered"><td>2989<td>    C1 := Rijndael_T[0, C2        and $FF] xor
<tr class="nocodegen"><td>2990<td>          Rijndael_T[1, D2 shr  8 and $FF] xor
<tr class="nocodegen"><td>2991<td>          Rijndael_T[2, A2 shr 16 and $FF] xor
<tr class="nocodegen"><td>2992<td>          Rijndael_T[3, B2 shr 24        ];
<tr class="covered"><td>2993<td>    D1 := Rijndael_T[0, D2        and $FF] xor
<tr class="nocodegen"><td>2994<td>          Rijndael_T[1, A2 shr  8 and $FF] xor
<tr class="nocodegen"><td>2995<td>          Rijndael_T[2, B2 shr 16 and $FF] xor
<tr class="nocodegen"><td>2996<td>          Rijndael_T[3, C2 shr 24        ];
<tr class="nocodegen"><td>2997<td>
<tr class="covered"><td>2998<td>    P := @P[4];
<tr class="covered"><td>2999<td>  end;
<tr class="nocodegen"><td>3000<td>
<tr class="covered"><td>3001<td>  A2 := A1 xor P[0];
<tr class="covered"><td>3002<td>  B2 := B1 xor P[1];
<tr class="covered"><td>3003<td>  C2 := C1 xor P[2];
<tr class="covered"><td>3004<td>  D2 := D1 xor P[3];
<tr class="nocodegen"><td>3005<td>
<tr class="covered"><td>3006<td>  PUInt32Array(Dest)[0] := (Rijndael_S[0, A2        and $FF]        or
<tr class="nocodegen"><td>3007<td>                          Rijndael_S[0, B2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3008<td>                          Rijndael_S[0, C2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3009<td>                          Rijndael_S[0, D2 shr 24        ] shl 24)     xor P[4];
<tr class="covered"><td>3010<td>  PUInt32Array(Dest)[1] := (Rijndael_S[0, B2        and $FF]        or
<tr class="nocodegen"><td>3011<td>                          Rijndael_S[0, C2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3012<td>                          Rijndael_S[0, D2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3013<td>                          Rijndael_S[0, A2 shr 24        ] shl 24)     xor P[5];
<tr class="covered"><td>3014<td>  PUInt32Array(Dest)[2] := (Rijndael_S[0, C2        and $FF]        or
<tr class="nocodegen"><td>3015<td>                          Rijndael_S[0, D2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3016<td>                          Rijndael_S[0, A2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3017<td>                          Rijndael_S[0, B2 shr 24        ] shl 24)     xor P[6];
<tr class="covered"><td>3018<td>  PUInt32Array(Dest)[3] := (Rijndael_S[0, D2        and $FF]        or
<tr class="nocodegen"><td>3019<td>                          Rijndael_S[0, A2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3020<td>                          Rijndael_S[0, B2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3021<td>                          Rijndael_S[0, C2 shr 24        ] shl 24)     xor P[7];
<tr class="covered"><td>3022<td>end;
<tr class="nocodegen"><td>3023<td>
<tr class="nocodegen"><td>3024<td>procedure TCipher_Rijndael.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3025<td>var
<tr class="nocodegen"><td>3026<td>  P: PUInt32Array;
<tr class="nocodegen"><td>3027<td>  I: Integer;
<tr class="nocodegen"><td>3028<td>  A2, B2, C2, D2: UInt32;
<tr class="nocodegen"><td>3029<td>  A1, B1, C1, D1: UInt32;
<tr class="covered"><td>3030<td>begin
<tr class="covered"><td>3031<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>3032<td>
<tr class="covered"><td>3033<td>  P  := Pointer(PByte(FAdditionalBuffer) + FAdditionalBufferSize shr 1 + FRounds * 16); // for Pointer Math
<tr class="covered"><td>3034<td>  A1 := PUInt32Array(Source)[0];
<tr class="covered"><td>3035<td>  B1 := PUInt32Array(Source)[1];
<tr class="covered"><td>3036<td>  C1 := PUInt32Array(Source)[2];
<tr class="covered"><td>3037<td>  D1 := PUInt32Array(Source)[3];
<tr class="nocodegen"><td>3038<td>
<tr class="covered"><td>3039<td>  for I := 2 to FRounds do
<tr class="nocodegen"><td>3040<td>  begin
<tr class="covered"><td>3041<td>    A2 := A1 xor P[0];
<tr class="covered"><td>3042<td>    B2 := B1 xor P[1];
<tr class="covered"><td>3043<td>    C2 := C1 xor P[2];
<tr class="covered"><td>3044<td>    D2 := D1 xor P[3];
<tr class="nocodegen"><td>3045<td>
<tr class="covered"><td>3046<td>    A1 := Rijndael_T[4, A2        and $FF] xor
<tr class="nocodegen"><td>3047<td>          Rijndael_T[5, D2 shr  8 and $FF] xor
<tr class="nocodegen"><td>3048<td>          Rijndael_T[6, C2 shr 16 and $FF] xor
<tr class="nocodegen"><td>3049<td>          Rijndael_T[7, B2 shr 24        ];
<tr class="covered"><td>3050<td>    B1 := Rijndael_T[4, B2        and $FF] xor
<tr class="nocodegen"><td>3051<td>          Rijndael_T[5, A2 shr  8 and $FF] xor
<tr class="nocodegen"><td>3052<td>          Rijndael_T[6, D2 shr 16 and $FF] xor
<tr class="nocodegen"><td>3053<td>          Rijndael_T[7, C2 shr 24        ];
<tr class="covered"><td>3054<td>    C1 := Rijndael_T[4, C2        and $FF] xor
<tr class="nocodegen"><td>3055<td>          Rijndael_T[5, B2 shr  8 and $FF] xor
<tr class="nocodegen"><td>3056<td>          Rijndael_T[6, A2 shr 16 and $FF] xor
<tr class="nocodegen"><td>3057<td>          Rijndael_T[7, D2 shr 24        ];
<tr class="covered"><td>3058<td>    D1 := Rijndael_T[4, D2        and $FF] xor
<tr class="nocodegen"><td>3059<td>          Rijndael_T[5, C2 shr  8 and $FF] xor
<tr class="nocodegen"><td>3060<td>          Rijndael_T[6, B2 shr 16 and $FF] xor
<tr class="nocodegen"><td>3061<td>          Rijndael_T[7, A2 shr 24        ];
<tr class="nocodegen"><td>3062<td>
<tr class="covered"><td>3063<td>    Dec(PUInt32(P), 4);
<tr class="covered"><td>3064<td>  end;
<tr class="nocodegen"><td>3065<td>
<tr class="covered"><td>3066<td>  A2 := A1 xor P[0];
<tr class="covered"><td>3067<td>  B2 := B1 xor P[1];
<tr class="covered"><td>3068<td>  C2 := C1 xor P[2];
<tr class="covered"><td>3069<td>  D2 := D1 xor P[3];
<tr class="nocodegen"><td>3070<td>
<tr class="covered"><td>3071<td>  Dec(PUInt32(P), 4);
<tr class="nocodegen"><td>3072<td>
<tr class="covered"><td>3073<td>  PUInt32Array(Dest)[0] := (Rijndael_S[1, A2        and $FF]        or
<tr class="nocodegen"><td>3074<td>                          Rijndael_S[1, D2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3075<td>                          Rijndael_S[1, C2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3076<td>                          Rijndael_S[1, B2 shr 24]         shl 24)    xor P[0];
<tr class="covered"><td>3077<td>  PUInt32Array(Dest)[1] := (Rijndael_S[1, B2        and $FF]        or
<tr class="nocodegen"><td>3078<td>                          Rijndael_S[1, A2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3079<td>                          Rijndael_S[1, D2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3080<td>                          Rijndael_S[1, C2 shr 24]         shl 24)    xor P[1];
<tr class="covered"><td>3081<td>  PUInt32Array(Dest)[2] := (Rijndael_S[1, C2        and $FF]        or
<tr class="nocodegen"><td>3082<td>                          Rijndael_S[1, B2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3083<td>                          Rijndael_S[1, A2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3084<td>                          Rijndael_S[1, D2 shr 24]         shl 24)    xor P[2];
<tr class="covered"><td>3085<td>  PUInt32Array(Dest)[3] := (Rijndael_S[1, D2        and $FF]        or
<tr class="nocodegen"><td>3086<td>                          Rijndael_S[1, C2 shr  8 and $FF] shl  8 or
<tr class="nocodegen"><td>3087<td>                          Rijndael_S[1, B2 shr 16 and $FF] shl 16 or
<tr class="nocodegen"><td>3088<td>                          Rijndael_S[1, A2 shr 24]         shl 24)    xor P[3];
<tr class="covered"><td>3089<td>end;
<tr class="nocodegen"><td>3090<td>
<tr class="nocodegen"><td>3091<td>{ TCipher_AES128 }
<tr class="nocodegen"><td>3092<td>
<tr class="nocodegen"><td>3093<td>class function TCipher_AES128.Context: TCipherContext;
<tr class="nocodegen"><td>3094<td>const
<tr class="nocodegen"><td>3095<td>  // don't change this!
<tr class="nocodegen"><td>3096<td>  Rijndael_Blocks =  4;
<tr class="nocodegen"><td>3097<td>  Rijndael_Rounds = 14;
<tr class="covered"><td>3098<td>begin
<tr class="covered"><td>3099<td>  Result.KeySize                     := 16;
<tr class="covered"><td>3100<td>  Result.BlockSize                   := Rijndael_Blocks * 4;
<tr class="covered"><td>3101<td>  Result.BufferSize                  := Rijndael_Blocks * 4;
<tr class="covered"><td>3102<td>  Result.AdditionalBufferSize        := (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(UInt32) * 2;
<tr class="covered"><td>3103<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>3104<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3105<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3106<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>3107<td>end;
<tr class="nocodegen"><td>3108<td>
<tr class="nocodegen"><td>3109<td>procedure TCipher_AES128.DoInit(const Key; Size: Integer);
<tr class="covered"><td>3110<td>begin
<tr class="nocodegen"><td>3111<td>  // number of rounds is fixed for 128 bit and if a size &gt; 16 is given the
<tr class="nocodegen"><td>3112<td>  // inherited call should raise the &quot;key material too large&quot; exception.
<tr class="nocodegen"><td>3113<td>  // but that has still to be tested!
<tr class="covered"><td>3114<td>  FRounds := 10;
<tr class="nocodegen"><td>3115<td>
<tr class="covered"><td>3116<td>  FillChar(FAdditionalBuffer^, 32, 0);
<tr class="covered"><td>3117<td>  Move(Key, FAdditionalBuffer^, Size);
<tr class="covered"><td>3118<td>  BuildEncodeKey(Size);
<tr class="covered"><td>3119<td>  BuildDecodeKey;
<tr class="nocodegen"><td>3120<td>
<tr class="covered"><td>3121<td>  inherited;
<tr class="covered"><td>3122<td>end;
<tr class="nocodegen"><td>3123<td>
<tr class="nocodegen"><td>3124<td>{ TCipher_AES192 }
<tr class="nocodegen"><td>3125<td>
<tr class="nocodegen"><td>3126<td>class function TCipher_AES192.Context: TCipherContext;
<tr class="nocodegen"><td>3127<td>const
<tr class="nocodegen"><td>3128<td>  // don't change this!
<tr class="nocodegen"><td>3129<td>  Rijndael_Blocks =  4;
<tr class="nocodegen"><td>3130<td>  Rijndael_Rounds = 14;
<tr class="covered"><td>3131<td>begin
<tr class="covered"><td>3132<td>  Result.KeySize                     := 24;
<tr class="covered"><td>3133<td>  Result.BlockSize                   := Rijndael_Blocks * 4;
<tr class="covered"><td>3134<td>  Result.BufferSize                  := Rijndael_Blocks * 4;
<tr class="covered"><td>3135<td>  Result.AdditionalBufferSize        := (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(UInt32) * 2;
<tr class="covered"><td>3136<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>3137<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3138<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3139<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>3140<td>end;
<tr class="nocodegen"><td>3141<td>
<tr class="nocodegen"><td>3142<td>procedure TCipher_AES192.DoInit(const Key; Size: Integer);
<tr class="covered"><td>3143<td>begin
<tr class="nocodegen"><td>3144<td>  // number of rounds is fixed for 192 bit and if a size &gt; 24 is given the
<tr class="nocodegen"><td>3145<td>  // inherited call should raise the &quot;key material too large&quot; exception.
<tr class="nocodegen"><td>3146<td>  // but that has still to be tested!
<tr class="covered"><td>3147<td>  FRounds := 12;
<tr class="nocodegen"><td>3148<td>
<tr class="covered"><td>3149<td>  FillChar(FAdditionalBuffer^, 32, 0);
<tr class="covered"><td>3150<td>  Move(Key, FAdditionalBuffer^, Size);
<tr class="covered"><td>3151<td>  BuildEncodeKey(Size);
<tr class="covered"><td>3152<td>  BuildDecodeKey;
<tr class="nocodegen"><td>3153<td>
<tr class="covered"><td>3154<td>  inherited;
<tr class="covered"><td>3155<td>end;
<tr class="nocodegen"><td>3156<td>
<tr class="nocodegen"><td>3157<td>{ TCipher_AES256 }
<tr class="nocodegen"><td>3158<td>
<tr class="nocodegen"><td>3159<td>class function TCipher_AES256.Context: TCipherContext;
<tr class="nocodegen"><td>3160<td>const
<tr class="nocodegen"><td>3161<td>  // don't change this!
<tr class="nocodegen"><td>3162<td>  Rijndael_Blocks =  4;
<tr class="nocodegen"><td>3163<td>  Rijndael_Rounds = 14;
<tr class="covered"><td>3164<td>begin
<tr class="covered"><td>3165<td>  Result.KeySize                     := 32;
<tr class="covered"><td>3166<td>  Result.BlockSize                   := Rijndael_Blocks * 4;
<tr class="covered"><td>3167<td>  Result.BufferSize                  := Rijndael_Blocks * 4;
<tr class="covered"><td>3168<td>  Result.AdditionalBufferSize        := (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(UInt32) * 2;
<tr class="covered"><td>3169<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>3170<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3171<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3172<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>3173<td>end;
<tr class="nocodegen"><td>3174<td>
<tr class="nocodegen"><td>3175<td>procedure TCipher_AES256.DoInit(const Key; Size: Integer);
<tr class="covered"><td>3176<td>begin
<tr class="nocodegen"><td>3177<td>  // number of rounds is fixed for 256 bit and if a size &gt; 32 is given the
<tr class="nocodegen"><td>3178<td>  // inherited call should raise the &quot;key material too large&quot; exception.
<tr class="nocodegen"><td>3179<td>  // but that has still to be tested!
<tr class="covered"><td>3180<td>  FRounds := 14;
<tr class="nocodegen"><td>3181<td>
<tr class="covered"><td>3182<td>  FillChar(FAdditionalBuffer^, 32, 0);
<tr class="covered"><td>3183<td>  Move(Key, FAdditionalBuffer^, Size);
<tr class="covered"><td>3184<td>  BuildEncodeKey(Size);
<tr class="covered"><td>3185<td>  BuildDecodeKey;
<tr class="nocodegen"><td>3186<td>
<tr class="covered"><td>3187<td>  inherited;
<tr class="covered"><td>3188<td>end;
<tr class="nocodegen"><td>3189<td>
<tr class="nocodegen"><td>3190<td>{ TCipher_Square }
<tr class="nocodegen"><td>3191<td>
<tr class="nocodegen"><td>3192<td>class function TCipher_Square.Context: TCipherContext;
<tr class="covered"><td>3193<td>begin
<tr class="covered"><td>3194<td>  Result.KeySize                     := 16;
<tr class="covered"><td>3195<td>  Result.BlockSize                   := 16;
<tr class="covered"><td>3196<td>  Result.BufferSize                  := 16;
<tr class="covered"><td>3197<td>  Result.AdditionalBufferSize        := 9 * 4 * 2 * SizeOf(UInt32);
<tr class="covered"><td>3198<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>3199<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3200<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3201<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>3202<td>end;
<tr class="nocodegen"><td>3203<td>
<tr class="nocodegen"><td>3204<td>procedure TCipher_Square.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>3205<td>type
<tr class="nocodegen"><td>3206<td>  PSquare_Key = ^TSquare_Key;
<tr class="nocodegen"><td>3207<td>  TSquare_Key = array[0..8, 0..3] of UInt32;
<tr class="nocodegen"><td>3208<td>var
<tr class="nocodegen"><td>3209<td>  E, D: PSquare_Key;
<tr class="nocodegen"><td>3210<td>  S, T, R: UInt32;
<tr class="nocodegen"><td>3211<td>  I, J: Integer;
<tr class="covered"><td>3212<td>begin
<tr class="covered"><td>3213<td>  E := FAdditionalBuffer;
<tr class="covered"><td>3214<td>  D := FAdditionalBuffer; Inc(D);
<tr class="covered"><td>3215<td>  Move(Key, E^, Size);
<tr class="nocodegen"><td>3216<td>
<tr class="covered"><td>3217<td>  for I := 1 to 8 do
<tr class="nocodegen"><td>3218<td>  begin
<tr class="covered"><td>3219<td>    T := E[I - 1, 3];
<tr class="covered"><td>3220<td>    T := T shr 8 or T shl 24;
<tr class="covered"><td>3221<td>    E[I, 0] := E[I - 1, 0] xor T xor 1 shl (I - 1);
<tr class="covered"><td>3222<td>    E[I, 1] := E[I - 1, 1] xor E[I, 0];
<tr class="covered"><td>3223<td>    E[I, 2] := E[I - 1, 2] xor E[I, 1];
<tr class="covered"><td>3224<td>    E[I, 3] := E[I - 1, 3] xor E[I, 2];
<tr class="nocodegen"><td>3225<td>
<tr class="covered"><td>3226<td>    D[8 - I, 0] := E[I, 0];
<tr class="covered"><td>3227<td>    D[8 - I, 1] := E[I, 1];
<tr class="covered"><td>3228<td>    D[8 - I, 2] := E[I, 2];
<tr class="covered"><td>3229<td>    D[8 - I, 3] := E[I, 3];
<tr class="nocodegen"><td>3230<td>
<tr class="covered"><td>3231<td>    for J := 0 to 3 do
<tr class="nocodegen"><td>3232<td>    begin
<tr class="covered"><td>3233<td>      R := E[I - 1, J];
<tr class="covered"><td>3234<td>      S := Square_PHI[R and $FF];
<tr class="covered"><td>3235<td>      T := Square_PHI[R shr  8 and $FF];
<tr class="covered"><td>3236<td>      T := T shl 8 or T shr 24;
<tr class="covered"><td>3237<td>      S := S xor T;
<tr class="covered"><td>3238<td>      T := Square_PHI[R shr 16 and $FF];
<tr class="covered"><td>3239<td>      T := T shl 16 or T shr 16;
<tr class="covered"><td>3240<td>      S := S xor T;
<tr class="covered"><td>3241<td>      T := Square_PHI[R shr 24];
<tr class="covered"><td>3242<td>      T := T shl 24 or T shr 8;
<tr class="covered"><td>3243<td>      S := S xor T;
<tr class="covered"><td>3244<td>      E[I - 1, J] := S;
<tr class="covered"><td>3245<td>    end;
<tr class="covered"><td>3246<td>  end;
<tr class="nocodegen"><td>3247<td>
<tr class="covered"><td>3248<td>  D[8] := E[0];
<tr class="nocodegen"><td>3249<td>
<tr class="nocodegen"><td>3250<td>  inherited;
<tr class="covered"><td>3251<td>end;
<tr class="nocodegen"><td>3252<td>
<tr class="nocodegen"><td>3253<td>procedure TCipher_Square.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3254<td>var
<tr class="nocodegen"><td>3255<td>  Key: PUInt32Array;
<tr class="nocodegen"><td>3256<td>  A, B, C, D: UInt32;
<tr class="nocodegen"><td>3257<td>  AA, BB, CC: UInt32;
<tr class="nocodegen"><td>3258<td>  I: Integer;
<tr class="covered"><td>3259<td>begin
<tr class="covered"><td>3260<td>  Key := FAdditionalBuffer;
<tr class="covered"><td>3261<td>  A := PUInt32Array(Source)[0] xor Key[0];
<tr class="covered"><td>3262<td>  B := PUInt32Array(Source)[1] xor Key[1];
<tr class="covered"><td>3263<td>  C := PUInt32Array(Source)[2] xor Key[2];
<tr class="covered"><td>3264<td>  D := PUInt32Array(Source)[3] xor Key[3];
<tr class="covered"><td>3265<td>  Key := @Key[4];
<tr class="nocodegen"><td>3266<td>
<tr class="covered"><td>3267<td>  for I := 0 to 6 do
<tr class="nocodegen"><td>3268<td>  begin
<tr class="covered"><td>3269<td>    AA := Square_TE[0, A        and $FF] xor
<tr class="nocodegen"><td>3270<td>          Square_TE[1, B        and $FF] xor
<tr class="nocodegen"><td>3271<td>          Square_TE[2, C        and $FF] xor
<tr class="nocodegen"><td>3272<td>          Square_TE[3, D        and $FF] xor Key[0];
<tr class="covered"><td>3273<td>    BB := Square_TE[0, A shr  8 and $FF] xor
<tr class="nocodegen"><td>3274<td>          Square_TE[1, B shr  8 and $FF] xor
<tr class="nocodegen"><td>3275<td>          Square_TE[2, C shr  8 and $FF] xor
<tr class="nocodegen"><td>3276<td>          Square_TE[3, D shr  8 and $FF] xor Key[1];
<tr class="covered"><td>3277<td>    CC := Square_TE[0, A shr 16 and $FF] xor
<tr class="nocodegen"><td>3278<td>          Square_TE[1, B shr 16 and $FF] xor
<tr class="nocodegen"><td>3279<td>          Square_TE[2, C shr 16 and $FF] xor
<tr class="nocodegen"><td>3280<td>          Square_TE[3, D shr 16 and $FF] xor Key[2];
<tr class="covered"><td>3281<td>    D  := Square_TE[0, A shr 24        ] xor
<tr class="nocodegen"><td>3282<td>          Square_TE[1, B shr 24        ] xor
<tr class="nocodegen"><td>3283<td>          Square_TE[2, C shr 24        ] xor
<tr class="nocodegen"><td>3284<td>          Square_TE[3, D shr 24        ] xor Key[3];
<tr class="nocodegen"><td>3285<td>
<tr class="covered"><td>3286<td>    A := AA; B := BB; C := CC;
<tr class="nocodegen"><td>3287<td>
<tr class="covered"><td>3288<td>    Key := @Key[4];
<tr class="covered"><td>3289<td>  end;
<tr class="nocodegen"><td>3290<td>
<tr class="covered"><td>3291<td>  PUInt32Array(Dest)[0] := UInt32(Square_SE[A        and $FF])        xor
<tr class="nocodegen"><td>3292<td>                         UInt32(Square_SE[B        and $FF]) shl  8 xor
<tr class="nocodegen"><td>3293<td>                         UInt32(Square_SE[C        and $FF]) shl 16 xor
<tr class="nocodegen"><td>3294<td>                         UInt32(Square_SE[D        and $FF]) shl 24 xor Key[0];
<tr class="covered"><td>3295<td>  PUInt32Array(Dest)[1] := UInt32(Square_SE[A shr  8 and $FF])        xor
<tr class="nocodegen"><td>3296<td>                         UInt32(Square_SE[B shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>3297<td>                         UInt32(Square_SE[C shr  8 and $FF]) shl 16 xor
<tr class="nocodegen"><td>3298<td>                         UInt32(Square_SE[D shr  8 and $FF]) shl 24 xor Key[1];
<tr class="covered"><td>3299<td>  PUInt32Array(Dest)[2] := UInt32(Square_SE[A shr 16 and $FF])        xor
<tr class="nocodegen"><td>3300<td>                         UInt32(Square_SE[B shr 16 and $FF]) shl  8 xor
<tr class="nocodegen"><td>3301<td>                         UInt32(Square_SE[C shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>3302<td>                         UInt32(Square_SE[D shr 16 and $FF]) shl 24 xor Key[2];
<tr class="covered"><td>3303<td>  PUInt32Array(Dest)[3] := UInt32(Square_SE[A shr 24        ])        xor
<tr class="nocodegen"><td>3304<td>                         UInt32(Square_SE[B shr 24        ]) shl  8 xor
<tr class="nocodegen"><td>3305<td>                         UInt32(Square_SE[C shr 24        ]) shl 16 xor
<tr class="nocodegen"><td>3306<td>                         UInt32(Square_SE[D shr 24        ]) shl 24 xor Key[3];
<tr class="covered"><td>3307<td>end;
<tr class="nocodegen"><td>3308<td>
<tr class="nocodegen"><td>3309<td>procedure TCipher_Square.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3310<td>var
<tr class="nocodegen"><td>3311<td>  Key: PUInt32Array;
<tr class="nocodegen"><td>3312<td>  A, B, C, D: UInt32;
<tr class="nocodegen"><td>3313<td>  AA, BB, CC: UInt32;
<tr class="nocodegen"><td>3314<td>  I: Integer;
<tr class="covered"><td>3315<td>begin
<tr class="covered"><td>3316<td>  Key := @PUInt32Array(FAdditionalBuffer)[9 * 4];
<tr class="covered"><td>3317<td>  A := PUInt32Array(Source)[0] xor Key[0];
<tr class="covered"><td>3318<td>  B := PUInt32Array(Source)[1] xor Key[1];
<tr class="covered"><td>3319<td>  C := PUInt32Array(Source)[2] xor Key[2];
<tr class="covered"><td>3320<td>  D := PUInt32Array(Source)[3] xor Key[3];
<tr class="covered"><td>3321<td>  Key := @Key[4];
<tr class="nocodegen"><td>3322<td>
<tr class="covered"><td>3323<td>  for I := 0 to 6 do
<tr class="nocodegen"><td>3324<td>  begin
<tr class="covered"><td>3325<td>    AA := Square_TD[0, A        and $FF] xor
<tr class="nocodegen"><td>3326<td>          Square_TD[1, B        and $FF] xor
<tr class="nocodegen"><td>3327<td>          Square_TD[2, C        and $FF] xor
<tr class="nocodegen"><td>3328<td>          Square_TD[3, D        and $FF] xor Key[0];
<tr class="covered"><td>3329<td>    BB := Square_TD[0, A shr  8 and $FF] xor
<tr class="nocodegen"><td>3330<td>          Square_TD[1, B shr  8 and $FF] xor
<tr class="nocodegen"><td>3331<td>          Square_TD[2, C shr  8 and $FF] xor
<tr class="nocodegen"><td>3332<td>          Square_TD[3, D shr  8 and $FF] xor Key[1];
<tr class="covered"><td>3333<td>    CC := Square_TD[0, A shr 16 and $FF] xor
<tr class="nocodegen"><td>3334<td>          Square_TD[1, B shr 16 and $FF] xor
<tr class="nocodegen"><td>3335<td>          Square_TD[2, C shr 16 and $FF] xor
<tr class="nocodegen"><td>3336<td>          Square_TD[3, D shr 16 and $FF] xor Key[2];
<tr class="covered"><td>3337<td>    D  := Square_TD[0, A shr 24        ] xor
<tr class="nocodegen"><td>3338<td>          Square_TD[1, B shr 24        ] xor
<tr class="nocodegen"><td>3339<td>          Square_TD[2, C shr 24        ] xor
<tr class="nocodegen"><td>3340<td>          Square_TD[3, D shr 24        ] xor Key[3];
<tr class="nocodegen"><td>3341<td>
<tr class="covered"><td>3342<td>    A := AA; B := BB; C := CC;
<tr class="covered"><td>3343<td>    Key := @Key[4];
<tr class="covered"><td>3344<td>  end;
<tr class="nocodegen"><td>3345<td>
<tr class="covered"><td>3346<td>  PUInt32Array(Dest)[0] := UInt32(Square_SD[A        and $FF])        xor
<tr class="nocodegen"><td>3347<td>                         UInt32(Square_SD[B        and $FF]) shl  8 xor
<tr class="nocodegen"><td>3348<td>                         UInt32(Square_SD[C        and $FF]) shl 16 xor
<tr class="nocodegen"><td>3349<td>                         UInt32(Square_SD[D        and $FF]) shl 24 xor Key[0];
<tr class="covered"><td>3350<td>  PUInt32Array(Dest)[1] := UInt32(Square_SD[A shr  8 and $FF])        xor
<tr class="nocodegen"><td>3351<td>                         UInt32(Square_SD[B shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>3352<td>                         UInt32(Square_SD[C shr  8 and $FF]) shl 16 xor
<tr class="nocodegen"><td>3353<td>                         UInt32(Square_SD[D shr  8 and $FF]) shl 24 xor Key[1];
<tr class="covered"><td>3354<td>  PUInt32Array(Dest)[2] := UInt32(Square_SD[A shr 16 and $FF])        xor
<tr class="nocodegen"><td>3355<td>                         UInt32(Square_SD[B shr 16 and $FF]) shl  8 xor
<tr class="nocodegen"><td>3356<td>                         UInt32(Square_SD[C shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>3357<td>                         UInt32(Square_SD[D shr 16 and $FF]) shl 24 xor Key[2];
<tr class="covered"><td>3358<td>  PUInt32Array(Dest)[3] := UInt32(Square_SD[A shr 24        ])        xor
<tr class="nocodegen"><td>3359<td>                         UInt32(Square_SD[B shr 24        ]) shl  8 xor
<tr class="nocodegen"><td>3360<td>                         UInt32(Square_SD[C shr 24        ]) shl 16 xor
<tr class="nocodegen"><td>3361<td>                         UInt32(Square_SD[D shr 24        ]) shl 24 xor Key[3];
<tr class="covered"><td>3362<td>end;
<tr class="nocodegen"><td>3363<td>
<tr class="nocodegen"><td>3364<td>{ TCipher_SCOP }
<tr class="nocodegen"><td>3365<td>
<tr class="nocodegen"><td>3366<td>class function TCipher_SCOP.Context: TCipherContext;
<tr class="covered"><td>3367<td>begin
<tr class="covered"><td>3368<td>  Result.KeySize                     := 48;
<tr class="covered"><td>3369<td>  Result.BlockSize                   := 4;
<tr class="covered"><td>3370<td>  Result.BufferSize                  := 32;
<tr class="covered"><td>3371<td>  Result.AdditionalBufferSize        := 384 * 4 + 3 * SizeOf(UInt32);
<tr class="covered"><td>3372<td>  Result.NeedsAdditionalBufferBackup := True;
<tr class="covered"><td>3373<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3374<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3375<td>  Result.CipherType                  := [ctSymmetric, ctStream];
<tr class="covered"><td>3376<td>end;
<tr class="nocodegen"><td>3377<td>
<tr class="nocodegen"><td>3378<td>procedure TCipher_SCOP.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>3379<td>var
<tr class="nocodegen"><td>3380<td>  Init_State: packed record
<tr class="nocodegen"><td>3381<td>    Coef: array[0..7, 0..3] of Byte;
<tr class="nocodegen"><td>3382<td>    X: array[0..3] of UInt32;
<tr class="nocodegen"><td>3383<td>  end;
<tr class="nocodegen"><td>3384<td>
<tr class="nocodegen"><td>3385<td>  procedure ExpandKey;
<tr class="nocodegen"><td>3386<td>  var
<tr class="nocodegen"><td>3387<td>    P: PByteArray;
<tr class="nocodegen"><td>3388<td>    I, C: Integer;
<tr class="covered"><td>3389<td>  begin
<tr class="covered"><td>3390<td>    C := 1;
<tr class="covered"><td>3391<td>    P := @Init_State;
<tr class="covered"><td>3392<td>    Move(Key, P^, Size);
<tr class="covered"><td>3393<td>    for I := Size to 47 do
<tr class="covered"><td>3394<td>      P[I] := P[I - Size] + P[I - Size + 1];
<tr class="covered"><td>3395<td>    for I := 0 to 31 do
<tr class="covered"><td>3396<td>      if P[I] = 0 then
<tr class="nocodegen"><td>3397<td>      begin
<tr class="covered"><td>3398<td>        P[I] := C;
<tr class="covered"><td>3399<td>        Inc(C);
<tr class="covered"><td>3400<td>      end;
<tr class="covered"><td>3401<td>  end;
<tr class="nocodegen"><td>3402<td>
<tr class="nocodegen"><td>3403<td>  procedure GP8(Data: PUInt32Array);
<tr class="nocodegen"><td>3404<td>  var
<tr class="nocodegen"><td>3405<td>    I, I2: Integer;
<tr class="nocodegen"><td>3406<td>    NewX: array[0..3] of UInt32;
<tr class="nocodegen"><td>3407<td>    X1, X2, X3, X4: UInt32;
<tr class="nocodegen"><td>3408<td>    Y1, Y2: UInt32;
<tr class="covered"><td>3409<td>  begin
<tr class="covered"><td>3410<td>    I := 0;
<tr class="covered"><td>3411<td>    I2 := 0;
<tr class="covered"><td>3412<td>    while I &lt; 8 do
<tr class="nocodegen"><td>3413<td>    begin
<tr class="covered"><td>3414<td>      X1 := Init_State.X[I2] shr 16;
<tr class="covered"><td>3415<td>      X2 := X1 * X1;
<tr class="covered"><td>3416<td>      X3 := X2 * X1;
<tr class="covered"><td>3417<td>      X4 := X3 * X1;
<tr class="covered"><td>3418<td>      Y1 := Init_State.Coef[I][0] * X4 +
<tr class="nocodegen"><td>3419<td>            Init_State.Coef[I][1] * X3 +
<tr class="nocodegen"><td>3420<td>            Init_State.Coef[I][2] * X2 +
<tr class="nocodegen"><td>3421<td>            Init_State.Coef[I][3] * X1 + 1;
<tr class="covered"><td>3422<td>      X1 := Init_State.X[I2] and $FFFF;
<tr class="covered"><td>3423<td>      X2 := X1 * X1;
<tr class="covered"><td>3424<td>      X3 := X2 * X1;
<tr class="covered"><td>3425<td>      X4 := X3 * X1;
<tr class="covered"><td>3426<td>      Y2 := Init_State.Coef[I + 1][0] * X4 +
<tr class="nocodegen"><td>3427<td>            Init_State.Coef[I + 1][1] * X3 +
<tr class="nocodegen"><td>3428<td>            Init_State.Coef[I + 1][2] * X2 +
<tr class="nocodegen"><td>3429<td>            Init_State.Coef[I + 1][3] * X1 + 1;
<tr class="covered"><td>3430<td>      Data[I2] := Y1 shl 16 or Y2 and $FFFF;
<tr class="covered"><td>3431<td>      NewX[I2] := Y1 and $FFFF0000 or Y2 shr 16;
<tr class="covered"><td>3432<td>      Inc(I2);
<tr class="covered"><td>3433<td>      Inc(I, 2);
<tr class="nocodegen"><td>3434<td>    end;
<tr class="covered"><td>3435<td>    Init_State.X[0] := NewX[0] shr 16 or NewX[3] shl 16;
<tr class="covered"><td>3436<td>    Init_State.X[1] := NewX[0] shl 16 or NewX[1] shr 16;
<tr class="covered"><td>3437<td>    Init_State.X[2] := NewX[1] shl 16 or NewX[2] shr 16;
<tr class="covered"><td>3438<td>    Init_State.X[3] := NewX[2] shl 16 or NewX[3] shr 16;
<tr class="covered"><td>3439<td>  end;
<tr class="nocodegen"><td>3440<td>
<tr class="nocodegen"><td>3441<td>var
<tr class="nocodegen"><td>3442<td>  I, J: Integer;
<tr class="nocodegen"><td>3443<td>  T: array[0..3] of UInt32;
<tr class="nocodegen"><td>3444<td>  P: PUInt32Array;
<tr class="covered"><td>3445<td>begin
<tr class="covered"><td>3446<td>  FillChar(Init_State, SizeOf(Init_State), 0);
<tr class="covered"><td>3447<td>  FillChar(T, SizeOf(T), 0);
<tr class="covered"><td>3448<td>  P := Pointer(PByte(FAdditionalBuffer) + 12); // for Pointer Math
<tr class="covered"><td>3449<td>  ExpandKey;
<tr class="covered"><td>3450<td>  for I := 0 to 7 do
<tr class="covered"><td>3451<td>    GP8(@T);
<tr class="covered"><td>3452<td>  for I := 0 to 11 do
<tr class="nocodegen"><td>3453<td>  begin
<tr class="covered"><td>3454<td>    for J := 0 to 7 do
<tr class="covered"><td>3455<td>      GP8(@P[I * 32 + J * 4]);
<tr class="covered"><td>3456<td>    GP8(@T);
<tr class="covered"><td>3457<td>  end;
<tr class="covered"><td>3458<td>  GP8(@T);
<tr class="covered"><td>3459<td>  I := T[3] and $7F;
<tr class="covered"><td>3460<td>  P[I] := P[I] or 1;
<tr class="covered"><td>3461<td>  P := FAdditionalBuffer;
<tr class="covered"><td>3462<td>  P[0] := T[3] shr 24 and $FF;
<tr class="covered"><td>3463<td>  P[1] := T[3] shr 16 and $FF;
<tr class="covered"><td>3464<td>  P[2] := T[3] shr  8 and $FF;
<tr class="covered"><td>3465<td>  ProtectBuffer(Init_State, SizeOf(Init_State));
<tr class="nocodegen"><td>3466<td>
<tr class="nocodegen"><td>3467<td>  inherited;
<tr class="covered"><td>3468<td>end;
<tr class="nocodegen"><td>3469<td>
<tr class="nocodegen"><td>3470<td>procedure TCipher_SCOP.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3471<td>var
<tr class="nocodegen"><td>3472<td>  I, J: Byte;
<tr class="nocodegen"><td>3473<td>  T2, T3, T1: UInt32;
<tr class="nocodegen"><td>3474<td>  P: PUInt32Array;
<tr class="nocodegen"><td>3475<td>  W: Integer;
<tr class="covered"><td>3476<td>begin
<tr class="covered"><td>3477<td>  P  := FAdditionalBuffer;
<tr class="covered"><td>3478<td>  I  := P[0];
<tr class="covered"><td>3479<td>  J  := P[1];
<tr class="covered"><td>3480<td>  T3 := P[2];
<tr class="covered"><td>3481<td>  for W := 0 to Size div 4 - 1 do
<tr class="nocodegen"><td>3482<td>  begin
<tr class="covered"><td>3483<td>    T1 := P[J + 3 + 128]; Inc(J, T3);
<tr class="covered"><td>3484<td>    T2 := P[J + 3 + 128];
<tr class="covered"><td>3485<td>    PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] + T1 + T2;
<tr class="covered"><td>3486<td>    T3 := T2 + P[I + 3];  Inc(I);
<tr class="covered"><td>3487<td>    P[J + 3 + 128] := T3;
<tr class="covered"><td>3488<td>    Inc(J, T2);
<tr class="covered"><td>3489<td>  end;
<tr class="covered"><td>3490<td>  P[0] := I;
<tr class="covered"><td>3491<td>  P[1] := J;
<tr class="covered"><td>3492<td>  P[2] := T3;
<tr class="covered"><td>3493<td>end;
<tr class="nocodegen"><td>3494<td>
<tr class="nocodegen"><td>3495<td>procedure TCipher_SCOP.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3496<td>var
<tr class="nocodegen"><td>3497<td>  I, J: Byte;
<tr class="nocodegen"><td>3498<td>  T1, T2, T3: UInt32;
<tr class="nocodegen"><td>3499<td>  P: PUInt32Array;
<tr class="nocodegen"><td>3500<td>  W: Integer;
<tr class="covered"><td>3501<td>begin
<tr class="covered"><td>3502<td>  P  := FAdditionalBuffer;
<tr class="covered"><td>3503<td>  I  := P[0];
<tr class="covered"><td>3504<td>  J  := P[1];
<tr class="covered"><td>3505<td>  T3 := P[2];
<tr class="covered"><td>3506<td>  for W := 0 to Size div 4 - 1 do
<tr class="nocodegen"><td>3507<td>  begin
<tr class="covered"><td>3508<td>    T1 := P[J + 3 + 128]; Inc(J, T3);
<tr class="covered"><td>3509<td>    T2 := P[J + 3 + 128];
<tr class="covered"><td>3510<td>    PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] - T1 - T2;
<tr class="covered"><td>3511<td>    T3 := T2 + P[I + 3];
<tr class="covered"><td>3512<td>    Inc(I);
<tr class="covered"><td>3513<td>    P[J + 3 + 128] := T3;
<tr class="covered"><td>3514<td>    Inc(J, T2);
<tr class="covered"><td>3515<td>  end;
<tr class="covered"><td>3516<td>  P[0] := I;
<tr class="covered"><td>3517<td>  P[1] := J;
<tr class="covered"><td>3518<td>  P[2] := T3;
<tr class="covered"><td>3519<td>end;
<tr class="nocodegen"><td>3520<td>
<tr class="nocodegen"><td>3521<td>{ TCipher_SCOP_DEC52 }
<tr class="nocodegen"><td>3522<td>
<tr class="nocodegen"><td>3523<td>class function TCipher_SCOP_DEC52.Context: TCipherContext;
<tr class="covered"><td>3524<td>begin
<tr class="covered"><td>3525<td>  Result.KeySize                     := 48;
<tr class="covered"><td>3526<td>  Result.BlockSize                   := 4;
<tr class="covered"><td>3527<td>  Result.BufferSize                  := 32;
<tr class="covered"><td>3528<td>  Result.AdditionalBufferSize        := 384 * 4 + 3 * SizeOf(UInt32);
<tr class="covered"><td>3529<td>  Result.NeedsAdditionalBufferBackup := True;
<tr class="covered"><td>3530<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3531<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3532<td>  Result.CipherType                  := [ctSymmetric, ctStream];
<tr class="covered"><td>3533<td>end;
<tr class="nocodegen"><td>3534<td>
<tr class="nocodegen"><td>3535<td>procedure TCipher_SCOP_DEC52.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>3536<td>var
<tr class="nocodegen"><td>3537<td>  Init_State: packed record
<tr class="nocodegen"><td>3538<td>    Coef: array[0..7, 0..3] of Byte;
<tr class="nocodegen"><td>3539<td>    X: array[0..3] of UInt32;
<tr class="nocodegen"><td>3540<td>  end;
<tr class="nocodegen"><td>3541<td>
<tr class="nocodegen"><td>3542<td>  procedure ExpandKey;
<tr class="nocodegen"><td>3543<td>  var
<tr class="nocodegen"><td>3544<td>    P: PByteArray;
<tr class="nocodegen"><td>3545<td>    I, C: Integer;
<tr class="covered"><td>3546<td>  begin
<tr class="covered"><td>3547<td>    C := 1;
<tr class="covered"><td>3548<td>    P := @Init_State;
<tr class="covered"><td>3549<td>    Move(Key, P^, Size);
<tr class="covered"><td>3550<td>    for I := Size to 47 do
<tr class="covered"><td>3551<td>      P[I] := P[I - Size] + P[I - Size + 1];
<tr class="covered"><td>3552<td>    for I := 0 to 31 do
<tr class="covered"><td>3553<td>      if P[I] = 0 then
<tr class="nocodegen"><td>3554<td>      begin
<tr class="notcovered"><td>3555<td>        P[I] := C;
<tr class="notcovered"><td>3556<td>        Inc(C);
<tr class="covered"><td>3557<td>      end;
<tr class="covered"><td>3558<td>  end;
<tr class="nocodegen"><td>3559<td>
<tr class="nocodegen"><td>3560<td>  procedure GP8(Data: PUInt32Array);
<tr class="nocodegen"><td>3561<td>  var
<tr class="nocodegen"><td>3562<td>    I, I2: Integer;
<tr class="nocodegen"><td>3563<td>    NewX: array[0..3] of UInt32;
<tr class="nocodegen"><td>3564<td>    X1, X2, X3, X4: UInt32;
<tr class="nocodegen"><td>3565<td>    Y1, Y2: UInt32;
<tr class="covered"><td>3566<td>  begin
<tr class="covered"><td>3567<td>    I := 0;
<tr class="covered"><td>3568<td>    I2 := 0;
<tr class="covered"><td>3569<td>    while I &lt; 8 do
<tr class="nocodegen"><td>3570<td>    begin
<tr class="covered"><td>3571<td>      X1 := Init_State.X[I2] shr 16;
<tr class="covered"><td>3572<td>      X2 := X1 * X1;
<tr class="covered"><td>3573<td>      X3 := X2 * X1;
<tr class="covered"><td>3574<td>      X4 := X3 * X1;
<tr class="covered"><td>3575<td>      Y1 := Init_State.Coef[I][0] * X4 +
<tr class="nocodegen"><td>3576<td>            Init_State.Coef[I][1] * X3 +
<tr class="nocodegen"><td>3577<td>            Init_State.Coef[I][2] * X2 +
<tr class="nocodegen"><td>3578<td>            Init_State.Coef[I][3] * X1 + 1;
<tr class="covered"><td>3579<td>      X1 := Init_State.X[I2] and $FFFF;
<tr class="covered"><td>3580<td>      X2 := X1 * X1;
<tr class="covered"><td>3581<td>      X3 := X2 * X1;
<tr class="covered"><td>3582<td>      X4 := X3 * X1;
<tr class="covered"><td>3583<td>      Y2 := Init_State.Coef[I + 1][0] * X4 +
<tr class="nocodegen"><td>3584<td>            Init_State.Coef[I + 2][1] * X3 +
<tr class="nocodegen"><td>3585<td>            Init_State.Coef[I + 3][2] * X2 +
<tr class="nocodegen"><td>3586<td>            Init_State.Coef[I + 4][3] * X1 + 1;
<tr class="covered"><td>3587<td>      Data[I2] := Y1 shl 16 or Y2 and $FFFF;
<tr class="covered"><td>3588<td>      NewX[I2] := Y1 and $FFFF0000 or Y2 shr 16;
<tr class="covered"><td>3589<td>      Inc(I2);
<tr class="covered"><td>3590<td>      Inc(I, 2);
<tr class="nocodegen"><td>3591<td>    end;
<tr class="covered"><td>3592<td>    Init_State.X[0] := NewX[0] shr 16 or NewX[3] shl 16;
<tr class="covered"><td>3593<td>    Init_State.X[1] := NewX[0] shl 16 or NewX[1] shr 16;
<tr class="covered"><td>3594<td>    Init_State.X[2] := NewX[1] shl 16 or NewX[2] shr 16;
<tr class="covered"><td>3595<td>    Init_State.X[3] := NewX[2] shl 16 or NewX[3] shr 16;
<tr class="covered"><td>3596<td>  end;
<tr class="nocodegen"><td>3597<td>
<tr class="nocodegen"><td>3598<td>var
<tr class="nocodegen"><td>3599<td>  I, J: Integer;
<tr class="nocodegen"><td>3600<td>  T: array[0..3] of Integer;
<tr class="nocodegen"><td>3601<td>  P: PUInt32Array;
<tr class="covered"><td>3602<td>begin
<tr class="covered"><td>3603<td>  FillChar(Init_State, SizeOf(Init_State), 0);
<tr class="covered"><td>3604<td>  FillChar(T, SizeOf(T), 0);
<tr class="covered"><td>3605<td>  P := Pointer(PByte(FAdditionalBuffer) + 12); // for Pointer Math
<tr class="covered"><td>3606<td>  ExpandKey;
<tr class="covered"><td>3607<td>  for I := 0 to 7 do
<tr class="covered"><td>3608<td>    GP8(@T);
<tr class="covered"><td>3609<td>  for I := 0 to 11 do
<tr class="nocodegen"><td>3610<td>  begin
<tr class="covered"><td>3611<td>    for J := 0 to 7 do
<tr class="covered"><td>3612<td>      GP8(@P[I * 32 + J * 4]);
<tr class="covered"><td>3613<td>    GP8(@T);
<tr class="covered"><td>3614<td>  end;
<tr class="covered"><td>3615<td>  GP8(@T);
<tr class="covered"><td>3616<td>  I := T[3] and $7F;
<tr class="covered"><td>3617<td>  P[I + 3] := P[I + 3] or 1;
<tr class="covered"><td>3618<td>  P := FAdditionalBuffer;
<tr class="covered"><td>3619<td>  P[0] := T[3] shr 24 and $FF;
<tr class="covered"><td>3620<td>  P[1] := T[3] shr 16 and $FF;
<tr class="covered"><td>3621<td>  P[2] := T[3] shr  8 and $FF;
<tr class="covered"><td>3622<td>  ProtectBuffer(Init_State, SizeOf(Init_State));
<tr class="nocodegen"><td>3623<td>
<tr class="nocodegen"><td>3624<td>  inherited;
<tr class="covered"><td>3625<td>end;
<tr class="nocodegen"><td>3626<td>
<tr class="nocodegen"><td>3627<td>procedure TCipher_SCOP_DEC52.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3628<td>var
<tr class="nocodegen"><td>3629<td>  I, J: Byte;
<tr class="nocodegen"><td>3630<td>  T2, T3, T1: UInt32;
<tr class="nocodegen"><td>3631<td>  P: PUInt32Array;
<tr class="nocodegen"><td>3632<td>  W: Integer;
<tr class="covered"><td>3633<td>begin
<tr class="covered"><td>3634<td>  P  := FAdditionalBuffer;
<tr class="covered"><td>3635<td>  I  := P[0];
<tr class="covered"><td>3636<td>  J  := P[1];
<tr class="covered"><td>3637<td>  T3 := P[2];
<tr class="covered"><td>3638<td>  for W := 0 to Size div 4 - 1 do
<tr class="nocodegen"><td>3639<td>  begin
<tr class="covered"><td>3640<td>    T1 := P[J + 3 + 128]; Inc(J, T3);
<tr class="covered"><td>3641<td>    T2 := P[J + 3 + 128];
<tr class="covered"><td>3642<td>    PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] + T1 + T2;
<tr class="covered"><td>3643<td>    T3 := T2 + P[I + 3];  Inc(I);
<tr class="covered"><td>3644<td>    P[J + 3 + 128] := T3;
<tr class="covered"><td>3645<td>    Inc(J, T2);
<tr class="covered"><td>3646<td>  end;
<tr class="covered"><td>3647<td>  P[0] := I;
<tr class="covered"><td>3648<td>  P[1] := J;
<tr class="covered"><td>3649<td>  P[2] := T3;
<tr class="covered"><td>3650<td>end;
<tr class="nocodegen"><td>3651<td>
<tr class="nocodegen"><td>3652<td>procedure TCipher_SCOP_DEC52.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3653<td>var
<tr class="nocodegen"><td>3654<td>  I, J: Byte;
<tr class="nocodegen"><td>3655<td>  T1, T2, T3: UInt32;
<tr class="nocodegen"><td>3656<td>  P: PUInt32Array;
<tr class="nocodegen"><td>3657<td>  W: Integer;
<tr class="covered"><td>3658<td>begin
<tr class="covered"><td>3659<td>  P  := FAdditionalBuffer;
<tr class="covered"><td>3660<td>  I  := P[0];
<tr class="covered"><td>3661<td>  J  := P[1];
<tr class="covered"><td>3662<td>  T3 := P[2];
<tr class="covered"><td>3663<td>  for W := 0 to Size div 4 - 1 do
<tr class="nocodegen"><td>3664<td>  begin
<tr class="covered"><td>3665<td>    T1 := P[J + 3 + 128]; Inc(J, T3);
<tr class="covered"><td>3666<td>    T2 := P[J + 3 + 128];
<tr class="covered"><td>3667<td>    PUInt32Array(Dest)[W] := PUInt32Array(Source)[W] - T1 - T2;
<tr class="covered"><td>3668<td>    T3 := T2 + P[I + 3];
<tr class="covered"><td>3669<td>    Inc(I);
<tr class="covered"><td>3670<td>    P[J + 3 + 128] := T3;
<tr class="covered"><td>3671<td>    Inc(J, T2);
<tr class="covered"><td>3672<td>  end;
<tr class="covered"><td>3673<td>  P[0] := I;
<tr class="covered"><td>3674<td>  P[1] := J;
<tr class="covered"><td>3675<td>  P[2] := T3;
<tr class="covered"><td>3676<td>end;
<tr class="nocodegen"><td>3677<td>
<tr class="nocodegen"><td>3678<td>{ TCipher_Sapphire }
<tr class="nocodegen"><td>3679<td>
<tr class="nocodegen"><td>3680<td>type
<tr class="nocodegen"><td>3681<td>  PSapphireKey = ^TSapphireKey;
<tr class="nocodegen"><td>3682<td>  TSapphireKey = packed record
<tr class="nocodegen"><td>3683<td>    Cards: array[0..255] of UInt32;
<tr class="nocodegen"><td>3684<td>    Rotor: UInt32;
<tr class="nocodegen"><td>3685<td>    Ratchet: UInt32;
<tr class="nocodegen"><td>3686<td>    Avalanche: UInt32;
<tr class="nocodegen"><td>3687<td>    Plain: UInt32;
<tr class="nocodegen"><td>3688<td>    Cipher: UInt32;
<tr class="nocodegen"><td>3689<td>  end;
<tr class="nocodegen"><td>3690<td>
<tr class="nocodegen"><td>3691<td>class function TCipher_Sapphire.Context: TCipherContext;
<tr class="covered"><td>3692<td>begin
<tr class="covered"><td>3693<td>  Result.KeySize                     := 1024;
<tr class="covered"><td>3694<td>  Result.BlockSize                   := 1;
<tr class="covered"><td>3695<td>  Result.BufferSize                  := 32;
<tr class="covered"><td>3696<td>  Result.AdditionalBufferSize        := SizeOf(TSapphireKey);
<tr class="covered"><td>3697<td>  Result.NeedsAdditionalBufferBackup := True;
<tr class="covered"><td>3698<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3699<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3700<td>  Result.CipherType                  := [ctSymmetric, ctStream];
<tr class="covered"><td>3701<td>end;
<tr class="nocodegen"><td>3702<td>
<tr class="nocodegen"><td>3703<td>procedure TCipher_Sapphire.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>3704<td>var
<tr class="nocodegen"><td>3705<td>  Sum: Byte;
<tr class="nocodegen"><td>3706<td>  P: Integer;
<tr class="nocodegen"><td>3707<td>
<tr class="nocodegen"><td>3708<td>  function KeyRand(Max: UInt32): Byte;
<tr class="nocodegen"><td>3709<td>  var
<tr class="nocodegen"><td>3710<td>    I, M: UInt32;
<tr class="covered"><td>3711<td>  begin
<tr class="covered"><td>3712<td>    Result := 0;
<tr class="covered"><td>3713<td>    if Max = 0 then
<tr class="nocodegen"><td>3714<td>      Exit;
<tr class="covered"><td>3715<td>    I := 0;
<tr class="covered"><td>3716<td>    M := 1;
<tr class="nocodegen"><td>3717<td>
<tr class="covered"><td>3718<td>    while M &lt; Max do
<tr class="covered"><td>3719<td>     Inc(M, M or 1);
<tr class="nocodegen"><td>3720<td>
<tr class="nocodegen"><td>3721<td>    repeat
<tr class="covered"><td>3722<td>      Inc(Sum, TByteArray(Key)[P]);
<tr class="covered"><td>3723<td>      Inc(P);
<tr class="covered"><td>3724<td>      if P &gt;= Size then
<tr class="nocodegen"><td>3725<td>      begin
<tr class="covered"><td>3726<td>        P := 0;
<tr class="covered"><td>3727<td>        Inc(Sum, Size);
<tr class="nocodegen"><td>3728<td>      end;
<tr class="covered"><td>3729<td>      Result := M and Sum;
<tr class="covered"><td>3730<td>      Inc(I);
<tr class="covered"><td>3731<td>      if I &gt; 11 then
<tr class="notcovered"><td>3732<td>        Result := Result mod Max;
<tr class="covered"><td>3733<td>    until Result &lt;= Max;
<tr class="covered"><td>3734<td>  end;
<tr class="nocodegen"><td>3735<td>
<tr class="nocodegen"><td>3736<td>var
<tr class="nocodegen"><td>3737<td>  I, S, T: Integer;
<tr class="nocodegen"><td>3738<td>  SKey : PSapphireKey;
<tr class="covered"><td>3739<td>begin
<tr class="covered"><td>3740<td>  SKey := PSapphireKey(FAdditionalBuffer);
<tr class="covered"><td>3741<td>  if Size &lt;= 0 then
<tr class="nocodegen"><td>3742<td>  begin
<tr class="notcovered"><td>3743<td>    SKey.Rotor     := 1;
<tr class="notcovered"><td>3744<td>    SKey.Ratchet   := 3;
<tr class="notcovered"><td>3745<td>    SKey.Avalanche := 5;
<tr class="notcovered"><td>3746<td>    SKey.Plain     := 7;
<tr class="notcovered"><td>3747<td>    SKey.Cipher    := 11;
<tr class="notcovered"><td>3748<td>    for I := 0 to 255 do
<tr class="notcovered"><td>3749<td>      SKey.Cards[I] := 255 - I;
<tr class="nocodegen"><td>3750<td>  end
<tr class="nocodegen"><td>3751<td>  else
<tr class="nocodegen"><td>3752<td>  begin
<tr class="covered"><td>3753<td>    for I := 0 to 255 do
<tr class="covered"><td>3754<td>      SKey.Cards[I] := I;
<tr class="covered"><td>3755<td>    P   := 0;
<tr class="covered"><td>3756<td>    Sum := 0;
<tr class="covered"><td>3757<td>    for I := 255 downto 1 do
<tr class="nocodegen"><td>3758<td>    begin
<tr class="covered"><td>3759<td>      S := KeyRand(I);
<tr class="covered"><td>3760<td>      T := SKey.Cards[I];
<tr class="covered"><td>3761<td>      SKey.Cards[I] := SKey.Cards[S];
<tr class="covered"><td>3762<td>      SKey.Cards[S] := T;
<tr class="covered"><td>3763<td>    end;
<tr class="covered"><td>3764<td>    SKey.Rotor     := SKey.Cards[1];
<tr class="covered"><td>3765<td>    SKey.Ratchet   := SKey.Cards[3];
<tr class="covered"><td>3766<td>    SKey.Avalanche := SKey.Cards[5];
<tr class="covered"><td>3767<td>    SKey.Plain     := SKey.Cards[7];
<tr class="covered"><td>3768<td>    SKey.Cipher    := SKey.Cards[Sum];
<tr class="nocodegen"><td>3769<td>  end;
<tr class="nocodegen"><td>3770<td>
<tr class="nocodegen"><td>3771<td>  inherited;
<tr class="covered"><td>3772<td>end;
<tr class="nocodegen"><td>3773<td>
<tr class="nocodegen"><td>3774<td>procedure TCipher_Sapphire.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3775<td>var
<tr class="nocodegen"><td>3776<td>  T: UInt32;
<tr class="nocodegen"><td>3777<td>  I: Integer;
<tr class="nocodegen"><td>3778<td>  SKey: PSapphireKey;
<tr class="covered"><td>3779<td>begin
<tr class="covered"><td>3780<td>  SKey := PSapphireKey(FAdditionalBuffer);
<tr class="covered"><td>3781<td>  for I := 0 to Size - 1 do
<tr class="nocodegen"><td>3782<td>  begin
<tr class="covered"><td>3783<td>    SKey.Ratchet := (SKey.Ratchet + SKey.Cards[SKey.Rotor]) and $FF;
<tr class="covered"><td>3784<td>    SKey.Rotor := (SKey.Rotor + 1) and $FF;
<tr class="covered"><td>3785<td>    T := SKey.Cards[SKey.Cipher];
<tr class="covered"><td>3786<td>    SKey.Cards[SKey.Cipher]  := SKey.Cards[SKey.Ratchet];
<tr class="covered"><td>3787<td>    SKey.Cards[SKey.Ratchet] := SKey.Cards[SKey.Plain];
<tr class="covered"><td>3788<td>    SKey.Cards[SKey.Plain]   := SKey.Cards[SKey.Rotor];
<tr class="covered"><td>3789<td>    SKey.Cards[SKey.Rotor]   := T;
<tr class="covered"><td>3790<td>    SKey.Avalanche := (SKey.Avalanche + SKey.Cards[T]) and $FF;
<tr class="covered"><td>3791<td>    T := (SKey.Cards[SKey.Plain] + SKey.Cards[SKey.Cipher] + SKey.Cards[SKey.Avalanche]) and $FF;
<tr class="covered"><td>3792<td>    SKey.Plain := PByteArray(Source)[I];
<tr class="covered"><td>3793<td>    SKey.Cipher := SKey.Plain xor SKey.Cards[SKey.Cards[T]] xor
<tr class="nocodegen"><td>3794<td>                   SKey.Cards[(SKey.Cards[SKey.Ratchet] +
<tr class="nocodegen"><td>3795<td>                   SKey.Cards[SKey.Rotor]) and $FF];
<tr class="covered"><td>3796<td>    PByteArray(Dest)[I] := SKey.Cipher;
<tr class="covered"><td>3797<td>  end;
<tr class="covered"><td>3798<td>end;
<tr class="nocodegen"><td>3799<td>
<tr class="nocodegen"><td>3800<td>procedure TCipher_Sapphire.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>3801<td>var
<tr class="nocodegen"><td>3802<td>  T: UInt32;
<tr class="nocodegen"><td>3803<td>  I: Integer;
<tr class="nocodegen"><td>3804<td>  SKey: PSapphireKey;
<tr class="covered"><td>3805<td>begin
<tr class="covered"><td>3806<td>  SKey := PSapphireKey(FAdditionalBuffer);
<tr class="covered"><td>3807<td>  for I := 0 to Size - 1 do
<tr class="nocodegen"><td>3808<td>  begin
<tr class="covered"><td>3809<td>    SKey.Ratchet := (SKey.Ratchet + SKey.Cards[SKey.Rotor]) and $FF;
<tr class="covered"><td>3810<td>    SKey.Rotor := (SKey.Rotor + 1) and $FF;
<tr class="covered"><td>3811<td>    T := SKey.Cards[SKey.Cipher];
<tr class="covered"><td>3812<td>    SKey.Cards[SKey.Cipher]  := SKey.Cards[SKey.Ratchet];
<tr class="covered"><td>3813<td>    SKey.Cards[SKey.Ratchet] := SKey.Cards[SKey.Plain];
<tr class="covered"><td>3814<td>    SKey.Cards[SKey.Plain]   := SKey.Cards[SKey.Rotor];
<tr class="covered"><td>3815<td>    SKey.Cards[SKey.Rotor]   := T;
<tr class="covered"><td>3816<td>    SKey.Avalanche := (SKey.Avalanche + SKey.Cards[T]) and $FF;
<tr class="covered"><td>3817<td>    T := (SKey.Cards[SKey.Plain] + SKey.Cards[SKey.Cipher] + SKey.Cards[SKey.Avalanche]) and $FF;
<tr class="covered"><td>3818<td>    SKey.Cipher := PByteArray(Source)[I];
<tr class="covered"><td>3819<td>    SKey.Plain := SKey.Cipher xor SKey.Cards[SKey.Cards[T]] xor
<tr class="nocodegen"><td>3820<td>                  SKey.Cards[(SKey.Cards[SKey.Ratchet] +
<tr class="nocodegen"><td>3821<td>                  SKey.Cards[SKey.Rotor]) and $FF];
<tr class="covered"><td>3822<td>    PByteArray(Dest)[I] := SKey.Plain;
<tr class="covered"><td>3823<td>  end;
<tr class="covered"><td>3824<td>end;
<tr class="nocodegen"><td>3825<td>
<tr class="nocodegen"><td>3826<td>{ DES basics }
<tr class="nocodegen"><td>3827<td>
<tr class="nocodegen"><td>3828<td>procedure DES_Func(Source, Dest, Key: PUInt32Array);
<tr class="nocodegen"><td>3829<td>var
<tr class="nocodegen"><td>3830<td>  L, R, X, Y, I: UInt32;
<tr class="covered"><td>3831<td>begin
<tr class="covered"><td>3832<td>  L := SwapUInt32(Source[0]);
<tr class="covered"><td>3833<td>  R := SwapUInt32(Source[1]);
<tr class="nocodegen"><td>3834<td>
<tr class="covered"><td>3835<td>  X := (L shr  4 xor R) and $0F0F0F0F; R := R xor X; L := L xor X shl  4;
<tr class="covered"><td>3836<td>  X := (L shr 16 xor R) and $0000FFFF; R := R xor X; L := L xor X shl 16;
<tr class="covered"><td>3837<td>  X := (R shr  2 xor L) and $33333333; L := L xor X; R := R xor X shl  2;
<tr class="covered"><td>3838<td>  X := (R shr  8 xor L) and $00FF00FF; L := L xor X; R := R xor X shl  8;
<tr class="nocodegen"><td>3839<td>
<tr class="covered"><td>3840<td>  R := R shl 1 or R shr 31;
<tr class="covered"><td>3841<td>  X := (L xor R) and $AAAAAAAA;
<tr class="covered"><td>3842<td>  R := R xor X;
<tr class="covered"><td>3843<td>  L := L xor X;
<tr class="covered"><td>3844<td>  L := L shl 1 or L shr 31;
<tr class="nocodegen"><td>3845<td>
<tr class="covered"><td>3846<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>3847<td>  begin
<tr class="covered"><td>3848<td>    X := (R shl 28 or R shr 4) xor Key[0];
<tr class="covered"><td>3849<td>    Y := R xor Key[1];
<tr class="covered"><td>3850<td>    L := L xor (DES_Data[0, X        and $3F] or DES_Data[1, X shr  8 and $3F] or
<tr class="nocodegen"><td>3851<td>                DES_Data[2, X shr 16 and $3F] or DES_Data[3, X shr 24 and $3F] or
<tr class="nocodegen"><td>3852<td>                DES_Data[4, Y        and $3F] or DES_Data[5, Y shr  8 and $3F] or
<tr class="nocodegen"><td>3853<td>                DES_Data[6, Y shr 16 and $3F] or DES_Data[7, Y shr 24 and $3F]);
<tr class="nocodegen"><td>3854<td>
<tr class="covered"><td>3855<td>    X := (L shl 28 or L shr 4) xor Key[2];
<tr class="covered"><td>3856<td>    Y := L xor Key[3];
<tr class="covered"><td>3857<td>    R := R xor (DES_Data[0, X        and $3F] or DES_Data[1, X shr  8 and $3F] or
<tr class="nocodegen"><td>3858<td>                DES_Data[2, X shr 16 and $3F] or DES_Data[3, X shr 24 and $3F] or
<tr class="nocodegen"><td>3859<td>                DES_Data[4, Y        and $3F] or DES_Data[5, Y shr  8 and $3F] or
<tr class="nocodegen"><td>3860<td>                DES_Data[6, Y shr 16 and $3F] or DES_Data[7, Y shr 24 and $3F]);
<tr class="covered"><td>3861<td>    Key := @Key[4];
<tr class="covered"><td>3862<td>  end;
<tr class="nocodegen"><td>3863<td>
<tr class="covered"><td>3864<td>  R := R shl 31 or R shr 1;
<tr class="covered"><td>3865<td>  X := (L xor R) and $AAAAAAAA;
<tr class="covered"><td>3866<td>  R := R xor X;
<tr class="covered"><td>3867<td>  L := L xor X;
<tr class="covered"><td>3868<td>  L := L shl 31 or L shr 1;
<tr class="nocodegen"><td>3869<td>
<tr class="covered"><td>3870<td>  X := (L shr  8 xor R) and $00FF00FF; R := R xor X; L := L xor X shl  8;
<tr class="covered"><td>3871<td>  X := (L shr  2 xor R) and $33333333; R := R xor X; L := L xor X shl  2;
<tr class="covered"><td>3872<td>  X := (R shr 16 xor L) and $0000FFFF; L := L xor X; R := R xor X shl 16;
<tr class="covered"><td>3873<td>  X := (R shr  4 xor L) and $0F0F0F0F; L := L xor X; R := R xor X shl  4;
<tr class="nocodegen"><td>3874<td>
<tr class="covered"><td>3875<td>  Dest[0] := SwapUInt32(R);
<tr class="covered"><td>3876<td>  Dest[1] := SwapUInt32(L);
<tr class="covered"><td>3877<td>end;
<tr class="nocodegen"><td>3878<td>
<tr class="nocodegen"><td>3879<td>procedure TCipher_DESBase.DoInitKey(const Data: array of Byte; Key: PUInt32Array; Reverse: Boolean);
<tr class="nocodegen"><td>3880<td>const
<tr class="nocodegen"><td>3881<td>  ROT: array[0..15] of Byte = (1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28);
<tr class="nocodegen"><td>3882<td>var
<tr class="nocodegen"><td>3883<td>  I, J, L, M, N: UInt32;
<tr class="nocodegen"><td>3884<td>  PC_M, PC_R: array[0..55] of Byte;
<tr class="nocodegen"><td>3885<td>  K: array[0..31] of UInt32;
<tr class="covered"><td>3886<td>begin
<tr class="covered"><td>3887<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>3888<td>  for I := 0 to 55 do
<tr class="covered"><td>3889<td>    if Data[DES_PC1[I] shr 3] and ($80 shr (DES_PC1[I] and $07)) &lt;&gt; 0 then
<tr class="covered"><td>3890<td>      PC_M[I] := 1
<tr class="nocodegen"><td>3891<td>    else
<tr class="covered"><td>3892<td>      PC_M[I] := 0;
<tr class="covered"><td>3893<td>  for I := 0 to 15 do
<tr class="nocodegen"><td>3894<td>  begin
<tr class="covered"><td>3895<td>    if Reverse then
<tr class="covered"><td>3896<td>      M := (15 - I) shl 1
<tr class="nocodegen"><td>3897<td>    else
<tr class="covered"><td>3898<td>      M := I shl 1;
<tr class="covered"><td>3899<td>    N := M + 1;
<tr class="covered"><td>3900<td>    for J := 0 to 27 do
<tr class="nocodegen"><td>3901<td>    begin
<tr class="covered"><td>3902<td>      L := J + ROT[I];
<tr class="covered"><td>3903<td>      if L &lt; 28 then
<tr class="covered"><td>3904<td>        PC_R[J] := PC_M[L]
<tr class="nocodegen"><td>3905<td>      else
<tr class="covered"><td>3906<td>        PC_R[J] := PC_M[L - 28];
<tr class="covered"><td>3907<td>    end;
<tr class="covered"><td>3908<td>    for J := 28 to 55 do
<tr class="nocodegen"><td>3909<td>    begin
<tr class="covered"><td>3910<td>      L := J + ROT[I];
<tr class="covered"><td>3911<td>      if L &lt; 56 then
<tr class="covered"><td>3912<td>        PC_R[J] := PC_M[L]
<tr class="nocodegen"><td>3913<td>      else
<tr class="covered"><td>3914<td>        PC_R[J] := PC_M[L - 28];
<tr class="covered"><td>3915<td>    end;
<tr class="covered"><td>3916<td>    L := $1000000;
<tr class="covered"><td>3917<td>    for J := 0 to 23 do
<tr class="nocodegen"><td>3918<td>    begin
<tr class="covered"><td>3919<td>      L := L shr 1;
<tr class="covered"><td>3920<td>      if PC_R[DES_PC2[J     ]] &lt;&gt; 0 then
<tr class="covered"><td>3921<td>        K[M] := K[M] or L;
<tr class="covered"><td>3922<td>      if PC_R[DES_PC2[J + 24]] &lt;&gt; 0 then
<tr class="covered"><td>3923<td>        K[N] := K[N] or L;
<tr class="covered"><td>3924<td>    end;
<tr class="covered"><td>3925<td>  end;
<tr class="covered"><td>3926<td>  for I := 0 to 15 do
<tr class="nocodegen"><td>3927<td>  begin
<tr class="covered"><td>3928<td>    M := I shl 1;
<tr class="covered"><td>3929<td>    N := M + 1;
<tr class="covered"><td>3930<td>    Key[0] := K[M] and $00FC0000 shl  6 or
<tr class="nocodegen"><td>3931<td>              K[M] and $00000FC0 shl 10 or
<tr class="nocodegen"><td>3932<td>              K[N] and $00FC0000 shr 10 or
<tr class="nocodegen"><td>3933<td>              K[N] and $00000FC0 shr  6;
<tr class="covered"><td>3934<td>    Key[1] := K[M] and $0003F000 shl 12 or
<tr class="nocodegen"><td>3935<td>              K[M] and $0000003F shl 16 or
<tr class="nocodegen"><td>3936<td>              K[N] and $0003F000 shr  4 or
<tr class="nocodegen"><td>3937<td>              K[N] and $0000003F;
<tr class="covered"><td>3938<td>    Key := @Key[2];
<tr class="covered"><td>3939<td>  end;
<tr class="covered"><td>3940<td>  ProtectBuffer(K, SizeOf(K));
<tr class="covered"><td>3941<td>  ProtectBuffer(PC_M, SizeOf(PC_M));
<tr class="covered"><td>3942<td>  ProtectBuffer(PC_R, SizeOf(PC_R));
<tr class="covered"><td>3943<td>end;
<tr class="nocodegen"><td>3944<td>
<tr class="nocodegen"><td>3945<td>{ TCipher_1DES }
<tr class="nocodegen"><td>3946<td>
<tr class="nocodegen"><td>3947<td>class function TCipher_1DES.Context: TCipherContext;
<tr class="covered"><td>3948<td>begin
<tr class="covered"><td>3949<td>  Result.KeySize                     := 8;
<tr class="covered"><td>3950<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>3951<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>3952<td>  Result.AdditionalBufferSize        := 32 * 4 * 2;
<tr class="covered"><td>3953<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>3954<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3955<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3956<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>3957<td>end;
<tr class="nocodegen"><td>3958<td>
<tr class="nocodegen"><td>3959<td>procedure TCipher_1DES.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>3960<td>var
<tr class="nocodegen"><td>3961<td>  K: array[0..7] of Byte;
<tr class="covered"><td>3962<td>begin
<tr class="covered"><td>3963<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>3964<td>  Move(Key, K, Size);
<tr class="covered"><td>3965<td>  DoInitKey(K, FAdditionalBuffer, False);
<tr class="covered"><td>3966<td>  DoInitKey(K, @PUInt32Array(FAdditionalBuffer)[32], True);
<tr class="covered"><td>3967<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>3968<td>
<tr class="nocodegen"><td>3969<td>  inherited;
<tr class="covered"><td>3970<td>end;
<tr class="nocodegen"><td>3971<td>
<tr class="nocodegen"><td>3972<td>procedure TCipher_1DES.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>3973<td>begin
<tr class="covered"><td>3974<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>3975<td>  DES_Func(Source, Dest, FAdditionalBuffer);
<tr class="covered"><td>3976<td>end;
<tr class="nocodegen"><td>3977<td>
<tr class="nocodegen"><td>3978<td>procedure TCipher_1DES.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>3979<td>begin
<tr class="covered"><td>3980<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>3981<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>3982<td>end;
<tr class="nocodegen"><td>3983<td>
<tr class="nocodegen"><td>3984<td>{ TCipher_2DES }
<tr class="nocodegen"><td>3985<td>
<tr class="nocodegen"><td>3986<td>class function TCipher_2DES.Context: TCipherContext;
<tr class="covered"><td>3987<td>begin
<tr class="covered"><td>3988<td>  Result.KeySize                     := 16;
<tr class="covered"><td>3989<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>3990<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>3991<td>  Result.AdditionalBufferSize        := 32 * 4 * 2 * 2;
<tr class="covered"><td>3992<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>3993<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>3994<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>3995<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>3996<td>end;
<tr class="nocodegen"><td>3997<td>
<tr class="nocodegen"><td>3998<td>procedure TCipher_2DES.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>3999<td>var
<tr class="nocodegen"><td>4000<td>  K: array[0..15] of Byte;
<tr class="nocodegen"><td>4001<td>  P: PUInt32Array;
<tr class="covered"><td>4002<td>begin
<tr class="covered"><td>4003<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>4004<td>  Move(Key, K, Size);
<tr class="covered"><td>4005<td>  P := FAdditionalBuffer;
<tr class="covered"><td>4006<td>  DoInitKey(K[0], @P[ 0], False);
<tr class="covered"><td>4007<td>  DoInitKey(K[8], @P[32], True);
<tr class="covered"><td>4008<td>  DoInitKey(K[0], @P[64], True);
<tr class="covered"><td>4009<td>  DoInitKey(K[8], @P[96], False);
<tr class="covered"><td>4010<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>4011<td>
<tr class="nocodegen"><td>4012<td>  inherited;
<tr class="covered"><td>4013<td>end;
<tr class="nocodegen"><td>4014<td>
<tr class="nocodegen"><td>4015<td>procedure TCipher_2DES.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>4016<td>begin
<tr class="covered"><td>4017<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>4018<td>  DES_Func(Source, Dest, FAdditionalBuffer);
<tr class="covered"><td>4019<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4020<td>  DES_Func(Source, Dest, FAdditionalBuffer);
<tr class="covered"><td>4021<td>end;
<tr class="nocodegen"><td>4022<td>
<tr class="nocodegen"><td>4023<td>procedure TCipher_2DES.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>4024<td>begin
<tr class="covered"><td>4025<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>4026<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4027<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4028<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4029<td>end;
<tr class="nocodegen"><td>4030<td>
<tr class="nocodegen"><td>4031<td>{ TCipher_3DES }
<tr class="nocodegen"><td>4032<td>
<tr class="nocodegen"><td>4033<td>class function TCipher_3DES.Context: TCipherContext;
<tr class="covered"><td>4034<td>begin
<tr class="covered"><td>4035<td>  Result.KeySize                     := 24;
<tr class="covered"><td>4036<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>4037<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>4038<td>  Result.AdditionalBufferSize        := 32 * 4 * 2 * 3;
<tr class="covered"><td>4039<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>4040<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>4041<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>4042<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>4043<td>end;
<tr class="nocodegen"><td>4044<td>
<tr class="nocodegen"><td>4045<td>procedure TCipher_3DES.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>4046<td>var
<tr class="nocodegen"><td>4047<td>  K: array[0..23] of Byte;
<tr class="nocodegen"><td>4048<td>  P: PUInt32Array;
<tr class="covered"><td>4049<td>begin
<tr class="covered"><td>4050<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>4051<td>  Move(Key, K, Size);
<tr class="covered"><td>4052<td>  P := FAdditionalBuffer;
<tr class="covered"><td>4053<td>  DoInitKey(K[ 0], @P[  0], False);
<tr class="covered"><td>4054<td>  DoInitKey(K[ 8], @P[ 32], True);
<tr class="covered"><td>4055<td>  DoInitKey(K[16], @P[ 64], False);
<tr class="covered"><td>4056<td>  DoInitKey(K[16], @P[ 96], True);
<tr class="covered"><td>4057<td>  DoInitKey(K[ 8], @P[128], False);
<tr class="covered"><td>4058<td>  DoInitKey(K[ 0], @P[160], True);
<tr class="covered"><td>4059<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>4060<td>
<tr class="nocodegen"><td>4061<td>  inherited;
<tr class="covered"><td>4062<td>end;
<tr class="nocodegen"><td>4063<td>
<tr class="nocodegen"><td>4064<td>procedure TCipher_3DES.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>4065<td>begin
<tr class="covered"><td>4066<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>4067<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[ 0]);
<tr class="covered"><td>4068<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4069<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4070<td>end;
<tr class="nocodegen"><td>4071<td>
<tr class="nocodegen"><td>4072<td>procedure TCipher_3DES.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>4073<td>begin
<tr class="covered"><td>4074<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>4075<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4076<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[128]);
<tr class="covered"><td>4077<td>  DES_Func(Source, Dest, @PUInt32Array(FAdditionalBuffer)[160]);
<tr class="covered"><td>4078<td>end;
<tr class="nocodegen"><td>4079<td>
<tr class="nocodegen"><td>4080<td>{ TCipher_2DDES }
<tr class="nocodegen"><td>4081<td>
<tr class="nocodegen"><td>4082<td>class function TCipher_2DDES.Context: TCipherContext;
<tr class="covered"><td>4083<td>begin
<tr class="covered"><td>4084<td>  Result            := inherited Context;
<tr class="covered"><td>4085<td>  Result.BlockSize  := 16;
<tr class="covered"><td>4086<td>  Result.BufferSize := 16;
<tr class="covered"><td>4087<td>  Result.MinRounds  := 1;
<tr class="covered"><td>4088<td>  Result.MaxRounds  := 1;
<tr class="covered"><td>4089<td>  Result.CipherType := [ctSymmetric, ctBlock];
<tr class="covered"><td>4090<td>end;
<tr class="nocodegen"><td>4091<td>
<tr class="nocodegen"><td>4092<td>procedure TCipher_2DDES.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4093<td>var
<tr class="nocodegen"><td>4094<td>  T: UInt32;
<tr class="covered"><td>4095<td>begin
<tr class="covered"><td>4096<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4097<td>
<tr class="covered"><td>4098<td>  DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);
<tr class="covered"><td>4099<td>  DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);
<tr class="covered"><td>4100<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4101<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4102<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4103<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4104<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4105<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4106<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4107<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4108<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);
<tr class="covered"><td>4109<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);
<tr class="covered"><td>4110<td>end;
<tr class="nocodegen"><td>4111<td>
<tr class="nocodegen"><td>4112<td>procedure TCipher_2DDES.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4113<td>var
<tr class="nocodegen"><td>4114<td>  T: UInt32;
<tr class="covered"><td>4115<td>begin
<tr class="covered"><td>4116<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4117<td>
<tr class="covered"><td>4118<td>  DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4119<td>  DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4120<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4121<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4122<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4123<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4124<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4125<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4126<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4127<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4128<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4129<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4130<td>end;
<tr class="nocodegen"><td>4131<td>
<tr class="nocodegen"><td>4132<td>{ TCipher_3DDES }
<tr class="nocodegen"><td>4133<td>
<tr class="nocodegen"><td>4134<td>class function TCipher_3DDES.Context: TCipherContext;
<tr class="covered"><td>4135<td>begin
<tr class="covered"><td>4136<td>  Result            := inherited Context;
<tr class="covered"><td>4137<td>  Result.BlockSize  := 16;
<tr class="covered"><td>4138<td>  Result.BufferSize := 16;
<tr class="covered"><td>4139<td>  Result.MinRounds  := 1;
<tr class="covered"><td>4140<td>  Result.MaxRounds  := 1;
<tr class="covered"><td>4141<td>  Result.CipherType := [ctSymmetric, ctBlock];
<tr class="covered"><td>4142<td>end;
<tr class="nocodegen"><td>4143<td>
<tr class="nocodegen"><td>4144<td>procedure TCipher_3DDES.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4145<td>var
<tr class="nocodegen"><td>4146<td>  T: UInt32;
<tr class="covered"><td>4147<td>begin
<tr class="covered"><td>4148<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4149<td>
<tr class="covered"><td>4150<td>  DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);
<tr class="covered"><td>4151<td>  DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);
<tr class="covered"><td>4152<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4153<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4154<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4155<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4156<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4157<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4158<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4159<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4160<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4161<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4162<td>end;
<tr class="nocodegen"><td>4163<td>
<tr class="nocodegen"><td>4164<td>procedure TCipher_3DDES.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4165<td>var
<tr class="nocodegen"><td>4166<td>  T: UInt32;
<tr class="covered"><td>4167<td>begin
<tr class="covered"><td>4168<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4169<td>
<tr class="covered"><td>4170<td>  DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4171<td>  DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4172<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4173<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4174<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4175<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[128]);
<tr class="covered"><td>4176<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[128]);
<tr class="covered"><td>4177<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4178<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4179<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4180<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[160]);
<tr class="covered"><td>4181<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[160]);
<tr class="covered"><td>4182<td>end;
<tr class="nocodegen"><td>4183<td>
<tr class="nocodegen"><td>4184<td>{ TCipher_3TDES }
<tr class="nocodegen"><td>4185<td>
<tr class="nocodegen"><td>4186<td>class function TCipher_3TDES.Context: TCipherContext;
<tr class="covered"><td>4187<td>begin
<tr class="covered"><td>4188<td>  Result            := inherited Context;
<tr class="covered"><td>4189<td>  Result.BlockSize  := 24;
<tr class="covered"><td>4190<td>  Result.BufferSize := 24;
<tr class="covered"><td>4191<td>  Result.MinRounds  := 1;
<tr class="covered"><td>4192<td>  Result.MaxRounds  := 1;
<tr class="covered"><td>4193<td>  Result.CipherType := [ctSymmetric, ctBlock];
<tr class="covered"><td>4194<td>end;
<tr class="nocodegen"><td>4195<td>
<tr class="nocodegen"><td>4196<td>procedure TCipher_3TDES.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4197<td>var
<tr class="nocodegen"><td>4198<td>  T: UInt32;
<tr class="covered"><td>4199<td>begin
<tr class="covered"><td>4200<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4201<td>
<tr class="covered"><td>4202<td>  DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], FAdditionalBuffer);
<tr class="covered"><td>4203<td>  DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], FAdditionalBuffer);
<tr class="covered"><td>4204<td>  DES_Func(@PUInt32Array(Source)[4], @PUInt32Array(Dest)[4], FAdditionalBuffer);
<tr class="covered"><td>4205<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4206<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4207<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4208<td>  T := PUInt32Array(Dest)[3];
<tr class="covered"><td>4209<td>  PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];
<tr class="covered"><td>4210<td>  PUInt32Array(Dest)[4] := T;
<tr class="covered"><td>4211<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4212<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4213<td>  DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[32]);
<tr class="covered"><td>4214<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4215<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4216<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4217<td>  T := PUInt32Array(Dest)[3];
<tr class="covered"><td>4218<td>  PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];
<tr class="covered"><td>4219<td>  PUInt32Array(Dest)[4] := T;
<tr class="covered"><td>4220<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4221<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4222<td>  DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[64]);
<tr class="covered"><td>4223<td>end;
<tr class="nocodegen"><td>4224<td>
<tr class="nocodegen"><td>4225<td>procedure TCipher_3TDES.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4226<td>var
<tr class="nocodegen"><td>4227<td>  T: UInt32;
<tr class="covered"><td>4228<td>begin
<tr class="covered"><td>4229<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4230<td>
<tr class="covered"><td>4231<td>  DES_Func(@PUInt32Array(Source)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4232<td>  DES_Func(@PUInt32Array(Source)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4233<td>  DES_Func(@PUInt32Array(Source)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[96]);
<tr class="covered"><td>4234<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4235<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4236<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4237<td>  T := PUInt32Array(Dest)[3];
<tr class="covered"><td>4238<td>  PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];
<tr class="covered"><td>4239<td>  PUInt32Array(Dest)[4] := T;
<tr class="covered"><td>4240<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[128]);
<tr class="covered"><td>4241<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[128]);
<tr class="covered"><td>4242<td>  DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[128]);
<tr class="covered"><td>4243<td>  T := PUInt32Array(Dest)[1];
<tr class="covered"><td>4244<td>  PUInt32Array(Dest)[1] := PUInt32Array(Dest)[2];
<tr class="covered"><td>4245<td>  PUInt32Array(Dest)[2] := T;
<tr class="covered"><td>4246<td>  T := PUInt32Array(Dest)[3];
<tr class="covered"><td>4247<td>  PUInt32Array(Dest)[3] := PUInt32Array(Dest)[4];
<tr class="covered"><td>4248<td>  PUInt32Array(Dest)[4] := T;
<tr class="covered"><td>4249<td>  DES_Func(@PUInt32Array(Dest)[0], @PUInt32Array(Dest)[0], @PUInt32Array(FAdditionalBuffer)[160]);
<tr class="covered"><td>4250<td>  DES_Func(@PUInt32Array(Dest)[2], @PUInt32Array(Dest)[2], @PUInt32Array(FAdditionalBuffer)[160]);
<tr class="covered"><td>4251<td>  DES_Func(@PUInt32Array(Dest)[4], @PUInt32Array(Dest)[4], @PUInt32Array(FAdditionalBuffer)[160]);
<tr class="covered"><td>4252<td>end;
<tr class="nocodegen"><td>4253<td>
<tr class="nocodegen"><td>4254<td>{ TCipher_3Way }
<tr class="nocodegen"><td>4255<td>
<tr class="nocodegen"><td>4256<td>type
<tr class="nocodegen"><td>4257<td>  P3Way_Key = ^T3Way_Key;
<tr class="nocodegen"><td>4258<td>  T3Way_Key = packed record
<tr class="nocodegen"><td>4259<td>    E_Key: array[0..2] of UInt32;
<tr class="nocodegen"><td>4260<td>    E_Data: array[0..11] of UInt32;
<tr class="nocodegen"><td>4261<td>    D_Key: array[0..2] of UInt32;
<tr class="nocodegen"><td>4262<td>    D_Data: array[0..11] of UInt32;
<tr class="nocodegen"><td>4263<td>  end;
<tr class="nocodegen"><td>4264<td>
<tr class="nocodegen"><td>4265<td>class function TCipher_3Way.Context: TCipherContext;
<tr class="covered"><td>4266<td>begin
<tr class="covered"><td>4267<td>  Result.KeySize                     := 12;
<tr class="covered"><td>4268<td>  Result.BlockSize                   := 12;
<tr class="covered"><td>4269<td>  Result.BufferSize                  := 12;
<tr class="covered"><td>4270<td>  Result.AdditionalBufferSize        := SizeOf(T3Way_Key);
<tr class="covered"><td>4271<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>4272<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>4273<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>4274<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>4275<td>end;
<tr class="nocodegen"><td>4276<td>
<tr class="nocodegen"><td>4277<td>procedure TCipher_3Way.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>4278<td>
<tr class="nocodegen"><td>4279<td>  procedure RANDGenerate(Start: UInt32; var P: array of UInt32);
<tr class="nocodegen"><td>4280<td>  var
<tr class="nocodegen"><td>4281<td>    I: Integer;
<tr class="covered"><td>4282<td>  begin
<tr class="covered"><td>4283<td>    for I := 0 to 11 do
<tr class="nocodegen"><td>4284<td>    begin
<tr class="covered"><td>4285<td>      P[I] := Start;
<tr class="covered"><td>4286<td>      Start := Start shl 1;
<tr class="covered"><td>4287<td>      if Start and $10000 &lt;&gt; 0 then
<tr class="covered"><td>4288<td>        Start := Start xor $11011;
<tr class="covered"><td>4289<td>    end;
<tr class="covered"><td>4290<td>  end;
<tr class="nocodegen"><td>4291<td>
<tr class="nocodegen"><td>4292<td>var
<tr class="nocodegen"><td>4293<td>  A0, A1, A2: UInt32;
<tr class="nocodegen"><td>4294<td>  B0, B1, B2: UInt32;
<tr class="nocodegen"><td>4295<td>  P3WayKey: P3Way_Key;
<tr class="covered"><td>4296<td>begin
<tr class="covered"><td>4297<td>  P3WayKey := P3Way_Key(FAdditionalBuffer);
<tr class="nocodegen"><td>4298<td>
<tr class="covered"><td>4299<td>  Move(Key, P3WayKey.E_Key, Size);
<tr class="covered"><td>4300<td>  Move(Key, P3WayKey.D_Key, Size);
<tr class="covered"><td>4301<td>  RANDGenerate($0B0B, P3WayKey.E_Data);
<tr class="covered"><td>4302<td>  RANDGenerate($B1B1, P3WayKey.D_Data);
<tr class="covered"><td>4303<td>  A0 := P3WayKey.D_Key[0];
<tr class="covered"><td>4304<td>  A1 := P3WayKey.D_Key[1];
<tr class="covered"><td>4305<td>  A2 := P3WayKey.D_Key[2];
<tr class="covered"><td>4306<td>  B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor
<tr class="nocodegen"><td>4307<td>               A1 shr 24 xor A2 shl  8 xor A2 shr  8 xor A0 shl 24 xor
<tr class="nocodegen"><td>4308<td>               A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl  8;
<tr class="covered"><td>4309<td>  B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor
<tr class="nocodegen"><td>4310<td>               A2 shr 24 xor A0 shl  8 xor A0 shr  8 xor A1 shl 24 xor
<tr class="nocodegen"><td>4311<td>               A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl  8;
<tr class="covered"><td>4312<td>  B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor
<tr class="nocodegen"><td>4313<td>               A0 shr 24 xor A1 shl  8 xor A1 shr  8 xor A2 shl 24 xor
<tr class="nocodegen"><td>4314<td>               A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl  8;
<tr class="covered"><td>4315<td>  P3WayKey.D_Key[2] := ReverseBits(B0);
<tr class="covered"><td>4316<td>  P3WayKey.D_Key[1] := ReverseBits(B1);
<tr class="covered"><td>4317<td>  P3WayKey.D_Key[0] := ReverseBits(B2);
<tr class="nocodegen"><td>4318<td>
<tr class="nocodegen"><td>4319<td>  inherited;
<tr class="covered"><td>4320<td>end;
<tr class="nocodegen"><td>4321<td>
<tr class="nocodegen"><td>4322<td>procedure TCipher_3Way.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4323<td>var
<tr class="nocodegen"><td>4324<td>  I: Integer;
<tr class="nocodegen"><td>4325<td>  A0, A1, A2: UInt32;
<tr class="nocodegen"><td>4326<td>  B0, B1, B2: UInt32;
<tr class="nocodegen"><td>4327<td>  K0, K1, K2: UInt32;
<tr class="nocodegen"><td>4328<td>  E: PUInt32;
<tr class="nocodegen"><td>4329<td>  P3WayKey: P3Way_Key;
<tr class="covered"><td>4330<td>begin
<tr class="covered"><td>4331<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>4332<td>  P3WayKey := P3Way_Key(FAdditionalBuffer);
<tr class="nocodegen"><td>4333<td>
<tr class="covered"><td>4334<td>  K0 := P3WayKey.E_Key[0];
<tr class="covered"><td>4335<td>  K1 := P3WayKey.E_Key[1];
<tr class="covered"><td>4336<td>  K2 := P3WayKey.E_Key[2];
<tr class="covered"><td>4337<td>  E  := @P3WayKey.E_Data;
<tr class="nocodegen"><td>4338<td>
<tr class="covered"><td>4339<td>  A0 := PUInt32Array(Source)[0];
<tr class="covered"><td>4340<td>  A1 := PUInt32Array(Source)[1];
<tr class="covered"><td>4341<td>  A2 := PUInt32Array(Source)[2];
<tr class="covered"><td>4342<td>  for I := 0 to 10 do
<tr class="nocodegen"><td>4343<td>  begin
<tr class="covered"><td>4344<td>    A0 := A0 xor K0 xor E^ shl 16;
<tr class="covered"><td>4345<td>    A1 := A1 xor K1;
<tr class="covered"><td>4346<td>    A2 := A2 xor K2 xor E^;
<tr class="covered"><td>4347<td>    Inc(E);
<tr class="nocodegen"><td>4348<td>
<tr class="covered"><td>4349<td>    B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor
<tr class="nocodegen"><td>4350<td>                 A1 shr 24 xor A2 shl  8 xor A2 shr  8 xor A0 shl 24 xor
<tr class="nocodegen"><td>4351<td>                 A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl  8;
<tr class="covered"><td>4352<td>    B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor
<tr class="nocodegen"><td>4353<td>                 A2 shr 24 xor A0 shl  8 xor A0 shr  8 xor A1 shl 24 xor
<tr class="nocodegen"><td>4354<td>                 A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl  8;
<tr class="covered"><td>4355<td>    B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor
<tr class="nocodegen"><td>4356<td>                 A0 shr 24 xor A1 shl  8 xor A1 shr  8 xor A2 shl 24 xor
<tr class="nocodegen"><td>4357<td>                 A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl  8;
<tr class="covered"><td>4358<td>    B0 := B0 shr 10 or B0 shl 22;
<tr class="covered"><td>4359<td>    B2 := B2 shl  1 or B2 shr 31;
<tr class="covered"><td>4360<td>    A0 := B0 xor (B1 or not B2);
<tr class="covered"><td>4361<td>    A1 := B1 xor (B2 or not B0);
<tr class="covered"><td>4362<td>    A2 := B2 xor (B0 or not B1);
<tr class="covered"><td>4363<td>    A0 := A0 shl  1 or A0 shr 31;
<tr class="covered"><td>4364<td>    A2 := A2 shr 10 or A2 shl 22;
<tr class="covered"><td>4365<td>  end;
<tr class="covered"><td>4366<td>  A0 := A0 xor K0 xor E^ shl 16;
<tr class="covered"><td>4367<td>  A1 := A1 xor K1;
<tr class="covered"><td>4368<td>  A2 := A2 xor K2 xor E^;
<tr class="covered"><td>4369<td>  PUInt32Array(Dest)[0] := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor
<tr class="nocodegen"><td>4370<td>                                A1 shr 24 xor A2 shl  8 xor A2 shr  8 xor A0 shl 24 xor
<tr class="nocodegen"><td>4371<td>                                A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl  8;
<tr class="covered"><td>4372<td>  PUInt32Array(Dest)[1] := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor
<tr class="nocodegen"><td>4373<td>                                A2 shr 24 xor A0 shl  8 xor A0 shr  8 xor A1 shl 24 xor
<tr class="nocodegen"><td>4374<td>                                A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl  8;
<tr class="covered"><td>4375<td>  PUInt32Array(Dest)[2] := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor
<tr class="nocodegen"><td>4376<td>                                A0 shr 24 xor A1 shl  8 xor A1 shr  8 xor A2 shl 24 xor
<tr class="nocodegen"><td>4377<td>                                A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl  8;
<tr class="covered"><td>4378<td>end;
<tr class="nocodegen"><td>4379<td>
<tr class="nocodegen"><td>4380<td>procedure TCipher_3Way.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4381<td>var
<tr class="nocodegen"><td>4382<td>  I: Integer;
<tr class="nocodegen"><td>4383<td>  A0, A1, A2: UInt32;
<tr class="nocodegen"><td>4384<td>  B0, B1, B2: UInt32;
<tr class="nocodegen"><td>4385<td>  K0, K1, K2: UInt32;
<tr class="nocodegen"><td>4386<td>  E: PUInt32;
<tr class="nocodegen"><td>4387<td>  P3WayKey: P3Way_Key;
<tr class="covered"><td>4388<td>begin
<tr class="covered"><td>4389<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>4390<td>  P3WayKey := P3Way_Key(FAdditionalBuffer);
<tr class="nocodegen"><td>4391<td>
<tr class="covered"><td>4392<td>  K0 := P3WayKey.D_Key[0];
<tr class="covered"><td>4393<td>  K1 := P3WayKey.D_Key[1];
<tr class="covered"><td>4394<td>  K2 := P3WayKey.D_Key[2];
<tr class="covered"><td>4395<td>  E  := @P3WayKey.D_Data;
<tr class="nocodegen"><td>4396<td>
<tr class="covered"><td>4397<td>  A0 := ReverseBits(PUInt32Array(Source)[2]);
<tr class="covered"><td>4398<td>  A1 := ReverseBits(PUInt32Array(Source)[1]);
<tr class="covered"><td>4399<td>  A2 := ReverseBits(PUInt32Array(Source)[0]);
<tr class="covered"><td>4400<td>  for I := 0 to 10 do
<tr class="nocodegen"><td>4401<td>  begin
<tr class="covered"><td>4402<td>    A0 := A0 xor K0 xor E^ shl 16;
<tr class="covered"><td>4403<td>    A1 := A1 xor K1;
<tr class="covered"><td>4404<td>    A2 := A2 xor K2 xor E^;
<tr class="covered"><td>4405<td>    Inc(E);
<tr class="nocodegen"><td>4406<td>
<tr class="covered"><td>4407<td>    B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor
<tr class="nocodegen"><td>4408<td>                 A1 shr 24 xor A2 shl  8 xor A2 shr  8 xor A0 shl 24 xor
<tr class="nocodegen"><td>4409<td>                 A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl  8;
<tr class="covered"><td>4410<td>    B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor
<tr class="nocodegen"><td>4411<td>                 A2 shr 24 xor A0 shl  8 xor A0 shr  8 xor A1 shl 24 xor
<tr class="nocodegen"><td>4412<td>                 A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl  8;
<tr class="covered"><td>4413<td>    B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor
<tr class="nocodegen"><td>4414<td>                 A0 shr 24 xor A1 shl  8 xor A1 shr  8 xor A2 shl 24 xor
<tr class="nocodegen"><td>4415<td>                 A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl  8;
<tr class="covered"><td>4416<td>    B0 := B0 shr 10 or B0 shl 22;
<tr class="covered"><td>4417<td>    B2 := B2 shl  1 or B2 shr 31;
<tr class="covered"><td>4418<td>    A0 := B0 xor (B1 or not B2);
<tr class="covered"><td>4419<td>    A1 := B1 xor (B2 or not B0);
<tr class="covered"><td>4420<td>    A2 := B2 xor (B0 or not B1);
<tr class="covered"><td>4421<td>    A0 := A0 shl  1 or A0 shr 31;
<tr class="covered"><td>4422<td>    A2 := A2 shr 10 or A2 shl 22;
<tr class="covered"><td>4423<td>  end;
<tr class="covered"><td>4424<td>  A0 := A0 xor K0 xor E^ shl 16;
<tr class="covered"><td>4425<td>  A1 := A1 xor K1;
<tr class="covered"><td>4426<td>  A2 := A2 xor K2 xor E^;
<tr class="covered"><td>4427<td>  B0 := A0 xor A0 shr 16 xor A1 shl 16 xor A1 shr 16 xor A2 shl 16 xor
<tr class="nocodegen"><td>4428<td>               A1 shr 24 xor A2 shl  8 xor A2 shr  8 xor A0 shl 24 xor
<tr class="nocodegen"><td>4429<td>               A2 shr 16 xor A0 shl 16 xor A2 shr 24 xor A0 shl  8;
<tr class="covered"><td>4430<td>  B1 := A1 xor A1 shr 16 xor A2 shl 16 xor A2 shr 16 xor A0 shl 16 xor
<tr class="nocodegen"><td>4431<td>               A2 shr 24 xor A0 shl  8 xor A0 shr  8 xor A1 shl 24 xor
<tr class="nocodegen"><td>4432<td>               A0 shr 16 xor A1 shl 16 xor A0 shr 24 xor A1 shl  8;
<tr class="covered"><td>4433<td>  B2 := A2 xor A2 shr 16 xor A0 shl 16 xor A0 shr 16 xor A1 shl 16 xor
<tr class="nocodegen"><td>4434<td>               A0 shr 24 xor A1 shl  8 xor A1 shr  8 xor A2 shl 24 xor
<tr class="nocodegen"><td>4435<td>               A1 shr 16 xor A2 shl 16 xor A1 shr 24 xor A2 shl  8;
<tr class="nocodegen"><td>4436<td>
<tr class="covered"><td>4437<td>  PUInt32Array(Dest)[2] := ReverseBits(B0);
<tr class="covered"><td>4438<td>  PUInt32Array(Dest)[1] := ReverseBits(B1);
<tr class="covered"><td>4439<td>  PUInt32Array(Dest)[0] := ReverseBits(B2);
<tr class="covered"><td>4440<td>end;
<tr class="nocodegen"><td>4441<td>
<tr class="nocodegen"><td>4442<td>{ TCipher_Cast128 }
<tr class="nocodegen"><td>4443<td>
<tr class="nocodegen"><td>4444<td>class function TCipher_Cast128.Context: TCipherContext;
<tr class="covered"><td>4445<td>begin
<tr class="covered"><td>4446<td>  Result.KeySize                     := 16;
<tr class="covered"><td>4447<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>4448<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>4449<td>  Result.AdditionalBufferSize        := 128;
<tr class="covered"><td>4450<td>  Result.NeedsAdditionalBufferBackup := false;
<tr class="covered"><td>4451<td>  Result.MinRounds                   := 12;
<tr class="covered"><td>4452<td>  Result.MaxRounds                   := 16;
<tr class="covered"><td>4453<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>4454<td>end;
<tr class="nocodegen"><td>4455<td>
<tr class="nocodegen"><td>4456<td>procedure TCipher_Cast128.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>4457<td>var
<tr class="nocodegen"><td>4458<td>  Z, X, T: array[0..3] of UInt32;
<tr class="nocodegen"><td>4459<td>  K: PUInt32Array;
<tr class="nocodegen"><td>4460<td>  I: UInt32;
<tr class="covered"><td>4461<td>begin
<tr class="nocodegen"><td>4462<td>  // as per rfc2144 the number of rounds is 12 for key sizes &lt;= 80 bit,
<tr class="nocodegen"><td>4463<td>  // otherwise 16
<tr class="covered"><td>4464<td>  if Size &lt;= 10 then
<tr class="notcovered"><td>4465<td>    FRounds := 12
<tr class="nocodegen"><td>4466<td>  else
<tr class="covered"><td>4467<td>    FRounds := 16;
<tr class="nocodegen"><td>4468<td>
<tr class="covered"><td>4469<td>  K := FAdditionalBuffer;
<tr class="covered"><td>4470<td>  FillChar(X, SizeOf(X), 0);
<tr class="covered"><td>4471<td>  Move(Key, X, Size);
<tr class="covered"><td>4472<td>  SwapUInt32Buffer(X, X, 4);
<tr class="covered"><td>4473<td>  I := 0;
<tr class="covered"><td>4474<td>  while I &lt; 32 do
<tr class="nocodegen"><td>4475<td>  begin
<tr class="covered"><td>4476<td>    if I and 4 = 0 then
<tr class="nocodegen"><td>4477<td>    begin
<tr class="covered"><td>4478<td>      Z[0] := X[0] xor Cast128_Key[0, X[3] shr 16 and $FF] xor
<tr class="nocodegen"><td>4479<td>                       Cast128_Key[1, X[3] and $FF] xor
<tr class="nocodegen"><td>4480<td>                       Cast128_Key[2, X[3] shr 24] xor
<tr class="nocodegen"><td>4481<td>                       Cast128_Key[3, X[3] shr  8 and $FF] xor
<tr class="nocodegen"><td>4482<td>                       Cast128_Key[2, X[2] shr 24];
<tr class="covered"><td>4483<td>      T[0] := Z[0];
<tr class="covered"><td>4484<td>      Z[1] := X[2] xor Cast128_Key[0, Z[0] shr 24] xor
<tr class="nocodegen"><td>4485<td>                       Cast128_Key[1, Z[0] shr  8 and $FF] xor
<tr class="nocodegen"><td>4486<td>                       Cast128_Key[2, Z[0] shr 16 and $FF] xor
<tr class="nocodegen"><td>4487<td>                       Cast128_Key[3, Z[0] and $FF] xor
<tr class="nocodegen"><td>4488<td>                       Cast128_Key[3, X[2] shr  8 and $FF];
<tr class="covered"><td>4489<td>      T[1] := Z[1];
<tr class="covered"><td>4490<td>      Z[2] := X[3] xor Cast128_Key[0, Z[1] and $FF] xor
<tr class="nocodegen"><td>4491<td>                       Cast128_Key[1, Z[1] shr  8 and $FF] xor
<tr class="nocodegen"><td>4492<td>                       Cast128_Key[2, Z[1] shr 16 and $FF] xor
<tr class="nocodegen"><td>4493<td>                       Cast128_Key[3, Z[1] shr 24] xor
<tr class="nocodegen"><td>4494<td>                       Cast128_Key[0, X[2] shr 16 and $FF];
<tr class="covered"><td>4495<td>      T[2] := Z[2];
<tr class="covered"><td>4496<td>      Z[3] := X[1] xor Cast128_Key[0, Z[2] shr  8 and $FF] xor
<tr class="nocodegen"><td>4497<td>                       Cast128_Key[1, Z[2] shr 16 and $FF] xor
<tr class="nocodegen"><td>4498<td>                       Cast128_Key[2, Z[2] and $FF] xor
<tr class="nocodegen"><td>4499<td>                       Cast128_Key[3, Z[2] shr 24] xor
<tr class="nocodegen"><td>4500<td>                       Cast128_Key[1, X[2] and $FF];
<tr class="covered"><td>4501<td>      T[3] := Z[3];
<tr class="nocodegen"><td>4502<td>    end
<tr class="nocodegen"><td>4503<td>    else
<tr class="nocodegen"><td>4504<td>    begin
<tr class="covered"><td>4505<td>      X[0] := Z[2] xor Cast128_Key[0, Z[1] shr 16 and $FF] xor
<tr class="nocodegen"><td>4506<td>                       Cast128_Key[1, Z[1] and $FF] xor
<tr class="nocodegen"><td>4507<td>                       Cast128_Key[2, Z[1] shr 24] xor
<tr class="nocodegen"><td>4508<td>                       Cast128_Key[3, Z[1] shr  8 and $FF] xor
<tr class="nocodegen"><td>4509<td>                       Cast128_Key[2, Z[0] shr 24];
<tr class="covered"><td>4510<td>      T[0] := X[0];
<tr class="covered"><td>4511<td>      X[1] := Z[0] xor Cast128_Key[0, X[0] shr 24] xor
<tr class="nocodegen"><td>4512<td>                       Cast128_Key[1, X[0] shr  8 and $FF] xor
<tr class="nocodegen"><td>4513<td>                       Cast128_Key[2, X[0] shr 16 and $FF] xor
<tr class="nocodegen"><td>4514<td>                       Cast128_Key[3, X[0] and $FF] xor
<tr class="nocodegen"><td>4515<td>                       Cast128_Key[3, Z[0] shr  8 and $FF];
<tr class="covered"><td>4516<td>      T[1] := X[1];
<tr class="covered"><td>4517<td>      X[2] := Z[1] xor Cast128_Key[0, X[1] and $FF] xor
<tr class="nocodegen"><td>4518<td>                       Cast128_Key[1, X[1] shr  8 and $FF] xor
<tr class="nocodegen"><td>4519<td>                       Cast128_Key[2, X[1] shr 16 and $FF] xor
<tr class="nocodegen"><td>4520<td>                       Cast128_Key[3, X[1] shr 24] xor
<tr class="nocodegen"><td>4521<td>                       Cast128_Key[0, Z[0] shr 16 and $FF];
<tr class="covered"><td>4522<td>      T[2] := X[2];
<tr class="covered"><td>4523<td>      X[3] := Z[3] xor Cast128_Key[0, X[2] shr  8 and $FF] xor
<tr class="nocodegen"><td>4524<td>                       Cast128_Key[1, X[2] shr 16 and $FF] xor
<tr class="nocodegen"><td>4525<td>                       Cast128_Key[2, X[2] and $FF] xor
<tr class="nocodegen"><td>4526<td>                       Cast128_Key[3, X[2] shr 24] xor
<tr class="nocodegen"><td>4527<td>                       Cast128_Key[1, Z[0] and $FF];
<tr class="covered"><td>4528<td>      T[3] := X[3];
<tr class="nocodegen"><td>4529<td>    end;
<tr class="covered"><td>4530<td>    case I and 12 of
<tr class="nocodegen"><td>4531<td>      0,12:
<tr class="nocodegen"><td>4532<td>        begin
<tr class="covered"><td>4533<td>          K[I + 0] := Cast128_Key[0, T[2] shr 24] xor
<tr class="nocodegen"><td>4534<td>                      Cast128_Key[1, T[2] shr 16 and $FF] xor
<tr class="nocodegen"><td>4535<td>                      Cast128_Key[2, T[1] and $FF] xor
<tr class="nocodegen"><td>4536<td>                      Cast128_Key[3, T[1] shr  8 and $FF];
<tr class="covered"><td>4537<td>          K[I + 1] := Cast128_Key[0, T[2] shr  8 and $FF] xor
<tr class="nocodegen"><td>4538<td>                      Cast128_Key[1, T[2] and $FF] xor
<tr class="nocodegen"><td>4539<td>                      Cast128_Key[2, T[1] shr 16 and $FF] xor
<tr class="nocodegen"><td>4540<td>                      Cast128_Key[3, T[1] shr 24];
<tr class="covered"><td>4541<td>          K[I + 2] := Cast128_Key[0, T[3] shr 24] xor
<tr class="nocodegen"><td>4542<td>                      Cast128_Key[1, T[3] shr 16 and $FF] xor
<tr class="nocodegen"><td>4543<td>                      Cast128_Key[2, T[0] and $FF] xor
<tr class="nocodegen"><td>4544<td>                      Cast128_Key[3, T[0] shr  8 and $FF];
<tr class="covered"><td>4545<td>          K[I + 3] := Cast128_Key[0, T[3] shr  8 and $FF] xor
<tr class="nocodegen"><td>4546<td>                      Cast128_Key[1, T[3] and $FF] xor
<tr class="nocodegen"><td>4547<td>                      Cast128_Key[2, T[0] shr 16 and $FF] xor
<tr class="nocodegen"><td>4548<td>                      Cast128_Key[3, T[0] shr 24];
<tr class="nocodegen"><td>4549<td>        end;
<tr class="nocodegen"><td>4550<td>      4,8:
<tr class="nocodegen"><td>4551<td>        begin
<tr class="covered"><td>4552<td>          K[I + 0] := Cast128_Key[0, T[0] and $FF] xor
<tr class="nocodegen"><td>4553<td>                      Cast128_Key[1, T[0] shr  8 and $FF] xor
<tr class="nocodegen"><td>4554<td>                      Cast128_Key[2, T[3] shr 24] xor
<tr class="nocodegen"><td>4555<td>                      Cast128_Key[3, T[3] shr 16 and $FF];
<tr class="covered"><td>4556<td>          K[I + 1] := Cast128_Key[0, T[0] shr 16 and $FF] xor
<tr class="nocodegen"><td>4557<td>                      Cast128_Key[1, T[0] shr 24] xor
<tr class="nocodegen"><td>4558<td>                      Cast128_Key[2, T[3] shr  8 and $FF] xor
<tr class="nocodegen"><td>4559<td>                      Cast128_Key[3, T[3] and $FF];
<tr class="covered"><td>4560<td>          K[I + 2] := Cast128_Key[0, T[1] and $FF] xor
<tr class="nocodegen"><td>4561<td>                      Cast128_Key[1, T[1] shr  8 and $FF] xor
<tr class="nocodegen"><td>4562<td>                      Cast128_Key[2, T[2] shr 24] xor
<tr class="nocodegen"><td>4563<td>                      Cast128_Key[3, T[2] shr 16 and $FF];
<tr class="covered"><td>4564<td>          K[I + 3] := Cast128_Key[0, T[1] shr 16 and $FF] xor
<tr class="nocodegen"><td>4565<td>                      Cast128_Key[1, T[1] shr 24] xor
<tr class="nocodegen"><td>4566<td>                      Cast128_Key[2, T[2] shr  8 and $FF] xor
<tr class="nocodegen"><td>4567<td>                      Cast128_Key[3, T[2] and $FF];
<tr class="nocodegen"><td>4568<td>        end;
<tr class="nocodegen"><td>4569<td>    end;
<tr class="covered"><td>4570<td>    case I and 12 of
<tr class="nocodegen"><td>4571<td>      0: begin
<tr class="covered"><td>4572<td>           K[I + 0] := K[I + 0] xor Cast128_Key[0, Z[0] shr  8 and $FF];
<tr class="covered"><td>4573<td>           K[I + 1] := K[I + 1] xor Cast128_Key[1, Z[1] shr  8 and $FF];
<tr class="covered"><td>4574<td>           K[I + 2] := K[I + 2] xor Cast128_Key[2, Z[2] shr 16 and $FF];
<tr class="covered"><td>4575<td>           K[I + 3] := K[I + 3] xor Cast128_Key[3, Z[3] shr 24];
<tr class="nocodegen"><td>4576<td>         end;
<tr class="nocodegen"><td>4577<td>      4: begin
<tr class="covered"><td>4578<td>           K[I + 0] := K[I + 0] xor Cast128_Key[0, X[2] shr 24];
<tr class="covered"><td>4579<td>           K[I + 1] := K[I + 1] xor Cast128_Key[1, X[3] shr 16 and $FF];
<tr class="covered"><td>4580<td>           K[I + 2] := K[I + 2] xor Cast128_Key[2, X[0] and $FF];
<tr class="covered"><td>4581<td>           K[I + 3] := K[I + 3] xor Cast128_Key[3, X[1] and $FF];
<tr class="nocodegen"><td>4582<td>         end;
<tr class="nocodegen"><td>4583<td>      8: begin
<tr class="covered"><td>4584<td>           K[I + 0] := K[I + 0] xor Cast128_Key[0, Z[2] shr 16 and $FF];
<tr class="covered"><td>4585<td>           K[I + 1] := K[I + 1] xor Cast128_Key[1, Z[3] shr 24];
<tr class="covered"><td>4586<td>           K[I + 2] := K[I + 2] xor Cast128_Key[2, Z[0] shr  8 and $FF];
<tr class="covered"><td>4587<td>           K[I + 3] := K[I + 3] xor Cast128_Key[3, Z[1] shr  8 and $FF];
<tr class="nocodegen"><td>4588<td>         end;
<tr class="nocodegen"><td>4589<td>     12: begin
<tr class="covered"><td>4590<td>          K[I + 0] := K[I + 0] xor Cast128_Key[0, X[0] and $FF];
<tr class="covered"><td>4591<td>          K[I + 1] := K[I + 1] xor Cast128_Key[1, X[1] and $FF];
<tr class="covered"><td>4592<td>          K[I + 2] := K[I + 2] xor Cast128_Key[2, X[2] shr 24];
<tr class="covered"><td>4593<td>          K[I + 3] := K[I + 3] xor Cast128_Key[3, X[3] shr 16 and $FF];
<tr class="nocodegen"><td>4594<td>        end;
<tr class="nocodegen"><td>4595<td>    end;
<tr class="covered"><td>4596<td>    if I &gt;= 16 then
<tr class="nocodegen"><td>4597<td>    begin
<tr class="covered"><td>4598<td>      K[I + 0] := K[I + 0] and $1F;
<tr class="covered"><td>4599<td>      K[I + 1] := K[I + 1] and $1F;
<tr class="covered"><td>4600<td>      K[I + 2] := K[I + 2] and $1F;
<tr class="covered"><td>4601<td>      K[I + 3] := K[I + 3] and $1F;
<tr class="nocodegen"><td>4602<td>    end;
<tr class="covered"><td>4603<td>    Inc(I, 4);
<tr class="nocodegen"><td>4604<td>  end;
<tr class="covered"><td>4605<td>  ProtectBuffer(X, SizeOf(X));
<tr class="covered"><td>4606<td>  ProtectBuffer(Z, SizeOf(Z));
<tr class="covered"><td>4607<td>  ProtectBuffer(T, SizeOf(T));
<tr class="nocodegen"><td>4608<td>
<tr class="nocodegen"><td>4609<td>  inherited;
<tr class="covered"><td>4610<td>end;
<tr class="nocodegen"><td>4611<td>
<tr class="nocodegen"><td>4612<td>procedure TCipher_Cast128.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4613<td>var
<tr class="nocodegen"><td>4614<td>  T, I, A, B: UInt32;
<tr class="nocodegen"><td>4615<td>  K: PUInt32Array;
<tr class="covered"><td>4616<td>begin
<tr class="covered"><td>4617<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4618<td>
<tr class="covered"><td>4619<td>  K := FAdditionalBuffer;
<tr class="covered"><td>4620<td>  A := SwapUInt32(PUInt32Array(Source)[0]);
<tr class="covered"><td>4621<td>  B := SwapUInt32(PUInt32Array(Source)[1]);
<tr class="covered"><td>4622<td>  for I := 0 to 2 do
<tr class="nocodegen"><td>4623<td>  begin
<tr class="covered"><td>4624<td>    T := K[0] + B;
<tr class="covered"><td>4625<td>    T := T shl K[16] or T shr (32 - K[16]);
<tr class="covered"><td>4626<td>    A := A xor (Cast128_Data[0, T shr 24] xor
<tr class="nocodegen"><td>4627<td>                Cast128_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>4628<td>                Cast128_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>4629<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4630<td>    T := K[1] xor A;
<tr class="covered"><td>4631<td>    T := T shl K[17] or T shr (32 - K[17]);
<tr class="covered"><td>4632<td>    B := B xor (Cast128_Data[0, T shr 24] -
<tr class="nocodegen"><td>4633<td>                Cast128_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>4634<td>                Cast128_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4635<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4636<td>    T := K[2] - B;
<tr class="covered"><td>4637<td>    T := T shl K[18] or T shr (32 - K[18]);
<tr class="covered"><td>4638<td>    A := A xor (Cast128_Data[0, T shr 24] +
<tr class="nocodegen"><td>4639<td>                Cast128_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4640<td>                Cast128_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>4641<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4642<td>    T := K[3] + A;
<tr class="covered"><td>4643<td>    T := T shl K[19] or T shr (32 - K[19]);
<tr class="covered"><td>4644<td>    B := B xor (Cast128_Data[0, T shr 24] xor
<tr class="nocodegen"><td>4645<td>                Cast128_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>4646<td>                Cast128_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>4647<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4648<td>    if I = 2 then
<tr class="nocodegen"><td>4649<td>      Break;
<tr class="covered"><td>4650<td>    T := K[4] xor B;
<tr class="covered"><td>4651<td>    T := T shl K[20] or T shr (32 - K[20]);
<tr class="covered"><td>4652<td>    A := A xor (Cast128_Data[0, T shr 24] -
<tr class="nocodegen"><td>4653<td>                Cast128_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>4654<td>                Cast128_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4655<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4656<td>    T := K[5] - A;
<tr class="covered"><td>4657<td>    T := T shl K[21] or T shr (32 - K[21]);
<tr class="covered"><td>4658<td>    B := B xor (Cast128_Data[0, T shr 24] +
<tr class="nocodegen"><td>4659<td>                Cast128_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4660<td>                Cast128_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>4661<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4662<td>    if (I = 1) and (FRounds &lt;= 12) then
<tr class="nocodegen"><td>4663<td>      Break;
<tr class="covered"><td>4664<td>    K := @K[6];
<tr class="covered"><td>4665<td>  end;
<tr class="covered"><td>4666<td>  PUInt32Array(Dest)[0] := SwapUInt32(B);
<tr class="covered"><td>4667<td>  PUInt32Array(Dest)[1] := SwapUInt32(A);
<tr class="covered"><td>4668<td>end;
<tr class="nocodegen"><td>4669<td>
<tr class="nocodegen"><td>4670<td>procedure TCipher_Cast128.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4671<td>var
<tr class="nocodegen"><td>4672<td>  T, I, A, B: UInt32;
<tr class="nocodegen"><td>4673<td>  K: PUInt32Array;
<tr class="nocodegen"><td>4674<td>  JumpStart: Boolean;
<tr class="covered"><td>4675<td>begin
<tr class="covered"><td>4676<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>4677<td>  JumpStart := False;
<tr class="nocodegen"><td>4678<td>
<tr class="covered"><td>4679<td>  K := @PUInt32Array(FAdditionalBuffer)[12];
<tr class="covered"><td>4680<td>  B := SwapUInt32(PUInt32Array(Source)[0]);
<tr class="covered"><td>4681<td>  A := SwapUInt32(PUInt32Array(Source)[1]);
<tr class="covered"><td>4682<td>  I := 2;
<tr class="nocodegen"><td>4683<td>
<tr class="covered"><td>4684<td>  if FRounds &lt;= 12 then
<tr class="notcovered"><td>4685<td>    Dec(PUInt32(K), 6)
<tr class="nocodegen"><td>4686<td>  else
<tr class="covered"><td>4687<td>    JumpStart := True;
<tr class="nocodegen"><td>4688<td>
<tr class="covered"><td>4689<td>  while I &gt; 0 do
<tr class="nocodegen"><td>4690<td>  begin
<tr class="covered"><td>4691<td>    if not JumpStart then
<tr class="nocodegen"><td>4692<td>    begin
<tr class="covered"><td>4693<td>      Dec(I);
<tr class="covered"><td>4694<td>      T := K[5] - A;
<tr class="covered"><td>4695<td>      T := T shl K[21] or T shr (32 - K[21]);
<tr class="covered"><td>4696<td>      B := B xor (Cast128_Data[0, T shr 24] +
<tr class="nocodegen"><td>4697<td>                  Cast128_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4698<td>                  Cast128_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>4699<td>                  Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4700<td>      T := K[4] xor B;
<tr class="covered"><td>4701<td>      T := T shl K[20] or T shr (32 - K[20]);
<tr class="covered"><td>4702<td>      A := A xor (Cast128_Data[0, T shr 24] -
<tr class="nocodegen"><td>4703<td>                  Cast128_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>4704<td>                  Cast128_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4705<td>                  Cast128_Data[3, T and $FF]);
<tr class="nocodegen"><td>4706<td>    end
<tr class="nocodegen"><td>4707<td>    else
<tr class="covered"><td>4708<td>      JumpStart := False;
<tr class="nocodegen"><td>4709<td>
<tr class="covered"><td>4710<td>    T := K[3] + A;
<tr class="covered"><td>4711<td>    T := T shl K[19] or T shr (32 - K[19]);
<tr class="covered"><td>4712<td>    B := B xor (Cast128_Data[0, T shr 24] xor
<tr class="nocodegen"><td>4713<td>                Cast128_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>4714<td>                Cast128_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>4715<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4716<td>    T := K[2] - B;
<tr class="covered"><td>4717<td>    T := T shl K[18] or T shr (32 - K[18]);
<tr class="covered"><td>4718<td>    A := A xor (Cast128_Data[0, T shr 24] +
<tr class="nocodegen"><td>4719<td>                Cast128_Data[1, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4720<td>                Cast128_Data[2, T shr  8 and $FF] -
<tr class="nocodegen"><td>4721<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4722<td>    T := K[1] xor A;
<tr class="covered"><td>4723<td>    T := T shl K[17] or T shr (32 - K[17]);
<tr class="covered"><td>4724<td>    B := B xor (Cast128_Data[0, T shr 24] -
<tr class="nocodegen"><td>4725<td>                Cast128_Data[1, T shr 16 and $FF] +
<tr class="nocodegen"><td>4726<td>                Cast128_Data[2, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4727<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4728<td>    T := K[0] + B;
<tr class="covered"><td>4729<td>    T := T shl K[16] or T shr (32 - K[16]);
<tr class="covered"><td>4730<td>    A := A xor (Cast128_Data[0, T shr 24] xor
<tr class="nocodegen"><td>4731<td>                Cast128_Data[1, T shr 16 and $FF] -
<tr class="nocodegen"><td>4732<td>                Cast128_Data[2, T shr  8 and $FF] +
<tr class="nocodegen"><td>4733<td>                Cast128_Data[3, T and $FF]);
<tr class="covered"><td>4734<td>    Dec(PUInt32(K), 6);
<tr class="nocodegen"><td>4735<td>  end;
<tr class="nocodegen"><td>4736<td>
<tr class="covered"><td>4737<td>  PUInt32Array(Dest)[0] := SwapUInt32(A);
<tr class="covered"><td>4738<td>  PUInt32Array(Dest)[1] := SwapUInt32(B);
<tr class="covered"><td>4739<td>end;
<tr class="nocodegen"><td>4740<td>
<tr class="nocodegen"><td>4741<td>{ TCipher_Gost }
<tr class="nocodegen"><td>4742<td>
<tr class="nocodegen"><td>4743<td>class function TCipher_Gost.Context: TCipherContext;
<tr class="covered"><td>4744<td>begin
<tr class="covered"><td>4745<td>  Result.KeySize                     := 32;
<tr class="covered"><td>4746<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>4747<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>4748<td>  Result.AdditionalBufferSize        := 32;
<tr class="covered"><td>4749<td>  Result.NeedsAdditionalBufferBackup := false;
<tr class="covered"><td>4750<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>4751<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>4752<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>4753<td>end;
<tr class="nocodegen"><td>4754<td>
<tr class="nocodegen"><td>4755<td>procedure TCipher_Gost.DoInit(const Key; Size: Integer);
<tr class="covered"><td>4756<td>begin
<tr class="covered"><td>4757<td>  Move(Key, FAdditionalBuffer^, Size);
<tr class="nocodegen"><td>4758<td>
<tr class="nocodegen"><td>4759<td>  inherited;
<tr class="covered"><td>4760<td>end;
<tr class="nocodegen"><td>4761<td>
<tr class="nocodegen"><td>4762<td>procedure TCipher_Gost.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4763<td>var
<tr class="nocodegen"><td>4764<td>  I, A, B, T: UInt32;
<tr class="nocodegen"><td>4765<td>  K: PUInt32Array;
<tr class="covered"><td>4766<td>begin
<tr class="covered"><td>4767<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4768<td>
<tr class="covered"><td>4769<td>  K := FAdditionalBuffer;
<tr class="covered"><td>4770<td>  A := PUInt32Array(Source)[0];
<tr class="covered"><td>4771<td>  B := PUInt32Array(Source)[1];
<tr class="nocodegen"><td>4772<td>
<tr class="covered"><td>4773<td>  for I := 0 to 11 do
<tr class="nocodegen"><td>4774<td>  begin
<tr class="covered"><td>4775<td>    if I and 3 = 0 then
<tr class="covered"><td>4776<td>      K := FAdditionalBuffer;
<tr class="covered"><td>4777<td>    T := A + K[0];
<tr class="covered"><td>4778<td>    B := B xor Gost_Data[0, T        and $FF] xor
<tr class="nocodegen"><td>4779<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4780<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4781<td>               Gost_Data[3, T shr 24        ];
<tr class="covered"><td>4782<td>    T := B + K[1];
<tr class="covered"><td>4783<td>    A := A xor Gost_Data[0, T        and $FF] xor
<tr class="nocodegen"><td>4784<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4785<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4786<td>               Gost_Data[3, T shr 24        ];
<tr class="covered"><td>4787<td>    K := @K[2];
<tr class="covered"><td>4788<td>  end;
<tr class="nocodegen"><td>4789<td>
<tr class="covered"><td>4790<td>  K := @PUInt32Array(FAdditionalBuffer)[6];
<tr class="nocodegen"><td>4791<td>
<tr class="covered"><td>4792<td>  for I := 0 to 3 do
<tr class="nocodegen"><td>4793<td>  begin
<tr class="covered"><td>4794<td>    T := A + K[1];
<tr class="covered"><td>4795<td>    B := B xor Gost_Data[0, T        and $FF] xor
<tr class="nocodegen"><td>4796<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4797<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4798<td>               Gost_Data[3, T shr 24        ];
<tr class="covered"><td>4799<td>    T := B + K[0];
<tr class="covered"><td>4800<td>    A := A xor Gost_Data[0, T        and $FF] xor
<tr class="nocodegen"><td>4801<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4802<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4803<td>               Gost_Data[3, T shr 24        ];
<tr class="covered"><td>4804<td>    Dec(PUInt32(K), 2);
<tr class="covered"><td>4805<td>  end;
<tr class="nocodegen"><td>4806<td>
<tr class="covered"><td>4807<td>  PUInt32Array(Dest)[0] := B;
<tr class="covered"><td>4808<td>  PUInt32Array(Dest)[1] := A;
<tr class="covered"><td>4809<td>end;
<tr class="nocodegen"><td>4810<td>
<tr class="nocodegen"><td>4811<td>procedure TCipher_Gost.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4812<td>var
<tr class="nocodegen"><td>4813<td>  I, A, B, T: UInt32;
<tr class="nocodegen"><td>4814<td>  K: PUInt32Array;
<tr class="covered"><td>4815<td>begin
<tr class="covered"><td>4816<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4817<td>
<tr class="covered"><td>4818<td>  A := PUInt32Array(Source)[0];
<tr class="covered"><td>4819<td>  B := PUInt32Array(Source)[1];
<tr class="covered"><td>4820<td>  K := FAdditionalBuffer;
<tr class="nocodegen"><td>4821<td>
<tr class="covered"><td>4822<td>  for I := 0 to 3 do
<tr class="nocodegen"><td>4823<td>  begin
<tr class="covered"><td>4824<td>    T := A + K[0];
<tr class="covered"><td>4825<td>    B := B xor Gost_Data[0, T and $FF] xor
<tr class="nocodegen"><td>4826<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4827<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4828<td>               Gost_Data[3, T shr 24];
<tr class="covered"><td>4829<td>    T := B + K[1];
<tr class="covered"><td>4830<td>    A := A xor Gost_Data[0, T and $FF] xor
<tr class="nocodegen"><td>4831<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4832<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4833<td>               Gost_Data[3, T shr 24];
<tr class="covered"><td>4834<td>    K := @K[2];
<tr class="covered"><td>4835<td>  end;
<tr class="nocodegen"><td>4836<td>
<tr class="covered"><td>4837<td>  for I := 0 to 11 do
<tr class="nocodegen"><td>4838<td>  begin
<tr class="covered"><td>4839<td>    if I and 3 = 0 then
<tr class="covered"><td>4840<td>      K := @PUInt32Array(FAdditionalBuffer)[6];
<tr class="covered"><td>4841<td>    T := A + K[1];
<tr class="covered"><td>4842<td>    B := B xor Gost_Data[0, T and $FF] xor
<tr class="nocodegen"><td>4843<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4844<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4845<td>               Gost_Data[3, T shr 24];
<tr class="covered"><td>4846<td>    T := B + K[0];
<tr class="covered"><td>4847<td>    A := A xor Gost_Data[0, T and $FF] xor
<tr class="nocodegen"><td>4848<td>               Gost_Data[1, T shr  8 and $FF] xor
<tr class="nocodegen"><td>4849<td>               Gost_Data[2, T shr 16 and $FF] xor
<tr class="nocodegen"><td>4850<td>               Gost_Data[3, T shr 24];
<tr class="covered"><td>4851<td>    Dec(PUInt32(K), 2);
<tr class="covered"><td>4852<td>  end;
<tr class="nocodegen"><td>4853<td>
<tr class="covered"><td>4854<td>  PUInt32Array(Dest)[0] := B;
<tr class="covered"><td>4855<td>  PUInt32Array(Dest)[1] := A;
<tr class="covered"><td>4856<td>end;
<tr class="nocodegen"><td>4857<td>
<tr class="nocodegen"><td>4858<td>{ TCipher_Misty }
<tr class="nocodegen"><td>4859<td>
<tr class="nocodegen"><td>4860<td>class function TCipher_Misty.Context: TCipherContext;
<tr class="covered"><td>4861<td>begin
<tr class="covered"><td>4862<td>  Result.KeySize                     := 16;
<tr class="covered"><td>4863<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>4864<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>4865<td>  Result.AdditionalBufferSize        := 128;
<tr class="covered"><td>4866<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>4867<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>4868<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>4869<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>4870<td>end;
<tr class="nocodegen"><td>4871<td>
<tr class="nocodegen"><td>4872<td>function Misty_I(Value, Key: UInt32): UInt32;
<tr class="covered"><td>4873<td>begin
<tr class="covered"><td>4874<td>  Result := Misty_Data9[Value shr 7 and $1FF] xor (Value and $7F);
<tr class="covered"><td>4875<td>  Value := (Misty_Data7[Value and $7F] xor Result and $7F) xor (Key shr 9 and $7F);
<tr class="covered"><td>4876<td>  Result := Misty_Data9[Result xor (Key and $1FF)] xor Value or Value shl 9;
<tr class="covered"><td>4877<td>end;
<tr class="nocodegen"><td>4878<td>
<tr class="nocodegen"><td>4879<td>function Misty_O(Value, K: UInt32; Key: PUInt32Array): UInt32;
<tr class="covered"><td>4880<td>begin
<tr class="covered"><td>4881<td>  Result := Misty_I((Value shr 16) xor Key[K], Key[(K + 5) and 7 + 8]) xor (Value and $FFFF);
<tr class="covered"><td>4882<td>  Value  := Misty_I((Value and $FFFF) xor Key[(K + 2) and 7], Key[(K + 1) and 7 + 8]) xor Result;
<tr class="covered"><td>4883<td>  Result := Misty_I(Result xor Key[(K + 7) and 7], Key[(K + 3) and 7 + 8]) xor Value;
<tr class="covered"><td>4884<td>  Result := Result or (Value xor Key[(K + 4) and 7]) shl 16;
<tr class="covered"><td>4885<td>end;
<tr class="nocodegen"><td>4886<td>
<tr class="nocodegen"><td>4887<td>function Misty_E(Value, K: UInt32; Key: PUInt32Array): UInt32;
<tr class="covered"><td>4888<td>begin
<tr class="covered"><td>4889<td>  Result := Value shr 16;
<tr class="covered"><td>4890<td>  Value  := Value and $FFFF;
<tr class="nocodegen"><td>4891<td>
<tr class="covered"><td>4892<td>  if K and 1 &lt;&gt; 0 then
<tr class="nocodegen"><td>4893<td>  begin
<tr class="covered"><td>4894<td>    K      := K shr 1;
<tr class="covered"><td>4895<td>    Value  := Value  xor (Result and Key[(K + 2) and 7 + 8]);
<tr class="covered"><td>4896<td>    Result := Result xor (Value  or  Key[(K + 4) and 7]);
<tr class="nocodegen"><td>4897<td>  end
<tr class="nocodegen"><td>4898<td>  else
<tr class="nocodegen"><td>4899<td>  begin
<tr class="covered"><td>4900<td>    K      := K shr 1;
<tr class="covered"><td>4901<td>    Value  := Value  xor (Result and Key[K]);
<tr class="covered"><td>4902<td>    Result := Result xor (Value  or  Key[(K + 6) and 7 + 8]);
<tr class="nocodegen"><td>4903<td>  end;
<tr class="nocodegen"><td>4904<td>
<tr class="covered"><td>4905<td>  Result:= (Result shl 16) or Value;
<tr class="covered"><td>4906<td>end;
<tr class="nocodegen"><td>4907<td>
<tr class="nocodegen"><td>4908<td>function Misty_D(Value, K: UInt32; Key: PUInt32Array): UInt32;
<tr class="covered"><td>4909<td>begin
<tr class="covered"><td>4910<td>  Result := Value shr 16;
<tr class="covered"><td>4911<td>  Value  := Value and $FFFF;
<tr class="nocodegen"><td>4912<td>
<tr class="covered"><td>4913<td>  if K and 1 &lt;&gt; 0 then
<tr class="nocodegen"><td>4914<td>  begin
<tr class="covered"><td>4915<td>    K      := K shr 1;
<tr class="covered"><td>4916<td>    Result := Result xor (Value  or  Key[(K + 4) and 7]);
<tr class="covered"><td>4917<td>    Value  := Value  xor (Result and Key[(K + 2) and 7 + 8]);
<tr class="nocodegen"><td>4918<td>  end
<tr class="nocodegen"><td>4919<td>  else
<tr class="nocodegen"><td>4920<td>  begin
<tr class="covered"><td>4921<td>    K      := K shr 1;
<tr class="covered"><td>4922<td>    Result := Result xor (Value  or  Key[(K + 6) and 7 + 8]);
<tr class="covered"><td>4923<td>    Value  := Value  xor (Result and Key[K]);
<tr class="nocodegen"><td>4924<td>  end;
<tr class="nocodegen"><td>4925<td>
<tr class="covered"><td>4926<td>  Result:= (Result shl 16) or Value;
<tr class="covered"><td>4927<td>end;
<tr class="nocodegen"><td>4928<td>
<tr class="nocodegen"><td>4929<td>procedure TCipher_Misty.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>4930<td>var
<tr class="nocodegen"><td>4931<td>  K: array[0..15] of Byte;
<tr class="nocodegen"><td>4932<td>  D: PUInt32Array;
<tr class="nocodegen"><td>4933<td>  I: Integer;
<tr class="covered"><td>4934<td>begin
<tr class="covered"><td>4935<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>4936<td>  Move(Key, K, Size);
<tr class="covered"><td>4937<td>  D := FAdditionalBuffer;
<tr class="nocodegen"><td>4938<td>
<tr class="covered"><td>4939<td>  for I := 0 to 7 do
<tr class="covered"><td>4940<td>    D[I] := K[I * 2] * 256 + K[I * 2 + 1];
<tr class="nocodegen"><td>4941<td>
<tr class="covered"><td>4942<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>4943<td>  begin
<tr class="covered"><td>4944<td>    D[I +  8] := Misty_I(D[I], D[(I + 1) and 7]);
<tr class="covered"><td>4945<td>    D[I + 16] := D[I + 8] and $1FF;
<tr class="covered"><td>4946<td>    D[I + 24] := D[I + 8] shr 9;
<tr class="covered"><td>4947<td>  end;
<tr class="nocodegen"><td>4948<td>
<tr class="covered"><td>4949<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>4950<td>
<tr class="nocodegen"><td>4951<td>  inherited;
<tr class="covered"><td>4952<td>end;
<tr class="nocodegen"><td>4953<td>
<tr class="nocodegen"><td>4954<td>procedure TCipher_Misty.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4955<td>var
<tr class="nocodegen"><td>4956<td>  A, B: UInt32;
<tr class="covered"><td>4957<td>begin
<tr class="covered"><td>4958<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4959<td>
<tr class="covered"><td>4960<td>  A := PUInt32Array(Source)[0];
<tr class="covered"><td>4961<td>  B := PUInt32Array(Source)[1];
<tr class="covered"><td>4962<td>  A := Misty_E(A, 0, FAdditionalBuffer);
<tr class="covered"><td>4963<td>  B := Misty_E(B, 1, FAdditionalBuffer) xor Misty_O(A, 0, FAdditionalBuffer);
<tr class="covered"><td>4964<td>  A := A xor Misty_O(B, 1, FAdditionalBuffer);
<tr class="covered"><td>4965<td>  A := Misty_E(A, 2, FAdditionalBuffer);
<tr class="covered"><td>4966<td>  B := Misty_E(B, 3, FAdditionalBuffer) xor Misty_O(A, 2, FAdditionalBuffer);
<tr class="covered"><td>4967<td>  A := A xor Misty_O(B, 3, FAdditionalBuffer);
<tr class="covered"><td>4968<td>  A := Misty_E(A, 4, FAdditionalBuffer);
<tr class="covered"><td>4969<td>  B := Misty_E(B, 5, FAdditionalBuffer) xor Misty_O(A, 4, FAdditionalBuffer);
<tr class="covered"><td>4970<td>  A := A xor Misty_O(B, 5, FAdditionalBuffer);
<tr class="covered"><td>4971<td>  A := Misty_E(A, 6, FAdditionalBuffer);
<tr class="covered"><td>4972<td>  B := Misty_E(B, 7, FAdditionalBuffer) xor Misty_O(A, 6, FAdditionalBuffer);
<tr class="covered"><td>4973<td>  A := A xor Misty_O(B, 7, FAdditionalBuffer);
<tr class="nocodegen"><td>4974<td>
<tr class="covered"><td>4975<td>  PUInt32Array(Dest)[0] := Misty_E(B, 9, FAdditionalBuffer);
<tr class="covered"><td>4976<td>  PUInt32Array(Dest)[1] := Misty_E(A, 8, FAdditionalBuffer);
<tr class="covered"><td>4977<td>end;
<tr class="nocodegen"><td>4978<td>
<tr class="nocodegen"><td>4979<td>procedure TCipher_Misty.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>4980<td>var
<tr class="nocodegen"><td>4981<td>  A, B: UInt32;
<tr class="covered"><td>4982<td>begin
<tr class="covered"><td>4983<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>4984<td>
<tr class="covered"><td>4985<td>  B := Misty_D(PUInt32Array(Source)[0], 9, FAdditionalBuffer);
<tr class="covered"><td>4986<td>  A := Misty_D(PUInt32Array(Source)[1], 8, FAdditionalBuffer);
<tr class="covered"><td>4987<td>  A := A xor Misty_O(B, 7, FAdditionalBuffer);
<tr class="covered"><td>4988<td>  B := Misty_D(B xor Misty_O(A, 6, FAdditionalBuffer), 7, FAdditionalBuffer);
<tr class="covered"><td>4989<td>  A := Misty_D(A, 6, FAdditionalBuffer);
<tr class="covered"><td>4990<td>  A := A xor Misty_O(B, 5, FAdditionalBuffer);
<tr class="covered"><td>4991<td>  B := Misty_D(B xor Misty_O(A, 4, FAdditionalBuffer), 5, FAdditionalBuffer);
<tr class="covered"><td>4992<td>  A := Misty_D(A, 4, FAdditionalBuffer);
<tr class="covered"><td>4993<td>  A := A xor Misty_O(B, 3, FAdditionalBuffer);
<tr class="covered"><td>4994<td>  B := Misty_D(B xor Misty_O(A, 2, FAdditionalBuffer), 3, FAdditionalBuffer);
<tr class="covered"><td>4995<td>  A := Misty_D(A, 2, FAdditionalBuffer);
<tr class="covered"><td>4996<td>  A := A xor Misty_O(B, 1, FAdditionalBuffer);
<tr class="nocodegen"><td>4997<td>
<tr class="covered"><td>4998<td>  PUInt32Array(Dest)[0] := Misty_D(A, 0, FAdditionalBuffer);
<tr class="covered"><td>4999<td>  PUInt32Array(Dest)[1] := Misty_D(B xor Misty_O(A, 0, FAdditionalBuffer), 1, FAdditionalBuffer);
<tr class="covered"><td>5000<td>end;
<tr class="nocodegen"><td>5001<td>
<tr class="nocodegen"><td>5002<td>{ TCipher_NewDES }
<tr class="nocodegen"><td>5003<td>
<tr class="nocodegen"><td>5004<td>procedure NewDES_Func(Source, Dest, Key: PByteArray);
<tr class="nocodegen"><td>5005<td>var
<tr class="nocodegen"><td>5006<td>  I: Integer;
<tr class="nocodegen"><td>5007<td>  A, B, C, D, E, F, G, H: Byte;
<tr class="covered"><td>5008<td>begin
<tr class="covered"><td>5009<td>  A := Source[0];
<tr class="covered"><td>5010<td>  B := Source[1];
<tr class="covered"><td>5011<td>  C := Source[2];
<tr class="covered"><td>5012<td>  D := Source[3];
<tr class="covered"><td>5013<td>  E := Source[4];
<tr class="covered"><td>5014<td>  F := Source[5];
<tr class="covered"><td>5015<td>  G := Source[6];
<tr class="covered"><td>5016<td>  H := Source[7];
<tr class="nocodegen"><td>5017<td>
<tr class="covered"><td>5018<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>5019<td>  begin
<tr class="covered"><td>5020<td>    E := E xor NewDES_Data[A xor Key[0]];
<tr class="covered"><td>5021<td>    F := F xor NewDES_Data[B xor Key[1]];
<tr class="covered"><td>5022<td>    G := G xor NewDES_Data[C xor Key[2]];
<tr class="covered"><td>5023<td>    H := H xor NewDES_Data[D xor Key[3]];
<tr class="covered"><td>5024<td>    B := B xor NewDES_Data[E xor Key[4]];
<tr class="covered"><td>5025<td>    C := C xor NewDES_Data[F xor E];
<tr class="covered"><td>5026<td>    D := D xor NewDES_Data[G xor Key[5]];
<tr class="covered"><td>5027<td>    A := A xor NewDES_Data[H xor Key[6]];
<tr class="covered"><td>5028<td>    Key := @Key[7];
<tr class="covered"><td>5029<td>  end;
<tr class="nocodegen"><td>5030<td>
<tr class="covered"><td>5031<td>  E := E xor NewDES_Data[A xor Key[0]];
<tr class="covered"><td>5032<td>  F := F xor NewDES_Data[B xor Key[1]];
<tr class="covered"><td>5033<td>  G := G xor NewDES_Data[C xor Key[2]];
<tr class="covered"><td>5034<td>  H := H xor NewDES_Data[D xor Key[3]];
<tr class="nocodegen"><td>5035<td>
<tr class="covered"><td>5036<td>  Dest[0] := A;
<tr class="covered"><td>5037<td>  Dest[1] := B;
<tr class="covered"><td>5038<td>  Dest[2] := C;
<tr class="covered"><td>5039<td>  Dest[3] := D;
<tr class="covered"><td>5040<td>  Dest[4] := E;
<tr class="covered"><td>5041<td>  Dest[5] := F;
<tr class="covered"><td>5042<td>  Dest[6] := G;
<tr class="covered"><td>5043<td>  Dest[7] := H;
<tr class="covered"><td>5044<td>end;
<tr class="nocodegen"><td>5045<td>
<tr class="nocodegen"><td>5046<td>class function TCipher_NewDES.Context: TCipherContext;
<tr class="covered"><td>5047<td>begin
<tr class="covered"><td>5048<td>  Result.KeySize                     := 15;
<tr class="covered"><td>5049<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>5050<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>5051<td>  Result.AdditionalBufferSize        := 60 * 2;
<tr class="covered"><td>5052<td>  Result.NeedsAdditionalBufferBackup := true;
<tr class="covered"><td>5053<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>5054<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>5055<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>5056<td>end;
<tr class="nocodegen"><td>5057<td>
<tr class="nocodegen"><td>5058<td>procedure TCipher_NewDES.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>5059<td>var
<tr class="nocodegen"><td>5060<td>  K: array[0..14] of Byte;
<tr class="nocodegen"><td>5061<td>  E: PByteArray;
<tr class="nocodegen"><td>5062<td>  I: Integer;
<tr class="covered"><td>5063<td>begin
<tr class="covered"><td>5064<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>5065<td>  Move(Key, K, Size);
<tr class="covered"><td>5066<td>  E := FAdditionalBuffer;
<tr class="covered"><td>5067<td>  Move(K, E[ 0], 15);
<tr class="covered"><td>5068<td>  Move(K, E[15], 15);
<tr class="covered"><td>5069<td>  Move(K, E[30], 15);
<tr class="covered"><td>5070<td>  Move(K, E[45], 15);
<tr class="covered"><td>5071<td>  E := @E[60];
<tr class="covered"><td>5072<td>  I := 11;
<tr class="nocodegen"><td>5073<td>
<tr class="nocodegen"><td>5074<td>  repeat
<tr class="covered"><td>5075<td>    E[0] := K[I]; I := (I + 1) mod 15;
<tr class="covered"><td>5076<td>    E[1] := K[I]; I := (I + 1) mod 15;
<tr class="covered"><td>5077<td>    E[2] := K[I]; I := (I + 1) mod 15;
<tr class="covered"><td>5078<td>    E[3] := K[I]; I := (I + 9) mod 15;
<tr class="covered"><td>5079<td>    if I = 12 then
<tr class="nocodegen"><td>5080<td>      Break;
<tr class="covered"><td>5081<td>    E[4] := K[I]; Inc(I);
<tr class="covered"><td>5082<td>    E[5] := K[I]; Inc(I);
<tr class="covered"><td>5083<td>    E[6] := K[I]; I := (I + 9) mod 15;
<tr class="covered"><td>5084<td>    E := @E[7];
<tr class="covered"><td>5085<td>  until False;
<tr class="nocodegen"><td>5086<td>
<tr class="covered"><td>5087<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>5088<td>
<tr class="nocodegen"><td>5089<td>  inherited;
<tr class="covered"><td>5090<td>end;
<tr class="nocodegen"><td>5091<td>
<tr class="nocodegen"><td>5092<td>procedure TCipher_NewDES.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>5093<td>begin
<tr class="covered"><td>5094<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>5095<td>  NewDES_Func(Source, Dest, FAdditionalBuffer);
<tr class="covered"><td>5096<td>end;
<tr class="nocodegen"><td>5097<td>
<tr class="nocodegen"><td>5098<td>procedure TCipher_NewDES.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="covered"><td>5099<td>begin
<tr class="covered"><td>5100<td>  Assert(Size = Context.BlockSize);
<tr class="covered"><td>5101<td>  NewDES_Func(Source, Dest, @PByteArray(FAdditionalBuffer)[60]);
<tr class="covered"><td>5102<td>end;
<tr class="nocodegen"><td>5103<td>
<tr class="nocodegen"><td>5104<td>{ TCipher_Q128 }
<tr class="nocodegen"><td>5105<td>
<tr class="nocodegen"><td>5106<td>class function TCipher_Q128.Context: TCipherContext;
<tr class="covered"><td>5107<td>begin
<tr class="covered"><td>5108<td>  Result.KeySize                     := 16;
<tr class="covered"><td>5109<td>  Result.BlockSize                   := 16;
<tr class="covered"><td>5110<td>  Result.BufferSize                  := 16;
<tr class="covered"><td>5111<td>  Result.AdditionalBufferSize        := 256;
<tr class="covered"><td>5112<td>  Result.NeedsAdditionalBufferBackup := false;
<tr class="covered"><td>5113<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>5114<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>5115<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>5116<td>end;
<tr class="nocodegen"><td>5117<td>
<tr class="nocodegen"><td>5118<td>procedure TCipher_Q128.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>5119<td>var
<tr class="nocodegen"><td>5120<td>  K: array[0..3] of UInt32;
<tr class="nocodegen"><td>5121<td>  D: PUInt32Array;
<tr class="nocodegen"><td>5122<td>  I: Integer;
<tr class="covered"><td>5123<td>begin
<tr class="covered"><td>5124<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>5125<td>  Move(Key, K, Size);
<tr class="covered"><td>5126<td>  D := FAdditionalBuffer;
<tr class="nocodegen"><td>5127<td>
<tr class="covered"><td>5128<td>  for I := 19 downto 1 do
<tr class="nocodegen"><td>5129<td>  begin
<tr class="covered"><td>5130<td>    K[1] := K[1] xor Q128_Data[K[0] and $03FF]; K[0] := K[0] shr 10 or K[0] shl 22;
<tr class="covered"><td>5131<td>    K[2] := K[2] xor Q128_Data[K[1] and $03FF]; K[1] := K[1] shr 10 or K[1] shl 22;
<tr class="covered"><td>5132<td>    K[3] := K[3] xor Q128_Data[K[2] and $03FF]; K[2] := K[2] shr 10 or K[2] shl 22;
<tr class="covered"><td>5133<td>    K[0] := K[0] xor Q128_Data[K[3] and $03FF]; K[3] := K[3] shr 10 or K[3] shl 22;
<tr class="covered"><td>5134<td>    if I &lt;= 16 then
<tr class="nocodegen"><td>5135<td>    begin
<tr class="covered"><td>5136<td>      D[0] := K[0];
<tr class="covered"><td>5137<td>      D[1] := K[1];
<tr class="covered"><td>5138<td>      D[2] := K[2];
<tr class="covered"><td>5139<td>      D[3] := K[3];
<tr class="covered"><td>5140<td>      D := @D[4];
<tr class="nocodegen"><td>5141<td>    end;
<tr class="covered"><td>5142<td>  end;
<tr class="nocodegen"><td>5143<td>
<tr class="covered"><td>5144<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>5145<td>
<tr class="nocodegen"><td>5146<td>  inherited;
<tr class="covered"><td>5147<td>end;
<tr class="nocodegen"><td>5148<td>
<tr class="nocodegen"><td>5149<td>procedure TCipher_Q128.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5150<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>5151<td>asm
<tr class="nocodegen"><td>5152<td>       PUSH   ESI
<tr class="nocodegen"><td>5153<td>       PUSH   EDI
<tr class="nocodegen"><td>5154<td>       PUSH   EBX
<tr class="nocodegen"><td>5155<td>       PUSH   EBP
<tr class="nocodegen"><td>5156<td>       PUSH   ECX
<tr class="nocodegen"><td>5157<td>       MOV    EDI,[EAX].TCipher_Q128.FAdditionalBuffer
<tr class="nocodegen"><td>5158<td>       MOV    EAX,[EDX +  0]  // B0
<tr class="nocodegen"><td>5159<td>       MOV    EBX,[EDX +  4]  // B1
<tr class="nocodegen"><td>5160<td>       MOV    ECX,[EDX +  8]  // B2
<tr class="nocodegen"><td>5161<td>       MOV    EDX,[EDX + 12]  // B3
<tr class="nocodegen"><td>5162<td>       MOV    EBP,16
<tr class="nocodegen"><td>5163<td>@@1:   MOV    ESI,EAX
<tr class="nocodegen"><td>5164<td>       ROL    ESI,10
<tr class="nocodegen"><td>5165<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5166<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5167<td>       ADD    EAX,[EDI + 0]
<tr class="nocodegen"><td>5168<td>       XOR    EAX,EBX
<tr class="nocodegen"><td>5169<td>       MOV    EBX,EAX
<tr class="nocodegen"><td>5170<td>       ROL    EBX,10
<tr class="nocodegen"><td>5171<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5172<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5173<td>       ADD    EAX,[EDI + 4]
<tr class="nocodegen"><td>5174<td>       XOR    EAX,ECX
<tr class="nocodegen"><td>5175<td>       MOV    ECX,EAX
<tr class="nocodegen"><td>5176<td>       ROL    ECX,10
<tr class="nocodegen"><td>5177<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5178<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5179<td>       ADD    EAX,[EDI + 8]
<tr class="nocodegen"><td>5180<td>       XOR    EAX,EDX
<tr class="nocodegen"><td>5181<td>       MOV    EDX,EAX
<tr class="nocodegen"><td>5182<td>       ROL    EDX,10
<tr class="nocodegen"><td>5183<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5184<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5185<td>       ADD    EAX,[EDI + 12]
<tr class="nocodegen"><td>5186<td>       XOR    EAX,ESI
<tr class="nocodegen"><td>5187<td>       DEC    EBP
<tr class="nocodegen"><td>5188<td>       LEA    EDI,[EDI + 16]
<tr class="nocodegen"><td>5189<td>       JNZ    @@1
<tr class="nocodegen"><td>5190<td>       POP    ESI
<tr class="nocodegen"><td>5191<td>       MOV    [ESI +  0],EAX  // B0
<tr class="nocodegen"><td>5192<td>       MOV    [ESI +  4],EBX  // B1
<tr class="nocodegen"><td>5193<td>       MOV    [ESI +  8],ECX  // B2
<tr class="nocodegen"><td>5194<td>       MOV    [ESI + 12],EDX  // B3
<tr class="nocodegen"><td>5195<td>       POP    EBP
<tr class="nocodegen"><td>5196<td>       POP    EBX
<tr class="nocodegen"><td>5197<td>       POP    EDI
<tr class="nocodegen"><td>5198<td>       POP    ESI
<tr class="nocodegen"><td>5199<td>end;
<tr class="nocodegen"><td>5200<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>5201<td>var
<tr class="nocodegen"><td>5202<td>  D: PUInt32Array;
<tr class="nocodegen"><td>5203<td>  B0, B1, B2, B3, I: UInt32;
<tr class="covered"><td>5204<td>begin
<tr class="covered"><td>5205<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5206<td>
<tr class="covered"><td>5207<td>  D  := Pointer(FAdditionalBuffer);
<tr class="covered"><td>5208<td>  B0 := PUInt32Array(Source)[0];
<tr class="covered"><td>5209<td>  B1 := PUInt32Array(Source)[1];
<tr class="covered"><td>5210<td>  B2 := PUInt32Array(Source)[2];
<tr class="covered"><td>5211<td>  B3 := PUInt32Array(Source)[3];
<tr class="covered"><td>5212<td>  for I := 0 to 15 do
<tr class="nocodegen"><td>5213<td>  begin
<tr class="covered"><td>5214<td>    B1 := B1 xor (Q128_Data[B0 and $03FF] + D[0]); B0 := B0 shl 10 or B0 shr 22;
<tr class="covered"><td>5215<td>    B2 := B2 xor (Q128_Data[B1 and $03FF] + D[1]); B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>5216<td>    B3 := B3 xor (Q128_Data[B2 and $03FF] + D[2]); B2 := B2 shl 10 or B2 shr 22;
<tr class="covered"><td>5217<td>    B0 := B0 xor (Q128_Data[B3 and $03FF] + D[3]); B3 := B3 shl 10 or B3 shr 22;
<tr class="covered"><td>5218<td>    D := @D[4];
<tr class="covered"><td>5219<td>  end;
<tr class="covered"><td>5220<td>  PUInt32Array(Dest)[0] := B0;
<tr class="covered"><td>5221<td>  PUInt32Array(Dest)[1] := B1;
<tr class="covered"><td>5222<td>  PUInt32Array(Dest)[2] := B2;
<tr class="covered"><td>5223<td>  PUInt32Array(Dest)[3] := B3;
<tr class="covered"><td>5224<td>end;
<tr class="nocodegen"><td>5225<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>5226<td>
<tr class="nocodegen"><td>5227<td>procedure TCipher_Q128.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5228<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>5229<td>asm
<tr class="nocodegen"><td>5230<td>       PUSH   ESI
<tr class="nocodegen"><td>5231<td>       PUSH   EDI
<tr class="nocodegen"><td>5232<td>       PUSH   EBX
<tr class="nocodegen"><td>5233<td>       PUSH   EBP
<tr class="nocodegen"><td>5234<td>       PUSH   ECX
<tr class="nocodegen"><td>5235<td>       MOV    EDI,[EAX].TCipher_Q128.FAdditionalBuffer
<tr class="nocodegen"><td>5236<td>       LEA    EDI,[EDI + 64 * 4]
<tr class="nocodegen"><td>5237<td>       MOV    ESI,[EDX +  0]   // B0
<tr class="nocodegen"><td>5238<td>       MOV    EBX,[EDX +  4]  // B1
<tr class="nocodegen"><td>5239<td>       MOV    ECX,[EDX +  8]  // B2
<tr class="nocodegen"><td>5240<td>       MOV    EDX,[EDX + 12]  // B3
<tr class="nocodegen"><td>5241<td>       MOV    EBP,16
<tr class="nocodegen"><td>5242<td>@@1:   SUB    EDI,16
<tr class="nocodegen"><td>5243<td>       ROR    EDX,10
<tr class="nocodegen"><td>5244<td>       MOV    EAX,EDX
<tr class="nocodegen"><td>5245<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5246<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5247<td>       ADD    EAX,[EDI + 12]
<tr class="nocodegen"><td>5248<td>       XOR    ESI,EAX
<tr class="nocodegen"><td>5249<td>       ROR    ECX,10
<tr class="nocodegen"><td>5250<td>       MOV    EAX,ECX
<tr class="nocodegen"><td>5251<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5252<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5253<td>       ADD    EAX,[EDI +  8]
<tr class="nocodegen"><td>5254<td>       XOR    EDX,EAX
<tr class="nocodegen"><td>5255<td>       ROR    EBX,10
<tr class="nocodegen"><td>5256<td>       MOV    EAX,EBX
<tr class="nocodegen"><td>5257<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5258<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5259<td>       ADD    EAX,[EDI +  4]
<tr class="nocodegen"><td>5260<td>       XOR    ECX,EAX
<tr class="nocodegen"><td>5261<td>       ROR    ESI,10
<tr class="nocodegen"><td>5262<td>       MOV    EAX,ESI
<tr class="nocodegen"><td>5263<td>       AND    EAX,03FFh
<tr class="nocodegen"><td>5264<td>       MOV    EAX,[EAX * 4 + OFFSET Q128_DATA]
<tr class="nocodegen"><td>5265<td>       ADD    EAX,[EDI]
<tr class="nocodegen"><td>5266<td>       XOR    EBX,EAX
<tr class="nocodegen"><td>5267<td>       DEC    EBP
<tr class="nocodegen"><td>5268<td>       JNZ    @@1
<tr class="nocodegen"><td>5269<td>       POP    EAX
<tr class="nocodegen"><td>5270<td>       MOV    [EAX +  0],ESI  // B0
<tr class="nocodegen"><td>5271<td>       MOV    [EAX +  4],EBX  // B1
<tr class="nocodegen"><td>5272<td>       MOV    [EAX +  8],ECX  // B2
<tr class="nocodegen"><td>5273<td>       MOV    [EAX + 12],EDX  // B3
<tr class="nocodegen"><td>5274<td>       POP    EBP
<tr class="nocodegen"><td>5275<td>       POP    EBX
<tr class="nocodegen"><td>5276<td>       POP    EDI
<tr class="nocodegen"><td>5277<td>       POP    ESI
<tr class="nocodegen"><td>5278<td>end;
<tr class="nocodegen"><td>5279<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>5280<td>var
<tr class="nocodegen"><td>5281<td>  D: PUInt32Array;
<tr class="nocodegen"><td>5282<td>  B0, B1, B2, B3, I: UInt32;
<tr class="covered"><td>5283<td>begin
<tr class="covered"><td>5284<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5285<td>
<tr class="covered"><td>5286<td>  D  := @PUInt32Array(FAdditionalBuffer)[60];
<tr class="covered"><td>5287<td>  B0 := PUInt32Array(Source)[0];
<tr class="covered"><td>5288<td>  B1 := PUInt32Array(Source)[1];
<tr class="covered"><td>5289<td>  B2 := PUInt32Array(Source)[2];
<tr class="covered"><td>5290<td>  B3 := PUInt32Array(Source)[3];
<tr class="covered"><td>5291<td>  for I := 0 to 15 do
<tr class="nocodegen"><td>5292<td>  begin
<tr class="covered"><td>5293<td>    B3 := B3 shr 10 or B3 shl 22; B0 := B0 xor (Q128_Data[B3 and $03FF] + D[3]);
<tr class="covered"><td>5294<td>    B2 := B2 shr 10 or B2 shl 22; B3 := B3 xor (Q128_Data[B2 and $03FF] + D[2]);
<tr class="covered"><td>5295<td>    B1 := B1 shr 10 or B1 shl 22; B2 := B2 xor (Q128_Data[B1 and $03FF] + D[1]);
<tr class="covered"><td>5296<td>    B0 := B0 shr 10 or B0 shl 22; B1 := B1 xor (Q128_Data[B0 and $03FF] + D[0]);
<tr class="covered"><td>5297<td>    Dec(PUInt32(D), 4);
<tr class="covered"><td>5298<td>  end;
<tr class="covered"><td>5299<td>  PUInt32Array(Dest)[0] := B0;
<tr class="covered"><td>5300<td>  PUInt32Array(Dest)[1] := B1;
<tr class="covered"><td>5301<td>  PUInt32Array(Dest)[2] := B2;
<tr class="covered"><td>5302<td>  PUInt32Array(Dest)[3] := B3;
<tr class="covered"><td>5303<td>end;
<tr class="nocodegen"><td>5304<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>5305<td>
<tr class="nocodegen"><td>5306<td>{ TCipher_RC2 }
<tr class="nocodegen"><td>5307<td>
<tr class="nocodegen"><td>5308<td>class function TCipher_RC2.Context: TCipherContext;
<tr class="covered"><td>5309<td>begin
<tr class="covered"><td>5310<td>  Result.KeySize                     := 128;
<tr class="covered"><td>5311<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>5312<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>5313<td>  Result.AdditionalBufferSize        := 128;
<tr class="covered"><td>5314<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>5315<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>5316<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>5317<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>5318<td>end;
<tr class="nocodegen"><td>5319<td>
<tr class="nocodegen"><td>5320<td>procedure TCipher_RC2.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>5321<td>// New keyscheduling according to RFC2268 and it's testcases. The V3 keysetup
<tr class="nocodegen"><td>5322<td>// was using an older, inferior version. Special thanks to Brendan Bosnan for
<tr class="nocodegen"><td>5323<td>// pointing that out.
<tr class="nocodegen"><td>5324<td>var
<tr class="nocodegen"><td>5325<td>  I, L, Mask, KeyEffectiveBits: Integer;
<tr class="nocodegen"><td>5326<td>  K: PByteArray;
<tr class="covered"><td>5327<td>begin
<tr class="covered"><td>5328<td>  if Size &lt;= 0 then
<tr class="nocodegen"><td>5329<td>    Exit;
<tr class="covered"><td>5330<td>  KeyEffectiveBits := Size * 8;
<tr class="covered"><td>5331<td>  L := KeyEffectiveBits and 7;
<tr class="covered"><td>5332<td>  if L = 0 then
<tr class="covered"><td>5333<td>    Mask := $FF
<tr class="nocodegen"><td>5334<td>  else
<tr class="notcovered"><td>5335<td>    Mask := $FF shr (8 - L);
<tr class="covered"><td>5336<td>  L := (KeyEffectiveBits + 7) shr 3;
<tr class="covered"><td>5337<td>  K := FAdditionalBuffer;
<tr class="covered"><td>5338<td>  Move(Key, K[0], Size);
<tr class="covered"><td>5339<td>  for I := Size to 127 do
<tr class="covered"><td>5340<td>    K[I] := RC2_Data[(K[I - Size] + K[I - 1]) and $FF];
<tr class="covered"><td>5341<td>  K[128 - L] := RC2_Data[K[128 - L] and Mask];
<tr class="covered"><td>5342<td>  for I := 127 - L downto 0 do
<tr class="covered"><td>5343<td>     K[I] := RC2_Data[K[I + 1] xor K[I + L]];
<tr class="nocodegen"><td>5344<td>
<tr class="nocodegen"><td>5345<td>  inherited;
<tr class="covered"><td>5346<td>end;
<tr class="nocodegen"><td>5347<td>
<tr class="nocodegen"><td>5348<td>procedure TCipher_RC2.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5349<td>var
<tr class="nocodegen"><td>5350<td>  I: Integer;
<tr class="nocodegen"><td>5351<td>  K: PWordArray;
<tr class="nocodegen"><td>5352<td>  A, B, C, D: Word;
<tr class="covered"><td>5353<td>begin
<tr class="covered"><td>5354<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5355<td>
<tr class="covered"><td>5356<td>  K := FAdditionalBuffer;
<tr class="covered"><td>5357<td>  A := PWordArray(Source)[0];
<tr class="covered"><td>5358<td>  B := PWordArray(Source)[1];
<tr class="covered"><td>5359<td>  C := PWordArray(Source)[2];
<tr class="covered"><td>5360<td>  D := PWordArray(Source)[3];
<tr class="covered"><td>5361<td>  for I := 0 to 15 do
<tr class="nocodegen"><td>5362<td>  begin
<tr class="covered"><td>5363<td>    Inc(A, (B and not D) + (C and D) + K[I * 4 + 0]); A := A shl 1 or A shr 15;
<tr class="covered"><td>5364<td>    Inc(B, (C and not A) + (D and A) + K[I * 4 + 1]); B := B shl 2 or B shr 14;
<tr class="covered"><td>5365<td>    Inc(C, (D and not B) + (A and B) + K[I * 4 + 2]); C := C shl 3 or C shr 13;
<tr class="covered"><td>5366<td>    Inc(D, (A and not C) + (B and C) + K[I * 4 + 3]); D := D shl 5 or D shr 11;
<tr class="covered"><td>5367<td>    if I in [4, 10] then
<tr class="nocodegen"><td>5368<td>    begin
<tr class="covered"><td>5369<td>      Inc(A, K[D and $3F]);
<tr class="covered"><td>5370<td>      Inc(B, K[A and $3F]);
<tr class="covered"><td>5371<td>      Inc(C, K[B and $3F]);
<tr class="covered"><td>5372<td>      Inc(D, K[C and $3F]);
<tr class="nocodegen"><td>5373<td>    end;
<tr class="covered"><td>5374<td>  end;
<tr class="covered"><td>5375<td>  PWordArray(Dest)[0] := A;
<tr class="covered"><td>5376<td>  PWordArray(Dest)[1] := B;
<tr class="covered"><td>5377<td>  PWordArray(Dest)[2] := C;
<tr class="covered"><td>5378<td>  PWordArray(Dest)[3] := D;
<tr class="covered"><td>5379<td>end;
<tr class="nocodegen"><td>5380<td>
<tr class="nocodegen"><td>5381<td>procedure TCipher_RC2.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5382<td>var
<tr class="nocodegen"><td>5383<td>  I: Integer;
<tr class="nocodegen"><td>5384<td>  K: PWordArray;
<tr class="nocodegen"><td>5385<td>  A, B, C, D: Word;
<tr class="covered"><td>5386<td>begin
<tr class="covered"><td>5387<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5388<td>
<tr class="covered"><td>5389<td>  K := FAdditionalBuffer;
<tr class="covered"><td>5390<td>  A := PWordArray(Source)[0];
<tr class="covered"><td>5391<td>  B := PWordArray(Source)[1];
<tr class="covered"><td>5392<td>  C := PWordArray(Source)[2];
<tr class="covered"><td>5393<td>  D := PWordArray(Source)[3];
<tr class="covered"><td>5394<td>  for I := 15 downto 0 do
<tr class="nocodegen"><td>5395<td>  begin
<tr class="covered"><td>5396<td>    D := D shr 5 or D shl 11 - (A and not C) - (B and C) - K[I * 4 + 3];
<tr class="covered"><td>5397<td>    C := C shr 3 or C shl 13 - (D and not B) - (A and B) - K[I * 4 + 2];
<tr class="covered"><td>5398<td>    B := B shr 2 or B shl 14 - (C and not A) - (D and A) - K[I * 4 + 1];
<tr class="covered"><td>5399<td>    A := A shr 1 or A shl 15 - (B and not D) - (C and D) - K[I * 4 + 0];
<tr class="covered"><td>5400<td>    if I in [5, 11] then
<tr class="nocodegen"><td>5401<td>    begin
<tr class="covered"><td>5402<td>      Dec(D, K[C and $3F]);
<tr class="covered"><td>5403<td>      Dec(C, K[B and $3F]);
<tr class="covered"><td>5404<td>      Dec(B, K[A and $3F]);
<tr class="covered"><td>5405<td>      Dec(A, K[D and $3F]);
<tr class="nocodegen"><td>5406<td>    end;
<tr class="covered"><td>5407<td>  end;
<tr class="covered"><td>5408<td>  PWordArray(Dest)[0] := A;
<tr class="covered"><td>5409<td>  PWordArray(Dest)[1] := B;
<tr class="covered"><td>5410<td>  PWordArray(Dest)[2] := C;
<tr class="covered"><td>5411<td>  PWordArray(Dest)[3] := D;
<tr class="covered"><td>5412<td>end;
<tr class="nocodegen"><td>5413<td>
<tr class="nocodegen"><td>5414<td>{ TCipher_RC5 }
<tr class="nocodegen"><td>5415<td>
<tr class="nocodegen"><td>5416<td>class function TCipher_RC5.Context: TCipherContext;
<tr class="covered"><td>5417<td>begin
<tr class="covered"><td>5418<td>  Result.KeySize                     := 256;
<tr class="covered"><td>5419<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>5420<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>5421<td>  Result.AdditionalBufferSize        := 136;
<tr class="covered"><td>5422<td>  Result.NeedsAdditionalBufferBackup := false;
<tr class="covered"><td>5423<td>  Result.MinRounds                   := 0;
<tr class="covered"><td>5424<td>  Result.MaxRounds                   := 256;
<tr class="covered"><td>5425<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>5426<td>end;
<tr class="nocodegen"><td>5427<td>
<tr class="nocodegen"><td>5428<td>procedure TCipher_RC5.SetRounds(Value: Integer);
<tr class="covered"><td>5429<td>begin
<tr class="covered"><td>5430<td>  if Value &lt;&gt; FRounds then
<tr class="nocodegen"><td>5431<td>  begin
<tr class="covered"><td>5432<td>    if not (FState in [csNew, csInitialized, csDone]) then
<tr class="notcovered"><td>5433<td>      Done;
<tr class="nocodegen"><td>5434<td>
<tr class="covered"><td>5435<td>    if Value &lt; 0 then
<tr class="covered"><td>5436<td>      Value := 12;
<tr class="nocodegen"><td>5437<td>
<tr class="covered"><td>5438<td>    if (Value &gt; Context.MaxRounds) then
<tr class="covered"><td>5439<td>      Value := Context.MaxRounds;
<tr class="nocodegen"><td>5440<td>
<tr class="covered"><td>5441<td>    FRounds := Value;
<tr class="nocodegen"><td>5442<td>  end;
<tr class="covered"><td>5443<td>end;
<tr class="nocodegen"><td>5444<td>
<tr class="nocodegen"><td>5445<td>procedure TCipher_RC5.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>5446<td>var
<tr class="nocodegen"><td>5447<td>  K: array[0..63] of UInt32;
<tr class="nocodegen"><td>5448<td>  L, Z, I, J: Integer;
<tr class="nocodegen"><td>5449<td>  D: PUInt32Array;
<tr class="nocodegen"><td>5450<td>  A, B, T: UInt32;
<tr class="covered"><td>5451<td>begin
<tr class="covered"><td>5452<td>  if FRounds &lt;= 0 then
<tr class="covered"><td>5453<td>    FRounds := 12;
<tr class="covered"><td>5454<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>5455<td>  Move(Key, K, Size);
<tr class="covered"><td>5456<td>  D := FAdditionalBuffer;
<tr class="covered"><td>5457<td>  L := (Size + 3) shr 2;
<tr class="covered"><td>5458<td>  if L &lt;= 0 then
<tr class="notcovered"><td>5459<td>    L := 1;
<tr class="covered"><td>5460<td>  T := $B7E15163;
<tr class="covered"><td>5461<td>  for I := 0 to (FRounds + 1) * 2 do
<tr class="nocodegen"><td>5462<td>  begin
<tr class="covered"><td>5463<td>    D[I] := T;
<tr class="covered"><td>5464<td>    Inc(T, $9E3779B9);
<tr class="covered"><td>5465<td>  end;
<tr class="covered"><td>5466<td>  if L &gt; (FRounds + 1) * 2 then
<tr class="notcovered"><td>5467<td>    Z := L * 3
<tr class="nocodegen"><td>5468<td>  else
<tr class="covered"><td>5469<td>    Z := (FRounds + 1) * 6;
<tr class="covered"><td>5470<td>  I := 0;
<tr class="covered"><td>5471<td>  J := 0;
<tr class="covered"><td>5472<td>  A := 0;
<tr class="covered"><td>5473<td>  B := 0;
<tr class="covered"><td>5474<td>  for Z := Z downto 1 do
<tr class="nocodegen"><td>5475<td>  begin
<tr class="covered"><td>5476<td>    A := D[I] + A + B;
<tr class="covered"><td>5477<td>    A := A shl 3 or A shr 29;
<tr class="covered"><td>5478<td>    D[I] := A;
<tr class="covered"><td>5479<td>    T := A + B;
<tr class="covered"><td>5480<td>    B := K[J] + T;
<tr class="covered"><td>5481<td>    B := B shl T or B shr (32 - T);
<tr class="covered"><td>5482<td>    K[J] := B;
<tr class="covered"><td>5483<td>    I := (I + 1) mod ((FRounds + 1) * 2);
<tr class="covered"><td>5484<td>    J := (J + 1) mod L;
<tr class="covered"><td>5485<td>  end;
<tr class="covered"><td>5486<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>5487<td>
<tr class="nocodegen"><td>5488<td>  inherited;
<tr class="covered"><td>5489<td>end;
<tr class="nocodegen"><td>5490<td>
<tr class="nocodegen"><td>5491<td>procedure TCipher_RC5.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5492<td>var
<tr class="nocodegen"><td>5493<td>  K: PUInt32Array;
<tr class="nocodegen"><td>5494<td>  I: Integer;
<tr class="nocodegen"><td>5495<td>  A, B: UInt32;
<tr class="covered"><td>5496<td>begin
<tr class="covered"><td>5497<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5498<td>
<tr class="covered"><td>5499<td>  K := FAdditionalBuffer;
<tr class="covered"><td>5500<td>  A := PUInt32Array(Source)[0] + K[0];
<tr class="covered"><td>5501<td>  B := PUInt32Array(Source)[1] + K[1];
<tr class="covered"><td>5502<td>  for I := 1 to FRounds do
<tr class="nocodegen"><td>5503<td>  begin
<tr class="covered"><td>5504<td>    A := A xor B; A := A shl B or A shr (32 - B) + K[I * 2 + 0];
<tr class="covered"><td>5505<td>    B := B xor A; B := B shl A or B shr (32 - A) + K[I * 2 + 1];
<tr class="covered"><td>5506<td>  end;
<tr class="covered"><td>5507<td>  PUInt32Array(Dest)[0] := A;
<tr class="covered"><td>5508<td>  PUInt32Array(Dest)[1] := B;
<tr class="covered"><td>5509<td>end;
<tr class="nocodegen"><td>5510<td>
<tr class="nocodegen"><td>5511<td>procedure TCipher_RC5.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5512<td>var
<tr class="nocodegen"><td>5513<td>  K: PUInt32Array;
<tr class="nocodegen"><td>5514<td>  I: Integer;
<tr class="nocodegen"><td>5515<td>  A, B: UInt32;
<tr class="covered"><td>5516<td>begin
<tr class="covered"><td>5517<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5518<td>
<tr class="covered"><td>5519<td>  K := @PUInt32Array(FAdditionalBuffer)[0];
<tr class="covered"><td>5520<td>  A := PUInt32Array(Source)[0];
<tr class="covered"><td>5521<td>  B := PUInt32Array(Source)[1];
<tr class="covered"><td>5522<td>  for I := FRounds downto 1 do
<tr class="nocodegen"><td>5523<td>  begin
<tr class="covered"><td>5524<td>    B := B - K[I * 2 + 1]; B := B shr A or B shl (32 - A) xor A;
<tr class="covered"><td>5525<td>    A := A - K[I * 2 + 0]; A := A shr B or A shl (32 - B) xor B;
<tr class="covered"><td>5526<td>  end;
<tr class="covered"><td>5527<td>  PUInt32Array(Dest)[0] := A - K[0];
<tr class="covered"><td>5528<td>  PUInt32Array(Dest)[1] := B - K[1];
<tr class="covered"><td>5529<td>end;
<tr class="nocodegen"><td>5530<td>
<tr class="nocodegen"><td>5531<td>{ TCipher_SAFER }
<tr class="nocodegen"><td>5532<td>
<tr class="nocodegen"><td>5533<td>class function TCipher_SAFER.Context: TCipherContext;
<tr class="covered"><td>5534<td>begin
<tr class="covered"><td>5535<td>  Result.KeySize                     := 16;
<tr class="covered"><td>5536<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>5537<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>5538<td>  Result.AdditionalBufferSize        := 768;
<tr class="covered"><td>5539<td>  Result.NeedsAdditionalBufferBackup := false;
<tr class="covered"><td>5540<td>  Result.MinRounds                   := 4;
<tr class="covered"><td>5541<td>  Result.MaxRounds                   := 13;
<tr class="covered"><td>5542<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>5543<td>end;
<tr class="nocodegen"><td>5544<td>
<tr class="nocodegen"><td>5545<td>procedure TCipher_SAFER.SetRounds(Value: Integer);
<tr class="covered"><td>5546<td>begin
<tr class="covered"><td>5547<td>  if not (FState in [csNew, csInitialized, csDone]) then
<tr class="notcovered"><td>5548<td>    Done;
<tr class="covered"><td>5549<td>  if (Value &lt; 4) or (Value &gt; 13) then
<tr class="covered"><td>5550<td>    case FVersion of // Default Rounds
<tr class="covered"><td>5551<td>      svK40, svSK40: Value := 5;
<tr class="covered"><td>5552<td>      svK64, svSK64: Value := 6;
<tr class="covered"><td>5553<td>      svK128, svSK128: Value := 10;
<tr class="nocodegen"><td>5554<td>    else
<tr class="notcovered"><td>5555<td>      Value := 8;
<tr class="nocodegen"><td>5556<td>    end;
<tr class="covered"><td>5557<td>  FRounds := Value;
<tr class="covered"><td>5558<td>end;
<tr class="nocodegen"><td>5559<td>
<tr class="nocodegen"><td>5560<td>procedure TCipher_SAFER.SetVersion(Value: TSAFERVersion);
<tr class="covered"><td>5561<td>begin
<tr class="covered"><td>5562<td>  if Value &lt;&gt; FVersion then
<tr class="nocodegen"><td>5563<td>  begin
<tr class="covered"><td>5564<td>    if not (FState in [csNew, csInitialized, csDone]) then
<tr class="notcovered"><td>5565<td>      Done;
<tr class="covered"><td>5566<td>    FVersion := Value;
<tr class="covered"><td>5567<td>    SetRounds(0);
<tr class="nocodegen"><td>5568<td>  end;
<tr class="covered"><td>5569<td>end;
<tr class="nocodegen"><td>5570<td>
<tr class="nocodegen"><td>5571<td>procedure TCipher_SAFER.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>5572<td>
<tr class="nocodegen"><td>5573<td>  procedure InitTab;
<tr class="nocodegen"><td>5574<td>  var
<tr class="nocodegen"><td>5575<td>    I, E: Integer;
<tr class="nocodegen"><td>5576<td>    Exp: PByteArray;
<tr class="nocodegen"><td>5577<td>    Log: PByteArray;
<tr class="covered"><td>5578<td>  begin
<tr class="covered"><td>5579<td>    Exp := FAdditionalBuffer;
<tr class="covered"><td>5580<td>    Log := @Exp[256];
<tr class="covered"><td>5581<td>    E   := 1;
<tr class="covered"><td>5582<td>    for I := 0 to 255 do
<tr class="nocodegen"><td>5583<td>    begin
<tr class="covered"><td>5584<td>      Exp[I] := E and $FF;
<tr class="covered"><td>5585<td>      Log[E and $FF] := I;
<tr class="covered"><td>5586<td>      E := (E * 45) mod 257;
<tr class="covered"><td>5587<td>    end;
<tr class="covered"><td>5588<td>  end;
<tr class="nocodegen"><td>5589<td>
<tr class="nocodegen"><td>5590<td>  procedure InitKey;
<tr class="nocodegen"><td>5591<td>  var
<tr class="nocodegen"><td>5592<td>    D: PByte;
<tr class="nocodegen"><td>5593<td>    Exp: PByteArray;
<tr class="nocodegen"><td>5594<td>    Strong: Boolean;
<tr class="nocodegen"><td>5595<td>    K: array[Boolean, 0..8] of Byte;
<tr class="nocodegen"><td>5596<td>    I, J: Integer;
<tr class="covered"><td>5597<td>  begin
<tr class="covered"><td>5598<td>    Strong := FVersion in [svSK40, svSK64, svSK128];
<tr class="covered"><td>5599<td>    Exp := FAdditionalBuffer;
<tr class="covered"><td>5600<td>    D := @Exp[512];
<tr class="covered"><td>5601<td>    FillChar(K, SizeOf(K), 0);
<tr class="nocodegen"><td>5602<td>    // Setup Key A
<tr class="covered"><td>5603<td>    I := Size;
<tr class="covered"><td>5604<td>    if I &gt; 8 then
<tr class="covered"><td>5605<td>      I := 8;
<tr class="covered"><td>5606<td>    Move(Key, K[False], I);
<tr class="nocodegen"><td>5607<td>    // Setup the Key for K-40, SK-40
<tr class="covered"><td>5608<td>    if FVersion in [svK40, svSK40] then
<tr class="nocodegen"><td>5609<td>    begin
<tr class="notcovered"><td>5610<td>      K[False, 5] := K[False, 0] xor K[False, 2] xor 129;
<tr class="notcovered"><td>5611<td>      K[False, 6] := K[False, 0] xor K[False, 3] xor K[False, 4] xor 66;
<tr class="notcovered"><td>5612<td>      K[False, 7] := K[False, 1] xor K[False, 2] xor K[False, 4] xor 36;
<tr class="notcovered"><td>5613<td>      K[False, 8] := K[False, 1] xor K[False, 3] xor 24;
<tr class="notcovered"><td>5614<td>      Move(K[False], K[True], SizeOf(K[False]));
<tr class="nocodegen"><td>5615<td>    end
<tr class="nocodegen"><td>5616<td>    else
<tr class="nocodegen"><td>5617<td>    begin
<tr class="covered"><td>5618<td>      if Size &gt; 8 then
<tr class="nocodegen"><td>5619<td>      begin
<tr class="covered"><td>5620<td>        I := Size - 8;
<tr class="covered"><td>5621<td>        if I &gt; 8 then
<tr class="notcovered"><td>5622<td>          I := 8;
<tr class="covered"><td>5623<td>        Move(TByteArray(Key)[8], K[True], I);
<tr class="nocodegen"><td>5624<td>      end
<tr class="nocodegen"><td>5625<td>      else
<tr class="notcovered"><td>5626<td>        Move(K[False], K[True], 9);
<tr class="covered"><td>5627<td>      for I := 0 to 7 do
<tr class="nocodegen"><td>5628<td>      begin
<tr class="covered"><td>5629<td>        K[False, 8] := K[False, 8] xor K[False, I];
<tr class="covered"><td>5630<td>        K[True, 8]  := K[True, 8]  xor K[True, I];
<tr class="covered"><td>5631<td>      end;
<tr class="nocodegen"><td>5632<td>    end;
<tr class="nocodegen"><td>5633<td>    // Setup the KeyData
<tr class="covered"><td>5634<td>    Move(K[True], D^, 8);
<tr class="covered"><td>5635<td>    Inc(D, 8);
<tr class="nocodegen"><td>5636<td>
<tr class="covered"><td>5637<td>    for I := 0 to 8 do
<tr class="covered"><td>5638<td>      K[False, I] := K[False, I] shr 3 or K[False, I] shl 5;
<tr class="nocodegen"><td>5639<td>
<tr class="covered"><td>5640<td>    for I := 1 to FRounds do
<tr class="nocodegen"><td>5641<td>    begin
<tr class="covered"><td>5642<td>      for J := 0 to 8 do
<tr class="nocodegen"><td>5643<td>      begin
<tr class="covered"><td>5644<td>        K[False, J] := K[False, J] shl 6 or K[False, J] shr 2;
<tr class="covered"><td>5645<td>        K[True, J] := K[True, J] shl 6 or K[True, J] shr 2;
<tr class="covered"><td>5646<td>      end;
<tr class="covered"><td>5647<td>      for J := 0 to 7 do
<tr class="nocodegen"><td>5648<td>      begin
<tr class="covered"><td>5649<td>        if Strong then
<tr class="covered"><td>5650<td>          D^ := K[False, (J + I * 2 - 1) mod 9] + Exp[Exp[18 * I + J + 1]]
<tr class="nocodegen"><td>5651<td>        else
<tr class="notcovered"><td>5652<td>          D^ := K[False, J] + Exp[Exp[18 * I + J + 1]];
<tr class="covered"><td>5653<td>        Inc(D);
<tr class="covered"><td>5654<td>      end;
<tr class="covered"><td>5655<td>      for J := 0 to 7 do
<tr class="nocodegen"><td>5656<td>      begin
<tr class="covered"><td>5657<td>        if Strong then
<tr class="covered"><td>5658<td>          D^ := K[True, (J + I * 2) mod 9] + Exp[Exp[18 * I + J + 10]]
<tr class="nocodegen"><td>5659<td>        else
<tr class="notcovered"><td>5660<td>          D^ := K[True, J] + Exp[Exp[18 * I + J + 10]];
<tr class="covered"><td>5661<td>        Inc(D);
<tr class="covered"><td>5662<td>      end;
<tr class="covered"><td>5663<td>    end;
<tr class="covered"><td>5664<td>    ProtectBuffer(K, SizeOf(K));
<tr class="covered"><td>5665<td>  end;
<tr class="nocodegen"><td>5666<td>
<tr class="covered"><td>5667<td>begin
<tr class="covered"><td>5668<td>  if (FRounds &lt; 4) or (FRounds &gt; 13) then
<tr class="covered"><td>5669<td>    case FVersion of
<tr class="notcovered"><td>5670<td>      svK40, svSK40:    FRounds := 5;
<tr class="notcovered"><td>5671<td>      svK64, svSK64:    FRounds := 6;
<tr class="covered"><td>5672<td>      svK128, svSK128:  FRounds := 10;
<tr class="nocodegen"><td>5673<td>    else
<tr class="notcovered"><td>5674<td>      FRounds := 8;
<tr class="nocodegen"><td>5675<td>    end;
<tr class="covered"><td>5676<td>  InitTab;
<tr class="covered"><td>5677<td>  InitKey;
<tr class="nocodegen"><td>5678<td>
<tr class="nocodegen"><td>5679<td>  inherited;
<tr class="covered"><td>5680<td>end;
<tr class="nocodegen"><td>5681<td>
<tr class="nocodegen"><td>5682<td>procedure TCipher_SAFER.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5683<td>var
<tr class="nocodegen"><td>5684<td>  Exp, Log, Key: PByteArray;
<tr class="nocodegen"><td>5685<td>  I: Integer;
<tr class="nocodegen"><td>5686<td>  A, B, C, D, E, F, G, H, T: Byte;
<tr class="covered"><td>5687<td>begin
<tr class="covered"><td>5688<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5689<td>
<tr class="covered"><td>5690<td>  Exp := FAdditionalBuffer;
<tr class="covered"><td>5691<td>  Log := @Exp[256];
<tr class="covered"><td>5692<td>  Key := @Exp[512];
<tr class="nocodegen"><td>5693<td>
<tr class="covered"><td>5694<td>  A := PByteArray(Source)[0];
<tr class="covered"><td>5695<td>  B := PByteArray(Source)[1];
<tr class="covered"><td>5696<td>  C := PByteArray(Source)[2];
<tr class="covered"><td>5697<td>  D := PByteArray(Source)[3];
<tr class="covered"><td>5698<td>  E := PByteArray(Source)[4];
<tr class="covered"><td>5699<td>  F := PByteArray(Source)[5];
<tr class="covered"><td>5700<td>  G := PByteArray(Source)[6];
<tr class="covered"><td>5701<td>  H := PByteArray(Source)[7];
<tr class="nocodegen"><td>5702<td>
<tr class="covered"><td>5703<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>5704<td>  begin
<tr class="covered"><td>5705<td>    A := A xor Key[0];
<tr class="covered"><td>5706<td>    B := B  +  Key[1];
<tr class="covered"><td>5707<td>    C := C  +  Key[2];
<tr class="covered"><td>5708<td>    D := D xor Key[3];
<tr class="covered"><td>5709<td>    E := E xor Key[4];
<tr class="covered"><td>5710<td>    F := F  +  Key[5];
<tr class="covered"><td>5711<td>    G := G  +  Key[6];
<tr class="covered"><td>5712<td>    H := H xor Key[7];
<tr class="nocodegen"><td>5713<td>
<tr class="covered"><td>5714<td>    A := Exp[A]  +  Key[8];
<tr class="covered"><td>5715<td>    B := Log[B] xor Key[9];
<tr class="covered"><td>5716<td>    C := Log[C] xor Key[10];
<tr class="covered"><td>5717<td>    D := Exp[D]  +  Key[11];
<tr class="covered"><td>5718<td>    E := Exp[E]  +  Key[12];
<tr class="covered"><td>5719<td>    F := Log[F] xor Key[13];
<tr class="covered"><td>5720<td>    G := Log[G] xor Key[14];
<tr class="covered"><td>5721<td>    H := Exp[H]  +  Key[15];
<tr class="covered"><td>5722<td>    Inc(B, A); Inc(A, B);
<tr class="covered"><td>5723<td>    Inc(D, C); Inc(C, D);
<tr class="covered"><td>5724<td>    Inc(F, E); Inc(E, F);
<tr class="covered"><td>5725<td>    Inc(H, G); Inc(G, H);
<tr class="covered"><td>5726<td>    Inc(C, A); Inc(A, C);
<tr class="covered"><td>5727<td>    Inc(G, E); Inc(E, G);
<tr class="covered"><td>5728<td>    Inc(D, B); Inc(B, D);
<tr class="covered"><td>5729<td>    Inc(H, F); Inc(F, H);
<tr class="covered"><td>5730<td>    Inc(E, A); Inc(A, E);
<tr class="covered"><td>5731<td>    Inc(F, B); Inc(B, F);
<tr class="covered"><td>5732<td>    Inc(G, C); Inc(C, G);
<tr class="covered"><td>5733<td>    Inc(H, D); Inc(D, H);
<tr class="covered"><td>5734<td>    T := B; B := E; E := C; C := T;
<tr class="covered"><td>5735<td>    T := D; D := F; F := G; G := T;
<tr class="covered"><td>5736<td>    Key := @Key[16];
<tr class="covered"><td>5737<td>  end;
<tr class="nocodegen"><td>5738<td>
<tr class="covered"><td>5739<td>  PByteArray(Dest)[0] := A xor Key[0];
<tr class="covered"><td>5740<td>  PByteArray(Dest)[1] := B  +  Key[1];
<tr class="covered"><td>5741<td>  PByteArray(Dest)[2] := C  +  Key[2];
<tr class="covered"><td>5742<td>  PByteArray(Dest)[3] := D xor Key[3];
<tr class="covered"><td>5743<td>  PByteArray(Dest)[4] := E xor Key[4];
<tr class="covered"><td>5744<td>  PByteArray(Dest)[5] := F  +  Key[5];
<tr class="covered"><td>5745<td>  PByteArray(Dest)[6] := G  +  Key[6];
<tr class="covered"><td>5746<td>  PByteArray(Dest)[7] := H xor Key[7];
<tr class="covered"><td>5747<td>end;
<tr class="nocodegen"><td>5748<td>
<tr class="nocodegen"><td>5749<td>procedure TCipher_SAFER.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5750<td>var
<tr class="nocodegen"><td>5751<td>  Exp, Log, Key: PByteArray;
<tr class="nocodegen"><td>5752<td>  I: Integer;
<tr class="nocodegen"><td>5753<td>  A, B, C, D, E, F, G, H, T: Byte;
<tr class="covered"><td>5754<td>begin
<tr class="covered"><td>5755<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5756<td>
<tr class="covered"><td>5757<td>  Exp := FAdditionalBuffer;
<tr class="covered"><td>5758<td>  Log := @Exp[256];
<tr class="covered"><td>5759<td>  Key := @Exp[504 + 8 * (FRounds * 2 + 1)];
<tr class="nocodegen"><td>5760<td>
<tr class="covered"><td>5761<td>  A := PByteArray(Source)[0] xor Key[0];
<tr class="covered"><td>5762<td>  B := PByteArray(Source)[1]  -  Key[1];
<tr class="covered"><td>5763<td>  C := PByteArray(Source)[2]  -  Key[2];
<tr class="covered"><td>5764<td>  D := PByteArray(Source)[3] xor Key[3];
<tr class="covered"><td>5765<td>  E := PByteArray(Source)[4] xor Key[4];
<tr class="covered"><td>5766<td>  F := PByteArray(Source)[5]  -  Key[5];
<tr class="covered"><td>5767<td>  G := PByteArray(Source)[6]  -  Key[6];
<tr class="covered"><td>5768<td>  H := PByteArray(Source)[7] xor Key[7];
<tr class="nocodegen"><td>5769<td>
<tr class="covered"><td>5770<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>5771<td>  begin
<tr class="covered"><td>5772<td>    Dec(PByte(Key), 16);
<tr class="covered"><td>5773<td>    T := E; E := B; B := C; C := T;
<tr class="covered"><td>5774<td>    T := F; F := D; D := G; G := T;
<tr class="covered"><td>5775<td>    Dec(A, E); Dec(E, A);
<tr class="covered"><td>5776<td>    Dec(B, F); Dec(F, B);
<tr class="covered"><td>5777<td>    Dec(C, G); Dec(G, C);
<tr class="covered"><td>5778<td>    Dec(D, H); Dec(H, D);
<tr class="covered"><td>5779<td>    Dec(A, C); Dec(C, A);
<tr class="covered"><td>5780<td>    Dec(E, G); Dec(G, E);
<tr class="covered"><td>5781<td>    Dec(B, D); Dec(D, B);
<tr class="covered"><td>5782<td>    Dec(F, H); Dec(H, F);
<tr class="covered"><td>5783<td>    Dec(A, B); Dec(B, A);
<tr class="covered"><td>5784<td>    Dec(C, D); Dec(D, C);
<tr class="covered"><td>5785<td>    Dec(E, F); Dec(F, E);
<tr class="covered"><td>5786<td>    Dec(G, H); Dec(H, G);
<tr class="covered"><td>5787<td>    H := H  -  Key[15];
<tr class="covered"><td>5788<td>    G := G xor Key[14];
<tr class="covered"><td>5789<td>    F := F xor Key[13];
<tr class="covered"><td>5790<td>    E := E  -  Key[12];
<tr class="covered"><td>5791<td>    D := D  -  Key[11];
<tr class="covered"><td>5792<td>    C := C xor Key[10];
<tr class="covered"><td>5793<td>    B := B xor Key[9];
<tr class="covered"><td>5794<td>    A := A  -  Key[8];
<tr class="covered"><td>5795<td>    H := Log[H] xor Key[7];
<tr class="covered"><td>5796<td>    G := Exp[G]  -  Key[6];
<tr class="covered"><td>5797<td>    F := Exp[F]  -  Key[5];
<tr class="covered"><td>5798<td>    E := Log[E] xor Key[4];
<tr class="covered"><td>5799<td>    D := Log[D] xor Key[3];
<tr class="covered"><td>5800<td>    C := Exp[C]  -  Key[2];
<tr class="covered"><td>5801<td>    B := Exp[B]  -  Key[1];
<tr class="covered"><td>5802<td>    A := Log[A] xor Key[0];
<tr class="covered"><td>5803<td>  end;
<tr class="nocodegen"><td>5804<td>
<tr class="covered"><td>5805<td>  PByteArray(Dest)[0] := A;
<tr class="covered"><td>5806<td>  PByteArray(Dest)[1] := B;
<tr class="covered"><td>5807<td>  PByteArray(Dest)[2] := C;
<tr class="covered"><td>5808<td>  PByteArray(Dest)[3] := D;
<tr class="covered"><td>5809<td>  PByteArray(Dest)[4] := E;
<tr class="covered"><td>5810<td>  PByteArray(Dest)[5] := F;
<tr class="covered"><td>5811<td>  PByteArray(Dest)[6] := G;
<tr class="covered"><td>5812<td>  PByteArray(Dest)[7] := H;
<tr class="covered"><td>5813<td>end;
<tr class="nocodegen"><td>5814<td>
<tr class="nocodegen"><td>5815<td>{ TCipher_SharkBase }
<tr class="nocodegen"><td>5816<td>
<tr class="nocodegen"><td>5817<td>const
<tr class="nocodegen"><td>5818<td>  SHARK_ROOT      = $01F5; // GF(256) polynomial x^8 + x^7 + x^6 + x^5 + x^4 + x^2 + 1
<tr class="nocodegen"><td>5819<td>  SHARK_ROUNDS    = 6;
<tr class="nocodegen"><td>5820<td>  SHARK_ROUNDKEYS = SHARK_ROUNDS + 1;
<tr class="nocodegen"><td>5821<td>
<tr class="nocodegen"><td>5822<td>{$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>5823<td>function TCipher_SharkBase.Shark(D: TLong64; K: PLong64): TLong64;
<tr class="nocodegen"><td>5824<td>var
<tr class="nocodegen"><td>5825<td>  R, T: Integer;
<tr class="covered"><td>5826<td>begin
<tr class="covered"><td>5827<td>  for R := 0 to 4 do
<tr class="nocodegen"><td>5828<td>  begin
<tr class="covered"><td>5829<td>    D.L := D.L xor K.L;
<tr class="covered"><td>5830<td>    D.R := D.R xor K.R;
<tr class="covered"><td>5831<td>    Inc(K);
<tr class="covered"><td>5832<td>    T   := Shark_CE[0, D.R shr 23 and $1FE] xor
<tr class="nocodegen"><td>5833<td>           Shark_CE[1, D.R shr 15 and $1FE] xor
<tr class="nocodegen"><td>5834<td>           Shark_CE[2, D.R shr  7 and $1FE] xor
<tr class="nocodegen"><td>5835<td>           Shark_CE[3, D.R shl  1 and $1FE] xor
<tr class="nocodegen"><td>5836<td>           Shark_CE[4, D.L shr 23 and $1FE] xor
<tr class="nocodegen"><td>5837<td>           Shark_CE[5, D.L shr 15 and $1FE] xor
<tr class="nocodegen"><td>5838<td>           Shark_CE[6, D.L shr  7 and $1FE] xor
<tr class="nocodegen"><td>5839<td>           Shark_CE[7, D.L shl  1 and $1FE];
<tr class="nocodegen"><td>5840<td>
<tr class="covered"><td>5841<td>    D.R := Shark_CE[0, D.R shr 23 and $1FE or 1] xor
<tr class="nocodegen"><td>5842<td>           Shark_CE[1, D.R shr 15 and $1FE or 1] xor
<tr class="nocodegen"><td>5843<td>           Shark_CE[2, D.R shr  7 and $1FE or 1] xor
<tr class="nocodegen"><td>5844<td>           Shark_CE[3, D.R shl  1 and $1FE or 1] xor
<tr class="nocodegen"><td>5845<td>           Shark_CE[4, D.L shr 23 and $1FE or 1] xor
<tr class="nocodegen"><td>5846<td>           Shark_CE[5, D.L shr 15 and $1FE or 1] xor
<tr class="nocodegen"><td>5847<td>           Shark_CE[6, D.L shr  7 and $1FE or 1] xor
<tr class="nocodegen"><td>5848<td>           Shark_CE[7, D.L shl  1 and $1FE or 1];
<tr class="covered"><td>5849<td>    D.L := T;
<tr class="covered"><td>5850<td>  end;
<tr class="covered"><td>5851<td>  D.L := D.L xor K.L;
<tr class="covered"><td>5852<td>  D.R := D.R xor K.R;
<tr class="covered"><td>5853<td>  Inc(K);
<tr class="covered"><td>5854<td>  D.L := UInt32(Shark_SE[D.L shr 24 and $FF]) shl 24 xor
<tr class="nocodegen"><td>5855<td>         UInt32(Shark_SE[D.L shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>5856<td>         UInt32(Shark_SE[D.L shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>5857<td>         UInt32(Shark_SE[D.L        and $FF]);
<tr class="covered"><td>5858<td>  D.R := UInt32(Shark_SE[D.R shr 24 and $FF]) shl 24 xor
<tr class="nocodegen"><td>5859<td>         UInt32(Shark_SE[D.R shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>5860<td>         UInt32(Shark_SE[D.R shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>5861<td>         UInt32(Shark_SE[D.R        and $FF]);
<tr class="covered"><td>5862<td>  Result.L := D.L xor K.L;
<tr class="covered"><td>5863<td>  Result.R := D.R xor K.R;
<tr class="covered"><td>5864<td>end;
<tr class="nocodegen"><td>5865<td>{$ENDIF}
<tr class="nocodegen"><td>5866<td>
<tr class="nocodegen"><td>5867<td>{$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>5868<td>function TCipher_SharkBase.Transform(A: TLong64; Log, ALog: TLogArray): TLong64;
<tr class="nocodegen"><td>5869<td>  function Mul(A, B: Integer): Byte;
<tr class="covered"><td>5870<td>  begin
<tr class="nocodegen"><td>5871<td>    // GF(256) multiplication via logarithm tables
<tr class="covered"><td>5872<td>    Result := ALog[(Log[A] + Log[B]) mod 255];
<tr class="covered"><td>5873<td>  end;
<tr class="nocodegen"><td>5874<td>
<tr class="nocodegen"><td>5875<td>var
<tr class="nocodegen"><td>5876<td>  I, J: Byte;
<tr class="nocodegen"><td>5877<td>  K, T: array[0..7] of Byte;
<tr class="covered"><td>5878<td>begin
<tr class="covered"><td>5879<td>  Move(A.R, K[0], 4);
<tr class="covered"><td>5880<td>  Move(A.L, K[4], 4);
<tr class="covered"><td>5881<td>  SwapUInt32Buffer(K, K, 2);
<tr class="nocodegen"><td>5882<td>
<tr class="covered"><td>5883<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>5884<td>  begin
<tr class="covered"><td>5885<td>    T[I] := Mul(Shark_I[I, 0], K[0]);
<tr class="covered"><td>5886<td>    for J := 1 to 7 do
<tr class="covered"><td>5887<td>      T[I] := T[I] xor Mul(Shark_I[I, J], K[J]);
<tr class="covered"><td>5888<td>  end;
<tr class="nocodegen"><td>5889<td>
<tr class="covered"><td>5890<td>  Result.L := T[0];
<tr class="covered"><td>5891<td>  Result.R := 0;
<tr class="covered"><td>5892<td>  for I := 1 to 7 do
<tr class="nocodegen"><td>5893<td>  begin
<tr class="covered"><td>5894<td>    Result.R := Result.R shl 8 or Result.L shr 24;
<tr class="covered"><td>5895<td>    Result.L := Result.L shl 8 xor T[I];
<tr class="covered"><td>5896<td>  end;
<tr class="covered"><td>5897<td>end;
<tr class="nocodegen"><td>5898<td>
<tr class="nocodegen"><td>5899<td>{$ELSE CPU64BITS}
<tr class="nocodegen"><td>5900<td>function TCipher_SharkBase.Transform(A: UInt64; Log, ALog: TLogArray): UInt64;
<tr class="nocodegen"><td>5901<td>  function Mul(A, B: Integer): Byte;
<tr class="nocodegen"><td>5902<td>  begin
<tr class="nocodegen"><td>5903<td>    // GF(256) multiplication via logarithm tables
<tr class="nocodegen"><td>5904<td>    Result := ALog[(Log[A] + Log[B]) mod 255];
<tr class="nocodegen"><td>5905<td>  end;
<tr class="nocodegen"><td>5906<td>
<tr class="nocodegen"><td>5907<td>var
<tr class="nocodegen"><td>5908<td>  I, J: Byte;
<tr class="nocodegen"><td>5909<td>  K, T: array[0..7] of Byte;
<tr class="nocodegen"><td>5910<td>begin
<tr class="nocodegen"><td>5911<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>5912<td>    K[I] := A shr (56 - 8 * i);
<tr class="nocodegen"><td>5913<td>
<tr class="nocodegen"><td>5914<td>  for I := 0 to 7 do
<tr class="nocodegen"><td>5915<td>  begin
<tr class="nocodegen"><td>5916<td>    T[I] := Mul(Shark_I[I, 0], K[0]);
<tr class="nocodegen"><td>5917<td>    for J := 1 to 7 do
<tr class="nocodegen"><td>5918<td>      T[I] := T[I] xor Mul(Shark_I[I, J], K[J]);
<tr class="nocodegen"><td>5919<td>  end;
<tr class="nocodegen"><td>5920<td>
<tr class="nocodegen"><td>5921<td>  Result := T[0];
<tr class="nocodegen"><td>5922<td>  for I := 1 to 7 do
<tr class="nocodegen"><td>5923<td>    Result := (Result shl 8) xor T[I];
<tr class="nocodegen"><td>5924<td>end;
<tr class="nocodegen"><td>5925<td>{$ENDIF}
<tr class="nocodegen"><td>5926<td>
<tr class="nocodegen"><td>5927<td>class function TCipher_SharkBase.Context: TCipherContext;
<tr class="covered"><td>5928<td>begin
<tr class="covered"><td>5929<td>  Result.KeySize                     := 16;
<tr class="covered"><td>5930<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>5931<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>5932<td>  Result.AdditionalBufferSize        := 112;
<tr class="covered"><td>5933<td>  Result.NeedsAdditionalBufferBackup := False;
<tr class="covered"><td>5934<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>5935<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>5936<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>5937<td>end;
<tr class="nocodegen"><td>5938<td>
<tr class="nocodegen"><td>5939<td>
<tr class="nocodegen"><td>5940<td>procedure TCipher_SharkBase.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>5941<td>{$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>5942<td>var
<tr class="nocodegen"><td>5943<td>  I: Integer;
<tr class="nocodegen"><td>5944<td>  T, L, R: UInt32;
<tr class="nocodegen"><td>5945<td>  K: PUInt32Array;
<tr class="covered"><td>5946<td>begin
<tr class="covered"><td>5947<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>5948<td>
<tr class="covered"><td>5949<td>  K := FAdditionalBuffer;
<tr class="covered"><td>5950<td>  L := PLong64(Source).L;
<tr class="covered"><td>5951<td>  R := PLong64(Source).R;
<tr class="covered"><td>5952<td>  for I := 0 to 4 do
<tr class="nocodegen"><td>5953<td>  begin
<tr class="covered"><td>5954<td>    L := L xor K[I * 2 + 0];
<tr class="covered"><td>5955<td>    R := R xor K[I * 2 + 1];
<tr class="covered"><td>5956<td>    T := Shark_CE[0, R shr 23 and $1FE] xor
<tr class="nocodegen"><td>5957<td>         Shark_CE[1, R shr 15 and $1FE] xor
<tr class="nocodegen"><td>5958<td>         Shark_CE[2, R shr  7 and $1FE] xor
<tr class="nocodegen"><td>5959<td>         Shark_CE[3, R shl  1 and $1FE] xor
<tr class="nocodegen"><td>5960<td>         Shark_CE[4, L shr 23 and $1FE] xor
<tr class="nocodegen"><td>5961<td>         Shark_CE[5, L shr 15 and $1FE] xor
<tr class="nocodegen"><td>5962<td>         Shark_CE[6, L shr  7 and $1FE] xor
<tr class="nocodegen"><td>5963<td>         Shark_CE[7, L shl  1 and $1FE];
<tr class="covered"><td>5964<td>    R := Shark_CE[0, R shr 23 and $1FE or 1] xor
<tr class="nocodegen"><td>5965<td>         Shark_CE[1, R shr 15 and $1FE or 1] xor
<tr class="nocodegen"><td>5966<td>         Shark_CE[2, R shr  7 and $1FE or 1] xor
<tr class="nocodegen"><td>5967<td>         Shark_CE[3, R shl  1 and $1FE or 1] xor
<tr class="nocodegen"><td>5968<td>         Shark_CE[4, L shr 23 and $1FE or 1] xor
<tr class="nocodegen"><td>5969<td>         Shark_CE[5, L shr 15 and $1FE or 1] xor
<tr class="nocodegen"><td>5970<td>         Shark_CE[6, L shr  7 and $1FE or 1] xor
<tr class="nocodegen"><td>5971<td>         Shark_CE[7, L shl  1 and $1FE or 1];
<tr class="covered"><td>5972<td>    L := T;
<tr class="covered"><td>5973<td>  end;
<tr class="covered"><td>5974<td>  L := L xor K[10];
<tr class="covered"><td>5975<td>  R := R xor K[11];
<tr class="covered"><td>5976<td>  L := UInt32(Shark_SE[L shr 24        ]) shl 24 xor
<tr class="nocodegen"><td>5977<td>       UInt32(Shark_SE[L shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>5978<td>       UInt32(Shark_SE[L shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>5979<td>       UInt32(Shark_SE[L        and $FF]);
<tr class="covered"><td>5980<td>  R := UInt32(Shark_SE[R shr 24        ]) shl 24 xor
<tr class="nocodegen"><td>5981<td>       UInt32(Shark_SE[R shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>5982<td>       UInt32(Shark_SE[R shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>5983<td>       UInt32(Shark_SE[R        and $FF]);
<tr class="covered"><td>5984<td>  PLong64(Dest).L := L xor K[12];
<tr class="covered"><td>5985<td>  PLong64(Dest).R := R xor K[13];
<tr class="nocodegen"><td>5986<td>{$ELSE CPU64BITS}
<tr class="nocodegen"><td>5987<td>begin
<tr class="nocodegen"><td>5988<td>  // 64 bit
<tr class="nocodegen"><td>5989<td>  Assert(Size = Context.BufferSize);
<tr class="nocodegen"><td>5990<td>
<tr class="nocodegen"><td>5991<td>  PUInt64(Dest)^ := SharkEncode(PUInt64(Source)^, FAdditionalBuffer);
<tr class="nocodegen"><td>5992<td>{$ENDIF}
<tr class="covered"><td>5993<td>end;
<tr class="nocodegen"><td>5994<td>
<tr class="nocodegen"><td>5995<td>{$IFDEF CPU64BITS}
<tr class="nocodegen"><td>5996<td>function TCipher_SharkBase.SharkEncode(D: UInt64; K: PUInt64): UInt64;
<tr class="nocodegen"><td>5997<td>var
<tr class="nocodegen"><td>5998<td>  R: Integer;
<tr class="nocodegen"><td>5999<td>begin
<tr class="nocodegen"><td>6000<td>  for R := 1 to SHARK_ROUNDS - 1 do
<tr class="nocodegen"><td>6001<td>  begin
<tr class="nocodegen"><td>6002<td>    D := D xor K^;
<tr class="nocodegen"><td>6003<td>    Inc(K);
<tr class="nocodegen"><td>6004<td>    D := Shark_CE[0, D shr 56 and $FF] xor
<tr class="nocodegen"><td>6005<td>         Shark_CE[1, D shr 48 and $FF] xor
<tr class="nocodegen"><td>6006<td>         Shark_CE[2, D shr 40 and $FF] xor
<tr class="nocodegen"><td>6007<td>         Shark_CE[3, D shr 32 and $FF] xor
<tr class="nocodegen"><td>6008<td>         Shark_CE[4, D shr 24 and $FF] xor
<tr class="nocodegen"><td>6009<td>         Shark_CE[5, D shr 16 and $FF] xor
<tr class="nocodegen"><td>6010<td>         Shark_CE[6, D shr 8  and $FF] xor
<tr class="nocodegen"><td>6011<td>         Shark_CE[7, D        and $FF];
<tr class="nocodegen"><td>6012<td>  end;
<tr class="nocodegen"><td>6013<td>  D := D xor K^;
<tr class="nocodegen"><td>6014<td>  Inc(K);
<tr class="nocodegen"><td>6015<td>  D := UInt64(Shark_SE[D shr 56 and $FF]) shl 56 xor
<tr class="nocodegen"><td>6016<td>       UInt64(Shark_SE[D shr 48 and $FF]) shl 48 xor
<tr class="nocodegen"><td>6017<td>       UInt64(Shark_SE[D shr 40 and $FF]) shl 40 xor
<tr class="nocodegen"><td>6018<td>       UInt64(Shark_SE[D shr 32 and $FF]) shl 32 xor
<tr class="nocodegen"><td>6019<td>       UInt64(Shark_SE[D shr 24 and $FF]) shl 24 xor
<tr class="nocodegen"><td>6020<td>       UInt64(Shark_SE[D shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>6021<td>       UInt64(Shark_SE[D shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>6022<td>       UInt64(Shark_SE[D        and $FF]);
<tr class="nocodegen"><td>6023<td>  Result := D xor K^;
<tr class="nocodegen"><td>6024<td>end;
<tr class="nocodegen"><td>6025<td>{$ENDIF}
<tr class="nocodegen"><td>6026<td>
<tr class="nocodegen"><td>6027<td>
<tr class="nocodegen"><td>6028<td>{ TCipher_Shark }
<tr class="nocodegen"><td>6029<td>
<tr class="nocodegen"><td>6030<td>{$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>6031<td>procedure TCipher_Shark.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>6032<td>var
<tr class="nocodegen"><td>6033<td>  Log, ALog: TLogArray;
<tr class="nocodegen"><td>6034<td>
<tr class="nocodegen"><td>6035<td>  procedure InitLog;
<tr class="nocodegen"><td>6036<td>  var
<tr class="nocodegen"><td>6037<td>    I, J: Word;
<tr class="covered"><td>6038<td>  begin
<tr class="covered"><td>6039<td>    ALog[0] := 1;
<tr class="covered"><td>6040<td>    for I := 1 to 255 do
<tr class="nocodegen"><td>6041<td>    begin
<tr class="covered"><td>6042<td>      J := ALog[I - 1] shl 1;
<tr class="covered"><td>6043<td>      if J and $100 &lt;&gt; 0 then
<tr class="covered"><td>6044<td>        J := J xor SHARK_ROOT;
<tr class="covered"><td>6045<td>      ALog[I] := J;
<tr class="covered"><td>6046<td>    end;
<tr class="covered"><td>6047<td>    Log[0] := 0;
<tr class="covered"><td>6048<td>    for I := 0 to 254 do
<tr class="covered"><td>6049<td>      Log[ALog[I]] := I;
<tr class="covered"><td>6050<td>  end;
<tr class="nocodegen"><td>6051<td>
<tr class="nocodegen"><td>6052<td>var
<tr class="nocodegen"><td>6053<td>  T: array[0..6] of TLong64;
<tr class="nocodegen"><td>6054<td>  A: array[0..6] of TLong64;
<tr class="nocodegen"><td>6055<td>  K: array[0..15] of Byte;
<tr class="nocodegen"><td>6056<td>  I, J, R: Byte;
<tr class="nocodegen"><td>6057<td>  E, D: PLong64Array;
<tr class="nocodegen"><td>6058<td>  L: TLong64;
<tr class="covered"><td>6059<td>begin
<tr class="covered"><td>6060<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>6061<td>  Move(Key, K, Size);
<tr class="covered"><td>6062<td>  InitLog;
<tr class="covered"><td>6063<td>  E := FAdditionalBuffer;
<tr class="covered"><td>6064<td>  D := @E[7];
<tr class="covered"><td>6065<td>  Move(Shark_CE[0], T, SizeOf(T));
<tr class="covered"><td>6066<td>  T[6] := Transform(T[6], Log, ALog);
<tr class="covered"><td>6067<td>  I := 0;
<tr class="covered"><td>6068<td>  for R := 0 to 6 do
<tr class="nocodegen"><td>6069<td>  begin
<tr class="covered"><td>6070<td>    A[R].L := K[I and $F];
<tr class="covered"><td>6071<td>    A[R].R := 0;
<tr class="covered"><td>6072<td>    Inc(I);
<tr class="covered"><td>6073<td>    for J := 1 to 7 do
<tr class="nocodegen"><td>6074<td>    begin
<tr class="covered"><td>6075<td>      A[R].R := A[R].R shl 8 or A[R].L shr 24;
<tr class="covered"><td>6076<td>      A[R].L := A[R].L shl 8 or K[I and $F];
<tr class="covered"><td>6077<td>      Inc(I);
<tr class="covered"><td>6078<td>    end;
<tr class="covered"><td>6079<td>  end;
<tr class="covered"><td>6080<td>  L.L := 0;
<tr class="covered"><td>6081<td>  L.R := 0;
<tr class="covered"><td>6082<td>  L := Shark(L, @T);
<tr class="covered"><td>6083<td>  E[0].L := A[0].L xor L.L;
<tr class="covered"><td>6084<td>  E[0].R := A[0].R xor L.R;
<tr class="covered"><td>6085<td>  for R := 1 to 6 do
<tr class="nocodegen"><td>6086<td>  begin
<tr class="covered"><td>6087<td>    L := Shark(E[R - 1], @T);
<tr class="covered"><td>6088<td>    E[R].L := A[R].L xor L.L;
<tr class="covered"><td>6089<td>    E[R].R := A[R].R xor L.R;
<tr class="covered"><td>6090<td>  end;
<tr class="covered"><td>6091<td>  E[6] := Transform(E[6], Log, ALog);
<tr class="covered"><td>6092<td>  D[0] := E[6];
<tr class="covered"><td>6093<td>  D[6] := E[0];
<tr class="covered"><td>6094<td>  for R := 1 to 5 do
<tr class="covered"><td>6095<td>    D[R] := Transform(E[6-R], Log, ALog);
<tr class="covered"><td>6096<td>  ProtectBuffer(T, SizeOf(T));
<tr class="covered"><td>6097<td>  ProtectBuffer(A, SizeOf(A));
<tr class="covered"><td>6098<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>6099<td>
<tr class="nocodegen"><td>6100<td>  inherited;
<tr class="covered"><td>6101<td>end;
<tr class="nocodegen"><td>6102<td>{$ENDIF}
<tr class="nocodegen"><td>6103<td>
<tr class="nocodegen"><td>6104<td>{$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>6105<td>procedure TCipher_SharkBase.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6106<td>var
<tr class="nocodegen"><td>6107<td>  I: Integer;
<tr class="nocodegen"><td>6108<td>  T, R, L: UInt32;
<tr class="nocodegen"><td>6109<td>  K: PUInt32Array;
<tr class="covered"><td>6110<td>begin
<tr class="covered"><td>6111<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6112<td>
<tr class="covered"><td>6113<td>  K := @PUInt32Array(FAdditionalBuffer)[14];
<tr class="covered"><td>6114<td>  L := PLong64(Source).L;
<tr class="covered"><td>6115<td>  R := PLong64(Source).R;
<tr class="covered"><td>6116<td>  for I := 0 to 4 do
<tr class="nocodegen"><td>6117<td>  begin
<tr class="covered"><td>6118<td>    L := L xor K[I * 2 + 0];
<tr class="covered"><td>6119<td>    R := R xor K[I * 2 + 1];
<tr class="covered"><td>6120<td>    T := Shark_CD[0, R shr 23 and $1FE] xor
<tr class="nocodegen"><td>6121<td>         Shark_CD[1, R shr 15 and $1FE] xor
<tr class="nocodegen"><td>6122<td>         Shark_CD[2, R shr  7 and $1FE] xor
<tr class="nocodegen"><td>6123<td>         Shark_CD[3, R shl  1 and $1FE] xor
<tr class="nocodegen"><td>6124<td>         Shark_CD[4, L shr 23 and $1FE] xor
<tr class="nocodegen"><td>6125<td>         Shark_CD[5, L shr 15 and $1FE] xor
<tr class="nocodegen"><td>6126<td>         Shark_CD[6, L shr  7 and $1FE] xor
<tr class="nocodegen"><td>6127<td>         Shark_CD[7, L shl  1 and $1FE];
<tr class="covered"><td>6128<td>    R := Shark_CD[0, R shr 23 and $1FE or 1] xor
<tr class="nocodegen"><td>6129<td>         Shark_CD[1, R shr 15 and $1FE or 1] xor
<tr class="nocodegen"><td>6130<td>         Shark_CD[2, R shr  7 and $1FE or 1] xor
<tr class="nocodegen"><td>6131<td>         Shark_CD[3, R shl  1 and $1FE or 1] xor
<tr class="nocodegen"><td>6132<td>         Shark_CD[4, L shr 23 and $1FE or 1] xor
<tr class="nocodegen"><td>6133<td>         Shark_CD[5, L shr 15 and $1FE or 1] xor
<tr class="nocodegen"><td>6134<td>         Shark_CD[6, L shr  7 and $1FE or 1] xor
<tr class="nocodegen"><td>6135<td>         Shark_CD[7, L shl  1 and $1FE or 1];
<tr class="covered"><td>6136<td>    L := T;
<tr class="covered"><td>6137<td>  end;
<tr class="covered"><td>6138<td>  L := L xor K[10];
<tr class="covered"><td>6139<td>  R := R xor K[11];
<tr class="covered"><td>6140<td>  L := UInt32(Shark_SD[L shr 24        ]) shl 24 xor
<tr class="nocodegen"><td>6141<td>       UInt32(Shark_SD[L shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>6142<td>       UInt32(Shark_SD[L shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>6143<td>       UInt32(Shark_SD[L        and $FF]);
<tr class="covered"><td>6144<td>  R := UInt32(Shark_SD[R shr 24        ]) shl 24 xor
<tr class="nocodegen"><td>6145<td>       UInt32(Shark_SD[R shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>6146<td>       UInt32(Shark_SD[R shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>6147<td>       UInt32(Shark_SD[R        and $FF]);
<tr class="covered"><td>6148<td>  PLong64(Dest).L := L xor K[12];
<tr class="covered"><td>6149<td>  PLong64(Dest).R := R xor K[13];
<tr class="covered"><td>6150<td>end;
<tr class="nocodegen"><td>6151<td>
<tr class="nocodegen"><td>6152<td>{$ELSE CPU64BITS}
<tr class="nocodegen"><td>6153<td>procedure TCipher_Shark.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>6154<td>var
<tr class="nocodegen"><td>6155<td>  Log, ALog: TLogArray;
<tr class="nocodegen"><td>6156<td>
<tr class="nocodegen"><td>6157<td>  procedure InitLog;
<tr class="nocodegen"><td>6158<td>  var
<tr class="nocodegen"><td>6159<td>    I, J: Word;
<tr class="nocodegen"><td>6160<td>  begin
<tr class="nocodegen"><td>6161<td>    // Generate GF(256) anti-logarithm and logarithm tables
<tr class="nocodegen"><td>6162<td>    ALog[0] := 1;
<tr class="nocodegen"><td>6163<td>    for I := 1 to 255 do
<tr class="nocodegen"><td>6164<td>    begin
<tr class="nocodegen"><td>6165<td>      J := ALog[I - 1] shl 1;
<tr class="nocodegen"><td>6166<td>      if J and $100 &lt;&gt; 0 then
<tr class="nocodegen"><td>6167<td>        J := J xor SHARK_ROOT;
<tr class="nocodegen"><td>6168<td>      ALog[I] := J;
<tr class="nocodegen"><td>6169<td>    end;
<tr class="nocodegen"><td>6170<td>    Log[0] := 0;
<tr class="nocodegen"><td>6171<td>    for I := 0 to 254 do
<tr class="nocodegen"><td>6172<td>      Log[ALog[I]] := I;
<tr class="nocodegen"><td>6173<td>  end;
<tr class="nocodegen"><td>6174<td>
<tr class="nocodegen"><td>6175<td>var
<tr class="nocodegen"><td>6176<td>  T: array[0..SHARK_ROUNDS] of UInt64;
<tr class="nocodegen"><td>6177<td>  A: array[0..SHARK_ROUNDKEYS-1] of UInt64;
<tr class="nocodegen"><td>6178<td>  K: array[0..15] of Byte;
<tr class="nocodegen"><td>6179<td>  I, J, R: Integer;
<tr class="nocodegen"><td>6180<td>  E, D: PUInt64Array;
<tr class="nocodegen"><td>6181<td>begin
<tr class="nocodegen"><td>6182<td>  FillChar(K, SizeOf(K), 0);
<tr class="nocodegen"><td>6183<td>  Move(Key, K, Size);
<tr class="nocodegen"><td>6184<td>  InitLog;
<tr class="nocodegen"><td>6185<td>  E := FAdditionalBuffer; // encryption round key
<tr class="nocodegen"><td>6186<td>  D := @E[SHARK_ROUNDS + 1]; // decryption round key
<tr class="nocodegen"><td>6187<td>
<tr class="nocodegen"><td>6188<td>  Move(Shark_CE[0], T, SizeOf(T));
<tr class="nocodegen"><td>6189<td>  T[SHARK_ROUNDS] := Transform(T[SHARK_ROUNDS], Log, ALog);
<tr class="nocodegen"><td>6190<td>
<tr class="nocodegen"><td>6191<td>  I := 0;
<tr class="nocodegen"><td>6192<td>  for R := 0 to High(A) do
<tr class="nocodegen"><td>6193<td>  begin
<tr class="nocodegen"><td>6194<td>    A[R] := K[I and $F];
<tr class="nocodegen"><td>6195<td>    Inc(I);
<tr class="nocodegen"><td>6196<td>    for J := 1 to 7 do
<tr class="nocodegen"><td>6197<td>    begin
<tr class="nocodegen"><td>6198<td>      A[R] := A[R] shl 8 or K[I and $F];
<tr class="nocodegen"><td>6199<td>      Inc(I);
<tr class="nocodegen"><td>6200<td>    end;
<tr class="nocodegen"><td>6201<td>  end;
<tr class="nocodegen"><td>6202<td>
<tr class="nocodegen"><td>6203<td>  E[0] := A[0] xor SharkEncode(0, @T);
<tr class="nocodegen"><td>6204<td>  for R := 1 to High(A) do
<tr class="nocodegen"><td>6205<td>    E[R] := A[R] xor SharkEncode(E[R - 1], @T);
<tr class="nocodegen"><td>6206<td>
<tr class="nocodegen"><td>6207<td>  E[SHARK_ROUNDS] := Transform(E[SHARK_ROUNDS], Log, ALog);
<tr class="nocodegen"><td>6208<td>  D[0] := E[SHARK_ROUNDS];
<tr class="nocodegen"><td>6209<td>  D[SHARK_ROUNDS] := E[0];
<tr class="nocodegen"><td>6210<td>  for R := 1 to SHARK_ROUNDS - 1 do
<tr class="nocodegen"><td>6211<td>    D[R] := Transform(E[SHARK_ROUNDS - R], Log, ALog);
<tr class="nocodegen"><td>6212<td>
<tr class="nocodegen"><td>6213<td>  ProtectBuffer(T, SizeOf(T));
<tr class="nocodegen"><td>6214<td>  ProtectBuffer(A, SizeOf(A));
<tr class="nocodegen"><td>6215<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>6216<td>
<tr class="nocodegen"><td>6217<td>  inherited;
<tr class="nocodegen"><td>6218<td>end;
<tr class="nocodegen"><td>6219<td>
<tr class="nocodegen"><td>6220<td>procedure TCipher_SharkBase.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6221<td>var
<tr class="nocodegen"><td>6222<td>  R: Integer;
<tr class="nocodegen"><td>6223<td>  D: UInt64;
<tr class="nocodegen"><td>6224<td>  K: PUInt64;
<tr class="nocodegen"><td>6225<td>begin
<tr class="nocodegen"><td>6226<td>  Assert(Size = Context.BufferSize);
<tr class="nocodegen"><td>6227<td>
<tr class="nocodegen"><td>6228<td>  D := PUInt64(Source)^;
<tr class="nocodegen"><td>6229<td>  K := @PUInt64Array(FAdditionalBuffer)[SHARK_ROUNDS + 1]; // decryption round key
<tr class="nocodegen"><td>6230<td>  for R := 1 to SHARK_ROUNDS - 1 do
<tr class="nocodegen"><td>6231<td>  begin
<tr class="nocodegen"><td>6232<td>    D := D xor K^;
<tr class="nocodegen"><td>6233<td>    Inc(K);
<tr class="nocodegen"><td>6234<td>    D := Shark_CD[0, D shr 56 and $FF] xor
<tr class="nocodegen"><td>6235<td>         Shark_CD[1, D shr 48 and $FF] xor
<tr class="nocodegen"><td>6236<td>         Shark_CD[2, D shr 40 and $FF] xor
<tr class="nocodegen"><td>6237<td>         Shark_CD[3, D shr 32 and $FF] xor
<tr class="nocodegen"><td>6238<td>         Shark_CD[4, D shr 24 and $FF] xor
<tr class="nocodegen"><td>6239<td>         Shark_CD[5, D shr 16 and $FF] xor
<tr class="nocodegen"><td>6240<td>         Shark_CD[6, D shr 8  and $FF] xor
<tr class="nocodegen"><td>6241<td>         Shark_CD[7, D        and $FF];
<tr class="nocodegen"><td>6242<td>  end;
<tr class="nocodegen"><td>6243<td>  D := D xor K^;
<tr class="nocodegen"><td>6244<td>  Inc(K);
<tr class="nocodegen"><td>6245<td>  D := UInt64(Shark_SD[D shr 56 and $FF]) shl 56 xor
<tr class="nocodegen"><td>6246<td>       UInt64(Shark_SD[D shr 48 and $FF]) shl 48 xor
<tr class="nocodegen"><td>6247<td>       UInt64(Shark_SD[D shr 40 and $FF]) shl 40 xor
<tr class="nocodegen"><td>6248<td>       UInt64(Shark_SD[D shr 32 and $FF]) shl 32 xor
<tr class="nocodegen"><td>6249<td>       UInt64(Shark_SD[D shr 24 and $FF]) shl 24 xor
<tr class="nocodegen"><td>6250<td>       UInt64(Shark_SD[D shr 16 and $FF]) shl 16 xor
<tr class="nocodegen"><td>6251<td>       UInt64(Shark_SD[D shr  8 and $FF]) shl  8 xor
<tr class="nocodegen"><td>6252<td>       UInt64(Shark_SD[D        and $FF]);
<tr class="nocodegen"><td>6253<td>
<tr class="nocodegen"><td>6254<td>  PUInt64(Dest)^ := D xor K^;
<tr class="nocodegen"><td>6255<td>end;
<tr class="nocodegen"><td>6256<td>{$ENDIF CPU64BITS}
<tr class="nocodegen"><td>6257<td>
<tr class="nocodegen"><td>6258<td>{ TCipher_Shark_DEC52 }
<tr class="nocodegen"><td>6259<td>
<tr class="nocodegen"><td>6260<td>
<tr class="nocodegen"><td>6261<td>procedure TCipher_Shark_DEC52.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>6262<td>var
<tr class="nocodegen"><td>6263<td>  Log, ALog: TLogArray;
<tr class="nocodegen"><td>6264<td>
<tr class="nocodegen"><td>6265<td>  procedure InitLog;
<tr class="nocodegen"><td>6266<td>  var
<tr class="nocodegen"><td>6267<td>    I, J: Word;
<tr class="covered"><td>6268<td>  begin
<tr class="nocodegen"><td>6269<td>    // Generate GF(256) anti-logarithm and logarithm tables
<tr class="covered"><td>6270<td>    ALog[0] := 1;
<tr class="covered"><td>6271<td>    for I := 1 to 255 do
<tr class="nocodegen"><td>6272<td>    begin
<tr class="covered"><td>6273<td>      J := ALog[I - 1] shl 1;
<tr class="covered"><td>6274<td>      if J and $100 &lt;&gt; 0 then
<tr class="covered"><td>6275<td>        J := J xor SHARK_ROOT;
<tr class="covered"><td>6276<td>      ALog[I] := J;
<tr class="covered"><td>6277<td>    end;
<tr class="covered"><td>6278<td>    for I := 1 to 254 do
<tr class="covered"><td>6279<td>      Log[ALog[I]] := I;
<tr class="covered"><td>6280<td>  end;
<tr class="nocodegen"><td>6281<td>
<tr class="nocodegen"><td>6282<td>{$IFNDEF CPU64BITS}
<tr class="nocodegen"><td>6283<td>var
<tr class="nocodegen"><td>6284<td>  T: array[0..SHARK_ROUNDS] of TLong64;
<tr class="nocodegen"><td>6285<td>  A: array[0..SHARK_ROUNDS] of TLong64;
<tr class="nocodegen"><td>6286<td>  K: array[0..15] of Byte;
<tr class="nocodegen"><td>6287<td>  I, J, R: Byte;
<tr class="nocodegen"><td>6288<td>  E, D: PLong64Array;
<tr class="nocodegen"><td>6289<td>  L: TLong64;
<tr class="covered"><td>6290<td>begin
<tr class="covered"><td>6291<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>6292<td>  Move(Key, K, Size);
<tr class="covered"><td>6293<td>  InitLog;
<tr class="covered"><td>6294<td>  E := FAdditionalBuffer;
<tr class="covered"><td>6295<td>  D := @E[7];
<tr class="covered"><td>6296<td>  Move(Shark_CE[0], T, SizeOf(T));
<tr class="covered"><td>6297<td>  T[6] := Transform(T[6], Log, ALog);
<tr class="covered"><td>6298<td>  I := 0;
<tr class="covered"><td>6299<td>  for R := 0 to 6 do
<tr class="nocodegen"><td>6300<td>  begin
<tr class="covered"><td>6301<td>    Inc(I);
<tr class="covered"><td>6302<td>    A[R].L := K[I and $F];
<tr class="covered"><td>6303<td>    A[R].R := 0;
<tr class="covered"><td>6304<td>    for J := 1 to 7 do
<tr class="nocodegen"><td>6305<td>    begin
<tr class="covered"><td>6306<td>      Inc(I);
<tr class="covered"><td>6307<td>      A[R].R := A[R].R shl 8 or A[R].L shr 24;
<tr class="covered"><td>6308<td>      A[R].L := A[R].L shl 8 or K[I and $F];
<tr class="covered"><td>6309<td>    end;
<tr class="covered"><td>6310<td>  end;
<tr class="covered"><td>6311<td>  L.L := 0;
<tr class="covered"><td>6312<td>  L.R := 0;
<tr class="covered"><td>6313<td>  L := Shark(L, @T);
<tr class="covered"><td>6314<td>  E[0].L := A[0].L xor L.L;
<tr class="covered"><td>6315<td>  E[0].R := A[0].R xor L.R;
<tr class="covered"><td>6316<td>  for R := 1 to 6 do
<tr class="nocodegen"><td>6317<td>  begin
<tr class="covered"><td>6318<td>    L := Shark(E[R - 1], @T);
<tr class="covered"><td>6319<td>    E[R].L := A[R].L xor L.L;
<tr class="covered"><td>6320<td>    E[R].R := A[R].R xor L.R;
<tr class="covered"><td>6321<td>  end;
<tr class="covered"><td>6322<td>  E[6] := Transform(E[6], Log, ALog);
<tr class="covered"><td>6323<td>  D[0] := E[6];
<tr class="covered"><td>6324<td>  D[6] := E[0];
<tr class="covered"><td>6325<td>  for R := 1 to 5 do
<tr class="covered"><td>6326<td>    D[R] := Transform(E[6-R], Log, ALog);
<tr class="covered"><td>6327<td>  ProtectBuffer(T, SizeOf(T));
<tr class="covered"><td>6328<td>  ProtectBuffer(A, SizeOf(A));
<tr class="covered"><td>6329<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>6330<td>
<tr class="nocodegen"><td>6331<td>  inherited;
<tr class="nocodegen"><td>6332<td>  {$ELSE}
<tr class="nocodegen"><td>6333<td>var
<tr class="nocodegen"><td>6334<td>  T: array[0..SHARK_ROUNDS] of UInt64;
<tr class="nocodegen"><td>6335<td>  A: array[0..SHARK_ROUNDKEYS-1] of UInt64;
<tr class="nocodegen"><td>6336<td>  K: array[0..15] of Byte;
<tr class="nocodegen"><td>6337<td>  I, J, R: Integer;
<tr class="nocodegen"><td>6338<td>  E, D: PUInt64Array;
<tr class="nocodegen"><td>6339<td>begin
<tr class="nocodegen"><td>6340<td>  FillChar(K, SizeOf(K), 0);
<tr class="nocodegen"><td>6341<td>  Move(Key, K, Size);
<tr class="nocodegen"><td>6342<td>  InitLog;
<tr class="nocodegen"><td>6343<td>  E := FAdditionalBuffer; // encryption round key
<tr class="nocodegen"><td>6344<td>  D := @E[SHARK_ROUNDS + 1]; // decryption round key
<tr class="nocodegen"><td>6345<td>
<tr class="nocodegen"><td>6346<td>  Move(Shark_CE[0], T, SizeOf(T));
<tr class="nocodegen"><td>6347<td>  T[SHARK_ROUNDS] := Transform(T[SHARK_ROUNDS], Log, ALog);
<tr class="nocodegen"><td>6348<td>
<tr class="nocodegen"><td>6349<td>  I := 0;
<tr class="nocodegen"><td>6350<td>  for R := 0 to High(A) do
<tr class="nocodegen"><td>6351<td>  begin
<tr class="nocodegen"><td>6352<td>    Inc(I);
<tr class="nocodegen"><td>6353<td>    A[R] := K[I and $F];
<tr class="nocodegen"><td>6354<td>    for J := 1 to 7 do
<tr class="nocodegen"><td>6355<td>    begin
<tr class="nocodegen"><td>6356<td>      Inc(I);
<tr class="nocodegen"><td>6357<td>      A[R] := A[R] shl 8 or K[I and $F];
<tr class="nocodegen"><td>6358<td>    end;
<tr class="nocodegen"><td>6359<td>  end;
<tr class="nocodegen"><td>6360<td>
<tr class="nocodegen"><td>6361<td>  E[0] := A[0] xor SharkEncode(0, @T);
<tr class="nocodegen"><td>6362<td>  for R := 1 to High(A) do
<tr class="nocodegen"><td>6363<td>    E[R] := A[R] xor SharkEncode(E[R - 1], @T);
<tr class="nocodegen"><td>6364<td>
<tr class="nocodegen"><td>6365<td>  E[SHARK_ROUNDS] := Transform(E[SHARK_ROUNDS], Log, ALog);
<tr class="nocodegen"><td>6366<td>  D[0] := E[SHARK_ROUNDS];
<tr class="nocodegen"><td>6367<td>  D[SHARK_ROUNDS] := E[0];
<tr class="nocodegen"><td>6368<td>  for R := 1 to SHARK_ROUNDS - 1 do
<tr class="nocodegen"><td>6369<td>    D[R] := Transform(E[SHARK_ROUNDS - R], Log, ALog);
<tr class="nocodegen"><td>6370<td>
<tr class="nocodegen"><td>6371<td>  ProtectBuffer(T, SizeOf(T));
<tr class="nocodegen"><td>6372<td>  ProtectBuffer(A, SizeOf(A));
<tr class="nocodegen"><td>6373<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>6374<td>
<tr class="nocodegen"><td>6375<td>  inherited;
<tr class="nocodegen"><td>6376<td>  {$ENDIF}
<tr class="covered"><td>6377<td>end;
<tr class="nocodegen"><td>6378<td>
<tr class="nocodegen"><td>6379<td>{ TCipher_Skipjack }
<tr class="nocodegen"><td>6380<td>
<tr class="nocodegen"><td>6381<td>class function TCipher_Skipjack.Context: TCipherContext;
<tr class="covered"><td>6382<td>begin
<tr class="covered"><td>6383<td>  Result.KeySize                     := 10;
<tr class="covered"><td>6384<td>  Result.BlockSize                   := 8;
<tr class="covered"><td>6385<td>  Result.BufferSize                  := 8;
<tr class="covered"><td>6386<td>  Result.AdditionalBufferSize        := $A00;
<tr class="covered"><td>6387<td>  Result.NeedsAdditionalBufferBackup := false;
<tr class="covered"><td>6388<td>  Result.MinRounds                   := 1;
<tr class="covered"><td>6389<td>  Result.MaxRounds                   := 1;
<tr class="covered"><td>6390<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>6391<td>end;
<tr class="nocodegen"><td>6392<td>
<tr class="nocodegen"><td>6393<td>procedure TCipher_Skipjack.DoInit(const Key; Size: Integer);
<tr class="nocodegen"><td>6394<td>var
<tr class="nocodegen"><td>6395<td>  K: array[0..9] of Byte;
<tr class="nocodegen"><td>6396<td>  D: PByte;
<tr class="nocodegen"><td>6397<td>  I, J: Integer;
<tr class="covered"><td>6398<td>begin
<tr class="covered"><td>6399<td>  FillChar(K, SizeOf(K), 0);
<tr class="covered"><td>6400<td>  Move(Key, K, Size);
<tr class="covered"><td>6401<td>  D := FAdditionalBuffer;
<tr class="covered"><td>6402<td>  for I := 0 to 9 do
<tr class="covered"><td>6403<td>    for J := 0 to 255 do
<tr class="nocodegen"><td>6404<td>    begin
<tr class="covered"><td>6405<td>      D^ := Skipjack_Data[J xor K[I]];
<tr class="covered"><td>6406<td>      Inc(D);
<tr class="covered"><td>6407<td>    end;
<tr class="covered"><td>6408<td>  ProtectBuffer(K, SizeOf(K));
<tr class="nocodegen"><td>6409<td>
<tr class="nocodegen"><td>6410<td>  inherited;
<tr class="covered"><td>6411<td>end;
<tr class="nocodegen"><td>6412<td>
<tr class="nocodegen"><td>6413<td>procedure TCipher_Skipjack.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6414<td>var
<tr class="nocodegen"><td>6415<td>  Tab, Min: PSkipjackTab;
<tr class="nocodegen"><td>6416<td>  Max: PByte;
<tr class="nocodegen"><td>6417<td>  K, T, A, B, C, D: UInt32;
<tr class="nocodegen"><td>6418<td>
<tr class="covered"><td>6419<td>begin
<tr class="covered"><td>6420<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6421<td>
<tr class="covered"><td>6422<td>  Min := FAdditionalBuffer;
<tr class="covered"><td>6423<td>  Max := PByte(Min) + 9 * 256; // for Pointer Math
<tr class="covered"><td>6424<td>  Tab := Min;
<tr class="covered"><td>6425<td>  A   := Swap(PWordArray(Source)[0]);
<tr class="covered"><td>6426<td>  B   := Swap(PWordArray(Source)[1]);
<tr class="covered"><td>6427<td>  C   := Swap(PWordArray(Source)[2]);
<tr class="covered"><td>6428<td>  D   := Swap(PWordArray(Source)[3]);
<tr class="covered"><td>6429<td>  K   := 0;
<tr class="nocodegen"><td>6430<td>
<tr class="nocodegen"><td>6431<td>  repeat
<tr class="covered"><td>6432<td>    Inc(K);
<tr class="covered"><td>6433<td>    T := A;
<tr class="covered"><td>6434<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6435<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6436<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6437<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6438<td>    A := T xor D xor K;
<tr class="covered"><td>6439<td>    D := C;
<tr class="covered"><td>6440<td>    C := B;
<tr class="covered"><td>6441<td>    B := T;
<tr class="covered"><td>6442<td>  until K = 8;
<tr class="nocodegen"><td>6443<td>
<tr class="nocodegen"><td>6444<td>  repeat
<tr class="covered"><td>6445<td>    Inc(K);
<tr class="covered"><td>6446<td>    T := A;
<tr class="covered"><td>6447<td>    A := D;
<tr class="covered"><td>6448<td>    D := C;
<tr class="covered"><td>6449<td>    C := T xor B xor K;
<tr class="covered"><td>6450<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6451<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6452<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6453<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6454<td>    B := T;
<tr class="covered"><td>6455<td>  until K = 16;
<tr class="nocodegen"><td>6456<td>
<tr class="nocodegen"><td>6457<td>  repeat
<tr class="covered"><td>6458<td>    Inc(K);
<tr class="covered"><td>6459<td>    T := A;
<tr class="covered"><td>6460<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6461<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6462<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6463<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6464<td>    A := T xor D xor K;
<tr class="covered"><td>6465<td>    D := C;
<tr class="covered"><td>6466<td>    C := B;
<tr class="covered"><td>6467<td>    B := T;
<tr class="covered"><td>6468<td>  until K = 24;
<tr class="nocodegen"><td>6469<td>
<tr class="nocodegen"><td>6470<td>  repeat
<tr class="covered"><td>6471<td>    Inc(K);
<tr class="covered"><td>6472<td>    T := A;
<tr class="covered"><td>6473<td>    A := D;
<tr class="covered"><td>6474<td>    D := C;
<tr class="covered"><td>6475<td>    C := T xor B xor K;
<tr class="covered"><td>6476<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6477<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6478<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6479<td>    T := T xor Tab[T shr 8];           SkipjackIncCheck(Tab, Min, Max);
<tr class="covered"><td>6480<td>    B := T;
<tr class="covered"><td>6481<td>  until K = 32;
<tr class="nocodegen"><td>6482<td>
<tr class="covered"><td>6483<td>  PWordArray(Dest)[0] := Swap(A);
<tr class="covered"><td>6484<td>  PWordArray(Dest)[1] := Swap(B);
<tr class="covered"><td>6485<td>  PWordArray(Dest)[2] := Swap(C);
<tr class="covered"><td>6486<td>  PWordArray(Dest)[3] := Swap(D);
<tr class="covered"><td>6487<td>end;
<tr class="nocodegen"><td>6488<td>
<tr class="nocodegen"><td>6489<td>procedure TCipher_Skipjack.SkipjackIncCheck(var ATab: PSkipjackTab; AMin: PSkipjackTab; AMax: PByte);
<tr class="covered"><td>6490<td>begin
<tr class="covered"><td>6491<td>  Inc(ATab);
<tr class="nocodegen"><td>6492<td>
<tr class="covered"><td>6493<td>  if PByte(ATab) &gt; AMax then
<tr class="covered"><td>6494<td>    ATab := AMin;
<tr class="covered"><td>6495<td>end;
<tr class="nocodegen"><td>6496<td>
<tr class="nocodegen"><td>6497<td>procedure TCipher_Skipjack.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6498<td>var
<tr class="nocodegen"><td>6499<td>  Tab, Max: PSkipjackTab;
<tr class="nocodegen"><td>6500<td>  Min: PByte; // for Pointer Math
<tr class="nocodegen"><td>6501<td>  K, T, A, B, C, D: UInt32;
<tr class="nocodegen"><td>6502<td>
<tr class="covered"><td>6503<td>begin
<tr class="covered"><td>6504<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6505<td>
<tr class="covered"><td>6506<td>  Min := FAdditionalBuffer;
<tr class="covered"><td>6507<td>  Max := Pointer(Min + 9 * 256);
<tr class="covered"><td>6508<td>  Tab := Pointer(Min + 7 * 256);
<tr class="covered"><td>6509<td>  A   := Swap(PWordArray(Source)[0]); // holds an Integer, Compiler makes faster Code
<tr class="covered"><td>6510<td>  B   := Swap(PWordArray(Source)[1]);
<tr class="covered"><td>6511<td>  C   := Swap(PWordArray(Source)[2]);
<tr class="covered"><td>6512<td>  D   := Swap(PWordArray(Source)[3]);
<tr class="covered"><td>6513<td>  K   := 32;
<tr class="nocodegen"><td>6514<td>
<tr class="nocodegen"><td>6515<td>  repeat
<tr class="covered"><td>6516<td>    T := B;
<tr class="covered"><td>6517<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6518<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6519<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6520<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6521<td>    B := T xor C xor K;
<tr class="covered"><td>6522<td>    C := D;
<tr class="covered"><td>6523<td>    D := A;
<tr class="covered"><td>6524<td>    A := T;
<tr class="covered"><td>6525<td>    Dec(K);
<tr class="covered"><td>6526<td>  until K = 24;
<tr class="nocodegen"><td>6527<td>
<tr class="nocodegen"><td>6528<td>  repeat
<tr class="covered"><td>6529<td>    T := B;
<tr class="covered"><td>6530<td>    B := C;
<tr class="covered"><td>6531<td>    C := D;
<tr class="covered"><td>6532<td>    D := T xor A xor K;
<tr class="covered"><td>6533<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6534<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6535<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6536<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6537<td>    A := T;
<tr class="covered"><td>6538<td>    Dec(K);
<tr class="covered"><td>6539<td>  until K = 16;
<tr class="nocodegen"><td>6540<td>
<tr class="nocodegen"><td>6541<td>  repeat
<tr class="covered"><td>6542<td>    T := B;
<tr class="covered"><td>6543<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6544<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6545<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6546<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6547<td>    B := C xor T xor K;
<tr class="covered"><td>6548<td>    C := D;
<tr class="covered"><td>6549<td>    D := A;
<tr class="covered"><td>6550<td>    A := T;
<tr class="covered"><td>6551<td>    Dec(K);
<tr class="covered"><td>6552<td>  until K = 8;
<tr class="nocodegen"><td>6553<td>
<tr class="nocodegen"><td>6554<td>  repeat
<tr class="covered"><td>6555<td>    T := B;
<tr class="covered"><td>6556<td>    B := C;
<tr class="covered"><td>6557<td>    C := D;
<tr class="covered"><td>6558<td>    D := T xor A xor K;
<tr class="covered"><td>6559<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6560<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6561<td>    T := T xor Tab[T shr 8];           SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6562<td>    T := T xor Tab[T and $FF] shl 8;   SkipjackDecCheck(Tab, Min, Max);
<tr class="covered"><td>6563<td>    A := T;
<tr class="covered"><td>6564<td>    Dec(K);
<tr class="covered"><td>6565<td>  until K = 0;
<tr class="nocodegen"><td>6566<td>
<tr class="covered"><td>6567<td>  PWordArray(Dest)[0] := Swap(A);
<tr class="covered"><td>6568<td>  PWordArray(Dest)[1] := Swap(B);
<tr class="covered"><td>6569<td>  PWordArray(Dest)[2] := Swap(C);
<tr class="covered"><td>6570<td>  PWordArray(Dest)[3] := Swap(D);
<tr class="covered"><td>6571<td>end;
<tr class="nocodegen"><td>6572<td>
<tr class="nocodegen"><td>6573<td>procedure TCipher_Skipjack.SkipjackDecCheck(var ATab: PSkipjackTab; AMin: PByte; AMax: PSkipjackTab);
<tr class="covered"><td>6574<td>begin
<tr class="covered"><td>6575<td>  Dec(ATab);
<tr class="nocodegen"><td>6576<td>//    {$IFDEF DELPHIORBCB}
<tr class="nocodegen"><td>6577<td>//    if ATab &lt; AMin then
<tr class="nocodegen"><td>6578<td>//    {$ELSE !DELPHIORBCB}
<tr class="nocodegen"><td>6579<td>{ TODO : Prüfen ob so korrekt, da ATab auf PByte umgestellt wurde}
<tr class="covered"><td>6580<td>  if PByte(ATab) &lt; AMin then
<tr class="nocodegen"><td>6581<td>//    {$ENDIF !DELPHIORBCB}
<tr class="covered"><td>6582<td>    ATab := AMax;
<tr class="covered"><td>6583<td>end;
<tr class="nocodegen"><td>6584<td>
<tr class="nocodegen"><td>6585<td>{ TCipher_TEA }
<tr class="nocodegen"><td>6586<td>
<tr class="nocodegen"><td>6587<td>const
<tr class="nocodegen"><td>6588<td>  TEA_Delta = $9E3779B9; // magic constant, decimal 2654435769
<tr class="nocodegen"><td>6589<td>
<tr class="nocodegen"><td>6590<td>class function TCipher_TEA.Context: TCipherContext;
<tr class="covered"><td>6591<td>begin
<tr class="covered"><td>6592<td>  Result.KeySize                     := 16;   // 128 bits
<tr class="covered"><td>6593<td>  Result.BlockSize                   := 8;    // 64 bits
<tr class="covered"><td>6594<td>  Result.BufferSize                  := 8;    // 64 bits
<tr class="covered"><td>6595<td>  Result.AdditionalBufferSize        := 32;   // 256 bits
<tr class="covered"><td>6596<td>  Result.NeedsAdditionalBufferBackup := false;
<tr class="covered"><td>6597<td>  Result.MinRounds                   := 16;
<tr class="covered"><td>6598<td>  Result.MaxRounds                   := 256;
<tr class="covered"><td>6599<td>  Result.CipherType                  := [ctSymmetric, ctBlock];
<tr class="covered"><td>6600<td>end;
<tr class="nocodegen"><td>6601<td>
<tr class="nocodegen"><td>6602<td>procedure TCipher_TEA.SetRounds(Value: Integer);
<tr class="covered"><td>6603<td>begin
<tr class="covered"><td>6604<td>  if not (FState in [csNew, csInitialized, csDone]) then
<tr class="notcovered"><td>6605<td>    Done;
<tr class="covered"><td>6606<td>  if Value &lt; Context.MinRounds then
<tr class="covered"><td>6607<td>    Value := Context.MinRounds
<tr class="nocodegen"><td>6608<td>  else
<tr class="covered"><td>6609<td>  if Value &gt; Context.MaxRounds then
<tr class="covered"><td>6610<td>    Value := Context.MaxRounds;
<tr class="covered"><td>6611<td>  FRounds := Value;
<tr class="covered"><td>6612<td>end;
<tr class="nocodegen"><td>6613<td>
<tr class="nocodegen"><td>6614<td>procedure TCipher_TEA.DoInit(const Key; Size: Integer);
<tr class="covered"><td>6615<td>begin
<tr class="covered"><td>6616<td>  Move(Key, FAdditionalBuffer^, Size);
<tr class="covered"><td>6617<td>  SetRounds(FRounds);
<tr class="nocodegen"><td>6618<td>
<tr class="nocodegen"><td>6619<td>  inherited;
<tr class="covered"><td>6620<td>end;
<tr class="nocodegen"><td>6621<td>
<tr class="nocodegen"><td>6622<td>procedure TCipher_TEA.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6623<td>var
<tr class="nocodegen"><td>6624<td>  I: Integer;
<tr class="nocodegen"><td>6625<td>  Sum,
<tr class="nocodegen"><td>6626<td>  X, Y, A, B, C, D: UInt32;
<tr class="covered"><td>6627<td>begin
<tr class="covered"><td>6628<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6629<td>
<tr class="covered"><td>6630<td>  Sum := 0;
<tr class="nocodegen"><td>6631<td>
<tr class="covered"><td>6632<td>  A := PUInt32Array(FAdditionalBuffer)[0];
<tr class="covered"><td>6633<td>  B := PUInt32Array(FAdditionalBuffer)[1];
<tr class="covered"><td>6634<td>  C := PUInt32Array(FAdditionalBuffer)[2];
<tr class="covered"><td>6635<td>  D := PUInt32Array(FAdditionalBuffer)[3];
<tr class="covered"><td>6636<td>  X := PUInt32Array(Source)[0];
<tr class="covered"><td>6637<td>  Y := PUInt32Array(Source)[1];
<tr class="nocodegen"><td>6638<td>
<tr class="covered"><td>6639<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>6640<td>  begin
<tr class="covered"><td>6641<td>    Inc(Sum, TEA_Delta);
<tr class="covered"><td>6642<td>    Inc(X, (((Y shl 4 + A) xor Y) + Sum) xor (Y shr 5 + B));
<tr class="covered"><td>6643<td>    Inc(Y, (((X shl 4 + C) xor X) + Sum) xor (X shr 5 + D));
<tr class="covered"><td>6644<td>  end;
<tr class="nocodegen"><td>6645<td>
<tr class="covered"><td>6646<td>  PUInt32Array(Dest)[0] := X;
<tr class="covered"><td>6647<td>  PUInt32Array(Dest)[1] := Y;
<tr class="covered"><td>6648<td>end;
<tr class="nocodegen"><td>6649<td>
<tr class="nocodegen"><td>6650<td>procedure TCipher_TEA.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6651<td>var
<tr class="nocodegen"><td>6652<td>  I: Integer;
<tr class="nocodegen"><td>6653<td>  Sum,
<tr class="nocodegen"><td>6654<td>  X, Y, A, B, C, D: UInt32;
<tr class="covered"><td>6655<td>begin
<tr class="covered"><td>6656<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6657<td>
<tr class="covered"><td>6658<td>  Sum := TEA_Delta * UInt32(FRounds);
<tr class="nocodegen"><td>6659<td>
<tr class="covered"><td>6660<td>  A := PUInt32Array(FAdditionalBuffer)[0];
<tr class="covered"><td>6661<td>  B := PUInt32Array(FAdditionalBuffer)[1];
<tr class="covered"><td>6662<td>  C := PUInt32Array(FAdditionalBuffer)[2];
<tr class="covered"><td>6663<td>  D := PUInt32Array(FAdditionalBuffer)[3];
<tr class="covered"><td>6664<td>  X := PUInt32Array(Source)[0];
<tr class="covered"><td>6665<td>  Y := PUInt32Array(Source)[1];
<tr class="nocodegen"><td>6666<td>
<tr class="covered"><td>6667<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>6668<td>  begin
<tr class="covered"><td>6669<td>    Dec(Y, (X shl 4 + C) xor X + Sum xor (X shr 5 + D));
<tr class="covered"><td>6670<td>    Dec(X, (Y shl 4 + A) xor Y + Sum xor (Y shr 5 + B));
<tr class="covered"><td>6671<td>    Dec(Sum, TEA_Delta);
<tr class="covered"><td>6672<td>  end;
<tr class="nocodegen"><td>6673<td>
<tr class="covered"><td>6674<td>  PUInt32Array(Dest)[0] := X;
<tr class="covered"><td>6675<td>  PUInt32Array(Dest)[1] := Y;
<tr class="covered"><td>6676<td>end;
<tr class="nocodegen"><td>6677<td>
<tr class="nocodegen"><td>6678<td>{ TCipher_XTEA }
<tr class="nocodegen"><td>6679<td>
<tr class="nocodegen"><td>6680<td>procedure TCipher_XTEA.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6681<td>var
<tr class="nocodegen"><td>6682<td>  Sum,
<tr class="nocodegen"><td>6683<td>  I, X, Y: UInt32;
<tr class="nocodegen"><td>6684<td>  K: PUInt32Array;
<tr class="covered"><td>6685<td>begin
<tr class="covered"><td>6686<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6687<td>
<tr class="covered"><td>6688<td>  Sum := 0;
<tr class="nocodegen"><td>6689<td>
<tr class="covered"><td>6690<td>  X := PUInt32Array(Source)[0];
<tr class="covered"><td>6691<td>  Y := PUInt32Array(Source)[1];
<tr class="covered"><td>6692<td>  K := FAdditionalBuffer;
<tr class="nocodegen"><td>6693<td>
<tr class="covered"><td>6694<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>6695<td>  begin
<tr class="covered"><td>6696<td>    Inc(X, (((Y shl 4) xor (Y shr 5)) + Y) xor (Sum + K[Sum and 3]));
<tr class="covered"><td>6697<td>    Inc(Sum, TEA_Delta);
<tr class="covered"><td>6698<td>    Inc(Y, (((X shl 4) xor (X shr 5)) + X) xor (Sum + K[Sum shr 11 and 3]));
<tr class="covered"><td>6699<td>  end;
<tr class="nocodegen"><td>6700<td>
<tr class="covered"><td>6701<td>  PUInt32Array(Dest)[0] := X;
<tr class="covered"><td>6702<td>  PUInt32Array(Dest)[1] := Y;
<tr class="covered"><td>6703<td>end;
<tr class="nocodegen"><td>6704<td>
<tr class="nocodegen"><td>6705<td>procedure TCipher_XTEA.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6706<td>var
<tr class="nocodegen"><td>6707<td>  I: Integer;
<tr class="nocodegen"><td>6708<td>  Sum,
<tr class="nocodegen"><td>6709<td>  X, Y: UInt32;
<tr class="nocodegen"><td>6710<td>  K: PUInt32Array;
<tr class="covered"><td>6711<td>begin
<tr class="covered"><td>6712<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6713<td>
<tr class="covered"><td>6714<td>  Sum := TEA_Delta * UInt32(FRounds);
<tr class="nocodegen"><td>6715<td>
<tr class="covered"><td>6716<td>  X := PUInt32Array(Source)[0];
<tr class="covered"><td>6717<td>  Y := PUInt32Array(Source)[1];
<tr class="covered"><td>6718<td>  K := FAdditionalBuffer;
<tr class="nocodegen"><td>6719<td>
<tr class="covered"><td>6720<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>6721<td>  begin
<tr class="covered"><td>6722<td>    Dec(Y, (((X shl 4) xor (X shr 5)) + X) xor (Sum + K[Sum shr 11 and 3]));
<tr class="covered"><td>6723<td>    Dec(Sum, TEA_Delta);
<tr class="covered"><td>6724<td>    Dec(X, (((Y shl 4) xor (Y shr 5)) + Y) xor (Sum + K[Sum and 3]));
<tr class="covered"><td>6725<td>  end;
<tr class="nocodegen"><td>6726<td>
<tr class="covered"><td>6727<td>  PUInt32Array(Dest)[0] := X;
<tr class="covered"><td>6728<td>  PUInt32Array(Dest)[1] := Y;
<tr class="covered"><td>6729<td>end;
<tr class="nocodegen"><td>6730<td>
<tr class="nocodegen"><td>6731<td>{ TCipher_XTEA_DEC52 }
<tr class="nocodegen"><td>6732<td>
<tr class="nocodegen"><td>6733<td>procedure TCipher_XTEA_DEC52.DoEncode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6734<td>var
<tr class="nocodegen"><td>6735<td>  Sum,
<tr class="nocodegen"><td>6736<td>  I, X, Y: UInt32;
<tr class="nocodegen"><td>6737<td>  K: PUInt32Array;
<tr class="covered"><td>6738<td>begin
<tr class="covered"><td>6739<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6740<td>
<tr class="covered"><td>6741<td>  Sum := 0;
<tr class="nocodegen"><td>6742<td>
<tr class="covered"><td>6743<td>  X := PUInt32Array(Source)[0];
<tr class="covered"><td>6744<td>  Y := PUInt32Array(Source)[1];
<tr class="covered"><td>6745<td>  K := FAdditionalBuffer;
<tr class="nocodegen"><td>6746<td>
<tr class="covered"><td>6747<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>6748<td>  begin
<tr class="covered"><td>6749<td>    Inc(X, (Y shl 4 xor Y shr 5) + (Y xor Sum) + K[Sum and 3]);
<tr class="covered"><td>6750<td>    Inc(Sum, TEA_Delta);
<tr class="covered"><td>6751<td>    Inc(Y, (X shl 4 xor X shr 5) + (X xor Sum) + K[Sum shr 11 and 3]);
<tr class="covered"><td>6752<td>  end;
<tr class="nocodegen"><td>6753<td>
<tr class="covered"><td>6754<td>  PUInt32Array(Dest)[0] := X;
<tr class="covered"><td>6755<td>  PUInt32Array(Dest)[1] := Y;
<tr class="covered"><td>6756<td>end;
<tr class="nocodegen"><td>6757<td>
<tr class="nocodegen"><td>6758<td>procedure TCipher_XTEA_DEC52.DoDecode(Source, Dest: Pointer; Size: Integer);
<tr class="nocodegen"><td>6759<td>var
<tr class="nocodegen"><td>6760<td>  I: Integer;
<tr class="nocodegen"><td>6761<td>  Sum,
<tr class="nocodegen"><td>6762<td>  X, Y: UInt32;
<tr class="nocodegen"><td>6763<td>  K: PUInt32Array;
<tr class="covered"><td>6764<td>begin
<tr class="covered"><td>6765<td>  Assert(Size = Context.BlockSize);
<tr class="nocodegen"><td>6766<td>
<tr class="covered"><td>6767<td>  Sum := TEA_Delta * UInt32(FRounds);
<tr class="nocodegen"><td>6768<td>
<tr class="covered"><td>6769<td>  X := PUInt32Array(Source)[0];
<tr class="covered"><td>6770<td>  Y := PUInt32Array(Source)[1];
<tr class="covered"><td>6771<td>  K := FAdditionalBuffer;
<tr class="nocodegen"><td>6772<td>
<tr class="covered"><td>6773<td>  for I := 0 to FRounds - 1 do
<tr class="nocodegen"><td>6774<td>  begin
<tr class="covered"><td>6775<td>    Dec(Y, (X shl 4 xor X shr 5) + (X xor Sum) + K[Sum shr 11 and 3]);
<tr class="covered"><td>6776<td>    Dec(Sum, TEA_Delta);
<tr class="covered"><td>6777<td>    Dec(X, (Y shl 4 xor Y shr 5) + (Y xor Sum) + K[Sum and 3]);
<tr class="covered"><td>6778<td>  end;
<tr class="nocodegen"><td>6779<td>
<tr class="covered"><td>6780<td>  PUInt32Array(Dest)[0] := X;
<tr class="covered"><td>6781<td>  PUInt32Array(Dest)[1] := Y;
<tr class="covered"><td>6782<td>end;
<tr class="nocodegen"><td>6783<td>
<tr class="nocodegen"><td>6784<td>{$IFDEF RESTORE_RANGECHECKS}{$R+}{$ENDIF}
<tr class="nocodegen"><td>6785<td>{$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}
<tr class="nocodegen"><td>6786<td>
<tr class="covered"><td>6787<td>initialization
<tr class="covered"><td>6788<td>  SetDefaultCipherClass(TCipher_Null);
<tr class="nocodegen"><td>6789<td>
<tr class="nocodegen"><td>6790<td>  {$IFNDEF ManualRegisterCipherClasses}
<tr class="covered"><td>6791<td>  TCipher_Null.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6792<td>  TCipher_Blowfish.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6793<td>  TCipher_Twofish.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6794<td>  TCipher_IDEA.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6795<td>  TCipher_Cast256.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6796<td>  TCipher_Mars.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6797<td>  TCipher_RC4.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6798<td>  TCipher_RC6.RegisterClass(TDECCipher.ClassList);
<tr class="nocodegen"><td>6799<td>// Explicitely not registered, as Rijndael is 1:1 the same as AES and AES is the
<tr class="nocodegen"><td>6800<td>// more common name
<tr class="nocodegen"><td>6801<td>//  TCipher_Rijndael.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6802<td>  TCipher_AES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6803<td>  TCipher_AES128.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6804<td>  TCipher_AES192.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6805<td>  TCipher_AES256.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6806<td>  TCipher_Square.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6807<td>  TCipher_SCOP.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6808<td>  TCipher_Sapphire.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6809<td>  TCipher_1DES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6810<td>  TCipher_2DES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6811<td>  TCipher_3DES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6812<td>  TCipher_2DDES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6813<td>  TCipher_3DDES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6814<td>  TCipher_3TDES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6815<td>  TCipher_3Way.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6816<td>  TCipher_Cast128.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6817<td>  TCipher_Gost.RegisterClass(TDECCipher.ClassList);
<tr class="nocodegen"><td>6818<td>// Explicitely not registered, as this is an alias for Gost only
<tr class="nocodegen"><td>6819<td>//  TCipher_Magma.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6820<td>  TCipher_Misty.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6821<td>  TCipher_NewDES.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6822<td>  TCipher_Q128.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6823<td>  TCipher_RC2.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6824<td>  TCipher_RC5.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6825<td>  TCipher_SAFER.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6826<td>  TCipher_Shark.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6827<td>  TCipher_Skipjack.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6828<td>  TCipher_TEA.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6829<td>  TCipher_XTEA.RegisterClass(TDECCipher.ClassList);
<tr class="covered"><td>6830<td>  TCipher_TEAN.RegisterClass(TDECCipher.ClassList);
<tr class="nocodegen"><td>6831<td>
<tr class="nocodegen"><td>6832<td>    {$IFDEF OLD_REGISTER_FAULTY_CIPHERS}
<tr class="nocodegen"><td>6833<td>    // Those classes are only there for those who might have relied on the
<tr class="nocodegen"><td>6834<td>    // faulty implementation
<tr class="nocodegen"><td>6835<td>    TCipher_SCOP_DEC52.RegisterClass(TDECCipher.ClassList);
<tr class="nocodegen"><td>6836<td>    TCipher_Shark_DEC52.RegisterClass(TDECCipher.ClassList);
<tr class="nocodegen"><td>6837<td>    TCipher_XTEA_DEC52.RegisterClass(TDECCipher.ClassList);
<tr class="nocodegen"><td>6838<td>    {$ENDIF}
<tr class="nocodegen"><td>6839<td>  {$ENDIF}
<tr class="nocodegen"><td>6840<td>
<tr class="covered"><td>6841<td>finalization
<tr class="nocodegen"><td>6842<td>
<tr class="covered"><td>6843<td>end.
</table>
<script>(function () {
var starts = [],prev = document.getElementById("nav-prev"),next = document.getElementById("nav-next");
(function () {
var p;
document.querySelectorAll("table.s tr").forEach(r => {
if (r.classList.contains("notcovered")) {
if (!p) starts.push(r);
p = r;
} else { p = null }
})
})();
function findPrev() {
var y = prev.getBoundingClientRect().top - 4;
for (var i=starts.length-1; i>=0; i--) {
if (starts[i].getBoundingClientRect().top < y) return starts[i]
}
}
function findNext() {
var y = next.getBoundingClientRect().top + 4;
for (var i=0; i<starts.length; i++) {
if (starts[i].getBoundingClientRect().top > y) return starts[i];
}
}
function onScroll() {
prev.setAttribute("class", findPrev() ? "active" : "");
next.setAttribute("class", findNext() ? "active" : "");
onScroll.pending = 0;
}
document.addEventListener("scroll", function() {
if (!onScroll.pending) { onScroll.pending = requestAnimationFrame(onScroll) }
});
onScroll();
function scrollTo(row) {
if (row) window.scrollTo({ behavior: "smooth", top: window.scrollY+row.getBoundingClientRect().top-prev.getBoundingClientRect().top });
}
next.addEventListener("click", () => scrollTo(findNext()) );
prev.addEventListener("click", () => scrollTo(findPrev()) );
})();</script>
<script>
const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
const comparer = (idx, asc) => (a, b) => ((v1, v2) =>!isNaN(parseFloat(v1 || "-")) && !isNaN(parseFloat(v2 || "-")) ? parseFloat(v1)-parseFloat(v2) : v1.toString().localeCompare(v2))(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));
document.querySelectorAll("thead th[idx]").forEach(th => th.addEventListener("click", (() => {
	const table = th.closest("table").querySelector("tbody");
	Array.from(table.querySelectorAll("tr"))
		.sort(comparer(+th.getAttribute("idx"), this.asc = !this.asc))
		.forEach(tr => table.appendChild(tr) );
	})));
</script>
</body>
</html>
