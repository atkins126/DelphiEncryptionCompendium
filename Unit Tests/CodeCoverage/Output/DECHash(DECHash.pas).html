<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
body {max-width: max-content;margin: auto;}
table {border-spacing:0;}
table, td, th {border: 0;}
td, th {background: white; margin: 0; padding: .5em 1em}
table small { color: #777; }
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: consolas,courier,monospace; font-size: 10pt;}
thead, th {background: #808C98; color: white; }
table th small { color: #ddd; }
th[idx] {cursor: pointer; user-select: none;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: calc(min(80em, 95vw));}
table.s tr td {padding: .1em .5em; white-space: pre-wrap;}
table.s tr td:first-child {text-align: right; font-weight: bold; vertical-align: top}
table.s tr.notcovered td {background: #ddf;}
table.s tr.nocodegen td {background: #ffe;}
table.s tr.covered td {background: #cfc;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum td { background-position: 50%; background-repeat: no-repeat; background-size: 90% 70%; }
table.sum tr:nth-child(odd) td { background-color: #f4f4f4}
table.sum tr:hover td, tr:hover td a { filter: invert(10%) }
table.sum tr th {text-align:left; border: .5px solid #5d4e4c; height: 1em}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
table.sum thead th { position: sticky; top:0; }
table.sum thead tr + tr th { position: sticky; top: calc(2.5em - 2px); }
table.sum tfoot th { position: sticky; bottom:0; }
table.sum tfoot th+th {text-align: right;}
table.sum a, table.sum a:visited {color: #5d4e4c; text-decoration: none;}
#nav {position: fixed;overflow: visible;left: min(calc(50% + 41em), calc(100% - 6em));padding: .1em .5em .1em .2em;background: white;box-shadow: 1px 1px 3px #888;}
#nav div {opacity: .3; user-select: none; pointer-events: none;}
#nav div.active {opacity: 1;	cursor: pointer;	pointer-events: initial;}
#nav div.active:hover {color: #00A;}
</style>
</head>
<body>
<p>Coverage report for <bold>DECHash (..\..\Source\DECHash.pas)</bold>.</p>
<p>Generated at 30.11.2022 22:06:19 by <a href="https://github.com/DelphiCodeCoverage/DelphiCodeCoverage" target="_blank" title="DelphiCodeCoverage on GitHub">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p>Statistics for ..\..\Source\DECHash.pas</p>
<table class="o"><tr><td>Number of lines covered<td>2619<td rowspan=3 style="background: conic-gradient(#9fe098 99%, #eee 99%);width: 4.5em; border-radius: 50%"><tr><td>Number of lines with code gen<td>2639<tr><td>Line coverage<td>99<small>.2</small>&nbsp;%</table>
<br><br>
<div id="nav"><div id="nav-prev">&#x25b2; Prev</div><div id="nav-next">&#x25bc; Next</div></div>
<table class="s">
<tr class="nocodegen"><td>1<td>{*****************************************************************************
<tr class="nocodegen"><td>2<td>  The DEC team (see file NOTICE.txt) licenses this file
<tr class="nocodegen"><td>3<td>  to you under the Apache License, Version 2.0 (the
<tr class="nocodegen"><td>4<td>  &quot;License&quot;); you may not use this file except in compliance
<tr class="nocodegen"><td>5<td>  with the License. A copy of this licence is found in the root directory
<tr class="nocodegen"><td>6<td>  of this project in the file LICENCE.txt or alternatively at
<tr class="nocodegen"><td>7<td>
<tr class="nocodegen"><td>8<td>    http://www.apache.org/licenses/LICENSE-2.0
<tr class="nocodegen"><td>9<td>
<tr class="nocodegen"><td>10<td>  Unless required by applicable law or agreed to in writing,
<tr class="nocodegen"><td>11<td>  software distributed under the License is distributed on an
<tr class="nocodegen"><td>12<td>  &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<tr class="nocodegen"><td>13<td>  KIND, either express or implied.  See the License for the
<tr class="nocodegen"><td>14<td>  specific language governing permissions and limitations
<tr class="nocodegen"><td>15<td>  under the License.
<tr class="nocodegen"><td>16<td>*****************************************************************************}
<tr class="nocodegen"><td>17<td>
<tr class="nocodegen"><td>18<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>19<td>///   Hash functions. Be aware that the x86 ASM implementations, if activated
<tr class="nocodegen"><td>20<td>///   by the define, are provided by DECHash.asm86.inc!
<tr class="nocodegen"><td>21<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>22<td>unit DECHash;
<tr class="nocodegen"><td>23<td>
<tr class="nocodegen"><td>24<td>interface
<tr class="nocodegen"><td>25<td>
<tr class="nocodegen"><td>26<td>{$INCLUDE DECOptions.inc}
<tr class="nocodegen"><td>27<td>
<tr class="nocodegen"><td>28<td>uses
<tr class="nocodegen"><td>29<td>  {$IFDEF FPC}
<tr class="nocodegen"><td>30<td>  SysUtils, Classes,
<tr class="nocodegen"><td>31<td>  {$ELSE}
<tr class="nocodegen"><td>32<td>  System.SysUtils, System.Classes,
<tr class="nocodegen"><td>33<td>  {$ENDIF}
<tr class="nocodegen"><td>34<td>  DECBaseClass, DECFormatBase, DECUtil, DECHashBase, DECHashAuthentication,
<tr class="nocodegen"><td>35<td>  DECHashBitBase, DECHashInterface, DECTypes;
<tr class="nocodegen"><td>36<td>
<tr class="nocodegen"><td>37<td>type
<tr class="nocodegen"><td>38<td>  // Hash Classes
<tr class="nocodegen"><td>39<td>  THash_MD2         = class;
<tr class="nocodegen"><td>40<td>  THash_MD4         = class;
<tr class="nocodegen"><td>41<td>  THash_MD5         = class;
<tr class="nocodegen"><td>42<td>  THash_RipeMD128   = class;
<tr class="nocodegen"><td>43<td>  THash_RipeMD160   = class;
<tr class="nocodegen"><td>44<td>  THash_RipeMD256   = class;
<tr class="nocodegen"><td>45<td>  THash_RipeMD320   = class;
<tr class="nocodegen"><td>46<td>  THash_SHA0        = class;  // SHA-0
<tr class="nocodegen"><td>47<td>  THash_SHA1        = class;  // SHA-1
<tr class="nocodegen"><td>48<td>  THash_SHA224      = class;  // SHA-2, SHA-224
<tr class="nocodegen"><td>49<td>  THash_SHA256      = class;  // SHA-2, SHA-256
<tr class="nocodegen"><td>50<td>  THash_SHA384      = class;  // SHA-2, SHA-384
<tr class="nocodegen"><td>51<td>  THash_SHA512      = class;  // SHA-2, SHA-512
<tr class="nocodegen"><td>52<td>  THash_Keccak_224  = class;  // version of THash_SHA3_224 before that became the final standard
<tr class="nocodegen"><td>53<td>  THash_Keccak_256  = class;  // version of THash_SHA3_256 before that became the final standard
<tr class="nocodegen"><td>54<td>  THash_Keccak_384  = class;  // version of THash_SHA3_384 before that became the final standard
<tr class="nocodegen"><td>55<td>  THash_Keccak_512  = class;  // version of THash_SHA3_512 before that became the final standard
<tr class="nocodegen"><td>56<td>  THash_SHA3_224    = class;
<tr class="nocodegen"><td>57<td>  THash_SHA3_256    = class;
<tr class="nocodegen"><td>58<td>  THash_SHA3_384    = class;
<tr class="nocodegen"><td>59<td>  THash_SHA3_512    = class;
<tr class="nocodegen"><td>60<td>  THash_Shake128    = class;
<tr class="nocodegen"><td>61<td>  THash_Shake256    = class;
<tr class="nocodegen"><td>62<td>  THash_Haval128    = class;
<tr class="nocodegen"><td>63<td>  THash_Haval160    = class;  // Haval 160, 3 Rounds
<tr class="nocodegen"><td>64<td>  THash_Haval192    = class;  // Haval 192, 4 Rounds
<tr class="nocodegen"><td>65<td>  THash_Haval224    = class;  // Haval 224, 4 Rounds
<tr class="nocodegen"><td>66<td>  THash_Haval256    = class;  // Haval 256, 5 Rounds
<tr class="nocodegen"><td>67<td>  THash_Tiger       = class;
<tr class="nocodegen"><td>68<td>  THash_Panama      = class;
<tr class="nocodegen"><td>69<td>  {$IFDEF OLD_WHIRLPOOL_NAMES}
<tr class="nocodegen"><td>70<td>  THash_Whirlpool   = class;
<tr class="nocodegen"><td>71<td>  THash_Whirlpool1New = class;
<tr class="nocodegen"><td>72<td>  {$ENDIF}
<tr class="nocodegen"><td>73<td>
<tr class="nocodegen"><td>74<td>  THash_Whirlpool0  = class;
<tr class="nocodegen"><td>75<td>  THash_Whirlpool1  = class; // differs, depending on OLD_WHIRLPOOL_NAMES define
<tr class="nocodegen"><td>76<td>  THash_WhirlpoolT  = class;
<tr class="nocodegen"><td>77<td>
<tr class="nocodegen"><td>78<td>  THash_Square      = class;
<tr class="nocodegen"><td>79<td>  THash_Snefru128   = class;  // derived from the Xerox Secure Hash Function
<tr class="nocodegen"><td>80<td>  THash_Snefru256   = class;  // &quot; - &quot;
<tr class="nocodegen"><td>81<td>  THash_Sapphire    = class;
<tr class="nocodegen"><td>82<td>
<tr class="nocodegen"><td>83<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>84<td>  ///   Implementation of the MD2 hash algorithm. Considered to be broken,
<tr class="nocodegen"><td>85<td>  ///   at least on paper.
<tr class="nocodegen"><td>86<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>87<td>  THash_MD2 = class(TDECHashExtended)
<tr class="nocodegen"><td>88<td>  private
<tr class="nocodegen"><td>89<td>    FDigest: array[0..63] of Byte;
<tr class="nocodegen"><td>90<td>  protected
<tr class="nocodegen"><td>91<td>    procedure DoInit; override;
<tr class="nocodegen"><td>92<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>93<td>    procedure DoDone; override;
<tr class="nocodegen"><td>94<td>  public
<tr class="nocodegen"><td>95<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>96<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>97<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>98<td>  end;
<tr class="nocodegen"><td>99<td>
<tr class="nocodegen"><td>100<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>101<td>  ///   Base class for the MD4 hash alrogithm and for other hash-algorithms which
<tr class="nocodegen"><td>102<td>  ///   are close relatives to the MD4 algorithm like the RipeMD ones.
<tr class="nocodegen"><td>103<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>104<td>  THashBaseMD4 = class(TDECHashExtended)
<tr class="nocodegen"><td>105<td>  private
<tr class="nocodegen"><td>106<td>    FDigest: array[0..9] of UInt32;
<tr class="nocodegen"><td>107<td>  protected
<tr class="nocodegen"><td>108<td>    procedure DoInit; override;
<tr class="nocodegen"><td>109<td>    procedure DoDone; override;
<tr class="nocodegen"><td>110<td>  public
<tr class="nocodegen"><td>111<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>112<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>113<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>114<td>  end;
<tr class="nocodegen"><td>115<td>
<tr class="nocodegen"><td>116<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>117<td>  ///   The MD4 algorithm is considered to be broken, at least on paper.
<tr class="nocodegen"><td>118<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>119<td>  THash_MD4 = class(THashBaseMD4)
<tr class="nocodegen"><td>120<td>  protected
<tr class="nocodegen"><td>121<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>122<td>  end;
<tr class="nocodegen"><td>123<td>
<tr class="nocodegen"><td>124<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>125<td>  ///   The MD5 algorithm is considered to be broken. Using it in HMAC algorithms
<tr class="nocodegen"><td>126<td>  ///   is still ok.
<tr class="nocodegen"><td>127<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>128<td>  THash_MD5 = class(THashBaseMD4)
<tr class="nocodegen"><td>129<td>  protected
<tr class="nocodegen"><td>130<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>131<td>  end;
<tr class="nocodegen"><td>132<td>
<tr class="nocodegen"><td>133<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>134<td>  ///   Do not confuse with the original RipeMD algorithm which ís being
<tr class="nocodegen"><td>135<td>  ///   considered to be unsafe anyway. Considered to be broken due to the only
<tr class="nocodegen"><td>136<td>  ///   128 Bit long message digest result.
<tr class="nocodegen"><td>137<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>138<td>  THash_RipeMD128 = class(THashBaseMD4)
<tr class="nocodegen"><td>139<td>  protected
<tr class="nocodegen"><td>140<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>141<td>  end;
<tr class="nocodegen"><td>142<td>
<tr class="nocodegen"><td>143<td>  THash_RipeMD160 = class(THashBaseMD4)
<tr class="nocodegen"><td>144<td>  protected
<tr class="nocodegen"><td>145<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>146<td>  public
<tr class="nocodegen"><td>147<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>148<td>  end;
<tr class="nocodegen"><td>149<td>
<tr class="nocodegen"><td>150<td>  THash_RipeMD256 = class(THashBaseMD4)
<tr class="nocodegen"><td>151<td>  protected
<tr class="nocodegen"><td>152<td>    procedure DoInit; override;
<tr class="nocodegen"><td>153<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>154<td>  public
<tr class="nocodegen"><td>155<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>156<td>  end;
<tr class="nocodegen"><td>157<td>
<tr class="nocodegen"><td>158<td>  THash_RipeMD320 = class(THashBaseMD4)
<tr class="nocodegen"><td>159<td>  protected
<tr class="nocodegen"><td>160<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>161<td>  public
<tr class="nocodegen"><td>162<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>163<td>  end;
<tr class="nocodegen"><td>164<td>
<tr class="nocodegen"><td>165<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>166<td>  ///   Implementation of the SHA0 hash algorithm. This is the original version
<tr class="nocodegen"><td>167<td>  ///   of the SHA algorithm released in 1993. In 1995 some security issues have
<tr class="nocodegen"><td>168<td>  ///   been identified in this algorithm so he got replaced by the slightly
<tr class="nocodegen"><td>169<td>  ///   modified SHA1 algorithm. The recommendation is to not use this SHA0
<tr class="nocodegen"><td>170<td>  ///   algorithm at all. It is only being provided for scenarios where
<tr class="nocodegen"><td>171<td>  ///   compatibility with this algorithm is required.
<tr class="nocodegen"><td>172<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>173<td>  THash_SHA0 = class(THashBaseMD4)
<tr class="nocodegen"><td>174<td>  protected
<tr class="nocodegen"><td>175<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>176<td>    procedure DoDone; override;
<tr class="nocodegen"><td>177<td>  public
<tr class="nocodegen"><td>178<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>179<td>  end;
<tr class="nocodegen"><td>180<td>
<tr class="nocodegen"><td>181<td>  {$IFDEF OLD_SHA_NAME}
<tr class="nocodegen"><td>182<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>183<td>  ///   Implementation of the SHA0 hash algorithm. This is the original version
<tr class="nocodegen"><td>184<td>  ///   of the SHA algorithm released in 1993. In 1995 some security issues have
<tr class="nocodegen"><td>185<td>  ///   been identified in this algorithm so he got replaced by the slightly
<tr class="nocodegen"><td>186<td>  ///   modified SHA1 algorithm. The recommendation is to not use this SHA0
<tr class="nocodegen"><td>187<td>  ///   algorithm at all. It is only being provided for scenarios where
<tr class="nocodegen"><td>188<td>  ///   compatibility with this algorithm is required.
<tr class="nocodegen"><td>189<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>190<td>  THash_SHA = class(THash_SHA0)
<tr class="nocodegen"><td>191<td>  {$IFDEF X86ASM}
<tr class="nocodegen"><td>192<td>  protected
<tr class="nocodegen"><td>193<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>194<td>  end
<tr class="nocodegen"><td>195<td>  {$ENDIF};
<tr class="nocodegen"><td>196<td>
<tr class="nocodegen"><td>197<td>  {$ENDIF}
<tr class="nocodegen"><td>198<td>
<tr class="nocodegen"><td>199<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>200<td>  ///   Implementation of the SHA1 hash algorithm. At least since February 2017
<tr class="nocodegen"><td>201<td>  ///   collisions have been found for this algorithm so it's now completely
<tr class="nocodegen"><td>202<td>  ///   clear that it should not be used if possible! Use SHA256 or SHA512
<tr class="nocodegen"><td>203<td>  ///   instead!
<tr class="nocodegen"><td>204<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>205<td>  THash_SHA1 = class(THash_SHA0);
<tr class="nocodegen"><td>206<td>
<tr class="nocodegen"><td>207<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>208<td>  ///   This algorithm is part of the SHA2 series of hash algorithms.
<tr class="nocodegen"><td>209<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>210<td>  THash_SHA256 = class(THash_SHA0)
<tr class="nocodegen"><td>211<td>  protected
<tr class="nocodegen"><td>212<td>    procedure DoInit; override;
<tr class="nocodegen"><td>213<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>214<td>  public
<tr class="nocodegen"><td>215<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>216<td>  end;
<tr class="nocodegen"><td>217<td>
<tr class="nocodegen"><td>218<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>219<td>  ///   This algorithm is part of the SHA2 series of hash algorithms.
<tr class="nocodegen"><td>220<td>  ///   German BSI recommends not to use this algorithm, they recommend SHA256
<tr class="nocodegen"><td>221<td>  ///   or higher instead.
<tr class="nocodegen"><td>222<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>223<td>  THash_SHA224 = class(THash_SHA256)
<tr class="nocodegen"><td>224<td>  protected
<tr class="nocodegen"><td>225<td>    procedure DoInit; override;
<tr class="nocodegen"><td>226<td>  public
<tr class="nocodegen"><td>227<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>228<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>229<td>  end;
<tr class="nocodegen"><td>230<td>
<tr class="nocodegen"><td>231<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>232<td>  ///   This algorithm is part of the SHA2 series of hash algorithms.
<tr class="nocodegen"><td>233<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>234<td>  THash_SHA384 = class(TDECHashExtended)
<tr class="nocodegen"><td>235<td>  private
<tr class="nocodegen"><td>236<td>    FDigest: array[0..7] of Int64;
<tr class="nocodegen"><td>237<td>  protected
<tr class="nocodegen"><td>238<td>    procedure DoInit; override;
<tr class="nocodegen"><td>239<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>240<td>    procedure DoDone; override;
<tr class="nocodegen"><td>241<td>  public
<tr class="nocodegen"><td>242<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>243<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>244<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>245<td>  end;
<tr class="nocodegen"><td>246<td>
<tr class="nocodegen"><td>247<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>248<td>  ///   This algorithm is part of the SHA2 series of hash algorithms.
<tr class="nocodegen"><td>249<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>250<td>  THash_SHA512 = class(THash_SHA384)
<tr class="nocodegen"><td>251<td>  protected
<tr class="nocodegen"><td>252<td>    procedure DoInit; override;
<tr class="nocodegen"><td>253<td>  public
<tr class="nocodegen"><td>254<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>255<td>  end;
<tr class="nocodegen"><td>256<td>
<tr class="nocodegen"><td>257<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>258<td>  ///   Base class for tall SHA3 implementations
<tr class="nocodegen"><td>259<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>260<td>  THash_SHA3Base = class(TDECHashBit)
<tr class="nocodegen"><td>261<td>  strict private
<tr class="nocodegen"><td>262<td>    // Declarations for SHA3. Must be declared here to allow private methods
<tr class="nocodegen"><td>263<td>    // to use these types as well.
<tr class="nocodegen"><td>264<td>    const
<tr class="nocodegen"><td>265<td>      KeccakPermutationSize        = 1600;
<tr class="nocodegen"><td>266<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>267<td>      ///   Maximum bitrate? If yes this would be higher than any value listed here:
<tr class="nocodegen"><td>268<td>      ///   https://keccak.team/keccak.html
<tr class="nocodegen"><td>269<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>270<td>      KeccakMaximumRate            = 1536;
<tr class="nocodegen"><td>271<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>272<td>      ///   KeccakPermutationSize converted into bytes instead of bits
<tr class="nocodegen"><td>273<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>274<td>      KeccakPermutationSizeInBytes = KeccakPermutationSize div 8;
<tr class="nocodegen"><td>275<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>276<td>      ///   KeccakMaximumRate converted into bytes instead of bits
<tr class="nocodegen"><td>277<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>278<td>      KeccakMaximumRateInBytes     = KeccakMaximumRate div 8;
<tr class="nocodegen"><td>279<td>
<tr class="nocodegen"><td>280<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>281<td>      ///   Precalculated values for the 24 rounds of the algorithm
<tr class="nocodegen"><td>282<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>283<td>      cRoundConstants : array[0..23] of UInt64 = (
<tr class="nocodegen"><td>284<td>        UInt64($0000000000000001), UInt64($0000000000008082),
<tr class="nocodegen"><td>285<td>        UInt64($800000000000808A), UInt64($8000000080008000),
<tr class="nocodegen"><td>286<td>        UInt64($000000000000808B), UInt64($0000000080000001),
<tr class="nocodegen"><td>287<td>        UInt64($8000000080008081), UInt64($8000000000008009),
<tr class="nocodegen"><td>288<td>        UInt64($000000000000008A), UInt64($0000000000000088),
<tr class="nocodegen"><td>289<td>        UInt64($0000000080008009), UInt64($000000008000000A),
<tr class="nocodegen"><td>290<td>        UInt64($000000008000808B), UInt64($800000000000008B),
<tr class="nocodegen"><td>291<td>        UInt64($8000000000008089), UInt64($8000000000008003),
<tr class="nocodegen"><td>292<td>        UInt64($8000000000008002), UInt64($8000000000000080),
<tr class="nocodegen"><td>293<td>        UInt64($000000000000800A), UInt64($800000008000000A),
<tr class="nocodegen"><td>294<td>        UInt64($8000000080008081), UInt64($8000000000008080),
<tr class="nocodegen"><td>295<td>        UInt64($0000000080000001), UInt64($8000000080008008)
<tr class="nocodegen"><td>296<td>      );
<tr class="nocodegen"><td>297<td>    type
<tr class="nocodegen"><td>298<td>      TState_B = packed array[0..KeccakPermutationSizeInBytes-1] of UInt8;
<tr class="nocodegen"><td>299<td>      TState_L = packed array[0..(KeccakPermutationSizeInBytes) div 4 - 1] of Int32;
<tr class="nocodegen"><td>300<td>      TKDQueue = packed array[0..KeccakMaximumRateInBytes-1] of UInt8;
<tr class="nocodegen"><td>301<td>
<tr class="nocodegen"><td>302<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>303<td>      ///   Calculation status of the algorithm
<tr class="nocodegen"><td>304<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>305<td>      TSpongeState = packed record
<tr class="nocodegen"><td>306<td>                       State                     : TState_B;
<tr class="nocodegen"><td>307<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>308<td>                       ///   Data of the queue to be processed
<tr class="nocodegen"><td>309<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>310<td>                       DataQueue                 : TKDQueue;
<tr class="nocodegen"><td>311<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>312<td>                       ///   Bitrate r of Keccak
<tr class="nocodegen"><td>313<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>314<td>                       Rate                      : UInt16;
<tr class="nocodegen"><td>315<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>316<td>                       ///   Capacity c of Keccak
<tr class="nocodegen"><td>317<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>318<td>                       Capacity                  : UInt16;
<tr class="nocodegen"><td>319<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>320<td>                       ///   How many bits are in the queue
<tr class="nocodegen"><td>321<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>322<td>                       BitsInQueue               : UInt16;
<tr class="nocodegen"><td>323<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>324<td>                       ///   Length of the hash value to generate in bit
<tr class="nocodegen"><td>325<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>326<td>                       FixedOutputLength         : UInt16;
<tr class="nocodegen"><td>327<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>328<td>                       ///   Number of bits which can be squeezed
<tr class="nocodegen"><td>329<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>330<td>                       bitsAvailableForSqueezing : UInt16;
<tr class="nocodegen"><td>331<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>332<td>                       ///   Flag which is set to true when entering the
<tr class="nocodegen"><td>333<td>                       ///   squeezing state. Suppresses further absorb calls.
<tr class="nocodegen"><td>334<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>335<td>                       SqueezeActive             : Boolean;
<tr class="nocodegen"><td>336<td>                       /// &lt;summary&gt;
<tr class="nocodegen"><td>337<td>                       ///   If an operation fails it sets this error code
<tr class="nocodegen"><td>338<td>                       /// &lt;/summary&gt;
<tr class="nocodegen"><td>339<td>    //                   Fill3: packed array[405..HASHCTXSIZE] of byte;
<tr class="nocodegen"><td>340<td>                     end;
<tr class="nocodegen"><td>341<td>
<tr class="nocodegen"><td>342<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>343<td>      ///   Buffer type
<tr class="nocodegen"><td>344<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>345<td>      TBABytes = array[0..65535] of UInt8;
<tr class="nocodegen"><td>346<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>347<td>      ///   Pointer to a buffer
<tr class="nocodegen"><td>348<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>349<td>      PBABytes = ^TBABytes;
<tr class="nocodegen"><td>350<td>
<tr class="nocodegen"><td>351<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>352<td>      ///   Type for the generated hash value
<tr class="nocodegen"><td>353<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>354<td>      TSHA3Digest = array of UInt8;
<tr class="nocodegen"><td>355<td>
<tr class="nocodegen"><td>356<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>357<td>    ///   Function to give input data for the sponge function to absorb
<tr class="nocodegen"><td>358<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>359<td>    /// &lt;param name=&quot;Data&quot;&gt;
<tr class="nocodegen"><td>360<td>    ///   Pointer to the data to work on
<tr class="nocodegen"><td>361<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>362<td>    /// &lt;param name=&quot;DatabitLen&quot;&gt;
<tr class="nocodegen"><td>363<td>    ///   Length of the data passed via the pointer in bit
<tr class="nocodegen"><td>364<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>365<td>    /// &lt;remarks&gt;
<tr class="nocodegen"><td>366<td>    ///   Raises an EDECHashEception when DataBit len not divideable by 8 without
<tr class="nocodegen"><td>367<td>    ///   reminder or when already in squeezin state.
<tr class="nocodegen"><td>368<td>    /// &lt;/remarks&gt;
<tr class="nocodegen"><td>369<td>    /// &lt;exception cref=&quot;EDECHashException&quot;&gt;
<tr class="nocodegen"><td>370<td>    ///   Exception raised if DataBit len not divideable by 8 without
<tr class="nocodegen"><td>371<td>    ///   reminder or when already in squeezin state.
<tr class="nocodegen"><td>372<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>373<td>    procedure Absorb(Data: PBABytes; DatabitLen: Int32);
<tr class="nocodegen"><td>374<td>
<tr class="nocodegen"><td>375<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>376<td>    ///   Absorb remaining bits from queue
<tr class="nocodegen"><td>377<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>378<td>    procedure AbsorbQueue;
<tr class="nocodegen"><td>379<td>
<tr class="nocodegen"><td>380<td>    {$IFDEF PUREPASCAL}
<tr class="nocodegen"><td>381<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>382<td>    ///   Circular left shift
<tr class="nocodegen"><td>383<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>384<td>    /// &lt;param name=&quot;x&quot;&gt;
<tr class="nocodegen"><td>385<td>    ///   Value to be shifted
<tr class="nocodegen"><td>386<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>387<td>    /// &lt;param name=&quot;c&quot;&gt;
<tr class="nocodegen"><td>388<td>    ///   Number of bits the value will be shifted
<tr class="nocodegen"><td>389<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>390<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>391<td>    ///   Shifted value
<tr class="nocodegen"><td>392<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>393<td>    function RotL(const x: UInt64; c: Integer): UInt64; inline;
<tr class="nocodegen"><td>394<td>
<tr class="nocodegen"><td>395<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>396<td>    ///   Circular left shift by 1
<tr class="nocodegen"><td>397<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>398<td>    /// &lt;param name=&quot;x&quot;&gt;
<tr class="nocodegen"><td>399<td>    ///   Value to be shifted
<tr class="nocodegen"><td>400<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>401<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>402<td>    ///   Shifted value
<tr class="nocodegen"><td>403<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>404<td>    function RotL1(var x: UInt64): UInt64; inline;
<tr class="nocodegen"><td>405<td>    {$ENDIF}
<tr class="nocodegen"><td>406<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>407<td>    ///   Permutates the values in the passed state
<tr class="nocodegen"><td>408<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>409<td>    /// &lt;param name=&quot;State&quot;&gt;
<tr class="nocodegen"><td>410<td>    ///   State to permutate
<tr class="nocodegen"><td>411<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>412<td>    procedure KeccakPermutation(var State: TState_L);
<tr class="nocodegen"><td>413<td>
<tr class="nocodegen"><td>414<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>415<td>    ///   Carries out the XorIntoState and the permutation
<tr class="nocodegen"><td>416<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>417<td>    /// &lt;param name=&quot;State&quot;&gt;
<tr class="nocodegen"><td>418<td>    ///   State of the algorithm which gets modified by the permutation in this method
<tr class="nocodegen"><td>419<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>420<td>    /// &lt;param name=&quot;Data&quot;&gt;
<tr class="nocodegen"><td>421<td>    ///   Pointer to the data to operate on
<tr class="nocodegen"><td>422<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>423<td>    /// &lt;param name=&quot;LaneCount&quot;&gt;
<tr class="nocodegen"><td>424<td>    ///   Number of times the loop in this algorithm has tpo be carried out
<tr class="nocodegen"><td>425<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>426<td>    procedure KeccakAbsorb(var state: TState_B; data: PUInt64; laneCount: Integer);
<tr class="nocodegen"><td>427<td>
<tr class="nocodegen"><td>428<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>429<td>    ///   Include input message data bits into the sponge state
<tr class="nocodegen"><td>430<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>431<td>    procedure XORIntoState(var state: TState_L; pI: PUInt64; laneCount: Integer);
<tr class="nocodegen"><td>432<td>
<tr class="nocodegen"><td>433<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>434<td>    ///   Update state with DataBitLen bits from data. May be called multiple
<tr class="nocodegen"><td>435<td>    ///   times, only the last DataBitLen may be a non-multiple of 8
<tr class="nocodegen"><td>436<td>    ///   (the corresponding byte) must be MSB aligned, i.e. in the
<tr class="nocodegen"><td>437<td>    ///   (databitlen and 7) most significant bits.
<tr class="nocodegen"><td>438<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>439<td>    /// &lt;param name=&quot;data&quot;&gt;
<tr class="nocodegen"><td>440<td>    ///   Data to work on
<tr class="nocodegen"><td>441<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>442<td>    /// &lt;param name=&quot;DataBitLen&quot;&gt;
<tr class="nocodegen"><td>443<td>    ///   Length of the data in bits
<tr class="nocodegen"><td>444<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>445<td>    procedure DoUpdate(Data: Pointer; DataBitLen: Int32);
<tr class="nocodegen"><td>446<td>
<tr class="nocodegen"><td>447<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>448<td>    ///   Squeeze output data from the sponge function. If the sponge function
<tr class="nocodegen"><td>449<td>    ///   was in the absorbing phase, this function switches it to the squeezing
<tr class="nocodegen"><td>450<td>    ///   phase.
<tr class="nocodegen"><td>451<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>452<td>    /// &lt;param name=&quot;Output&quot;&gt;
<tr class="nocodegen"><td>453<td>    ///   pointer to the buffer where to store the output data
<tr class="nocodegen"><td>454<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>455<td>    /// &lt;param name=&quot;OutputLength&quot;&gt;
<tr class="nocodegen"><td>456<td>    ///   number of output bits desired, must be a multiple of 8.
<tr class="nocodegen"><td>457<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>458<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>459<td>    ///   0 if successful, 1 otherwise.
<tr class="nocodegen"><td>460<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>461<td>    /// &lt;exception cref=&quot;EDECHashException&quot;&gt;
<tr class="nocodegen"><td>462<td>    ///   Exception raised if &lt;c&gt;OutputLength&lt;/c&gt; is not a multiple of 8
<tr class="nocodegen"><td>463<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>464<td>    procedure Squeeze(var Output: TSHA3Digest; OutputLength: Int32);
<tr class="nocodegen"><td>465<td>
<tr class="nocodegen"><td>466<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>467<td>    ///   Update final bits in LSB format, pad them, and compute the hash value
<tr class="nocodegen"><td>468<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>469<td>    /// &lt;param name=&quot;Bits&quot;&gt;
<tr class="nocodegen"><td>470<td>    ///   Value used for padding if the length of the message to be hashed
<tr class="nocodegen"><td>471<td>    ///   is not a multiple of 8 bit bytes.
<tr class="nocodegen"><td>472<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>473<td>    /// &lt;param name=&quot;BitLen&quot;&gt;
<tr class="nocodegen"><td>474<td>    ///   Number of needed padding bits?
<tr class="nocodegen"><td>475<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>476<td>    /// &lt;param name=&quot;HashValue&quot;&gt;
<tr class="nocodegen"><td>477<td>    ///   The hash value which shall be updated by this method
<tr class="nocodegen"><td>478<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>479<td>    procedure FinalBit_LSB(Bits: Byte; Bitlen: UInt16;
<tr class="nocodegen"><td>480<td>                            var HashValue: TSHA3Digest);
<tr class="nocodegen"><td>481<td>
<tr class="nocodegen"><td>482<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>483<td>    ///   The algorithm starts in the absorb phase (one puts data into the sponge)
<tr class="nocodegen"><td>484<td>    ///   and ends with the squeze phase (one squeezes the sponge) and this method
<tr class="nocodegen"><td>485<td>    ///   does everything needed at the transition point between these two phases
<tr class="nocodegen"><td>486<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>487<td>    procedure PadAndSwitchToSqueezingPhase;
<tr class="nocodegen"><td>488<td>
<tr class="nocodegen"><td>489<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>490<td>    ///   ???
<tr class="nocodegen"><td>491<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>492<td>    /// &lt;param name=&quot;Outp&quot;&gt;
<tr class="nocodegen"><td>493<td>    ///   Pointer where the output will be stored in
<tr class="nocodegen"><td>494<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>495<td>    /// &lt;param name=&quot;State&quot;&gt;
<tr class="nocodegen"><td>496<td>    ///   State to work on
<tr class="nocodegen"><td>497<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>498<td>    /// &lt;param name=&quot;LaneCount&quot;&gt;
<tr class="nocodegen"><td>499<td>    ///   Number of iterations
<tr class="nocodegen"><td>500<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>501<td>    procedure ExtractFromState(Outp: Pointer; const State: TState_L; LaneCount: Integer);
<tr class="nocodegen"><td>502<td>  strict protected
<tr class="nocodegen"><td>503<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>504<td>    ///   Contains the current state of the algorithms sponge part
<tr class="nocodegen"><td>505<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>506<td>    FSpongeState : TSpongeState;
<tr class="nocodegen"><td>507<td>
<tr class="nocodegen"><td>508<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>509<td>    ///   The generated hash value is stored here
<tr class="nocodegen"><td>510<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>511<td>    FDigest      : TSHA3Digest;
<tr class="nocodegen"><td>512<td>
<tr class="nocodegen"><td>513<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>514<td>    ///   When true, the output length has been set (applicable for the expandable
<tr class="nocodegen"><td>515<td>    ///   output length algorithm variants named Shake) and needs to be preserved
<tr class="nocodegen"><td>516<td>    ///   in InitSponge
<tr class="nocodegen"><td>517<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>518<td>    FOutpLengSet : Boolean;
<tr class="nocodegen"><td>519<td>
<tr class="nocodegen"><td>520<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>521<td>    ///   If true the implementation is Keccack instead of SHA3. This changes
<tr class="nocodegen"><td>522<td>    ///   how the padding at the end is handled.
<tr class="nocodegen"><td>523<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>524<td>    FIsKeccack   : Boolean;
<tr class="nocodegen"><td>525<td>
<tr class="nocodegen"><td>526<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>527<td>    ///   Initializes the state of the Keccak/SHA3 sponge function. It is set to
<tr class="nocodegen"><td>528<td>    ///   the absorbing phase by this. If invalid parameter values are specified
<tr class="nocodegen"><td>529<td>    ///   a EDECHashException will be raised
<tr class="nocodegen"><td>530<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>531<td>    /// &lt;param name=&quot;rate&quot;&gt;
<tr class="nocodegen"><td>532<td>    ///   Block length of the message to be processed, depends directly on the
<tr class="nocodegen"><td>533<td>    ///   SHA3 variant (224, 256...) to be used
<tr class="nocodegen"><td>534<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>535<td>    /// &lt;param name=&quot;capacity&quot;&gt;
<tr class="nocodegen"><td>536<td>    ///   Capacity c (it could directly be calculated from the rate as
<tr class="nocodegen"><td>537<td>    ///   c = 1600 - r but the original author Wolfgang Erhardt decided against
<tr class="nocodegen"><td>538<td>    ///   this.
<tr class="nocodegen"><td>539<td>    ///   The capacity is the size of that part of the state vector which, when
<tr class="nocodegen"><td>540<td>    ///   xored with the message blocks and when extracting the resulting hash,
<tr class="nocodegen"><td>541<td>    ///   stays untouched.
<tr class="nocodegen"><td>542<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>543<td>    /// &lt;exception cref=&quot;EDECHashException&quot;&gt;
<tr class="nocodegen"><td>544<td>    ///   Exception raised if invalid parameter values are specified.
<tr class="nocodegen"><td>545<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>546<td>    procedure InitSponge(Rate, Capacity: UInt16);
<tr class="nocodegen"><td>547<td>
<tr class="nocodegen"><td>548<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>549<td>    ///   Init internal data
<tr class="nocodegen"><td>550<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>551<td>    procedure DoInit; override;
<tr class="nocodegen"><td>552<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>553<td>    ///   Dummy method to avoid the compiler warning about a class with abstract method
<tr class="nocodegen"><td>554<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>555<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>556<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>557<td>    ///   Final step of the calculation
<tr class="nocodegen"><td>558<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>559<td>    procedure DoDone; override;
<tr class="nocodegen"><td>560<td>
<tr class="nocodegen"><td>561<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>562<td>    ///   Returns the calculated hash value
<tr class="nocodegen"><td>563<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>564<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>565<td>    ///   Hash value calculated
<tr class="nocodegen"><td>566<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>567<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>568<td>  public
<tr class="nocodegen"><td>569<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>570<td>    ///   Dimension hash result buffer
<tr class="nocodegen"><td>571<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>572<td>    constructor Create; override;
<tr class="nocodegen"><td>573<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>574<td>    ///   Processes one chunk of data to be hashed.
<tr class="nocodegen"><td>575<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>576<td>    /// &lt;param name=&quot;Data&quot;&gt;
<tr class="nocodegen"><td>577<td>    ///   Data on which the hash value shall be calculated on
<tr class="nocodegen"><td>578<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>579<td>    /// &lt;param name=&quot;DataSize&quot;&gt;
<tr class="nocodegen"><td>580<td>    ///   Size of the data in bytes
<tr class="nocodegen"><td>581<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>582<td>    procedure Calc(const Data; DataSize: Integer); override;
<tr class="nocodegen"><td>583<td>  end;
<tr class="nocodegen"><td>584<td>
<tr class="nocodegen"><td>585<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>586<td>  ///   224 bit SHA3 variant
<tr class="nocodegen"><td>587<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>588<td>  THash_SHA3_224 = class(THash_SHA3Base)
<tr class="nocodegen"><td>589<td>  protected
<tr class="nocodegen"><td>590<td>    procedure DoInit; override;
<tr class="nocodegen"><td>591<td>  public
<tr class="nocodegen"><td>592<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>593<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>594<td>  end;
<tr class="nocodegen"><td>595<td>
<tr class="nocodegen"><td>596<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>597<td>  ///   256 bit SHA3 variant
<tr class="nocodegen"><td>598<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>599<td>  THash_SHA3_256 = class(THash_SHA3Base)
<tr class="nocodegen"><td>600<td>  protected
<tr class="nocodegen"><td>601<td>    procedure DoInit; override;
<tr class="nocodegen"><td>602<td>  public
<tr class="nocodegen"><td>603<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>604<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>605<td>  end;
<tr class="nocodegen"><td>606<td>
<tr class="nocodegen"><td>607<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>608<td>  ///   384 bit SHA3 variant
<tr class="nocodegen"><td>609<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>610<td>  THash_SHA3_384 = class(THash_SHA3Base)
<tr class="nocodegen"><td>611<td>  protected
<tr class="nocodegen"><td>612<td>    procedure DoInit; override;
<tr class="nocodegen"><td>613<td>  public
<tr class="nocodegen"><td>614<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>615<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>616<td>  end;
<tr class="nocodegen"><td>617<td>
<tr class="nocodegen"><td>618<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>619<td>  ///   512 bit SHA3 variant
<tr class="nocodegen"><td>620<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>621<td>  THash_SHA3_512 = class(THash_SHA3Base)
<tr class="nocodegen"><td>622<td>  protected
<tr class="nocodegen"><td>623<td>    procedure DoInit; override;
<tr class="nocodegen"><td>624<td>  public
<tr class="nocodegen"><td>625<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>626<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>627<td>  end;
<tr class="nocodegen"><td>628<td>
<tr class="nocodegen"><td>629<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>630<td>  ///   224 bit Keccack variant, the predecessor of SHA3_224
<tr class="nocodegen"><td>631<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>632<td>  THash_Keccak_224 = class(THash_SHA3_224)
<tr class="nocodegen"><td>633<td>  protected
<tr class="nocodegen"><td>634<td>    procedure DoInit; override;
<tr class="nocodegen"><td>635<td>  public
<tr class="nocodegen"><td>636<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>637<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>638<td>  end;
<tr class="nocodegen"><td>639<td>
<tr class="nocodegen"><td>640<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>641<td>  ///   256 bit Keccack variant, the predecessor of SHA3_256
<tr class="nocodegen"><td>642<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>643<td>  THash_Keccak_256 = class(THash_SHA3_256)
<tr class="nocodegen"><td>644<td>  protected
<tr class="nocodegen"><td>645<td>    procedure DoInit; override;
<tr class="nocodegen"><td>646<td>  public
<tr class="nocodegen"><td>647<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>648<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>649<td>  end;
<tr class="nocodegen"><td>650<td>
<tr class="nocodegen"><td>651<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>652<td>  ///   384 bit Keccack variant, the predecessor of SHA3_384
<tr class="nocodegen"><td>653<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>654<td>  THash_Keccak_384 = class(THash_SHA3_384)
<tr class="nocodegen"><td>655<td>  protected
<tr class="nocodegen"><td>656<td>    procedure DoInit; override;
<tr class="nocodegen"><td>657<td>  public
<tr class="nocodegen"><td>658<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>659<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>660<td>  end;
<tr class="nocodegen"><td>661<td>
<tr class="nocodegen"><td>662<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>663<td>  ///   512 bit Keccack variant, the predecessor of SHA3_512
<tr class="nocodegen"><td>664<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>665<td>  THash_Keccak_512 = class(THash_SHA3_512)
<tr class="nocodegen"><td>666<td>  protected
<tr class="nocodegen"><td>667<td>    procedure DoInit; override;
<tr class="nocodegen"><td>668<td>  public
<tr class="nocodegen"><td>669<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>670<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>671<td>  end;
<tr class="nocodegen"><td>672<td>
<tr class="nocodegen"><td>673<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>674<td>  ///   Base class for the Shake implementations
<tr class="nocodegen"><td>675<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>676<td>  THash_ShakeBase = class(THash_SHA3Base, IDECHashExtensibleOutput)
<tr class="nocodegen"><td>677<td>  private
<tr class="nocodegen"><td>678<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>679<td>    ///   Returns the length of the calculated hash value in byte
<tr class="nocodegen"><td>680<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>681<td>    function  GetHashSize: UInt16;
<tr class="nocodegen"><td>682<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>683<td>    ///   Defines the length of the calculated hash value
<tr class="nocodegen"><td>684<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>685<td>    /// &lt;param name=&quot;Value&quot;&gt;
<tr class="nocodegen"><td>686<td>    ///   Length of the hash value to be returned in byte
<tr class="nocodegen"><td>687<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>688<td>    /// &lt;exception cref=&quot;EDECHashException&quot;&gt;
<tr class="nocodegen"><td>689<td>    ///   Exception raised if &lt;c&gt;Value&lt;/c&gt; is 0.
<tr class="nocodegen"><td>690<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>691<td>    procedure SetHashSize(const Value: UInt16);
<tr class="nocodegen"><td>692<td>  public
<tr class="nocodegen"><td>693<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>694<td>    ///   Returns the calculated hash value as byte array. Needs to be overriden
<tr class="nocodegen"><td>695<td>    ///   here as the length of the output needs to be determined differently due
<tr class="nocodegen"><td>696<td>    ///   to Shake being extensible output length.
<tr class="nocodegen"><td>697<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>698<td>    function DigestAsBytes: TBytes; override;
<tr class="nocodegen"><td>699<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>700<td>    ///   Define the lenght of the resulting hash value in byte as these functions
<tr class="nocodegen"><td>701<td>    ///   are extendable output functions
<tr class="nocodegen"><td>702<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>703<td>    property HashSize : UInt16
<tr class="nocodegen"><td>704<td>      read   GetHashSize
<tr class="nocodegen"><td>705<td>      write  SetHashSize;
<tr class="nocodegen"><td>706<td>  end;
<tr class="nocodegen"><td>707<td>
<tr class="nocodegen"><td>708<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>709<td>  ///   Shake128 veriant of SHA3
<tr class="nocodegen"><td>710<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>711<td>  THash_Shake128 = class(THash_ShakeBase)
<tr class="nocodegen"><td>712<td>  protected
<tr class="nocodegen"><td>713<td>    procedure DoInit; override;
<tr class="nocodegen"><td>714<td>  public
<tr class="nocodegen"><td>715<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>716<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>717<td>  end;
<tr class="nocodegen"><td>718<td>
<tr class="nocodegen"><td>719<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>720<td>  ///   Shake128 veriant of SHA3
<tr class="nocodegen"><td>721<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>722<td>  THash_Shake256 = class(THash_ShakeBase)
<tr class="nocodegen"><td>723<td>  protected
<tr class="nocodegen"><td>724<td>    procedure DoInit; override;
<tr class="nocodegen"><td>725<td>  public
<tr class="nocodegen"><td>726<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>727<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>728<td>  end;
<tr class="nocodegen"><td>729<td>
<tr class="nocodegen"><td>730<td>  THavalBaseTransformMethod = procedure(Buffer: PUInt32Array) of object;
<tr class="nocodegen"><td>731<td>
<tr class="nocodegen"><td>732<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>733<td>  ///   Base class for all Haval implementations
<tr class="nocodegen"><td>734<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>735<td>  THashBaseHaval = class(TDECHashExtended, IDECHashRounds)
<tr class="nocodegen"><td>736<td>  private
<tr class="nocodegen"><td>737<td>    FDigest: array[0..7] of UInt32;
<tr class="nocodegen"><td>738<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>739<td>      ///   UInt32 for compatibility with 32 bit ASM implementation
<tr class="nocodegen"><td>740<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>741<td>    FRounds: UInt32;
<tr class="nocodegen"><td>742<td>    FTransform: THavalBaseTransformMethod;
<tr class="nocodegen"><td>743<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>744<td>    ///   Defines the number of calculation rounds and if a value outside the
<tr class="nocodegen"><td>745<td>    ///   allowed range is given it sets rounds to a value based on digest size.
<tr class="nocodegen"><td>746<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>747<td>    procedure SetRounds(Value: UInt32);
<tr class="nocodegen"><td>748<td>    function  GetRounds: UInt32;
<tr class="nocodegen"><td>749<td>  protected
<tr class="nocodegen"><td>750<td>    procedure DoInit; override;
<tr class="nocodegen"><td>751<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>752<td>    procedure DoTransform3(Buffer: PUInt32Array);
<tr class="nocodegen"><td>753<td>    procedure DoTransform4(Buffer: PUInt32Array);
<tr class="nocodegen"><td>754<td>    procedure DoTransform5(Buffer: PUInt32Array);
<tr class="nocodegen"><td>755<td>    procedure DoDone; override;
<tr class="nocodegen"><td>756<td>  public
<tr class="nocodegen"><td>757<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>758<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>759<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>760<td>    ///   Returns the minimum possible number for the rounds parameter.
<tr class="nocodegen"><td>761<td>    ///   Value depends on Digest size which depends on concrete implementation
<tr class="nocodegen"><td>762<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>763<td>    function GetMinRounds: UInt32;
<tr class="nocodegen"><td>764<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>765<td>    ///   Returns the maximum possible number for the rounds parameter.
<tr class="nocodegen"><td>766<td>    ///   Value depends on Digest size which depends on concrete implementation
<tr class="nocodegen"><td>767<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>768<td>    function GetMaxRounds: UInt32;
<tr class="nocodegen"><td>769<td>
<tr class="nocodegen"><td>770<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>771<td>    ///   Defines the number of rounds the algorithm performs on the input data.
<tr class="nocodegen"><td>772<td>    ///   The range for this parameter is 3-5 rounds. If a value outside this
<tr class="nocodegen"><td>773<td>    ///   range is assigned, the value used depends on the DigestSize. For
<tr class="nocodegen"><td>774<td>    ///   DigestSizes &lt;= 20 it will be set to 3, for values &lt;= 28 to 4 and for
<tr class="nocodegen"><td>775<td>    ///   bigger values to 5. For 3 rounds the algorithm is considered unsafe,
<tr class="nocodegen"><td>776<td>    ///   as in 2003 collisions could be found with a setting of 3 rounds only.
<tr class="nocodegen"><td>777<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>778<td>    property Rounds: UInt32 read GetRounds write SetRounds default 3;
<tr class="nocodegen"><td>779<td>  end;
<tr class="nocodegen"><td>780<td>
<tr class="nocodegen"><td>781<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>782<td>  ///   In 2004 collisions for this one were found, so this one should be
<tr class="nocodegen"><td>783<td>  ///   considered to be unsafe.
<tr class="nocodegen"><td>784<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>785<td>  THash_Haval128 = class(THashBaseHaval)
<tr class="nocodegen"><td>786<td>  public
<tr class="nocodegen"><td>787<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>788<td>  end;
<tr class="nocodegen"><td>789<td>
<tr class="nocodegen"><td>790<td>  THash_Haval160 = class(THashBaseHaval)
<tr class="nocodegen"><td>791<td>  public
<tr class="nocodegen"><td>792<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>793<td>  end;
<tr class="nocodegen"><td>794<td>
<tr class="nocodegen"><td>795<td>  THash_Haval192 = class(THashBaseHaval)
<tr class="nocodegen"><td>796<td>  public
<tr class="nocodegen"><td>797<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>798<td>  end;
<tr class="nocodegen"><td>799<td>
<tr class="nocodegen"><td>800<td>  THash_Haval224 = class(THashBaseHaval)
<tr class="nocodegen"><td>801<td>  public
<tr class="nocodegen"><td>802<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>803<td>  end;
<tr class="nocodegen"><td>804<td>
<tr class="nocodegen"><td>805<td>  THash_Haval256 = class(THashBaseHaval)
<tr class="nocodegen"><td>806<td>  public
<tr class="nocodegen"><td>807<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>808<td>  end;
<tr class="nocodegen"><td>809<td>
<tr class="nocodegen"><td>810<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>811<td>  ///   This is actually an implementation of the 192 bit variant of the Tiger
<tr class="nocodegen"><td>812<td>  ///   hash algorithm with 3 rounds, unless a different value is assigned
<tr class="nocodegen"><td>813<td>  ///   to the rounds property. It is considered to be unsafe at least in the
<tr class="nocodegen"><td>814<td>  ///   192 Bit variant!
<tr class="nocodegen"><td>815<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>816<td>  THash_Tiger = class(THashBaseMD4, IDECHashRounds)
<tr class="nocodegen"><td>817<td>  private
<tr class="nocodegen"><td>818<td>    const
<tr class="nocodegen"><td>819<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>820<td>      ///   Minimum number of rounds for the Tigher hash function. Trying to set a
<tr class="nocodegen"><td>821<td>      ///   lower one sets the rounds to this value.
<tr class="nocodegen"><td>822<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>823<td>      cTigerMinRounds = 3;
<tr class="nocodegen"><td>824<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>825<td>      ///   Maximum number of rounds for the Tigher hash function. Trying to set a
<tr class="nocodegen"><td>826<td>      ///   higher one sets the rounds to this value.
<tr class="nocodegen"><td>827<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>828<td>      cTigerMaxRounds = 32;
<tr class="nocodegen"><td>829<td>    var
<tr class="nocodegen"><td>830<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>831<td>      ///   UInt32 for compatibility with 32 bit ASM implementation
<tr class="nocodegen"><td>832<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>833<td>      FRounds: UInt32;
<tr class="nocodegen"><td>834<td>      function  GetRounds: UInt32;
<tr class="nocodegen"><td>835<td>      procedure SetRounds(Value: UInt32);
<tr class="nocodegen"><td>836<td>  protected
<tr class="nocodegen"><td>837<td>    procedure DoInit; override;
<tr class="nocodegen"><td>838<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>839<td>  public
<tr class="nocodegen"><td>840<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>841<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>842<td>    ///   Returns the minimum possible number for the rounds parameter
<tr class="nocodegen"><td>843<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>844<td>    function GetMinRounds: UInt32;
<tr class="nocodegen"><td>845<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>846<td>    ///   Returns the maximum possible number for the rounds parameter
<tr class="nocodegen"><td>847<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>848<td>    function GetMaxRounds: UInt32;
<tr class="nocodegen"><td>849<td>
<tr class="nocodegen"><td>850<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>851<td>    ///   Defines the number of rounds the algorithm will perform on the data
<tr class="nocodegen"><td>852<td>    ///   passed. Valid values are in the range from 3-32 rounds and values
<tr class="nocodegen"><td>853<td>    ///   outside this range will lead to a rounds value of 3 or 32 to be used,
<tr class="nocodegen"><td>854<td>    ///   depending on whether a lower or higher value has been given.
<tr class="nocodegen"><td>855<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>856<td>    property Rounds: UInt32 read GetRounds write SetRounds default 3;
<tr class="nocodegen"><td>857<td>  end;
<tr class="nocodegen"><td>858<td>
<tr class="nocodegen"><td>859<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>860<td>  ///   As there seem to exist 128 and 160 bit variants of Tiger, which seem to
<tr class="nocodegen"><td>861<td>  ///   be truncated variants of Tiger 192, but we want to keep compatibility
<tr class="nocodegen"><td>862<td>  ///   with old code we introduce an alias for the time being.
<tr class="nocodegen"><td>863<td>  ///   It is considered to be unsafe at least in the 192 Bit variant!
<tr class="nocodegen"><td>864<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>865<td>  THash_Tiger192 = THash_Tiger;
<tr class="nocodegen"><td>866<td>
<tr class="nocodegen"><td>867<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>868<td>  ///   The Panama algorithm is being considered to be unsafe. Support is only
<tr class="nocodegen"><td>869<td>  ///   being provided for backward compatibility.
<tr class="nocodegen"><td>870<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>871<td>  THash_Panama = class(TDECHashExtended)
<tr class="nocodegen"><td>872<td>  private
<tr class="nocodegen"><td>873<td>    FLFSRBuffer: array[0..31, 0..7] of UInt32;
<tr class="nocodegen"><td>874<td>    FDigest: array[0..16] of UInt32;
<tr class="nocodegen"><td>875<td>    FTap: UInt32;
<tr class="nocodegen"><td>876<td>  protected
<tr class="nocodegen"><td>877<td>    procedure DoInit; override;
<tr class="nocodegen"><td>878<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>879<td>    procedure DoDone; override;
<tr class="nocodegen"><td>880<td>    procedure DoPull;
<tr class="nocodegen"><td>881<td>  public
<tr class="nocodegen"><td>882<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>883<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>884<td>    class function BlockSize: UInt32; override; // 32
<tr class="nocodegen"><td>885<td>  end;
<tr class="nocodegen"><td>886<td>
<tr class="nocodegen"><td>887<td>  THashBaseWhirlpool = class(TDECHashExtended)
<tr class="nocodegen"><td>888<td>  private
<tr class="nocodegen"><td>889<td>    FDigest: array[0..15] of UInt32;
<tr class="nocodegen"><td>890<td>    FTableC: Pointer;
<tr class="nocodegen"><td>891<td>    FTableR: Pointer;
<tr class="nocodegen"><td>892<td>  protected
<tr class="nocodegen"><td>893<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>894<td>    procedure DoDone; override;
<tr class="nocodegen"><td>895<td>  public
<tr class="nocodegen"><td>896<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>897<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>898<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>899<td>  end;
<tr class="nocodegen"><td>900<td>
<tr class="nocodegen"><td>901<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>902<td>  ///   This is the original variant of the algorithmus. Do not use it as some
<tr class="nocodegen"><td>903<td>  ///   security flaw has been detected early on by its inventors. DEC contains
<tr class="nocodegen"><td>904<td>  ///   it for backwards compatibility and completeness.
<tr class="nocodegen"><td>905<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>906<td>  THash_Whirlpool0 = class(THashBaseWhirlpool)
<tr class="nocodegen"><td>907<td>  protected
<tr class="nocodegen"><td>908<td>    procedure DoInit; override;
<tr class="nocodegen"><td>909<td>  end;
<tr class="nocodegen"><td>910<td>
<tr class="nocodegen"><td>911<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>912<td>  ///   This is variant of the algorithmus fixing the security flaw of the
<tr class="nocodegen"><td>913<td>  ///   original version Whirlpool0. Do not use it in new code as it has been
<tr class="nocodegen"><td>914<td>  ///   superseeded by the optimized Whirlpool1 (THash_Whirlpool1 class in DEC)
<tr class="nocodegen"><td>915<td>  ///   variant which is additionally more safe as well! It is there for
<tr class="nocodegen"><td>916<td>  ///   backwards compatibility and completeness only.
<tr class="nocodegen"><td>917<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>918<td>  THash_WhirlpoolT = class(THashBaseWhirlpool)
<tr class="nocodegen"><td>919<td>  protected
<tr class="nocodegen"><td>920<td>    procedure DoInit; override;
<tr class="nocodegen"><td>921<td>  end;
<tr class="nocodegen"><td>922<td>
<tr class="nocodegen"><td>923<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>924<td>  ///   The current version of Whirlpool but not the one used in code developed
<tr class="nocodegen"><td>925<td>  ///   against the older DEC 5.x versions. The name of the one used in your
<tr class="nocodegen"><td>926<td>  ///   code differs, depending whether you opt tu use the old DEC 5.2 compatible
<tr class="nocodegen"><td>927<td>  ///   class names where the name Whirlpool1 was already taken by the variant
<tr class="nocodegen"><td>928<td>  ///   nowadays known as Whirlpool-T.
<tr class="nocodegen"><td>929<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>930<td>  THash_Whirlpool1_ = class(THashBaseWhirlpool)
<tr class="nocodegen"><td>931<td>  protected
<tr class="nocodegen"><td>932<td>    procedure DoInit; override;
<tr class="nocodegen"><td>933<td>  end;
<tr class="nocodegen"><td>934<td>
<tr class="nocodegen"><td>935<td>  {$IFDEF OLD_WHIRLPOOL_NAMES}
<tr class="nocodegen"><td>936<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>937<td>  ///   This is the original variant of the algorithmus. Do not use it as some
<tr class="nocodegen"><td>938<td>  ///   security flaw has been detected early on by its inventors. DEC contains
<tr class="nocodegen"><td>939<td>  ///   it for backwards compatibility and completeness.
<tr class="nocodegen"><td>940<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>941<td>  THash_Whirlpool = class(THash_Whirlpool0);
<tr class="nocodegen"><td>942<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>943<td>  ///   This is variant of the algorithmus fixing the security flaw of the
<tr class="nocodegen"><td>944<td>  ///   original version Whirlpool0. Do not use it in new code as it has been
<tr class="nocodegen"><td>945<td>  ///   superseeded by the optimized Whirlpool1 (THash_Whirlpool1 class in DEC)
<tr class="nocodegen"><td>946<td>  ///   variant which is additionally more safe as well! It is there for
<tr class="nocodegen"><td>947<td>  ///   backwards compatibility and completeness only.
<tr class="nocodegen"><td>948<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>949<td>  THash_Whirlpool1 = class(THash_WhirlpoolT);
<tr class="nocodegen"><td>950<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>951<td>  ///   The current version of Whirlpool but not the one used in code developed
<tr class="nocodegen"><td>952<td>  ///   against the older DEC 5.x versions. The name of the one used in your
<tr class="nocodegen"><td>953<td>  ///   code differs, depending whether you opt tu use the old DEC 5.2 compatible
<tr class="nocodegen"><td>954<td>  ///   class names where the name Whirlpool1 was already taken by the variant
<tr class="nocodegen"><td>955<td>  ///   nowadays known as Whirlpool-T.
<tr class="nocodegen"><td>956<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>957<td>  THash_Whirlpool1New = class(THash_Whirlpool1_);
<tr class="nocodegen"><td>958<td>  {$ELSE}
<tr class="nocodegen"><td>959<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>960<td>  ///   The current version of Whirlpool but not the one used in code developed
<tr class="nocodegen"><td>961<td>  ///   against the older DEC 5.x versions. The name of the one used in your
<tr class="nocodegen"><td>962<td>  ///   code differs, depending whether you opt tu use the old DEC 5.2 compatible
<tr class="nocodegen"><td>963<td>  ///   class names where the name Whirlpool1 was already taken by the variant
<tr class="nocodegen"><td>964<td>  ///   nowadays known as Whirlpool-T.
<tr class="nocodegen"><td>965<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>966<td>  THash_Whirlpool1 = class(THash_Whirlpool1_);
<tr class="nocodegen"><td>967<td>  {$ENDIF}
<tr class="nocodegen"><td>968<td>
<tr class="nocodegen"><td>969<td>  THash_Square = class(TDECHashExtended)
<tr class="nocodegen"><td>970<td>  private
<tr class="nocodegen"><td>971<td>    FDigest: array[0..3] of UInt32;
<tr class="nocodegen"><td>972<td>  protected
<tr class="nocodegen"><td>973<td>    procedure DoInit; override;
<tr class="nocodegen"><td>974<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>975<td>    procedure DoDone; override;
<tr class="nocodegen"><td>976<td>  public
<tr class="nocodegen"><td>977<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>978<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>979<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>980<td>  end;
<tr class="nocodegen"><td>981<td>
<tr class="nocodegen"><td>982<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>983<td>  ///   This 1990 developed hash function was named after the Egyptian Pharaoh
<tr class="nocodegen"><td>984<td>  ///   Sneferu. Be sure to set SecurityLevel to at least 8. See remark there.
<tr class="nocodegen"><td>985<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>986<td>  THashBaseSnefru = class(TDECHashExtended, IDECHashRounds)
<tr class="nocodegen"><td>987<td>  private
<tr class="nocodegen"><td>988<td>    FDigest: array[0..23] of UInt32;
<tr class="nocodegen"><td>989<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>990<td>    ///   Number of rounds the loop will do on the data.
<tr class="nocodegen"><td>991<td>    ///   UInt32 for compatibility with 32 bit ASM implementation
<tr class="nocodegen"><td>992<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>993<td>    FRounds: UInt32;
<tr class="nocodegen"><td>994<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>995<td>    ///   Sets the number of rounds for the looping over the data
<tr class="nocodegen"><td>996<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>997<td>    procedure SetRounds(Value: UInt32);
<tr class="nocodegen"><td>998<td>    function  GetRounds: UInt32;
<tr class="nocodegen"><td>999<td>  protected
<tr class="nocodegen"><td>1000<td>    procedure DoInit; override;
<tr class="nocodegen"><td>1001<td>    procedure DoDone; override;
<tr class="nocodegen"><td>1002<td>  public
<tr class="nocodegen"><td>1003<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>1004<td>    ///   Returns the minimum possible number for the rounds parameter.
<tr class="nocodegen"><td>1005<td>    ///   Value depends on Digest size which depends on concrete implementation
<tr class="nocodegen"><td>1006<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1007<td>    function GetMinRounds: UInt32;
<tr class="nocodegen"><td>1008<td>    ///   Returns the maximum possible number for the rounds parameter.
<tr class="nocodegen"><td>1009<td>    ///   Value depends on Digest size which depends on concrete implementation
<tr class="nocodegen"><td>1010<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1011<td>    function GetMaxRounds: UInt32;
<tr class="nocodegen"><td>1012<td>
<tr class="nocodegen"><td>1013<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1014<td>    ///   Can be set from 2 to 8, default is 8. This is the number of rounds the
<tr class="nocodegen"><td>1015<td>    ///   algorithm will use. With the default of 8 rounds it is being considered
<tr class="nocodegen"><td>1016<td>    ///   as safe as of spring 2016, with less rounds this algorithm is considered
<tr class="nocodegen"><td>1017<td>    ///   to be unsafe and even with 8 rounds it is not really strong.
<tr class="nocodegen"><td>1018<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1019<td>    property Rounds: UInt32
<tr class="nocodegen"><td>1020<td>      read   GetRounds
<tr class="nocodegen"><td>1021<td>      write  SetRounds;
<tr class="nocodegen"><td>1022<td>  end;
<tr class="nocodegen"><td>1023<td>
<tr class="nocodegen"><td>1024<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1025<td>  ///   This 1990 developed hash function was named after the Egyptian Pharaoh
<tr class="nocodegen"><td>1026<td>  ///   Sneferu. Be sure to set SecurityLevel to at least 8. See remark for
<tr class="nocodegen"><td>1027<td>  ///   THashBaseSnefru.SecurityLevel.
<tr class="nocodegen"><td>1028<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1029<td>  THash_Snefru128 = class(THashBaseSnefru)
<tr class="nocodegen"><td>1030<td>  protected
<tr class="nocodegen"><td>1031<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>1032<td>  public
<tr class="nocodegen"><td>1033<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>1034<td>    class function BlockSize: UInt32; override; // 48
<tr class="nocodegen"><td>1035<td>  end;
<tr class="nocodegen"><td>1036<td>
<tr class="nocodegen"><td>1037<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1038<td>  ///   This 1990 developed hash function was named after the Egyptian Pharaoh
<tr class="nocodegen"><td>1039<td>  ///   Sneferu. Be sure to set SecurityLevel to at least 8. See remark
<tr class="nocodegen"><td>1040<td>  ///   THashBaseSnefru.SecurityLevel.
<tr class="nocodegen"><td>1041<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1042<td>  THash_Snefru256 = class(THashBaseSnefru)
<tr class="nocodegen"><td>1043<td>  protected
<tr class="nocodegen"><td>1044<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>1045<td>  public
<tr class="nocodegen"><td>1046<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>1047<td>    class function BlockSize: UInt32; override; // 32
<tr class="nocodegen"><td>1048<td>  end;
<tr class="nocodegen"><td>1049<td>
<tr class="nocodegen"><td>1050<td>  THash_Sapphire = class(TDECHashExtended)
<tr class="nocodegen"><td>1051<td>  private
<tr class="nocodegen"><td>1052<td>    FCards: array[0..255] of UInt32;
<tr class="nocodegen"><td>1053<td>    FDigest: array[0..15] of UInt32;
<tr class="nocodegen"><td>1054<td>    FRotor: UInt32;
<tr class="nocodegen"><td>1055<td>    FRatchet: UInt32;
<tr class="nocodegen"><td>1056<td>    FAvalanche: UInt32;
<tr class="nocodegen"><td>1057<td>    FPlain: UInt32;
<tr class="nocodegen"><td>1058<td>    FCipher: UInt32;
<tr class="nocodegen"><td>1059<td>    FDigestSize: UInt8;
<tr class="nocodegen"><td>1060<td>
<tr class="nocodegen"><td>1061<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1062<td>    ///   Set the length of the output hash value in byte.
<tr class="nocodegen"><td>1063<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1064<td>    /// &lt;param name=&quot;Value&quot;&gt;
<tr class="nocodegen"><td>1065<td>    ///   Minimum value is 1 byte, maximum value is 64 byte = 512 bit.
<tr class="nocodegen"><td>1066<td>    ///   Sets the size to the default size returned by DigestSize otherwise.
<tr class="nocodegen"><td>1067<td>    ///   is specified.
<tr class="nocodegen"><td>1068<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1069<td>    procedure SetDigestSize(Value: UInt8);
<tr class="nocodegen"><td>1070<td>  protected
<tr class="nocodegen"><td>1071<td>    procedure DoInit; override;
<tr class="nocodegen"><td>1072<td>    procedure DoDone; override;
<tr class="nocodegen"><td>1073<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>1074<td>  public
<tr class="nocodegen"><td>1075<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>1076<td>    function DigestAsBytes: TBytes; override;
<tr class="nocodegen"><td>1077<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1078<td>    ///   Returns the default digest/hash size in bit. If RequestedDigestSize is
<tr class="nocodegen"><td>1079<td>    ///   not set, the defauilt size returned here is being used.
<tr class="nocodegen"><td>1080<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1081<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>1082<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1083<td>    ///   Returns on which block size this algorithm operates. Since the Sapphire
<tr class="nocodegen"><td>1084<td>    ///   hash originates from a Sapphire stream cipher algorithm this is always 1.
<tr class="nocodegen"><td>1085<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1086<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>1087<td>    procedure Calc(const Data; DataSize: Integer); override;
<tr class="nocodegen"><td>1088<td>
<tr class="nocodegen"><td>1089<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1090<td>    ///   This property defines the length of the output from the hash calculation
<tr class="nocodegen"><td>1091<td>    ///   in byte. The maximum value is 64 byte = 512 bit. Values bigger 64 byte
<tr class="nocodegen"><td>1092<td>    ///   and a value of 0 lead to the default size returned by DigestSize otherwise.
<tr class="nocodegen"><td>1093<td>    ///   This setting is only respected by the DigestAsBytes method and all other
<tr class="nocodegen"><td>1094<td>    ///   convenience methods using that one like CalcStream, CalcString,
<tr class="nocodegen"><td>1095<td>    ///   DigestAsString or DigestAsRawString.
<tr class="nocodegen"><td>1096<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1097<td>    property RequestedDigestSize: UInt8
<tr class="nocodegen"><td>1098<td>      read   FDigestSize
<tr class="nocodegen"><td>1099<td>      write  SetDigestSize;
<tr class="nocodegen"><td>1100<td>  end;
<tr class="nocodegen"><td>1101<td>
<tr class="nocodegen"><td>1102<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1103<td>  ///   Implementation of the bcrypt password hash algorithm. Maximum password
<tr class="nocodegen"><td>1104<td>  ///   length is 72 byte. When encoding typed in passwords in UTF8 that can mean
<tr class="nocodegen"><td>1105<td>  ///   18 chars in worst case of all typed chars being encoded in 4 byte each
<tr class="nocodegen"><td>1106<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1107<td>  THash_BCrypt = class(TDECPasswordHash)
<tr class="nocodegen"><td>1108<td>  private
<tr class="nocodegen"><td>1109<td>    type
<tr class="nocodegen"><td>1110<td>      TBFBlock   = packed array[0..7]  of UInt8;
<tr class="nocodegen"><td>1111<td>      PBFBlock   = ^TBFBlock;
<tr class="nocodegen"><td>1112<td>
<tr class="nocodegen"><td>1113<td>      TBCDigest  = packed array[0..23] of byte;
<tr class="nocodegen"><td>1114<td>
<tr class="nocodegen"><td>1115<td>      TBF2Long   = packed record
<tr class="nocodegen"><td>1116<td>                     L,R: UInt32;
<tr class="nocodegen"><td>1117<td>                   end;
<tr class="nocodegen"><td>1118<td>
<tr class="nocodegen"><td>1119<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>1120<td>      ///   user supplied IncCTR proc
<tr class="nocodegen"><td>1121<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>1122<td>      TBFIncProc = procedure(var CTR: TBFBlock);
<tr class="nocodegen"><td>1123<td>
<tr class="nocodegen"><td>1124<td>      TBFContext = packed record
<tr class="nocodegen"><td>1125<td>                     /// &lt;summary&gt;
<tr class="nocodegen"><td>1126<td>                     ///   key dependend SBox: 0..3, 0..255
<tr class="nocodegen"><td>1127<td>                     /// &lt;/summary&gt;
<tr class="nocodegen"><td>1128<td>                     SBox    : TBlowfishMatrix;
<tr class="nocodegen"><td>1129<td>                     /// &lt;summary&gt;
<tr class="nocodegen"><td>1130<td>                     ///   key dependend PArray
<tr class="nocodegen"><td>1131<td>                     /// &lt;/summary&gt;
<tr class="nocodegen"><td>1132<td>                     PArray  : TBlowfishKey;
<tr class="nocodegen"><td>1133<td>                     /// &lt;summary&gt;
<tr class="nocodegen"><td>1134<td>                     ///   InitVector or CTR
<tr class="nocodegen"><td>1135<td>                     /// &lt;/summary&gt;
<tr class="nocodegen"><td>1136<td>                     IV      : TBFBlock;
<tr class="nocodegen"><td>1137<td>                     /// &lt;summary&gt;
<tr class="nocodegen"><td>1138<td>                     ///  Working buffer
<tr class="nocodegen"><td>1139<td>                     /// &lt;/summary&gt;
<tr class="nocodegen"><td>1140<td>                     buf     : TBFBlock;
<tr class="nocodegen"><td>1141<td>                     /// &lt;summary&gt;
<tr class="nocodegen"><td>1142<td>                     ///   Bytes used in buf
<tr class="nocodegen"><td>1143<td>                     /// &lt;/summary&gt;
<tr class="nocodegen"><td>1144<td>                     bLen    : UInt16;
<tr class="nocodegen"><td>1145<td>                     /// &lt;summary&gt;
<tr class="nocodegen"><td>1146<td>                     ///   Bit 1: Short block
<tr class="nocodegen"><td>1147<td>                     /// &lt;/summary&gt;
<tr class="nocodegen"><td>1148<td>                     Flag    : UInt16;
<tr class="nocodegen"><td>1149<td>                     /// &lt;summary&gt;
<tr class="nocodegen"><td>1150<td>                     ///   Increment proc CTR-Mode
<tr class="nocodegen"><td>1151<td>                     /// &lt;/summary&gt;
<tr class="nocodegen"><td>1152<td>                     IncProc : TBFIncProc;
<tr class="nocodegen"><td>1153<td>                   end;
<tr class="nocodegen"><td>1154<td>
<tr class="nocodegen"><td>1155<td>      /// &lt;summary&gt;
<tr class="nocodegen"><td>1156<td>      ///   Parts of the BSD/Crypt style password storage for BCrypt
<tr class="nocodegen"><td>1157<td>      /// &lt;/summary&gt;
<tr class="nocodegen"><td>1158<td>      TBCryptBSDData = record
<tr class="nocodegen"><td>1159<td>        /// &lt;summary&gt;
<tr class="nocodegen"><td>1160<td>        ///   Algorithm ID
<tr class="nocodegen"><td>1161<td>        /// &lt;/summary&gt;
<tr class="nocodegen"><td>1162<td>        ID       : string;
<tr class="nocodegen"><td>1163<td>        /// &lt;summary&gt;
<tr class="nocodegen"><td>1164<td>        ///   Salt in Crypt encoding
<tr class="nocodegen"><td>1165<td>        /// &lt;/summary&gt;
<tr class="nocodegen"><td>1166<td>        Salt     : string;
<tr class="nocodegen"><td>1167<td>        /// &lt;summary&gt;
<tr class="nocodegen"><td>1168<td>        ///   Cost factor
<tr class="nocodegen"><td>1169<td>        /// &lt;/summary&gt;
<tr class="nocodegen"><td>1170<td>        Cost     : string;
<tr class="nocodegen"><td>1171<td>      end;
<tr class="nocodegen"><td>1172<td>
<tr class="nocodegen"><td>1173<td>      var
<tr class="nocodegen"><td>1174<td>        /// &lt;summary&gt;
<tr class="nocodegen"><td>1175<td>        ///   The calculated hash value
<tr class="nocodegen"><td>1176<td>        ///   Should have been 192 bit = 24 byte, but original author's
<tr class="nocodegen"><td>1177<td>        ///   imnplementation had a flaw not returning the last byte, which has
<tr class="nocodegen"><td>1178<td>        ///   been kept instead of fixing it. Thus DigestSize returns 23 instead
<tr class="nocodegen"><td>1179<td>        ///   of 24!
<tr class="nocodegen"><td>1180<td>        /// &lt;/summary&gt;
<tr class="nocodegen"><td>1181<td>        FDigest  : array[0..23] of Byte;
<tr class="nocodegen"><td>1182<td>        /// &lt;summary&gt;
<tr class="nocodegen"><td>1183<td>        ///   Context with the working data used by all the initialization and
<tr class="nocodegen"><td>1184<td>        ///   calculation methods
<tr class="nocodegen"><td>1185<td>        /// &lt;/summary&gt;
<tr class="nocodegen"><td>1186<td>        FContext : TBFContext;
<tr class="nocodegen"><td>1187<td>        /// &lt;summary&gt;
<tr class="nocodegen"><td>1188<td>        ///   Cost factor which might be used to adapt the algorithm to increased
<tr class="nocodegen"><td>1189<td>        ///   processing power.
<tr class="nocodegen"><td>1190<td>        /// &lt;/summary&gt;
<tr class="nocodegen"><td>1191<td>        FCost   : UInt8;
<tr class="nocodegen"><td>1192<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1193<td>    ///   Sets the cost factor. Throws an EDECHashException when a value of 0
<tr class="nocodegen"><td>1194<td>    ///   is to be set.
<tr class="nocodegen"><td>1195<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1196<td>    /// &lt;exception cref=&quot;EDECHashException&quot;&gt;
<tr class="nocodegen"><td>1197<td>    ///   Exception raised if &lt;c&gt;Value&lt;/c&gt; is lower than &lt;c&gt;MinCost&lt;/c&gt; or
<tr class="nocodegen"><td>1198<td>    ///   higher than &lt;c&gt;MaxCost&lt;/c&gt;.
<tr class="nocodegen"><td>1199<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>1200<td>    procedure SetCost(const Value: UInt8);
<tr class="nocodegen"><td>1201<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1202<td>    ///   Special setup for the bcrypt variant of the blowfish implementation.
<tr class="nocodegen"><td>1203<td>    ///   Designed to be unavoidably slow.
<tr class="nocodegen"><td>1204<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1205<td>    /// &lt;param name=&quot;Password&quot;&gt;
<tr class="nocodegen"><td>1206<td>    ///   Password from which the salt shall be calculated
<tr class="nocodegen"><td>1207<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1208<td>    /// &lt;param name=&quot;PasswordSize&quot;&gt;
<tr class="nocodegen"><td>1209<td>    ///    Length of the password in byte
<tr class="nocodegen"><td>1210<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1211<td>    procedure EksBlowfishSetup(var Password: TBytes;
<tr class="nocodegen"><td>1212<td>                               PasswordSize: Integer);
<tr class="nocodegen"><td>1213<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1214<td>    ///   Expensive key setup for Blowfish
<tr class="nocodegen"><td>1215<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1216<td>    /// &lt;param name=&quot;Salt&quot;&gt;
<tr class="nocodegen"><td>1217<td>    ///   Needed as parameter here as something else than FSalt has to be
<tr class="nocodegen"><td>1218<td>    ///   passed sometimes.
<tr class="nocodegen"><td>1219<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1220<td>    /// &lt;param name=&quot;Password&quot;&gt;
<tr class="nocodegen"><td>1221<td>    ///   Password from which the salt shall be calculated
<tr class="nocodegen"><td>1222<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1223<td>    /// &lt;param name=&quot;PasswordSize&quot;&gt;
<tr class="nocodegen"><td>1224<td>    ///    Length of the password in byte
<tr class="nocodegen"><td>1225<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1226<td>    procedure Expandkey(Salt         : TBytes;
<tr class="nocodegen"><td>1227<td>                        var Password : TBytes;
<tr class="nocodegen"><td>1228<td>                        PasswordSize : Integer);
<tr class="nocodegen"><td>1229<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1230<td>    ///   Encrypt one block (in ECB mode)
<tr class="nocodegen"><td>1231<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1232<td>    procedure BF_Encrypt(const BI: TBFBlock; var BO: TBFBlock);
<tr class="nocodegen"><td>1233<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1234<td>    ///   xors two blocks and returns the result in a 3rd one result in third
<tr class="nocodegen"><td>1235<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1236<td>    /// &lt;param name=&quot;B1&quot;&gt;
<tr class="nocodegen"><td>1237<td>    ///   1st block to xor
<tr class="nocodegen"><td>1238<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1239<td>    /// &lt;param name=&quot;B2&quot;&gt;
<tr class="nocodegen"><td>1240<td>    ///   2nd block to xor
<tr class="nocodegen"><td>1241<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1242<td>    /// &lt;param name=&quot;B3&quot;&gt;
<tr class="nocodegen"><td>1243<td>    ///   Block to store the result in
<tr class="nocodegen"><td>1244<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1245<td>    procedure BF_XorBlock(const B1, B2: TBFBlock; var B3: TBFBlock);
<tr class="nocodegen"><td>1246<td>
<tr class="nocodegen"><td>1247<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1248<td>    ///   Splits a given Crypt/BSD style password record into its parts
<tr class="nocodegen"><td>1249<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1250<td>    /// &lt;param name=&quot;Vector&quot;&gt;
<tr class="nocodegen"><td>1251<td>    ///   Data to split
<tr class="nocodegen"><td>1252<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1253<td>    /// &lt;param name=&quot;SplittedData&quot;&gt;
<tr class="nocodegen"><td>1254<td>    ///   Data splitted in ID, Cost and Salt
<tr class="nocodegen"><td>1255<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1256<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>1257<td>    ///   true if splitting resulted in the right number of parts,
<tr class="nocodegen"><td>1258<td>    ///   otherwise false
<tr class="nocodegen"><td>1259<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>1260<td>    function SplitTestVector(const Vector     : string;
<tr class="nocodegen"><td>1261<td>                             var SplittedData : TBCryptBSDData):Boolean;
<tr class="nocodegen"><td>1262<td>  strict protected
<tr class="nocodegen"><td>1263<td>    procedure DoInit; override;
<tr class="nocodegen"><td>1264<td>    procedure DoTransform(Buffer: PUInt32Array); override;
<tr class="nocodegen"><td>1265<td>    procedure DoDone; override;
<tr class="nocodegen"><td>1266<td>
<tr class="nocodegen"><td>1267<td>    {$Region CryptFormat}
<tr class="nocodegen"><td>1268<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1269<td>    ///   Returns the ID code for Crypt/BSD like storing of passwords.
<tr class="nocodegen"><td>1270<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1271<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>1272<td>    ///   A Crypt/BSD ID
<tr class="nocodegen"><td>1273<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>1274<td>    class function GetCryptID:string; override;
<tr class="nocodegen"><td>1275<td>
<tr class="nocodegen"><td>1276<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1277<td>    ///   Returns the parameters required for the crypt-like password storing
<tr class="nocodegen"><td>1278<td>    ///   in that format.
<tr class="nocodegen"><td>1279<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1280<td>    /// &lt;param name=&quot;Params&quot;&gt;
<tr class="nocodegen"><td>1281<td>    ///   In case of BCrypt this has to be the numeric integer value of &quot;Cost&quot;.
<tr class="nocodegen"><td>1282<td>    ///   This method will ensure it is prefixed with 0 when having too few chars
<tr class="nocodegen"><td>1283<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1284<td>    /// &lt;param name=&quot;Format&quot;&gt;
<tr class="nocodegen"><td>1285<td>    ///   Format class for formatting the output
<tr class="nocodegen"><td>1286<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1287<td>    function GetCryptParams(const Params : string;
<tr class="nocodegen"><td>1288<td>                            Format : TDECFormatClass):string; override;
<tr class="nocodegen"><td>1289<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1290<td>    ///   Returns the hash required for the crypt-like password storing
<tr class="nocodegen"><td>1291<td>    ///   in that format. If a salt etc. is needed that needs to be specified
<tr class="nocodegen"><td>1292<td>    ///   before calling this method.
<tr class="nocodegen"><td>1293<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1294<td>    /// &lt;param name=&quot;Password&quot;&gt;
<tr class="nocodegen"><td>1295<td>    ///   Password entered which shall be hashed.
<tr class="nocodegen"><td>1296<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1297<td>    /// &lt;param name=&quot;Params&quot;&gt;
<tr class="nocodegen"><td>1298<td>    ///   In case of BCrypt this has to be the numeric integer value of &quot;Cost&quot;
<tr class="nocodegen"><td>1299<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1300<td>    /// &lt;param name=&quot;Salt&quot;&gt;
<tr class="nocodegen"><td>1301<td>    ///   Salt value used by the password hash calculation in binary raw format,
<tr class="nocodegen"><td>1302<td>    ///   means not Radix64 encoded or so.
<tr class="nocodegen"><td>1303<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1304<td>    /// &lt;param name=&quot;Format&quot;&gt;
<tr class="nocodegen"><td>1305<td>    ///   Format class for formatting the output
<tr class="nocodegen"><td>1306<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1307<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>1308<td>    ///   Calculated hash value
<tr class="nocodegen"><td>1309<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>1310<td>    function GetCryptHash(Password     : TBytes;
<tr class="nocodegen"><td>1311<td>                          const Params : string;
<tr class="nocodegen"><td>1312<td>                          const Salt   : TBytes;
<tr class="nocodegen"><td>1313<td>                          Format       : TDECFormatClass):string; override;
<tr class="nocodegen"><td>1314<td>    {$EndRegion}
<tr class="nocodegen"><td>1315<td>  public
<tr class="nocodegen"><td>1316<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1317<td>    ///   Initialize internal fields
<tr class="nocodegen"><td>1318<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1319<td>    constructor Create; override;
<tr class="nocodegen"><td>1320<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1321<td>    ///   Returns the maximum supported length of the salt value in byte
<tr class="nocodegen"><td>1322<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1323<td>    function MaxSaltLength:UInt8; override;
<tr class="nocodegen"><td>1324<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1325<td>    ///   Returns the minimum supported length of the salt value in byte
<tr class="nocodegen"><td>1326<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1327<td>    function MinSaltLength:UInt8; override;
<tr class="nocodegen"><td>1328<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1329<td>    ///   Returns the maximum length of a user supplied password given for the
<tr class="nocodegen"><td>1330<td>    ///   algorithm in byte
<tr class="nocodegen"><td>1331<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1332<td>    /// &lt;remarks&gt;
<tr class="nocodegen"><td>1333<td>    ///   For BCrypt version &quot;2a&quot; it is specified that the password ends with a
<tr class="nocodegen"><td>1334<td>    ///   null-terminator, which will be added internally in our implementation
<tr class="nocodegen"><td>1335<td>    /// &lt;/remarks&gt;
<tr class="nocodegen"><td>1336<td>    class function MaxPasswordLength:UInt8; override;
<tr class="nocodegen"><td>1337<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1338<td>    ///   Returns the minimum allowed value for the Cost property
<tr class="nocodegen"><td>1339<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1340<td>    function MinCost:UInt8;
<tr class="nocodegen"><td>1341<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1342<td>    ///   Returns the maximum allowed value for the Cost property
<tr class="nocodegen"><td>1343<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1344<td>    function MaxCost:UInt8;
<tr class="nocodegen"><td>1345<td>
<tr class="nocodegen"><td>1346<td>//    /// &lt;summary&gt;
<tr class="nocodegen"><td>1347<td>//    ///   Checks whether a given password is the correct one for a password
<tr class="nocodegen"><td>1348<td>//    ///   storage &quot;record&quot;/entry in Crypt/BSD format.
<tr class="nocodegen"><td>1349<td>//    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1350<td>//    /// &lt;param name=&quot;Password&quot;&gt;
<tr class="nocodegen"><td>1351<td>//    ///   Password to check for validity
<tr class="nocodegen"><td>1352<td>//    /// &lt;/param&gt;
<tr class="nocodegen"><td>1353<td>//    /// &lt;param name=&quot;CryptData&quot;&gt;
<tr class="nocodegen"><td>1354<td>//    ///   The data needed to &quot;compare&quot; the password against in Crypt/BSD like
<tr class="nocodegen"><td>1355<td>//    ///   format: $&lt;id&gt;[$&lt;param&gt;=&lt;value&gt;(,&lt;param&gt;=&lt;value&gt;)*][$&lt;salt&gt;[$&lt;hash&gt;]]
<tr class="nocodegen"><td>1356<td>//    /// &lt;/param&gt;
<tr class="nocodegen"><td>1357<td>//    /// &lt;param name=&quot;Format&quot;&gt;
<tr class="nocodegen"><td>1358<td>//    ///   Must be the right type for the Crypt/BSD encoding used by the
<tr class="nocodegen"><td>1359<td>//    ///   algorithm used. This was implemented this way to avoid making the
<tr class="nocodegen"><td>1360<td>//    ///   DECHashAuthentication unit dependant on the DECFormat unit not needed
<tr class="nocodegen"><td>1361<td>//    ///   otherwise.
<tr class="nocodegen"><td>1362<td>//    /// &lt;/param&gt;
<tr class="nocodegen"><td>1363<td>//    /// &lt;returns&gt;
<tr class="nocodegen"><td>1364<td>//    ///    True if the password given is correct.
<tr class="nocodegen"><td>1365<td>//    /// &lt;/returns&gt;
<tr class="nocodegen"><td>1366<td>//    function IsValidPassword(const Password  : string;
<tr class="nocodegen"><td>1367<td>//                             const CryptData : string;
<tr class="nocodegen"><td>1368<td>//                             Format          : TDECFormatClass): Boolean; override;
<tr class="nocodegen"><td>1369<td>
<tr class="nocodegen"><td>1370<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1371<td>    ///   Checks whether a given password is the correct one for a password
<tr class="nocodegen"><td>1372<td>    ///   storage &quot;record&quot;/entry in Crypt/BSD format.
<tr class="nocodegen"><td>1373<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1374<td>    /// &lt;param name=&quot;Password&quot;&gt;
<tr class="nocodegen"><td>1375<td>    ///   Password to check for validity
<tr class="nocodegen"><td>1376<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1377<td>    /// &lt;param name=&quot;CryptData&quot;&gt;
<tr class="nocodegen"><td>1378<td>    ///   The data needed to &quot;compare&quot; the password against in Crypt/BSD like
<tr class="nocodegen"><td>1379<td>    ///   format: $&lt;id&gt;[$&lt;param&gt;=&lt;value&gt;(,&lt;param&gt;=&lt;value&gt;)*][$&lt;salt&gt;[$&lt;hash&gt;]]
<tr class="nocodegen"><td>1380<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1381<td>    /// &lt;param name=&quot;Format&quot;&gt;
<tr class="nocodegen"><td>1382<td>    ///   Must be the right type for the Crypt/BSD encoding used by the
<tr class="nocodegen"><td>1383<td>    ///   algorithm used. This was implemented this way to avoid making the
<tr class="nocodegen"><td>1384<td>    ///   DECHashAuthentication unit dependant on the DECFormat unit not needed
<tr class="nocodegen"><td>1385<td>    ///   otherwise.
<tr class="nocodegen"><td>1386<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1387<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>1388<td>    ///    True if the password given is correct.
<tr class="nocodegen"><td>1389<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>1390<td>    function IsValidPassword(Password        : TBytes;
<tr class="nocodegen"><td>1391<td>                             const CryptData : string;
<tr class="nocodegen"><td>1392<td>                             Format          : TDECFormatClass): Boolean; override;
<tr class="nocodegen"><td>1393<td>
<tr class="nocodegen"><td>1394<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1395<td>    ///   Processes one chunk of data to be hashed.
<tr class="nocodegen"><td>1396<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1397<td>    /// &lt;param name=&quot;Data&quot;&gt;
<tr class="nocodegen"><td>1398<td>    ///   Data on which the hash value shall be calculated on
<tr class="nocodegen"><td>1399<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1400<td>    /// &lt;param name=&quot;DataSize&quot;&gt;
<tr class="nocodegen"><td>1401<td>    ///   Size of the data in bytes
<tr class="nocodegen"><td>1402<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>1403<td>    /// &lt;exception cref=&quot;EDECHashException&quot;&gt;
<tr class="nocodegen"><td>1404<td>    ///   Exception raised if &lt;c&gt;DataSize&lt;/c&gt; is higher than
<tr class="nocodegen"><td>1405<td>    ///   &lt;c&gt;MaxPasswordLength&lt;/c&gt; or if a salt with a different length than
<tr class="nocodegen"><td>1406<td>    ///   128 bit has been specified.
<tr class="nocodegen"><td>1407<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>1408<td>    procedure Calc(const Data; DataSize: Integer); override;
<tr class="nocodegen"><td>1409<td>
<tr class="nocodegen"><td>1410<td>    function Digest: PByteArray; override;
<tr class="nocodegen"><td>1411<td>    class function DigestSize: UInt32; override;
<tr class="nocodegen"><td>1412<td>    class function BlockSize: UInt32; override;
<tr class="nocodegen"><td>1413<td>
<tr class="nocodegen"><td>1414<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>1415<td>    ///   Defines the cost factor of the calculation. Real factor will be 2^Cost.
<tr class="nocodegen"><td>1416<td>    ///   This is used to adapt to increasing CPU power and must be stored along
<tr class="nocodegen"><td>1417<td>    ///   with the hash value and salt to be able to verify a password against it.
<tr class="nocodegen"><td>1418<td>    ///   Value must be between 4 and 31, other values will raise a
<tr class="nocodegen"><td>1419<td>    ///   EDECHashException
<tr class="nocodegen"><td>1420<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>1421<td>    /// &lt;exception cref=&quot;EDECHashException&quot;&gt;
<tr class="nocodegen"><td>1422<td>    ///   Exception raised if a value outside of the range 4..31 is given.
<tr class="nocodegen"><td>1423<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>1424<td>    property Cost: UInt8
<tr class="nocodegen"><td>1425<td>      read   FCost
<tr class="nocodegen"><td>1426<td>      write  SetCost;
<tr class="nocodegen"><td>1427<td>  end;
<tr class="nocodegen"><td>1428<td>
<tr class="nocodegen"><td>1429<td>implementation
<tr class="nocodegen"><td>1430<td>
<tr class="nocodegen"><td>1431<td>{$IFOPT Q+}{$DEFINE RESTORE_OVERFLOWCHECKS}{$Q-}{$ENDIF}
<tr class="nocodegen"><td>1432<td>{$IFOPT R+}{$DEFINE RESTORE_RANGECHECKS}{$R-}{$ENDIF}
<tr class="nocodegen"><td>1433<td>
<tr class="nocodegen"><td>1434<td>uses
<tr class="nocodegen"><td>1435<td>  DECData, DECDataHash;
<tr class="nocodegen"><td>1436<td>
<tr class="nocodegen"><td>1437<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>1438<td>  {$DEFINE INCLUDED} // allows having the DECHash.inc in the IDE's project manager
<tr class="nocodegen"><td>1439<td>  {$INCLUDE DECHash.asm86.inc}
<tr class="nocodegen"><td>1440<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>1441<td>
<tr class="nocodegen"><td>1442<td>{ Speed comparison of ASM vs. PurePascal Implementation. Valid only for Win32 compiler
<tr class="nocodegen"><td>1443<td>  and this was for DEC 5.1 and thus compiler versions &lt; D2009!
<tr class="nocodegen"><td>1444<td>
<tr class="nocodegen"><td>1445<td>                                           assembler                             pascal
<tr class="nocodegen"><td>1446<td>
<tr class="nocodegen"><td>1447<td>  THash_SHA512    :       85.1 cycles/byte      17.62 Mb/sec      220.9 cycles/byte       6.79 Mb/sec  159%
<tr class="nocodegen"><td>1448<td>  THash_SHA384    :       85.2 cycles/byte      17.61 Mb/sec      220.0 cycles/byte       6.82 Mb/sec  158%
<tr class="nocodegen"><td>1449<td>  THash_Tiger     :       24.6 cycles/byte      60.98 Mb/sec       60.7 cycles/byte      24.69 Mb/sec  147%
<tr class="nocodegen"><td>1450<td>  THash_Haval128  :       13.3 cycles/byte     112.55 Mb/sec       26.0 cycles/byte      57.77 Mb/sec   95%
<tr class="nocodegen"><td>1451<td>  THash_SHA1      :       20.1 cycles/byte      74.80 Mb/sec       36.1 cycles/byte      41.51 Mb/sec   80%
<tr class="nocodegen"><td>1452<td>  THash_SHA       :       20.0 cycles/byte      75.03 Mb/sec       35.5 cycles/byte      42.21 Mb/sec   78%
<tr class="nocodegen"><td>1453<td>  THash_Haval160  :       13.2 cycles/byte     113.30 Mb/sec       22.7 cycles/byte      66.12 Mb/sec   71%
<tr class="nocodegen"><td>1454<td>  THash_Haval256  :       25.9 cycles/byte      57.84 Mb/sec       40.5 cycles/byte      37.07 Mb/sec   56%
<tr class="nocodegen"><td>1455<td>  THash_Snefru128 :      159.7 cycles/byte       9.39 Mb/sec      248.2 cycles/byte       6.04 Mb/sec   55%
<tr class="nocodegen"><td>1456<td>  THash_Snefru256 :      239.3 cycles/byte       6.27 Mb/sec      367.9 cycles/byte       4.08 Mb/sec   54%
<tr class="nocodegen"><td>1457<td>  THash_RipeMD256 :       14.5 cycles/byte     103.16 Mb/sec       21.4 cycles/byte      70.08 Mb/sec   47%
<tr class="nocodegen"><td>1458<td>  THash_MD4       :        5.8 cycles/byte     256.73 Mb/sec        8.5 cycles/byte     176.92 Mb/sec   45%
<tr class="nocodegen"><td>1459<td>
<tr class="nocodegen"><td>1460<td>  THash_MD2       :      251.6 cycles/byte       5.96 Mb/sec      366.1 cycles/byte       4.10 Mb/sec   45%
<tr class="nocodegen"><td>1461<td>  THash_RipeMD128 :       15.2 cycles/byte      98.89 Mb/sec       21.2 cycles/byte      70.61 Mb/sec   40%
<tr class="nocodegen"><td>1462<td>  THash_RipeMD320 :       25.5 cycles/byte      58.73 Mb/sec       35.8 cycles/byte      41.87 Mb/sec   40%
<tr class="nocodegen"><td>1463<td>  THash_MD5       :        8.9 cycles/byte     169.43 Mb/sec       11.4 cycles/byte     131.01 Mb/sec   29%
<tr class="nocodegen"><td>1464<td>  THash_RipeMD160 :       26.5 cycles/byte      56.66 Mb/sec       31.4 cycles/byte      47.79 Mb/sec   19%
<tr class="nocodegen"><td>1465<td>  THash_Square    :       44.7 cycles/byte      33.58 Mb/sec       53.1 cycles/byte      28.23 Mb/sec   19%
<tr class="nocodegen"><td>1466<td>  THash_Haval192  :       32.5 cycles/byte      46.17 Mb/sec       37.6 cycles/byte      39.87 Mb/sec   18%
<tr class="nocodegen"><td>1467<td>  THash_WhirlpoolT:      104.9 cycles/byte      14.30 Mb/sec      122.8 cycles/byte      12.22 Mb/sec   17%
<tr class="nocodegen"><td>1468<td>  THash_Whirlpool0:      104.7 cycles/byte      14.33 Mb/sec      119.9 cycles/byte      12.51 Mb/sec   15%
<tr class="nocodegen"><td>1469<td>  THash_Sapphire  :       52.9 cycles/byte      28.35 Mb/sec       53.8 cycles/byte      27.86 Mb/sec    2%
<tr class="nocodegen"><td>1470<td>  THash_Haval224  :       32.0 cycles/byte      46.82 Mb/sec       32.3 cycles/byte      46.46 Mb/sec    1%
<tr class="nocodegen"><td>1471<td>  THash_SHA256    :       47.8 cycles/byte      31.35 Mb/sec       47.8 cycles/byte      31.39 Mb/sec    0%
<tr class="nocodegen"><td>1472<td>  THash_Panama    :        8.9 cycles/byte     169.01 Mb/sec        7.3 cycles/byte     206.55 Mb/sec  -18%
<tr class="nocodegen"><td>1473<td>}
<tr class="nocodegen"><td>1474<td>
<tr class="nocodegen"><td>1475<td>resourcestring
<tr class="nocodegen"><td>1476<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1477<td>  ///   Failure message when a hash algorithm is initialized with wrong parameters
<tr class="nocodegen"><td>1478<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1479<td>  sHashInitFailure   = 'Invalid %0:s algorithm initialization parameters '+
<tr class="nocodegen"><td>1480<td>                       'specified: %1:s';
<tr class="nocodegen"><td>1481<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1482<td>  ///   Failure message when absorb is callt with a bitlength not divideable by 8
<tr class="nocodegen"><td>1483<td>  ///   without reminder or when it is called while already in squeezing state
<tr class="nocodegen"><td>1484<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1485<td>  sSHA3AbsorbFailure = 'Absorb: number of bits mod 8 &lt;&gt; 0 or squeezing active. '+
<tr class="nocodegen"><td>1486<td>                       'Bits: %0:d, Squeezing: %1:s';
<tr class="nocodegen"><td>1487<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1488<td>  ///   Part of the failure message shown when setting HashSize of Shake
<tr class="nocodegen"><td>1489<td>  ///   algorithms to 0.
<tr class="nocodegen"><td>1490<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1491<td>  sHashOutputLength0 = 'HashSize must not be 0';
<tr class="nocodegen"><td>1492<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1493<td>  ///   Some password hash algorithms have a cost factor to be able to adopt
<tr class="nocodegen"><td>1494<td>  ///   them to increasing CPU power. This text is the exception message when
<tr class="nocodegen"><td>1495<td>  ///   the user specifies 0 for this.
<tr class="nocodegen"><td>1496<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1497<td>  sCostFactorInvalid = 'Specified cost factor must be in the range of %0:d-%1:d';
<tr class="nocodegen"><td>1498<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1499<td>  ///   Exception message for password hashes when a too long password is specified
<tr class="nocodegen"><td>1500<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1501<td>  sPasswordTooLong   = 'Password to be hashed is too long. Max. length: %0:d bytes';
<tr class="nocodegen"><td>1502<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>1503<td>  ///   Exception message for password hashes requiring a salt when a salt value
<tr class="nocodegen"><td>1504<td>  ///   which is either too short or too long has been specified
<tr class="nocodegen"><td>1505<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>1506<td>  sWrongSaltLength   = 'Length of specified salt value must be between %0:d '+
<tr class="nocodegen"><td>1507<td>                       'and %1:d bytes';
<tr class="nocodegen"><td>1508<td>
<tr class="nocodegen"><td>1509<td>{ THash_MD2 }
<tr class="nocodegen"><td>1510<td>
<tr class="nocodegen"><td>1511<td>{$IFNDEF THash_MD2_asm}
<tr class="nocodegen"><td>1512<td>procedure THash_MD2.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>1513<td>var
<tr class="nocodegen"><td>1514<td>  I, J, T: UInt32;
<tr class="covered"><td>1515<td>begin
<tr class="covered"><td>1516<td>  for I := 0 to 3 do
<tr class="nocodegen"><td>1517<td>  begin
<tr class="covered"><td>1518<td>    PUInt32Array(@FDigest[16])[I] := Buffer[I];
<tr class="covered"><td>1519<td>    PUInt32Array(@FDigest[32])[I] := PUInt32Array(@FDigest[0])[I] xor PUInt32Array(@FDigest[16])[I];
<tr class="covered"><td>1520<td>  end;
<tr class="covered"><td>1521<td>  T := FDigest[63];
<tr class="covered"><td>1522<td>  for I := 0 to 15 do
<tr class="nocodegen"><td>1523<td>  begin
<tr class="covered"><td>1524<td>    T := FDigest[I + 48] xor MD2_PISubst[FDigest[I + 16] xor Byte(T)];
<tr class="covered"><td>1525<td>    FDigest[I + 48] := Byte(T);
<tr class="covered"><td>1526<td>  end;
<tr class="covered"><td>1527<td>  T := 0;
<tr class="covered"><td>1528<td>  for I := 0 to 17 do
<tr class="nocodegen"><td>1529<td>  begin
<tr class="covered"><td>1530<td>    for J := 0 to 47 do
<tr class="nocodegen"><td>1531<td>    begin
<tr class="covered"><td>1532<td>      T := FDigest[J] xor MD2_PISubst[T];
<tr class="covered"><td>1533<td>      FDigest[J] := Byte(T);
<tr class="covered"><td>1534<td>    end;
<tr class="covered"><td>1535<td>    T := (T + I) and $FF;
<tr class="covered"><td>1536<td>  end;
<tr class="covered"><td>1537<td>end;
<tr class="nocodegen"><td>1538<td>{$ENDIF !THash_MD2_asm}
<tr class="nocodegen"><td>1539<td>
<tr class="nocodegen"><td>1540<td>procedure THash_MD2.DoInit;
<tr class="covered"><td>1541<td>begin
<tr class="covered"><td>1542<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>1543<td>end;
<tr class="nocodegen"><td>1544<td>
<tr class="nocodegen"><td>1545<td>procedure THash_MD2.DoDone;
<tr class="nocodegen"><td>1546<td>var
<tr class="nocodegen"><td>1547<td>  Remain: Integer;
<tr class="covered"><td>1548<td>begin
<tr class="covered"><td>1549<td>  Remain := FBufferSize - FBufferIndex;
<tr class="covered"><td>1550<td>  FillChar(FBuffer[FBufferIndex], Remain, Remain);
<tr class="covered"><td>1551<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>1552<td>  Move(FDigest[48], FBuffer^, FBufferSize);
<tr class="covered"><td>1553<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>1554<td>end;
<tr class="nocodegen"><td>1555<td>
<tr class="nocodegen"><td>1556<td>function THash_MD2.Digest: PByteArray;
<tr class="covered"><td>1557<td>begin
<tr class="covered"><td>1558<td>  Result := @FDigest;
<tr class="covered"><td>1559<td>end;
<tr class="nocodegen"><td>1560<td>
<tr class="nocodegen"><td>1561<td>class function THash_MD2.DigestSize: UInt32;
<tr class="covered"><td>1562<td>begin
<tr class="covered"><td>1563<td>  Result := 16;
<tr class="covered"><td>1564<td>end;
<tr class="nocodegen"><td>1565<td>
<tr class="nocodegen"><td>1566<td>class function THash_MD2.BlockSize: UInt32;
<tr class="covered"><td>1567<td>begin
<tr class="covered"><td>1568<td>  Result := 16;
<tr class="covered"><td>1569<td>end;
<tr class="nocodegen"><td>1570<td>
<tr class="nocodegen"><td>1571<td>{ THashBaseMD4 }
<tr class="nocodegen"><td>1572<td>
<tr class="nocodegen"><td>1573<td>procedure THashBaseMD4.DoInit;
<tr class="covered"><td>1574<td>begin
<tr class="covered"><td>1575<td>  FDigest[0] := $67452301;
<tr class="covered"><td>1576<td>  FDigest[1] := $EFCDAB89;
<tr class="covered"><td>1577<td>  FDigest[2] := $98BADCFE;
<tr class="covered"><td>1578<td>  FDigest[3] := $10325476;
<tr class="covered"><td>1579<td>  FDigest[4] := $C3D2E1F0;
<tr class="covered"><td>1580<td>  FDigest[5] := $76543210;
<tr class="covered"><td>1581<td>  FDigest[6] := $FEDCBA98;
<tr class="covered"><td>1582<td>  FDigest[7] := $89ABCDEF;
<tr class="covered"><td>1583<td>  FDigest[8] := $01234567;
<tr class="covered"><td>1584<td>  FDigest[9] := $3C2D1E0F;
<tr class="covered"><td>1585<td>end;
<tr class="nocodegen"><td>1586<td>
<tr class="nocodegen"><td>1587<td>procedure THashBaseMD4.DoDone;
<tr class="covered"><td>1588<td>begin
<tr class="covered"><td>1589<td>  if FCount[2] or FCount[3] &lt;&gt; 0 then
<tr class="notcovered"><td>1590<td>    RaiseHashOverflowError;
<tr class="covered"><td>1591<td>  if FPaddingByte = 0 then
<tr class="covered"><td>1592<td>    FPaddingByte := $80;
<tr class="covered"><td>1593<td>  FBuffer[FBufferIndex] := FPaddingByte;
<tr class="covered"><td>1594<td>  Inc(FBufferIndex);
<tr class="covered"><td>1595<td>  if FBufferIndex &gt; FBufferSize - 8 then
<tr class="nocodegen"><td>1596<td>  begin
<tr class="covered"><td>1597<td>    FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>1598<td>    DoTransform(Pointer(FBuffer));
<tr class="covered"><td>1599<td>    FBufferIndex := 0;
<tr class="nocodegen"><td>1600<td>  end;
<tr class="covered"><td>1601<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>1602<td>  Move(FCount, FBuffer[FBufferSize - 8], 8);
<tr class="covered"><td>1603<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>1604<td>end;
<tr class="nocodegen"><td>1605<td>
<tr class="nocodegen"><td>1606<td>function THashBaseMD4.Digest: PByteArray;
<tr class="covered"><td>1607<td>begin
<tr class="covered"><td>1608<td>  Result := @FDigest;
<tr class="covered"><td>1609<td>end;
<tr class="nocodegen"><td>1610<td>
<tr class="nocodegen"><td>1611<td>class function THashBaseMD4.DigestSize: UInt32;
<tr class="covered"><td>1612<td>begin
<tr class="covered"><td>1613<td>  Result := 16;
<tr class="covered"><td>1614<td>end;
<tr class="nocodegen"><td>1615<td>
<tr class="nocodegen"><td>1616<td>class function THashBaseMD4.BlockSize: UInt32;
<tr class="covered"><td>1617<td>begin
<tr class="covered"><td>1618<td>  Result := 64;
<tr class="covered"><td>1619<td>end;
<tr class="nocodegen"><td>1620<td>
<tr class="nocodegen"><td>1621<td>{ THash_MD4 }
<tr class="nocodegen"><td>1622<td>
<tr class="nocodegen"><td>1623<td>{$IFNDEF THash_MD4_asm}
<tr class="nocodegen"><td>1624<td>procedure THash_MD4.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>1625<td>const
<tr class="nocodegen"><td>1626<td>  S1 = $5A827999;
<tr class="nocodegen"><td>1627<td>  S2 = $6ED9EBA1;
<tr class="nocodegen"><td>1628<td>var
<tr class="nocodegen"><td>1629<td>  A, B, C, D: UInt32;
<tr class="covered"><td>1630<td>begin
<tr class="covered"><td>1631<td>  A := FDigest[0];
<tr class="covered"><td>1632<td>  B := FDigest[1];
<tr class="covered"><td>1633<td>  C := FDigest[2];
<tr class="covered"><td>1634<td>  D := FDigest[3];
<tr class="nocodegen"><td>1635<td>
<tr class="covered"><td>1636<td>  Inc(A, B and C or not B and D + Buffer[ 0]); A := A shl  3 or A shr 29;
<tr class="covered"><td>1637<td>  Inc(D, A and B or not A and C + Buffer[ 1]); D := D shl  7 or D shr 25;
<tr class="covered"><td>1638<td>  Inc(C, D and A or not D and B + Buffer[ 2]); C := C shl 11 or C shr 21;
<tr class="covered"><td>1639<td>  Inc(B, C and D or not C and A + Buffer[ 3]); B := B shl 19 or B shr 13;
<tr class="covered"><td>1640<td>  Inc(A, B and C or not B and D + Buffer[ 4]); A := A shl  3 or A shr 29;
<tr class="covered"><td>1641<td>  Inc(D, A and B or not A and C + Buffer[ 5]); D := D shl  7 or D shr 25;
<tr class="covered"><td>1642<td>  Inc(C, D and A or not D and B + Buffer[ 6]); C := C shl 11 or C shr 21;
<tr class="covered"><td>1643<td>  Inc(B, C and D or not C and A + Buffer[ 7]); B := B shl 19 or B shr 13;
<tr class="covered"><td>1644<td>  Inc(A, B and C or not B and D + Buffer[ 8]); A := A shl  3 or A shr 29;
<tr class="covered"><td>1645<td>  Inc(D, A and B or not A and C + Buffer[ 9]); D := D shl  7 or D shr 25;
<tr class="covered"><td>1646<td>  Inc(C, D and A or not D and B + Buffer[10]); C := C shl 11 or C shr 21;
<tr class="covered"><td>1647<td>  Inc(B, C and D or not C and A + Buffer[11]); B := B shl 19 or B shr 13;
<tr class="covered"><td>1648<td>  Inc(A, B and C or not B and D + Buffer[12]); A := A shl  3 or A shr 29;
<tr class="covered"><td>1649<td>  Inc(D, A and B or not A and C + Buffer[13]); D := D shl  7 or D shr 25;
<tr class="covered"><td>1650<td>  Inc(C, D and A or not D and B + Buffer[14]); C := C shl 11 or C shr 21;
<tr class="covered"><td>1651<td>  Inc(B, C and D or not C and A + Buffer[15]); B := B shl 19 or B shr 13;
<tr class="nocodegen"><td>1652<td>
<tr class="covered"><td>1653<td>  Inc(A, B and C or B and D or C and D + Buffer[ 0] + S1); A := A shl  3 or A shr 29;
<tr class="covered"><td>1654<td>  Inc(D, A and B or A and C or B and C + Buffer[ 4] + S1); D := D shl  5 or D shr 27;
<tr class="covered"><td>1655<td>  Inc(C, D and A or D and B or A and B + Buffer[ 8] + S1); C := C shl  9 or C shr 23;
<tr class="covered"><td>1656<td>  Inc(B, C and D or C and A or D and A + Buffer[12] + S1); B := B shl 13 or B shr 19;
<tr class="covered"><td>1657<td>  Inc(A, B and C or B and D or C and D + Buffer[ 1] + S1); A := A shl  3 or A shr 29;
<tr class="covered"><td>1658<td>  Inc(D, A and B or A and C or B and C + Buffer[ 5] + S1); D := D shl  5 or D shr 27;
<tr class="covered"><td>1659<td>  Inc(C, D and A or D and B or A and B + Buffer[ 9] + S1); C := C shl  9 or C shr 23;
<tr class="covered"><td>1660<td>  Inc(B, C and D or C and A or D and A + Buffer[13] + S1); B := B shl 13 or B shr 19;
<tr class="covered"><td>1661<td>  Inc(A, B and C or B and D or C and D + Buffer[ 2] + S1); A := A shl  3 or A shr 29;
<tr class="covered"><td>1662<td>  Inc(D, A and B or A and C or B and C + Buffer[ 6] + S1); D := D shl  5 or D shr 27;
<tr class="covered"><td>1663<td>  Inc(C, D and A or D and B or A and B + Buffer[10] + S1); C := C shl  9 or C shr 23;
<tr class="covered"><td>1664<td>  Inc(B, C and D or C and A or D and A + Buffer[14] + S1); B := B shl 13 or B shr 19;
<tr class="covered"><td>1665<td>  Inc(A, B and C or B and D or C and D + Buffer[ 3] + S1); A := A shl  3 or A shr 29;
<tr class="covered"><td>1666<td>  Inc(D, A and B or A and C or B and C + Buffer[ 7] + S1); D := D shl  5 or D shr 27;
<tr class="covered"><td>1667<td>  Inc(C, D and A or D and B or A and B + Buffer[11] + S1); C := C shl  9 or C shr 23;
<tr class="covered"><td>1668<td>  Inc(B, C and D or C and A or D and A + Buffer[15] + S1); B := B shl 13 or B shr 19;
<tr class="nocodegen"><td>1669<td>
<tr class="covered"><td>1670<td>  Inc(A, B xor C xor D + Buffer[ 0] + S2); A := A shl  3 or A shr 29;
<tr class="covered"><td>1671<td>  Inc(D, A xor B xor C + Buffer[ 8] + S2); D := D shl  9 or D shr 23;
<tr class="covered"><td>1672<td>  Inc(C, D xor A xor B + Buffer[ 4] + S2); C := C shl 11 or C shr 21;
<tr class="covered"><td>1673<td>  Inc(B, C xor D xor A + Buffer[12] + S2); B := B shl 15 or B shr 17;
<tr class="covered"><td>1674<td>  Inc(A, B xor C xor D + Buffer[ 2] + S2); A := A shl  3 or A shr 29;
<tr class="covered"><td>1675<td>  Inc(D, A xor B xor C + Buffer[10] + S2); D := D shl  9 or D shr 23;
<tr class="covered"><td>1676<td>  Inc(C, D xor A xor B + Buffer[ 6] + S2); C := C shl 11 or C shr 21;
<tr class="covered"><td>1677<td>  Inc(B, C xor D xor A + Buffer[14] + S2); B := B shl 15 or B shr 17;
<tr class="covered"><td>1678<td>  Inc(A, B xor C xor D + Buffer[ 1] + S2); A := A shl  3 or A shr 29;
<tr class="covered"><td>1679<td>  Inc(D, A xor B xor C + Buffer[ 9] + S2); D := D shl  9 or D shr 23;
<tr class="covered"><td>1680<td>  Inc(C, D xor A xor B + Buffer[ 5] + S2); C := C shl 11 or C shr 21;
<tr class="covered"><td>1681<td>  Inc(B, C xor D xor A + Buffer[13] + S2); B := B shl 15 or B shr 17;
<tr class="covered"><td>1682<td>  Inc(A, B xor C xor D + Buffer[ 3] + S2); A := A shl  3 or A shr 29;
<tr class="covered"><td>1683<td>  Inc(D, A xor B xor C + Buffer[11] + S2); D := D shl  9 or D shr 23;
<tr class="covered"><td>1684<td>  Inc(C, D xor A xor B + Buffer[ 7] + S2); C := C shl 11 or C shr 21;
<tr class="covered"><td>1685<td>  Inc(B, C xor D xor A + Buffer[15] + S2); B := B shl 15 or B shr 17;
<tr class="nocodegen"><td>1686<td>
<tr class="covered"><td>1687<td>  Inc(FDigest[0], A);
<tr class="covered"><td>1688<td>  Inc(FDigest[1], B);
<tr class="covered"><td>1689<td>  Inc(FDigest[2], C);
<tr class="covered"><td>1690<td>  Inc(FDigest[3], D);
<tr class="covered"><td>1691<td>end;
<tr class="nocodegen"><td>1692<td>{$ENDIF}
<tr class="nocodegen"><td>1693<td>
<tr class="nocodegen"><td>1694<td>{ THash_MD5 }
<tr class="nocodegen"><td>1695<td>
<tr class="nocodegen"><td>1696<td>{$IFNDEF THash_MD5_asm}
<tr class="nocodegen"><td>1697<td>procedure THash_MD5.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>1698<td>var
<tr class="nocodegen"><td>1699<td>  A, B, C, D: UInt32;
<tr class="covered"><td>1700<td>begin
<tr class="covered"><td>1701<td>  A := FDigest[0];
<tr class="covered"><td>1702<td>  B := FDigest[1];
<tr class="covered"><td>1703<td>  C := FDigest[2];
<tr class="covered"><td>1704<td>  D := FDigest[3];
<tr class="nocodegen"><td>1705<td>
<tr class="covered"><td>1706<td>  Inc(A, Buffer[ 0] + $D76AA478 + (D xor (B and (C xor D)))); A := A shl  7 or A shr 25 + B;
<tr class="covered"><td>1707<td>  Inc(D, Buffer[ 1] + $E8C7B756 + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;
<tr class="covered"><td>1708<td>  Inc(C, Buffer[ 2] + $242070DB + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;
<tr class="covered"><td>1709<td>  Inc(B, Buffer[ 3] + $C1BDCEEE + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;
<tr class="covered"><td>1710<td>  Inc(A, Buffer[ 4] + $F57C0FAF + (D xor (B and (C xor D)))); A := A shl  7 or A shr 25 + B;
<tr class="covered"><td>1711<td>  Inc(D, Buffer[ 5] + $4787C62A + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;
<tr class="covered"><td>1712<td>  Inc(C, Buffer[ 6] + $A8304613 + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;
<tr class="covered"><td>1713<td>  Inc(B, Buffer[ 7] + $FD469501 + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;
<tr class="covered"><td>1714<td>  Inc(A, Buffer[ 8] + $698098D8 + (D xor (B and (C xor D)))); A := A shl  7 or A shr 25 + B;
<tr class="covered"><td>1715<td>  Inc(D, Buffer[ 9] + $8B44F7AF + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;
<tr class="covered"><td>1716<td>  Inc(C, Buffer[10] + $FFFF5BB1 + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;
<tr class="covered"><td>1717<td>  Inc(B, Buffer[11] + $895CD7BE + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;
<tr class="covered"><td>1718<td>  Inc(A, Buffer[12] + $6B901122 + (D xor (B and (C xor D)))); A := A shl  7 or A shr 25 + B;
<tr class="covered"><td>1719<td>  Inc(D, Buffer[13] + $FD987193 + (C xor (A and (B xor C)))); D := D shl 12 or D shr 20 + A;
<tr class="covered"><td>1720<td>  Inc(C, Buffer[14] + $A679438E + (B xor (D and (A xor B)))); C := C shl 17 or C shr 15 + D;
<tr class="covered"><td>1721<td>  Inc(B, Buffer[15] + $49B40821 + (A xor (C and (D xor A)))); B := B shl 22 or B shr 10 + C;
<tr class="nocodegen"><td>1722<td>
<tr class="covered"><td>1723<td>  Inc(A, Buffer[ 1] + $F61E2562 + (C xor (D and (B xor C)))); A := A shl  5 or A shr 27 + B;
<tr class="covered"><td>1724<td>  Inc(D, Buffer[ 6] + $C040B340 + (B xor (C and (A xor B)))); D := D shl  9 or D shr 23 + A;
<tr class="covered"><td>1725<td>  Inc(C, Buffer[11] + $265E5A51 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;
<tr class="covered"><td>1726<td>  Inc(B, Buffer[ 0] + $E9B6C7AA + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;
<tr class="covered"><td>1727<td>  Inc(A, Buffer[ 5] + $D62F105D + (C xor (D and (B xor C)))); A := A shl  5 or A shr 27 + B;
<tr class="covered"><td>1728<td>  Inc(D, Buffer[10] + $02441453 + (B xor (C and (A xor B)))); D := D shl  9 or D shr 23 + A;
<tr class="covered"><td>1729<td>  Inc(C, Buffer[15] + $D8A1E681 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;
<tr class="covered"><td>1730<td>  Inc(B, Buffer[ 4] + $E7D3FBC8 + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;
<tr class="covered"><td>1731<td>  Inc(A, Buffer[ 9] + $21E1CDE6 + (C xor (D and (B xor C)))); A := A shl  5 or A shr 27 + B;
<tr class="covered"><td>1732<td>  Inc(D, Buffer[14] + $C33707D6 + (B xor (C and (A xor B)))); D := D shl  9 or D shr 23 + A;
<tr class="covered"><td>1733<td>  Inc(C, Buffer[ 3] + $F4D50D87 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;
<tr class="covered"><td>1734<td>  Inc(B, Buffer[ 8] + $455A14ED + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;
<tr class="covered"><td>1735<td>  Inc(A, Buffer[13] + $A9E3E905 + (C xor (D and (B xor C)))); A := A shl  5 or A shr 27 + B;
<tr class="covered"><td>1736<td>  Inc(D, Buffer[ 2] + $FCEFA3F8 + (B xor (C and (A xor B)))); D := D shl  9 or D shr 23 + A;
<tr class="covered"><td>1737<td>  Inc(C, Buffer[ 7] + $676F02D9 + (A xor (B and (D xor A)))); C := C shl 14 or C shr 18 + D;
<tr class="covered"><td>1738<td>  Inc(B, Buffer[12] + $8D2A4C8A + (D xor (A and (C xor D)))); B := B shl 20 or B shr 12 + C;
<tr class="nocodegen"><td>1739<td>
<tr class="covered"><td>1740<td>  Inc(A, Buffer[ 5] + $FFFA3942 + (B xor C xor D)); A := A shl  4 or A shr 28 + B;
<tr class="covered"><td>1741<td>  Inc(D, Buffer[ 8] + $8771F681 + (A xor B xor C)); D := D shl 11 or D shr 21 + A;
<tr class="covered"><td>1742<td>  Inc(C, Buffer[11] + $6D9D6122 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;
<tr class="covered"><td>1743<td>  Inc(B, Buffer[14] + $FDE5380C + (C xor D xor A)); B := B shl 23 or B shr  9 + C;
<tr class="covered"><td>1744<td>  Inc(A, Buffer[ 1] + $A4BEEA44 + (B xor C xor D)); A := A shl  4 or A shr 28 + B;
<tr class="covered"><td>1745<td>  Inc(D, Buffer[ 4] + $4BDECFA9 + (A xor B xor C)); D := D shl 11 or D shr 21 + A;
<tr class="covered"><td>1746<td>  Inc(C, Buffer[ 7] + $F6BB4B60 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;
<tr class="covered"><td>1747<td>  Inc(B, Buffer[10] + $BEBFBC70 + (C xor D xor A)); B := B shl 23 or B shr  9 + C;
<tr class="covered"><td>1748<td>  Inc(A, Buffer[13] + $289B7EC6 + (B xor C xor D)); A := A shl  4 or A shr 28 + B;
<tr class="covered"><td>1749<td>  Inc(D, Buffer[ 0] + $EAA127FA + (A xor B xor C)); D := D shl 11 or D shr 21 + A;
<tr class="covered"><td>1750<td>  Inc(C, Buffer[ 3] + $D4EF3085 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;
<tr class="covered"><td>1751<td>  Inc(B, Buffer[ 6] + $04881D05 + (C xor D xor A)); B := B shl 23 or B shr  9 + C;
<tr class="covered"><td>1752<td>  Inc(A, Buffer[ 9] + $D9D4D039 + (B xor C xor D)); A := A shl  4 or A shr 28 + B;
<tr class="covered"><td>1753<td>  Inc(D, Buffer[12] + $E6DB99E5 + (A xor B xor C)); D := D shl 11 or D shr 21 + A;
<tr class="covered"><td>1754<td>  Inc(C, Buffer[15] + $1FA27CF8 + (D xor A xor B)); C := C shl 16 or C shr 16 + D;
<tr class="covered"><td>1755<td>  Inc(B, Buffer[ 2] + $C4AC5665 + (C xor D xor A)); B := B shl 23 or B shr  9 + C;
<tr class="nocodegen"><td>1756<td>
<tr class="covered"><td>1757<td>  Inc(A, Buffer[ 0] + $F4292244 + (C xor (B or not D))); A := A shl  6 or A shr 26 + B;
<tr class="covered"><td>1758<td>  Inc(D, Buffer[ 7] + $432AFF97 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;
<tr class="covered"><td>1759<td>  Inc(C, Buffer[14] + $AB9423A7 + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;
<tr class="covered"><td>1760<td>  Inc(B, Buffer[ 5] + $FC93A039 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;
<tr class="covered"><td>1761<td>  Inc(A, Buffer[12] + $655B59C3 + (C xor (B or not D))); A := A shl  6 or A shr 26 + B;
<tr class="covered"><td>1762<td>  Inc(D, Buffer[ 3] + $8F0CCC92 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;
<tr class="covered"><td>1763<td>  Inc(C, Buffer[10] + $FFEFF47D + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;
<tr class="covered"><td>1764<td>  Inc(B, Buffer[ 1] + $85845DD1 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;
<tr class="covered"><td>1765<td>  Inc(A, Buffer[ 8] + $6FA87E4F + (C xor (B or not D))); A := A shl  6 or A shr 26 + B;
<tr class="covered"><td>1766<td>  Inc(D, Buffer[15] + $FE2CE6E0 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;
<tr class="covered"><td>1767<td>  Inc(C, Buffer[ 6] + $A3014314 + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;
<tr class="covered"><td>1768<td>  Inc(B, Buffer[13] + $4E0811A1 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;
<tr class="covered"><td>1769<td>  Inc(A, Buffer[ 4] + $F7537E82 + (C xor (B or not D))); A := A shl  6 or A shr 26 + B;
<tr class="covered"><td>1770<td>  Inc(D, Buffer[11] + $BD3AF235 + (B xor (A or not C))); D := D shl 10 or D shr 22 + A;
<tr class="covered"><td>1771<td>  Inc(C, Buffer[ 2] + $2AD7D2BB + (A xor (D or not B))); C := C shl 15 or C shr 17 + D;
<tr class="covered"><td>1772<td>  Inc(B, Buffer[ 9] + $EB86D391 + (D xor (C or not A))); B := B shl 21 or B shr 11 + C;
<tr class="nocodegen"><td>1773<td>
<tr class="covered"><td>1774<td>  Inc(FDigest[0], A);
<tr class="covered"><td>1775<td>  Inc(FDigest[1], B);
<tr class="covered"><td>1776<td>  Inc(FDigest[2], C);
<tr class="covered"><td>1777<td>  Inc(FDigest[3], D);
<tr class="covered"><td>1778<td>end;
<tr class="nocodegen"><td>1779<td>{$ENDIF}
<tr class="nocodegen"><td>1780<td>
<tr class="nocodegen"><td>1781<td>{ THash_RipeMD128 }
<tr class="nocodegen"><td>1782<td>
<tr class="nocodegen"><td>1783<td>{$IFNDEF X86ASM}
<tr class="nocodegen"><td>1784<td>const
<tr class="nocodegen"><td>1785<td>  RipeS1 = $5A827999;
<tr class="nocodegen"><td>1786<td>  RipeS2 = $6ED9EBA1;
<tr class="nocodegen"><td>1787<td>  RipeS3 = $8F1BBCDC;
<tr class="nocodegen"><td>1788<td>  RipeS4 = $A953FD4E;
<tr class="nocodegen"><td>1789<td>  RipeS5 = $50A28BE6;
<tr class="nocodegen"><td>1790<td>  RipeS6 = $5C4DD124;
<tr class="nocodegen"><td>1791<td>  RipeS7 = $6D703EF3;
<tr class="nocodegen"><td>1792<td>  RipeS8 = $7A6D76E9;
<tr class="nocodegen"><td>1793<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>1794<td>
<tr class="nocodegen"><td>1795<td>{$IFNDEF THash_RipeMD128_asm}
<tr class="nocodegen"><td>1796<td>procedure THash_RipeMD128.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>1797<td>var
<tr class="nocodegen"><td>1798<td>  A1, B1, C1, D1: UInt32;
<tr class="nocodegen"><td>1799<td>  A2, B2, C2, D2: UInt32;
<tr class="nocodegen"><td>1800<td>  T: UInt32;
<tr class="covered"><td>1801<td>begin
<tr class="covered"><td>1802<td>  A1 := FDigest[0];
<tr class="covered"><td>1803<td>  B1 := FDigest[1];
<tr class="covered"><td>1804<td>  C1 := FDigest[2];
<tr class="covered"><td>1805<td>  D1 := FDigest[3];
<tr class="covered"><td>1806<td>  A2 := FDigest[0];
<tr class="covered"><td>1807<td>  B2 := FDigest[1];
<tr class="covered"><td>1808<td>  C2 := FDigest[2];
<tr class="covered"><td>1809<td>  D2 := FDigest[3];
<tr class="nocodegen"><td>1810<td>
<tr class="covered"><td>1811<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>1812<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 1]); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>1813<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>1814<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 3]); B1 := B1 shl 12 or B1 shr 20;
<tr class="covered"><td>1815<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 4]); A1 := A1 shl  5 or A1 shr 27;
<tr class="covered"><td>1816<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 5]); D1 := D1 shl  8 or D1 shr 24;
<tr class="covered"><td>1817<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 6]); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>1818<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 7]); B1 := B1 shl  9 or B1 shr 23;
<tr class="covered"><td>1819<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>1820<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 9]); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>1821<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 14 or C1 shr 18;
<tr class="covered"><td>1822<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[11]); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>1823<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[12]); A1 := A1 shl  6 or A1 shr 26;
<tr class="covered"><td>1824<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[13]); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>1825<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[14]); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>1826<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[15]); B1 := B1 shl  8 or B1 shr 24;
<tr class="nocodegen"><td>1827<td>
<tr class="covered"><td>1828<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS1); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>1829<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 4] + RipeS1); D1 := D1 shl  6 or D1 shr 26;
<tr class="covered"><td>1830<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[13] + RipeS1); C1 := C1 shl  8 or C1 shr 24;
<tr class="covered"><td>1831<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19;
<tr class="covered"><td>1832<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>1833<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>1834<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[15] + RipeS1); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>1835<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS1); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>1836<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[12] + RipeS1); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>1837<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS1); D1 := D1 shl 12 or D1 shr 20;
<tr class="covered"><td>1838<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 9] + RipeS1); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>1839<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 5] + RipeS1); B1 := B1 shl  9 or B1 shr 23;
<tr class="covered"><td>1840<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 2] + RipeS1); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>1841<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS1); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>1842<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[11] + RipeS1); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>1843<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 8] + RipeS1); B1 := B1 shl 12 or B1 shr 20;
<tr class="nocodegen"><td>1844<td>
<tr class="covered"><td>1845<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS2); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>1846<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[10] + RipeS2); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>1847<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[14] + RipeS2); C1 := C1 shl  6 or C1 shr 26;
<tr class="covered"><td>1848<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 4] + RipeS2); B1 := B1 shl  7 or B1 shr 25;
<tr class="covered"><td>1849<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 9] + RipeS2); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>1850<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS2); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>1851<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>1852<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>1853<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>1854<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); D1 := D1 shl  8 or D1 shr 24;
<tr class="covered"><td>1855<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 0] + RipeS2); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>1856<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 6] + RipeS2); B1 := B1 shl  6 or B1 shr 26;
<tr class="covered"><td>1857<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[13] + RipeS2); A1 := A1 shl  5 or A1 shr 27;
<tr class="covered"><td>1858<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS2); D1 := D1 shl 12 or D1 shr 20;
<tr class="covered"><td>1859<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS2); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>1860<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS2); B1 := B1 shl  5 or B1 shr 27;
<tr class="nocodegen"><td>1861<td>
<tr class="covered"><td>1862<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS3); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>1863<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 9] + RipeS3); D1 := D1 shl 12 or D1 shr 20;
<tr class="covered"><td>1864<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS3); C1 := C1 shl 14 or C1 shr 18;
<tr class="covered"><td>1865<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[10] + RipeS3); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>1866<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS3); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>1867<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS3); D1 := D1 shl 15 or D1 shr 17;
<tr class="covered"><td>1868<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[12] + RipeS3); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>1869<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS3); B1 := B1 shl  8 or B1 shr 24;
<tr class="covered"><td>1870<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS3); A1 := A1 shl  9 or A1 shr 23;
<tr class="covered"><td>1871<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>1872<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS3); C1 := C1 shl  5 or C1 shr 27;
<tr class="covered"><td>1873<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[15] + RipeS3); B1 := B1 shl  6 or B1 shr 26;
<tr class="covered"><td>1874<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl  8 or A1 shr 24;
<tr class="covered"><td>1875<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); D1 := D1 shl  6 or D1 shr 26;
<tr class="covered"><td>1876<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); C1 := C1 shl  5 or C1 shr 27;
<tr class="covered"><td>1877<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 2] + RipeS3); B1 := B1 shl 12 or B1 shr 20;
<tr class="nocodegen"><td>1878<td>
<tr class="covered"><td>1879<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>1880<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>1881<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>1882<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>1883<td>
<tr class="covered"><td>1884<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 5] + RipeS5); A1 := A1 shl  8 or A1 shr 24;
<tr class="covered"><td>1885<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[14] + RipeS5); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>1886<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS5); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>1887<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 0] + RipeS5); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>1888<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 9] + RipeS5); A1 := A1 shl 13 or A1 shr 19;
<tr class="covered"><td>1889<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS5); D1 := D1 shl 15 or D1 shr 17;
<tr class="covered"><td>1890<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS5); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>1891<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS5); B1 := B1 shl  5 or B1 shr 27;
<tr class="covered"><td>1892<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS5); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>1893<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS5); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>1894<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[15] + RipeS5); C1 := C1 shl  8 or C1 shr 24;
<tr class="covered"><td>1895<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 8] + RipeS5); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>1896<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS5); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>1897<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS5); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>1898<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS5); C1 := C1 shl 12 or C1 shr 20;
<tr class="covered"><td>1899<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[12] + RipeS5); B1 := B1 shl  6 or B1 shr 26;
<tr class="nocodegen"><td>1900<td>
<tr class="covered"><td>1901<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 6] + RipeS6); A1 := A1 shl  9 or A1 shr 23;
<tr class="covered"><td>1902<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>1903<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>1904<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 7] + RipeS6); B1 := B1 shl  7 or B1 shr 25;
<tr class="covered"><td>1905<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20;
<tr class="covered"><td>1906<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[13] + RipeS6); D1 := D1 shl  8 or D1 shr 24;
<tr class="covered"><td>1907<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS6); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>1908<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[10] + RipeS6); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>1909<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[14] + RipeS6); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>1910<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS6); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>1911<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS6); C1 := C1 shl 12 or C1 shr 20;
<tr class="covered"><td>1912<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS6); B1 := B1 shl  7 or B1 shr 25;
<tr class="covered"><td>1913<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS6); A1 := A1 shl  6 or A1 shr 26;
<tr class="covered"><td>1914<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS6); D1 := D1 shl 15 or D1 shr 17;
<tr class="covered"><td>1915<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 1] + RipeS6); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>1916<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 2] + RipeS6); B1 := B1 shl 11 or B1 shr 21;
<tr class="nocodegen"><td>1917<td>
<tr class="covered"><td>1918<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[15] + RipeS7); A1 := A1 shl  9 or A1 shr 23;
<tr class="covered"><td>1919<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS7); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>1920<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 1] + RipeS7); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>1921<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS7); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>1922<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS7); A1 := A1 shl  8 or A1 shr 24;
<tr class="covered"><td>1923<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS7); D1 := D1 shl  6 or D1 shr 26;
<tr class="covered"><td>1924<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 6] + RipeS7); C1 := C1 shl  6 or C1 shr 26;
<tr class="covered"><td>1925<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18;
<tr class="covered"><td>1926<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20;
<tr class="covered"><td>1927<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS7); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>1928<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[12] + RipeS7); C1 := C1 shl  5 or C1 shr 27;
<tr class="covered"><td>1929<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 2] + RipeS7); B1 := B1 shl 14 or B1 shr 18;
<tr class="covered"><td>1930<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS7); A1 := A1 shl 13 or A1 shr 19;
<tr class="covered"><td>1931<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS7); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>1932<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 4] + RipeS7); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>1933<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[13] + RipeS7); B1 := B1 shl  5 or B1 shr 27;
<tr class="nocodegen"><td>1934<td>
<tr class="covered"><td>1935<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 15 or A1 shr 17;
<tr class="covered"><td>1936<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 6]); D1 := D1 shl  5 or D1 shr 27;
<tr class="covered"><td>1937<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 4]); C1 := C1 shl  8 or C1 shr 24;
<tr class="covered"><td>1938<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 1]); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>1939<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 3]); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>1940<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[11]); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>1941<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[15]); C1 := C1 shl  6 or C1 shr 26;
<tr class="covered"><td>1942<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 0]); B1 := B1 shl 14 or B1 shr 18;
<tr class="covered"><td>1943<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl  6 or A1 shr 26;
<tr class="covered"><td>1944<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[12]); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>1945<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 12 or C1 shr 20;
<tr class="covered"><td>1946<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[13]); B1 := B1 shl  9 or B1 shr 23;
<tr class="covered"><td>1947<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 9]); A1 := A1 shl 12 or A1 shr 20;
<tr class="covered"><td>1948<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 7]); D1 := D1 shl  5 or D1 shr 27;
<tr class="covered"><td>1949<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>1950<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[14]); B1 := B1 shl  8 or B1 shr 24;
<tr class="nocodegen"><td>1951<td>
<tr class="covered"><td>1952<td>  Inc(D1, C2 + FDigest[1]);
<tr class="covered"><td>1953<td>  FDigest[1] := FDigest[2] + D2 + A1;
<tr class="covered"><td>1954<td>  FDigest[2] := FDigest[3] + A2 + B1;
<tr class="covered"><td>1955<td>  FDigest[3] := FDIgest[0] + B2 + C1;
<tr class="covered"><td>1956<td>  FDigest[0] := D1;
<tr class="covered"><td>1957<td>end;
<tr class="nocodegen"><td>1958<td>{$ENDIF !THash_RipeMD128_asm}
<tr class="nocodegen"><td>1959<td>
<tr class="nocodegen"><td>1960<td>{ THash_RipeMD160 }
<tr class="nocodegen"><td>1961<td>
<tr class="nocodegen"><td>1962<td>{$IFNDEF THash_RipeMD160_asm}
<tr class="nocodegen"><td>1963<td>procedure THash_RipeMD160.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>1964<td>var
<tr class="nocodegen"><td>1965<td>  A1, B1, C1, D1, E1: UInt32;
<tr class="nocodegen"><td>1966<td>  A2, B2, C2, D2, E2: UInt32;
<tr class="nocodegen"><td>1967<td>  T: UInt32;
<tr class="covered"><td>1968<td>begin
<tr class="covered"><td>1969<td>  A1 := FDigest[0];
<tr class="covered"><td>1970<td>  B1 := FDigest[1];
<tr class="covered"><td>1971<td>  C1 := FDigest[2];
<tr class="covered"><td>1972<td>  D1 := FDigest[3];
<tr class="covered"><td>1973<td>  E1 := FDigest[4];
<tr class="nocodegen"><td>1974<td>
<tr class="covered"><td>1975<td>  A2 := FDigest[0];
<tr class="covered"><td>1976<td>  B2 := FDigest[1];
<tr class="covered"><td>1977<td>  C2 := FDigest[2];
<tr class="covered"><td>1978<td>  D2 := FDigest[3];
<tr class="covered"><td>1979<td>  E2 := FDigest[4];
<tr class="nocodegen"><td>1980<td>
<tr class="covered"><td>1981<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>1982<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 1]); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>1983<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 2]); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>1984<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 3]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>1985<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[ 4]); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>1986<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>1987<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 6]); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>1988<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 7]); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>1989<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 8]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>1990<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[ 9]); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>1991<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[10]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>1992<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[11]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>1993<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[12]); D1 := D1 shl  6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>1994<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[13]); C1 := C1 shl  7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>1995<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[14]); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>1996<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="nocodegen"><td>1997<td>
<tr class="covered"><td>1998<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS1); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>1999<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 4] + RipeS1); D1 := D1 shl  6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2000<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[13] + RipeS1); C1 := C1 shl  8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2001<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2002<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2003<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2004<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[15] + RipeS1); D1 := D1 shl  7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2005<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 3] + RipeS1); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2006<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[12] + RipeS1); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2007<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS1); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2008<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 9] + RipeS1); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2009<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 5] + RipeS1); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2010<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS1); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2011<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[14] + RipeS1); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2012<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS1); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2013<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS1); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="nocodegen"><td>2014<td>
<tr class="covered"><td>2015<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[ 3] + RipeS2); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2016<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[10] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2017<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[14] + RipeS2); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2018<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS2); A1 := A1 shl  7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2019<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS2); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2020<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS2); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2021<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2022<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2023<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2024<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); E1 := E1 shl  8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2025<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[ 0] + RipeS2); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2026<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS2); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2027<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[13] + RipeS2); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2028<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS2); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2029<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 5] + RipeS2); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2030<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS2); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="nocodegen"><td>2031<td>
<tr class="covered"><td>2032<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 1] + RipeS3); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2033<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS3); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2034<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[11] + RipeS3); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2035<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS3); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2036<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 0] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2037<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 8] + RipeS3); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2038<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[12] + RipeS3); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2039<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 4] + RipeS3); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2040<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS3); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2041<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2042<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 7] + RipeS3); C1 := C1 shl  5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2043<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[15] + RipeS3); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2044<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2045<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); E1 := E1 shl  6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2046<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2047<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 2] + RipeS3); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="nocodegen"><td>2048<td>
<tr class="covered"><td>2049<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 4] + RipeS4); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2050<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 0] + RipeS4); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2051<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[ 5] + RipeS4); E1 := E1 shl  5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2052<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 9] + RipeS4); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2053<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[ 7] + RipeS4); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2054<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[12] + RipeS4); B1 := B1 shl  8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2055<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS4); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2056<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[10] + RipeS4); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2057<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[14] + RipeS4); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2058<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[ 1] + RipeS4); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2059<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS4); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2060<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 8] + RipeS4); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2061<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS4); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2062<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 6] + RipeS4); D1 := D1 shl  8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2063<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[15] + RipeS4); C1 := C1 shl  5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2064<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[13] + RipeS4); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="nocodegen"><td>2065<td>
<tr class="covered"><td>2066<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2067<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2068<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2069<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2070<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2071<td>
<tr class="covered"><td>2072<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 5] + RipeS5); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2073<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[14] + RipeS5); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2074<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 7] + RipeS5); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2075<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[ 0] + RipeS5); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2076<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 9] + RipeS5); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2077<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS5); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2078<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS5); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2079<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 4] + RipeS5); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2080<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[13] + RipeS5); C1 := C1 shl  7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2081<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 6] + RipeS5); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2082<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[15] + RipeS5); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2083<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[ 8] + RipeS5); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2084<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 1] + RipeS5); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2085<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[10] + RipeS5); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2086<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS5); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2087<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[12] + RipeS5); A1 := A1 shl  6 or A1 shr 26 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="nocodegen"><td>2088<td>
<tr class="covered"><td>2089<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS6); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2090<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2091<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2092<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 7] + RipeS6); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2093<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2094<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS6); E1 := E1 shl  8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2095<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 5] + RipeS6); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2096<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[10] + RipeS6); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2097<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[14] + RipeS6); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2098<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[15] + RipeS6); A1 := A1 shl  7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2099<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS6); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2100<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[12] + RipeS6); D1 := D1 shl  7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2101<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 4] + RipeS6); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2102<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS6); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2103<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS6); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2104<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS6); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="nocodegen"><td>2105<td>
<tr class="covered"><td>2106<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS7); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2107<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 5] + RipeS7); C1 := C1 shl  7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2108<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS7); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2109<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS7); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2110<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS7); E1 := E1 shl  8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2111<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[14] + RipeS7); D1 := D1 shl  6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2112<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS7); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2113<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2114<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2115<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 8] + RipeS7); E1 := E1 shl 13 or E1 shr 19 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2116<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS7); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2117<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 2] + RipeS7); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2118<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[10] + RipeS7); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2119<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS7); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2120<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 4] + RipeS7); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2121<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[13] + RipeS7); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="nocodegen"><td>2122<td>
<tr class="covered"><td>2123<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 8] + RipeS8); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2124<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 6] + RipeS8); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2125<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 4] + RipeS8); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2126<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 1] + RipeS8); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2127<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 3] + RipeS8); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2128<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[11] + RipeS8); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2129<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[15] + RipeS8); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2130<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS8); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2131<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS8); E1 := E1 shl  6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2132<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[12] + RipeS8); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2133<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS8); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2134<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[13] + RipeS8); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2135<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 9] + RipeS8); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2136<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS8); E1 := E1 shl  5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2137<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[10] + RipeS8); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2138<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[14] + RipeS8); C1 := C1 shl  8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="nocodegen"><td>2139<td>
<tr class="covered"><td>2140<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[12]); B1 := B1 shl  8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2141<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl  5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2142<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[10]); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2143<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 4]); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2144<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 1]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2145<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[ 5]); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2146<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2147<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 7]); E1 := E1 shl  6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2148<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 6]); D1 := D1 shl  8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2149<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 2]); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2150<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[13]); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2151<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[14]); A1 := A1 shl  5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2152<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 0]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2153<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 3]); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2154<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 9]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2155<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[11]); B1 := B1 shl 11 or B1 shr 21 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="nocodegen"><td>2156<td>
<tr class="covered"><td>2157<td>  Inc(D1, C2 + FDigest[1]);
<tr class="covered"><td>2158<td>  FDigest[1] := FDigest[2] + D2 + E1;
<tr class="covered"><td>2159<td>  FDigest[2] := FDigest[3] + E2 + A1;
<tr class="covered"><td>2160<td>  FDigest[3] := FDigest[4] + A2 + B1;
<tr class="covered"><td>2161<td>  FDigest[4] := FDigest[0] + B2 + C1;
<tr class="covered"><td>2162<td>  FDigest[0] := D1;
<tr class="covered"><td>2163<td>end;
<tr class="nocodegen"><td>2164<td>{$ENDIF !THash_RipeMD160_asm}
<tr class="nocodegen"><td>2165<td>
<tr class="nocodegen"><td>2166<td>class function THash_RipeMD160.DigestSize: UInt32;
<tr class="covered"><td>2167<td>begin
<tr class="covered"><td>2168<td>  Result := 20;
<tr class="covered"><td>2169<td>end;
<tr class="nocodegen"><td>2170<td>
<tr class="nocodegen"><td>2171<td>{ THash_RipeMD256 }
<tr class="nocodegen"><td>2172<td>
<tr class="nocodegen"><td>2173<td>{$IFNDEF THash_RipeMD256_asm}
<tr class="nocodegen"><td>2174<td>procedure THash_RipeMD256.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>2175<td>var
<tr class="nocodegen"><td>2176<td>  A1, B1, C1, D1: UInt32;
<tr class="nocodegen"><td>2177<td>  A2, B2, C2, D2: UInt32;
<tr class="nocodegen"><td>2178<td>  T: UInt32;
<tr class="covered"><td>2179<td>begin
<tr class="covered"><td>2180<td>  A1 := FDigest[0];
<tr class="covered"><td>2181<td>  B1 := FDigest[1];
<tr class="covered"><td>2182<td>  C1 := FDigest[2];
<tr class="covered"><td>2183<td>  D1 := FDigest[3];
<tr class="nocodegen"><td>2184<td>
<tr class="covered"><td>2185<td>  A2 := FDigest[4];
<tr class="covered"><td>2186<td>  B2 := FDigest[5];
<tr class="covered"><td>2187<td>  C2 := FDigest[6];
<tr class="covered"><td>2188<td>  D2 := FDigest[7];
<tr class="nocodegen"><td>2189<td>
<tr class="covered"><td>2190<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>2191<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 1]); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>2192<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>2193<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 3]); B1 := B1 shl 12 or B1 shr 20;
<tr class="covered"><td>2194<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 4]); A1 := A1 shl  5 or A1 shr 27;
<tr class="covered"><td>2195<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 5]); D1 := D1 shl  8 or D1 shr 24;
<tr class="covered"><td>2196<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 6]); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>2197<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 7]); B1 := B1 shl  9 or B1 shr 23;
<tr class="covered"><td>2198<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>2199<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 9]); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>2200<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 14 or C1 shr 18;
<tr class="covered"><td>2201<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[11]); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>2202<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[12]); A1 := A1 shl  6 or A1 shr 26;
<tr class="covered"><td>2203<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[13]); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>2204<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[14]); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>2205<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[15]); B1 := B1 shl  8 or B1 shr 24;
<tr class="nocodegen"><td>2206<td>
<tr class="covered"><td>2207<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2208<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2209<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2210<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>2211<td>
<tr class="covered"><td>2212<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 5] + RipeS5); A1 := A1 shl  8 or A1 shr 24;
<tr class="covered"><td>2213<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[14] + RipeS5); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>2214<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS5); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>2215<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 0] + RipeS5); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>2216<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 9] + RipeS5); A1 := A1 shl 13 or A1 shr 19;
<tr class="covered"><td>2217<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS5); D1 := D1 shl 15 or D1 shr 17;
<tr class="covered"><td>2218<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS5); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>2219<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS5); B1 := B1 shl  5 or B1 shr 27;
<tr class="covered"><td>2220<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS5); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>2221<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS5); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>2222<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[15] + RipeS5); C1 := C1 shl  8 or C1 shr 24;
<tr class="covered"><td>2223<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 8] + RipeS5); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>2224<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS5); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>2225<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS5); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>2226<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS5); C1 := C1 shl 12 or C1 shr 20;
<tr class="covered"><td>2227<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[12] + RipeS5); B1 := B1 shl  6 or B1 shr 26;
<tr class="nocodegen"><td>2228<td>
<tr class="covered"><td>2229<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2230<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2231<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>2232<td>
<tr class="covered"><td>2233<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS1); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>2234<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 4] + RipeS1); D1 := D1 shl  6 or D1 shr 26;
<tr class="covered"><td>2235<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[13] + RipeS1); C1 := C1 shl  8 or C1 shr 24;
<tr class="covered"><td>2236<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19;
<tr class="covered"><td>2237<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>2238<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>2239<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[15] + RipeS1); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>2240<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS1); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>2241<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[12] + RipeS1); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>2242<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS1); D1 := D1 shl 12 or D1 shr 20;
<tr class="covered"><td>2243<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 9] + RipeS1); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>2244<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 5] + RipeS1); B1 := B1 shl  9 or B1 shr 23;
<tr class="covered"><td>2245<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 2] + RipeS1); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>2246<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS1); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>2247<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[11] + RipeS1); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>2248<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 8] + RipeS1); B1 := B1 shl 12 or B1 shr 20;
<tr class="nocodegen"><td>2249<td>
<tr class="covered"><td>2250<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2251<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2252<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2253<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>2254<td>
<tr class="covered"><td>2255<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 6] + RipeS6); A1 := A1 shl  9 or A1 shr 23;
<tr class="covered"><td>2256<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>2257<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>2258<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 7] + RipeS6); B1 := B1 shl  7 or B1 shr 25;
<tr class="covered"><td>2259<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20;
<tr class="covered"><td>2260<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[13] + RipeS6); D1 := D1 shl  8 or D1 shr 24;
<tr class="covered"><td>2261<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS6); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>2262<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[10] + RipeS6); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>2263<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[14] + RipeS6); A1 := A1 shl  7 or A1 shr 25;
<tr class="covered"><td>2264<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS6); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>2265<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS6); C1 := C1 shl 12 or C1 shr 20;
<tr class="covered"><td>2266<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS6); B1 := B1 shl  7 or B1 shr 25;
<tr class="covered"><td>2267<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS6); A1 := A1 shl  6 or A1 shr 26;
<tr class="covered"><td>2268<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS6); D1 := D1 shl 15 or D1 shr 17;
<tr class="covered"><td>2269<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 1] + RipeS6); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>2270<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 2] + RipeS6); B1 := B1 shl 11 or B1 shr 21;
<tr class="nocodegen"><td>2271<td>
<tr class="covered"><td>2272<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2273<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2274<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>2275<td>
<tr class="covered"><td>2276<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS2); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>2277<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[10] + RipeS2); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>2278<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[14] + RipeS2); C1 := C1 shl  6 or C1 shr 26;
<tr class="covered"><td>2279<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 4] + RipeS2); B1 := B1 shl  7 or B1 shr 25;
<tr class="covered"><td>2280<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 9] + RipeS2); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>2281<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[15] + RipeS2); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>2282<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>2283<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>2284<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>2285<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); D1 := D1 shl  8 or D1 shr 24;
<tr class="covered"><td>2286<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 0] + RipeS2); C1 := C1 shl 13 or C1 shr 19;
<tr class="covered"><td>2287<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[ 6] + RipeS2); B1 := B1 shl  6 or B1 shr 26;
<tr class="covered"><td>2288<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[13] + RipeS2); A1 := A1 shl  5 or A1 shr 27;
<tr class="covered"><td>2289<td>  Inc(D1, A1 or not B1 xor C1 + Buffer[11] + RipeS2); D1 := D1 shl 12 or D1 shr 20;
<tr class="covered"><td>2290<td>  Inc(C1, D1 or not A1 xor B1 + Buffer[ 5] + RipeS2); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>2291<td>  Inc(B1, C1 or not D1 xor A1 + Buffer[12] + RipeS2); B1 := B1 shl  5 or B1 shr 27;
<tr class="nocodegen"><td>2292<td>
<tr class="covered"><td>2293<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2294<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2295<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2296<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>2297<td>
<tr class="covered"><td>2298<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[15] + RipeS7); A1 := A1 shl  9 or A1 shr 23;
<tr class="covered"><td>2299<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS7); D1 := D1 shl  7 or D1 shr 25;
<tr class="covered"><td>2300<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 1] + RipeS7); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>2301<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 3] + RipeS7); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>2302<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 7] + RipeS7); A1 := A1 shl  8 or A1 shr 24;
<tr class="covered"><td>2303<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[14] + RipeS7); D1 := D1 shl  6 or D1 shr 26;
<tr class="covered"><td>2304<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 6] + RipeS7); C1 := C1 shl  6 or C1 shr 26;
<tr class="covered"><td>2305<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18;
<tr class="covered"><td>2306<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20;
<tr class="covered"><td>2307<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS7); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>2308<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[12] + RipeS7); C1 := C1 shl  5 or C1 shr 27;
<tr class="covered"><td>2309<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[ 2] + RipeS7); B1 := B1 shl 14 or B1 shr 18;
<tr class="covered"><td>2310<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS7); A1 := A1 shl 13 or A1 shr 19;
<tr class="covered"><td>2311<td>  Inc(D1, A1 and B1 or not A1 and C1 + Buffer[ 0] + RipeS7); D1 := D1 shl 13 or D1 shr 19;
<tr class="covered"><td>2312<td>  Inc(C1, D1 and A1 or not D1 and B1 + Buffer[ 4] + RipeS7); C1 := C1 shl  7 or C1 shr 25;
<tr class="covered"><td>2313<td>  Inc(B1, C1 and D1 or not C1 and A1 + Buffer[13] + RipeS7); B1 := B1 shl  5 or B1 shr 27;
<tr class="nocodegen"><td>2314<td>
<tr class="covered"><td>2315<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2316<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2317<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>2318<td>
<tr class="covered"><td>2319<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS3); A1 := A1 shl 11 or A1 shr 21;
<tr class="covered"><td>2320<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 9] + RipeS3); D1 := D1 shl 12 or D1 shr 20;
<tr class="covered"><td>2321<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[11] + RipeS3); C1 := C1 shl 14 or C1 shr 18;
<tr class="covered"><td>2322<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[10] + RipeS3); B1 := B1 shl 15 or B1 shr 17;
<tr class="covered"><td>2323<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS3); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>2324<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS3); D1 := D1 shl 15 or D1 shr 17;
<tr class="covered"><td>2325<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[12] + RipeS3); C1 := C1 shl  9 or C1 shr 23;
<tr class="covered"><td>2326<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 4] + RipeS3); B1 := B1 shl  8 or B1 shr 24;
<tr class="covered"><td>2327<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[13] + RipeS3); A1 := A1 shl  9 or A1 shr 23;
<tr class="covered"><td>2328<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>2329<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 7] + RipeS3); C1 := C1 shl  5 or C1 shr 27;
<tr class="covered"><td>2330<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[15] + RipeS3); B1 := B1 shl  6 or B1 shr 26;
<tr class="covered"><td>2331<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl  8 or A1 shr 24;
<tr class="covered"><td>2332<td>  Inc(D1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); D1 := D1 shl  6 or D1 shr 26;
<tr class="covered"><td>2333<td>  Inc(C1, D1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); C1 := C1 shl  5 or C1 shr 27;
<tr class="covered"><td>2334<td>  Inc(B1, C1 and A1 or D1 and not A1 + Buffer[ 2] + RipeS3); B1 := B1 shl 12 or B1 shr 20;
<tr class="nocodegen"><td>2335<td>
<tr class="covered"><td>2336<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2337<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2338<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2339<td>  T := D1; D1 := D2; D2 := T;
<tr class="nocodegen"><td>2340<td>
<tr class="covered"><td>2341<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 15 or A1 shr 17;
<tr class="covered"><td>2342<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 6]); D1 := D1 shl  5 or D1 shr 27;
<tr class="covered"><td>2343<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 4]); C1 := C1 shl  8 or C1 shr 24;
<tr class="covered"><td>2344<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 1]); B1 := B1 shl 11 or B1 shr 21;
<tr class="covered"><td>2345<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 3]); A1 := A1 shl 14 or A1 shr 18;
<tr class="covered"><td>2346<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[11]); D1 := D1 shl 14 or D1 shr 18;
<tr class="covered"><td>2347<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[15]); C1 := C1 shl  6 or C1 shr 26;
<tr class="covered"><td>2348<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[ 0]); B1 := B1 shl 14 or B1 shr 18;
<tr class="covered"><td>2349<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl  6 or A1 shr 26;
<tr class="covered"><td>2350<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[12]); D1 := D1 shl  9 or D1 shr 23;
<tr class="covered"><td>2351<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[ 2]); C1 := C1 shl 12 or C1 shr 20;
<tr class="covered"><td>2352<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[13]); B1 := B1 shl  9 or B1 shr 23;
<tr class="covered"><td>2353<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 9]); A1 := A1 shl 12 or A1 shr 20;
<tr class="covered"><td>2354<td>  Inc(D1, A1 xor B1 xor C1 + Buffer[ 7]); D1 := D1 shl  5 or D1 shr 27;
<tr class="covered"><td>2355<td>  Inc(C1, D1 xor A1 xor B1 + Buffer[10]); C1 := C1 shl 15 or C1 shr 17;
<tr class="covered"><td>2356<td>  Inc(B1, C1 xor D1 xor A1 + Buffer[14]); B1 := B1 shl  8 or B1 shr 24;
<tr class="nocodegen"><td>2357<td>
<tr class="covered"><td>2358<td>  Inc(FDigest[0], A2);
<tr class="covered"><td>2359<td>  Inc(FDigest[1], B2);
<tr class="covered"><td>2360<td>  Inc(FDigest[2], C2);
<tr class="covered"><td>2361<td>  Inc(FDigest[3], D1);
<tr class="nocodegen"><td>2362<td>
<tr class="covered"><td>2363<td>  Inc(FDigest[4], A1);
<tr class="covered"><td>2364<td>  Inc(FDigest[5], B1);
<tr class="covered"><td>2365<td>  Inc(FDigest[6], C1);
<tr class="covered"><td>2366<td>  Inc(FDigest[7], D2);
<tr class="covered"><td>2367<td>end;
<tr class="nocodegen"><td>2368<td>{$ENDIF !THash_RipeMD256_asm}
<tr class="nocodegen"><td>2369<td>
<tr class="nocodegen"><td>2370<td>procedure THash_RipeMD256.DoInit;
<tr class="covered"><td>2371<td>begin
<tr class="covered"><td>2372<td>  FDigest[0] := $67452301;
<tr class="covered"><td>2373<td>  FDigest[1] := $EFCDAB89;
<tr class="covered"><td>2374<td>  FDigest[2] := $98BADCFE;
<tr class="covered"><td>2375<td>  FDigest[3] := $10325476;
<tr class="covered"><td>2376<td>  FDigest[4] := $76543210;
<tr class="covered"><td>2377<td>  FDigest[5] := $FEDCBA98;
<tr class="covered"><td>2378<td>  FDigest[6] := $89ABCDEF;
<tr class="covered"><td>2379<td>  FDigest[7] := $01234567;
<tr class="covered"><td>2380<td>  FDigest[8] := $01234567;
<tr class="covered"><td>2381<td>  FDigest[9] := $3C2D1E0F;
<tr class="covered"><td>2382<td>end;
<tr class="nocodegen"><td>2383<td>
<tr class="nocodegen"><td>2384<td>class function THash_RipeMD256.DigestSize: UInt32;
<tr class="covered"><td>2385<td>begin
<tr class="covered"><td>2386<td>  Result := 32;
<tr class="covered"><td>2387<td>end;
<tr class="nocodegen"><td>2388<td>
<tr class="nocodegen"><td>2389<td>{ THash_RipeMD320 }
<tr class="nocodegen"><td>2390<td>
<tr class="nocodegen"><td>2391<td>{$IFNDEF THash_RipeMD320_asm}
<tr class="nocodegen"><td>2392<td>procedure THash_RipeMD320.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>2393<td>var
<tr class="nocodegen"><td>2394<td>  A1, B1, C1, D1, E1: UInt32;
<tr class="nocodegen"><td>2395<td>  A2, B2, C2, D2, E2: UInt32;
<tr class="nocodegen"><td>2396<td>  T: UInt32;
<tr class="covered"><td>2397<td>begin
<tr class="covered"><td>2398<td>  A1 := FDigest[0];
<tr class="covered"><td>2399<td>  B1 := FDigest[1];
<tr class="covered"><td>2400<td>  C1 := FDigest[2];
<tr class="covered"><td>2401<td>  D1 := FDigest[3];
<tr class="covered"><td>2402<td>  E1 := FDigest[4];
<tr class="covered"><td>2403<td>  A2 := FDigest[5];
<tr class="covered"><td>2404<td>  B2 := FDigest[6];
<tr class="covered"><td>2405<td>  C2 := FDigest[7];
<tr class="covered"><td>2406<td>  D2 := FDigest[8];
<tr class="covered"><td>2407<td>  E2 := FDigest[9];
<tr class="nocodegen"><td>2408<td>
<tr class="covered"><td>2409<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 0]); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2410<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 1]); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2411<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 2]); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2412<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 3]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2413<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[ 4]); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2414<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 5]); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2415<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 6]); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2416<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 7]); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2417<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 8]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2418<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[ 9]); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2419<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[10]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2420<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[11]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2421<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[12]); D1 := D1 shl  6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2422<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[13]); C1 := C1 shl  7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2423<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[14]); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2424<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="nocodegen"><td>2425<td>
<tr class="covered"><td>2426<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2427<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2428<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2429<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2430<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2431<td>
<tr class="covered"><td>2432<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 5] + RipeS5); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2433<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[14] + RipeS5); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2434<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 7] + RipeS5); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2435<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[ 0] + RipeS5); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2436<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 9] + RipeS5); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2437<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS5); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2438<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS5); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2439<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 4] + RipeS5); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2440<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[13] + RipeS5); C1 := C1 shl  7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2441<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 6] + RipeS5); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2442<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[15] + RipeS5); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2443<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[ 8] + RipeS5); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2444<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 1] + RipeS5); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2445<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[10] + RipeS5); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2446<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS5); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2447<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[12] + RipeS5); A1 := A1 shl  6 or A1 shr 26 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="nocodegen"><td>2448<td>
<tr class="covered"><td>2449<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2450<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2451<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2452<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2453<td>
<tr class="covered"><td>2454<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS1); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2455<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 4] + RipeS1); D1 := D1 shl  6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2456<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[13] + RipeS1); C1 := C1 shl  8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2457<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 1] + RipeS1); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2458<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[10] + RipeS1); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2459<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 6] + RipeS1); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2460<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[15] + RipeS1); D1 := D1 shl  7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2461<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 3] + RipeS1); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2462<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[12] + RipeS1); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2463<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS1); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2464<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 9] + RipeS1); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2465<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 5] + RipeS1); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2466<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS1); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2467<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[14] + RipeS1); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2468<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[11] + RipeS1); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2469<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 8] + RipeS1); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="nocodegen"><td>2470<td>
<tr class="covered"><td>2471<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2472<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2473<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2474<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2475<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2476<td>
<tr class="covered"><td>2477<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 6] + RipeS6); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2478<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[11] + RipeS6); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2479<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 3] + RipeS6); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2480<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 7] + RipeS6); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2481<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 0] + RipeS6); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2482<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS6); E1 := E1 shl  8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2483<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 5] + RipeS6); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2484<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[10] + RipeS6); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2485<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[14] + RipeS6); B1 := B1 shl  7 or B1 shr 25 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2486<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[15] + RipeS6); A1 := A1 shl  7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2487<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 8] + RipeS6); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2488<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[12] + RipeS6); D1 := D1 shl  7 or D1 shr 25 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2489<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 4] + RipeS6); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2490<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS6); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2491<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 1] + RipeS6); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2492<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 2] + RipeS6); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="nocodegen"><td>2493<td>
<tr class="covered"><td>2494<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2495<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2496<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2497<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2498<td>
<tr class="covered"><td>2499<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[ 3] + RipeS2); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2500<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[10] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2501<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[14] + RipeS2); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2502<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 4] + RipeS2); A1 := A1 shl  7 or A1 shr 25 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2503<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 9] + RipeS2); E1 := E1 shl 14 or E1 shr 18 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2504<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS2); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2505<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 8] + RipeS2); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2506<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS2); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2507<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 2] + RipeS2); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2508<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS2); E1 := E1 shl  8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2509<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[ 0] + RipeS2); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2510<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS2); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2511<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[13] + RipeS2); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2512<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS2); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2513<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 5] + RipeS2); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2514<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS2); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="nocodegen"><td>2515<td>
<tr class="covered"><td>2516<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2517<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2518<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2519<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2520<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2521<td>
<tr class="covered"><td>2522<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[15] + RipeS7); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2523<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 5] + RipeS7); C1 := C1 shl  7 or C1 shr 25 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2524<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[ 1] + RipeS7); B1 := B1 shl 15 or B1 shr 17 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2525<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 3] + RipeS7); A1 := A1 shl 11 or A1 shr 21 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2526<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 7] + RipeS7); E1 := E1 shl  8 or E1 shr 24 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2527<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[14] + RipeS7); D1 := D1 shl  6 or D1 shr 26 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2528<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 6] + RipeS7); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2529<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[ 9] + RipeS7); B1 := B1 shl 14 or B1 shr 18 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2530<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[11] + RipeS7); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2531<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 8] + RipeS7); E1 := E1 shl 13 or E1 shr 19 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2532<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[12] + RipeS7); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2533<td>  Inc(C1, D1 or not E1 xor A1 + Buffer[ 2] + RipeS7); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2534<td>  Inc(B1, C1 or not D1 xor E1 + Buffer[10] + RipeS7); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2535<td>  Inc(A1, B1 or not C1 xor D1 + Buffer[ 0] + RipeS7); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2536<td>  Inc(E1, A1 or not B1 xor C1 + Buffer[ 4] + RipeS7); E1 := E1 shl  7 or E1 shr 25 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2537<td>  Inc(D1, E1 or not A1 xor B1 + Buffer[13] + RipeS7); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="nocodegen"><td>2538<td>
<tr class="covered"><td>2539<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2540<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2541<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2542<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2543<td>
<tr class="covered"><td>2544<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 1] + RipeS3); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2545<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[ 9] + RipeS3); B1 := B1 shl 12 or B1 shr 20 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2546<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[11] + RipeS3); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2547<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[10] + RipeS3); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2548<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 0] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2549<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 8] + RipeS3); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2550<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[12] + RipeS3); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2551<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[ 4] + RipeS3); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2552<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[13] + RipeS3); E1 := E1 shl  9 or E1 shr 23 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2553<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 3] + RipeS3); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2554<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 7] + RipeS3); C1 := C1 shl  5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2555<td>  Inc(B1, C1 and E1 or D1 and not E1 + Buffer[15] + RipeS3); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2556<td>  Inc(A1, B1 and D1 or C1 and not D1 + Buffer[14] + RipeS3); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2557<td>  Inc(E1, A1 and C1 or B1 and not C1 + Buffer[ 5] + RipeS3); E1 := E1 shl  6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2558<td>  Inc(D1, E1 and B1 or A1 and not B1 + Buffer[ 6] + RipeS3); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2559<td>  Inc(C1, D1 and A1 or E1 and not A1 + Buffer[ 2] + RipeS3); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="nocodegen"><td>2560<td>
<tr class="covered"><td>2561<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2562<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2563<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2564<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2565<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2566<td>
<tr class="covered"><td>2567<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 8] + RipeS8); C1 := C1 shl 15 or C1 shr 17 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2568<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[ 6] + RipeS8); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2569<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 4] + RipeS8); A1 := A1 shl  8 or A1 shr 24 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2570<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 1] + RipeS8); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2571<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[ 3] + RipeS8); D1 := D1 shl 14 or D1 shr 18 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2572<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[11] + RipeS8); C1 := C1 shl 14 or C1 shr 18 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2573<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[15] + RipeS8); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2574<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 0] + RipeS8); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2575<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 5] + RipeS8); E1 := E1 shl  6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2576<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[12] + RipeS8); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2577<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[ 2] + RipeS8); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2578<td>  Inc(B1, C1 and D1 or not C1 and E1 + Buffer[13] + RipeS8); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2579<td>  Inc(A1, B1 and C1 or not B1 and D1 + Buffer[ 9] + RipeS8); A1 := A1 shl 12 or A1 shr 20 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2580<td>  Inc(E1, A1 and B1 or not A1 and C1 + Buffer[ 7] + RipeS8); E1 := E1 shl  5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2581<td>  Inc(D1, E1 and A1 or not E1 and B1 + Buffer[10] + RipeS8); D1 := D1 shl 15 or D1 shr 17 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2582<td>  Inc(C1, D1 and E1 or not D1 and A1 + Buffer[14] + RipeS8); C1 := C1 shl  8 or C1 shr 24 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="nocodegen"><td>2583<td>
<tr class="covered"><td>2584<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2585<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2586<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2587<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2588<td>
<tr class="covered"><td>2589<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 4] + RipeS4); B1 := B1 shl  9 or B1 shr 23 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2590<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 0] + RipeS4); A1 := A1 shl 15 or A1 shr 17 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2591<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[ 5] + RipeS4); E1 := E1 shl  5 or E1 shr 27 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2592<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 9] + RipeS4); D1 := D1 shl 11 or D1 shr 21 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2593<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[ 7] + RipeS4); C1 := C1 shl  6 or C1 shr 26 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2594<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[12] + RipeS4); B1 := B1 shl  8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2595<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 2] + RipeS4); A1 := A1 shl 13 or A1 shr 19 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2596<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[10] + RipeS4); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2597<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[14] + RipeS4); D1 := D1 shl  5 or D1 shr 27 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2598<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[ 1] + RipeS4); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2599<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[ 3] + RipeS4); B1 := B1 shl 13 or B1 shr 19 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2600<td>  Inc(A1, C1 or not D1 xor B1 + Buffer[ 8] + RipeS4); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2601<td>  Inc(E1, B1 or not C1 xor A1 + Buffer[11] + RipeS4); E1 := E1 shl 11 or E1 shr 21 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2602<td>  Inc(D1, A1 or not B1 xor E1 + Buffer[ 6] + RipeS4); D1 := D1 shl  8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2603<td>  Inc(C1, E1 or not A1 xor D1 + Buffer[15] + RipeS4); C1 := C1 shl  5 or C1 shr 27 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2604<td>  Inc(B1, D1 or not E1 xor C1 + Buffer[13] + RipeS4); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="nocodegen"><td>2605<td>
<tr class="covered"><td>2606<td>  T := A1; A1 := A2; A2 := T;
<tr class="covered"><td>2607<td>  T := B1; B1 := B2; B2 := T;
<tr class="covered"><td>2608<td>  T := C1; C1 := C2; C2 := T;
<tr class="covered"><td>2609<td>  T := D1; D1 := D2; D2 := T;
<tr class="covered"><td>2610<td>  T := E1; E1 := E2; E2 := T;
<tr class="nocodegen"><td>2611<td>
<tr class="covered"><td>2612<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[12]); B1 := B1 shl  8 or B1 shr 24 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2613<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[15]); A1 := A1 shl  5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2614<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[10]); E1 := E1 shl 12 or E1 shr 20 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2615<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 4]); D1 := D1 shl  9 or D1 shr 23 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2616<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 1]); C1 := C1 shl 12 or C1 shr 20 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2617<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[ 5]); B1 := B1 shl  5 or B1 shr 27 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2618<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[ 8]); A1 := A1 shl 14 or A1 shr 18 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2619<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 7]); E1 := E1 shl  6 or E1 shr 26 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2620<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 6]); D1 := D1 shl  8 or D1 shr 24 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2621<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 2]); C1 := C1 shl 13 or C1 shr 19 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2622<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[13]); B1 := B1 shl  6 or B1 shr 26 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="covered"><td>2623<td>  Inc(A1, B1 xor C1 xor D1 + Buffer[14]); A1 := A1 shl  5 or A1 shr 27 + E1; C1 := C1 shl 10 or C1 shr 22;
<tr class="covered"><td>2624<td>  Inc(E1, A1 xor B1 xor C1 + Buffer[ 0]); E1 := E1 shl 15 or E1 shr 17 + D1; B1 := B1 shl 10 or B1 shr 22;
<tr class="covered"><td>2625<td>  Inc(D1, E1 xor A1 xor B1 + Buffer[ 3]); D1 := D1 shl 13 or D1 shr 19 + C1; A1 := A1 shl 10 or A1 shr 22;
<tr class="covered"><td>2626<td>  Inc(C1, D1 xor E1 xor A1 + Buffer[ 9]); C1 := C1 shl 11 or C1 shr 21 + B1; E1 := E1 shl 10 or E1 shr 22;
<tr class="covered"><td>2627<td>  Inc(B1, C1 xor D1 xor E1 + Buffer[11]); B1 := B1 shl 11 or B1 shr 21 + A1; D1 := D1 shl 10 or D1 shr 22;
<tr class="nocodegen"><td>2628<td>
<tr class="covered"><td>2629<td>  Inc(FDigest[0], A2);
<tr class="covered"><td>2630<td>  Inc(FDigest[1], B2);
<tr class="covered"><td>2631<td>  Inc(FDigest[2], C2);
<tr class="covered"><td>2632<td>  Inc(FDigest[3], D2);
<tr class="covered"><td>2633<td>  Inc(FDigest[4], E1);
<tr class="covered"><td>2634<td>  Inc(FDigest[5], A1);
<tr class="covered"><td>2635<td>  Inc(FDigest[6], B1);
<tr class="covered"><td>2636<td>  Inc(FDigest[7], C1);
<tr class="covered"><td>2637<td>  Inc(FDigest[8], D1);
<tr class="covered"><td>2638<td>  Inc(FDigest[9], E2);
<tr class="covered"><td>2639<td>end;
<tr class="nocodegen"><td>2640<td>{$ENDIF !THash_RipeMD320_asm}
<tr class="nocodegen"><td>2641<td>
<tr class="nocodegen"><td>2642<td>class function THash_RipeMD320.DigestSize: UInt32;
<tr class="covered"><td>2643<td>begin
<tr class="covered"><td>2644<td>  Result := 40;
<tr class="covered"><td>2645<td>end;
<tr class="nocodegen"><td>2646<td>
<tr class="nocodegen"><td>2647<td>{ THash_SHA }
<tr class="nocodegen"><td>2648<td>
<tr class="nocodegen"><td>2649<td>{$IFNDEF THash_SHA_asm}
<tr class="nocodegen"><td>2650<td>procedure THash_SHA0.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>2651<td>var
<tr class="nocodegen"><td>2652<td>  A, B, C, D, E, T: UInt32;
<tr class="nocodegen"><td>2653<td>  W: array[0..79] of UInt32;
<tr class="nocodegen"><td>2654<td>  I: Integer;
<tr class="covered"><td>2655<td>begin
<tr class="covered"><td>2656<td>  SwapUInt32Buffer(Buffer[0], W, 16);
<tr class="covered"><td>2657<td>  if ClassType &lt;&gt; THash_SHA1 then
<tr class="nocodegen"><td>2658<td>  begin
<tr class="covered"><td>2659<td>    for I := 16 to 79 do
<tr class="nocodegen"><td>2660<td>    begin
<tr class="covered"><td>2661<td>      T := W[I - 3] xor W[I - 8] xor W[I - 14] xor W[I - 16];
<tr class="covered"><td>2662<td>      W[I] := T;
<tr class="covered"><td>2663<td>    end;
<tr class="nocodegen"><td>2664<td>  end
<tr class="nocodegen"><td>2665<td>  else
<tr class="nocodegen"><td>2666<td>  begin
<tr class="covered"><td>2667<td>    for I := 16 to 79 do
<tr class="nocodegen"><td>2668<td>    begin
<tr class="covered"><td>2669<td>      T := W[I - 3] xor W[I - 8] xor W[I - 14] xor W[I - 16];
<tr class="covered"><td>2670<td>      W[I] := T shl 1 or T shr 31;
<tr class="covered"><td>2671<td>    end;
<tr class="nocodegen"><td>2672<td>  end;
<tr class="nocodegen"><td>2673<td>
<tr class="covered"><td>2674<td>  A := FDigest[0];
<tr class="covered"><td>2675<td>  B := FDigest[1];
<tr class="covered"><td>2676<td>  C := FDigest[2];
<tr class="covered"><td>2677<td>  D := FDigest[3];
<tr class="covered"><td>2678<td>  E := FDigest[4];
<tr class="nocodegen"><td>2679<td>
<tr class="covered"><td>2680<td>  Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[ 0] + $5A827999); B := B shr 2 or B shl 30;
<tr class="covered"><td>2681<td>  Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[ 1] + $5A827999); A := A shr 2 or A shl 30;
<tr class="covered"><td>2682<td>  Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[ 2] + $5A827999); E := E shr 2 or E shl 30;
<tr class="covered"><td>2683<td>  Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[ 3] + $5A827999); D := D shr 2 or D shl 30;
<tr class="covered"><td>2684<td>  Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[ 4] + $5A827999); C := C shr 2 or C shl 30;
<tr class="covered"><td>2685<td>  Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[ 5] + $5A827999); B := B shr 2 or B shl 30;
<tr class="covered"><td>2686<td>  Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[ 6] + $5A827999); A := A shr 2 or A shl 30;
<tr class="covered"><td>2687<td>  Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[ 7] + $5A827999); E := E shr 2 or E shl 30;
<tr class="covered"><td>2688<td>  Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[ 8] + $5A827999); D := D shr 2 or D shl 30;
<tr class="covered"><td>2689<td>  Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[ 9] + $5A827999); C := C shr 2 or C shl 30;
<tr class="covered"><td>2690<td>  Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[10] + $5A827999); B := B shr 2 or B shl 30;
<tr class="covered"><td>2691<td>  Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[11] + $5A827999); A := A shr 2 or A shl 30;
<tr class="covered"><td>2692<td>  Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[12] + $5A827999); E := E shr 2 or E shl 30;
<tr class="covered"><td>2693<td>  Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[13] + $5A827999); D := D shr 2 or D shl 30;
<tr class="covered"><td>2694<td>  Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[14] + $5A827999); C := C shr 2 or C shl 30;
<tr class="covered"><td>2695<td>  Inc(E, (A shl 5 or A shr 27) + (D xor (B and (C xor D))) + W[15] + $5A827999); B := B shr 2 or B shl 30;
<tr class="covered"><td>2696<td>  Inc(D, (E shl 5 or E shr 27) + (C xor (A and (B xor C))) + W[16] + $5A827999); A := A shr 2 or A shl 30;
<tr class="covered"><td>2697<td>  Inc(C, (D shl 5 or D shr 27) + (B xor (E and (A xor B))) + W[17] + $5A827999); E := E shr 2 or E shl 30;
<tr class="covered"><td>2698<td>  Inc(B, (C shl 5 or C shr 27) + (A xor (D and (E xor A))) + W[18] + $5A827999); D := D shr 2 or D shl 30;
<tr class="covered"><td>2699<td>  Inc(A, (B shl 5 or B shr 27) + (E xor (C and (D xor E))) + W[19] + $5A827999); C := C shr 2 or C shl 30;
<tr class="nocodegen"><td>2700<td>
<tr class="covered"><td>2701<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[20] + $6ED9EBA1); B := B shr 2 or B shl 30;
<tr class="covered"><td>2702<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[21] + $6ED9EBA1); A := A shr 2 or A shl 30;
<tr class="covered"><td>2703<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[22] + $6ED9EBA1); E := E shr 2 or E shl 30;
<tr class="covered"><td>2704<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[23] + $6ED9EBA1); D := D shr 2 or D shl 30;
<tr class="covered"><td>2705<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[24] + $6ED9EBA1); C := C shr 2 or C shl 30;
<tr class="covered"><td>2706<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[25] + $6ED9EBA1); B := B shr 2 or B shl 30;
<tr class="covered"><td>2707<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[26] + $6ED9EBA1); A := A shr 2 or A shl 30;
<tr class="covered"><td>2708<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[27] + $6ED9EBA1); E := E shr 2 or E shl 30;
<tr class="covered"><td>2709<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[28] + $6ED9EBA1); D := D shr 2 or D shl 30;
<tr class="covered"><td>2710<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[29] + $6ED9EBA1); C := C shr 2 or C shl 30;
<tr class="covered"><td>2711<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[30] + $6ED9EBA1); B := B shr 2 or B shl 30;
<tr class="covered"><td>2712<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[31] + $6ED9EBA1); A := A shr 2 or A shl 30;
<tr class="covered"><td>2713<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[32] + $6ED9EBA1); E := E shr 2 or E shl 30;
<tr class="covered"><td>2714<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[33] + $6ED9EBA1); D := D shr 2 or D shl 30;
<tr class="covered"><td>2715<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[34] + $6ED9EBA1); C := C shr 2 or C shl 30;
<tr class="covered"><td>2716<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[35] + $6ED9EBA1); B := B shr 2 or B shl 30;
<tr class="covered"><td>2717<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[36] + $6ED9EBA1); A := A shr 2 or A shl 30;
<tr class="covered"><td>2718<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[37] + $6ED9EBA1); E := E shr 2 or E shl 30;
<tr class="covered"><td>2719<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[38] + $6ED9EBA1); D := D shr 2 or D shl 30;
<tr class="covered"><td>2720<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[39] + $6ED9EBA1); C := C shr 2 or C shl 30;
<tr class="nocodegen"><td>2721<td>
<tr class="covered"><td>2722<td>  Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[40] + $8F1BBCDC); B := B shr 2 or B shl 30;
<tr class="covered"><td>2723<td>  Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[41] + $8F1BBCDC); A := A shr 2 or A shl 30;
<tr class="covered"><td>2724<td>  Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[42] + $8F1BBCDC); E := E shr 2 or E shl 30;
<tr class="covered"><td>2725<td>  Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[43] + $8F1BBCDC); D := D shr 2 or D shl 30;
<tr class="covered"><td>2726<td>  Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[44] + $8F1BBCDC); C := C shr 2 or C shl 30;
<tr class="covered"><td>2727<td>  Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[45] + $8F1BBCDC); B := B shr 2 or B shl 30;
<tr class="covered"><td>2728<td>  Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[46] + $8F1BBCDC); A := A shr 2 or A shl 30;
<tr class="covered"><td>2729<td>  Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[47] + $8F1BBCDC); E := E shr 2 or E shl 30;
<tr class="covered"><td>2730<td>  Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[48] + $8F1BBCDC); D := D shr 2 or D shl 30;
<tr class="covered"><td>2731<td>  Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[49] + $8F1BBCDC); C := C shr 2 or C shl 30;
<tr class="covered"><td>2732<td>  Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[50] + $8F1BBCDC); B := B shr 2 or B shl 30;
<tr class="covered"><td>2733<td>  Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[51] + $8F1BBCDC); A := A shr 2 or A shl 30;
<tr class="covered"><td>2734<td>  Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[52] + $8F1BBCDC); E := E shr 2 or E shl 30;
<tr class="covered"><td>2735<td>  Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[53] + $8F1BBCDC); D := D shr 2 or D shl 30;
<tr class="covered"><td>2736<td>  Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[54] + $8F1BBCDC); C := C shr 2 or C shl 30;
<tr class="covered"><td>2737<td>  Inc(E, (A shl 5 or A shr 27) + ((B and C) or (D and (B or C))) + W[55] + $8F1BBCDC); B := B shr 2 or B shl 30;
<tr class="covered"><td>2738<td>  Inc(D, (E shl 5 or E shr 27) + ((A and B) or (C and (A or B))) + W[56] + $8F1BBCDC); A := A shr 2 or A shl 30;
<tr class="covered"><td>2739<td>  Inc(C, (D shl 5 or D shr 27) + ((E and A) or (B and (E or A))) + W[57] + $8F1BBCDC); E := E shr 2 or E shl 30;
<tr class="covered"><td>2740<td>  Inc(B, (C shl 5 or C shr 27) + ((D and E) or (A and (D or E))) + W[58] + $8F1BBCDC); D := D shr 2 or D shl 30;
<tr class="covered"><td>2741<td>  Inc(A, (B shl 5 or B shr 27) + ((C and D) or (E and (C or D))) + W[59] + $8F1BBCDC); C := C shr 2 or C shl 30;
<tr class="nocodegen"><td>2742<td>
<tr class="covered"><td>2743<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[60] + $CA62C1D6); B := B shr 2 or B shl 30;
<tr class="covered"><td>2744<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[61] + $CA62C1D6); A := A shr 2 or A shl 30;
<tr class="covered"><td>2745<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[62] + $CA62C1D6); E := E shr 2 or E shl 30;
<tr class="covered"><td>2746<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[63] + $CA62C1D6); D := D shr 2 or D shl 30;
<tr class="covered"><td>2747<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[64] + $CA62C1D6); C := C shr 2 or C shl 30;
<tr class="covered"><td>2748<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[65] + $CA62C1D6); B := B shr 2 or B shl 30;
<tr class="covered"><td>2749<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[66] + $CA62C1D6); A := A shr 2 or A shl 30;
<tr class="covered"><td>2750<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[67] + $CA62C1D6); E := E shr 2 or E shl 30;
<tr class="covered"><td>2751<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[68] + $CA62C1D6); D := D shr 2 or D shl 30;
<tr class="covered"><td>2752<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[69] + $CA62C1D6); C := C shr 2 or C shl 30;
<tr class="covered"><td>2753<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[70] + $CA62C1D6); B := B shr 2 or B shl 30;
<tr class="covered"><td>2754<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[71] + $CA62C1D6); A := A shr 2 or A shl 30;
<tr class="covered"><td>2755<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[72] + $CA62C1D6); E := E shr 2 or E shl 30;
<tr class="covered"><td>2756<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[73] + $CA62C1D6); D := D shr 2 or D shl 30;
<tr class="covered"><td>2757<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[74] + $CA62C1D6); C := C shr 2 or C shl 30;
<tr class="covered"><td>2758<td>  Inc(E, (A shl 5 or A shr 27) + (D xor B xor C) + W[75] + $CA62C1D6); B := B shr 2 or B shl 30;
<tr class="covered"><td>2759<td>  Inc(D, (E shl 5 or E shr 27) + (C xor A xor B) + W[76] + $CA62C1D6); A := A shr 2 or A shl 30;
<tr class="covered"><td>2760<td>  Inc(C, (D shl 5 or D shr 27) + (B xor E xor A) + W[77] + $CA62C1D6); E := E shr 2 or E shl 30;
<tr class="covered"><td>2761<td>  Inc(B, (C shl 5 or C shr 27) + (A xor D xor E) + W[78] + $CA62C1D6); D := D shr 2 or D shl 30;
<tr class="covered"><td>2762<td>  Inc(A, (B shl 5 or B shr 27) + (E xor C xor D) + W[79] + $CA62C1D6); C := C shr 2 or C shl 30;
<tr class="nocodegen"><td>2763<td>
<tr class="covered"><td>2764<td>  Inc(FDigest[0], A);
<tr class="covered"><td>2765<td>  Inc(FDigest[1], B);
<tr class="covered"><td>2766<td>  Inc(FDigest[2], C);
<tr class="covered"><td>2767<td>  Inc(FDigest[3], D);
<tr class="covered"><td>2768<td>  Inc(FDigest[4], E);
<tr class="covered"><td>2769<td>end;
<tr class="nocodegen"><td>2770<td>{$ENDIF !THash_SHA_asm}
<tr class="nocodegen"><td>2771<td>
<tr class="nocodegen"><td>2772<td>procedure THash_SHA0.DoDone;
<tr class="covered"><td>2773<td>begin
<tr class="covered"><td>2774<td>  if FCount[2] or FCount[3] &lt;&gt; 0 then
<tr class="notcovered"><td>2775<td>    RaiseHashOverflowError;
<tr class="covered"><td>2776<td>  if FPaddingByte = 0 then
<tr class="covered"><td>2777<td>    FPaddingByte := $80;
<tr class="covered"><td>2778<td>  FBuffer[FBufferIndex] := FPaddingByte;
<tr class="covered"><td>2779<td>  Inc(FBufferIndex);
<tr class="covered"><td>2780<td>  if FBufferIndex &gt; FBufferSize - 8 then
<tr class="nocodegen"><td>2781<td>  begin
<tr class="covered"><td>2782<td>    FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>2783<td>    DoTransform(Pointer(FBuffer));
<tr class="covered"><td>2784<td>    FBufferIndex := 0;
<tr class="nocodegen"><td>2785<td>  end;
<tr class="covered"><td>2786<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>2787<td>  PUInt32(@FBuffer[FBufferSize - 8])^ := SwapUInt32(FCount[1]);
<tr class="covered"><td>2788<td>  PUInt32(@FBuffer[FBufferSize - 4])^ := SwapUInt32(FCount[0]);
<tr class="covered"><td>2789<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>2790<td>  SwapUInt32Buffer(FDigest, FDigest, SizeOf(FDigest) div 4);
<tr class="covered"><td>2791<td>end;
<tr class="nocodegen"><td>2792<td>
<tr class="nocodegen"><td>2793<td>class function THash_SHA0.DigestSize: UInt32;
<tr class="covered"><td>2794<td>begin
<tr class="covered"><td>2795<td>  Result := 20;
<tr class="covered"><td>2796<td>end;
<tr class="nocodegen"><td>2797<td>
<tr class="nocodegen"><td>2798<td>{ THash_SHA256 }
<tr class="nocodegen"><td>2799<td>
<tr class="nocodegen"><td>2800<td>procedure THash_SHA256.DoInit;
<tr class="covered"><td>2801<td>begin
<tr class="covered"><td>2802<td>  FDigest[0]:= $6A09E667;
<tr class="covered"><td>2803<td>  FDigest[1]:= $BB67AE85;
<tr class="covered"><td>2804<td>  FDigest[2]:= $3C6EF372;
<tr class="covered"><td>2805<td>  FDigest[3]:= $A54FF53A;
<tr class="covered"><td>2806<td>  FDigest[4]:= $510E527F;
<tr class="covered"><td>2807<td>  FDigest[5]:= $9B05688C;
<tr class="covered"><td>2808<td>  FDigest[6]:= $1F83D9AB;
<tr class="covered"><td>2809<td>  FDigest[7]:= $5BE0CD19;
<tr class="covered"><td>2810<td>end;
<tr class="nocodegen"><td>2811<td>
<tr class="nocodegen"><td>2812<td>{$IFNDEF THash_SHA256_asm}
<tr class="nocodegen"><td>2813<td>procedure THash_SHA256.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>2814<td>var
<tr class="nocodegen"><td>2815<td>  I: Integer;
<tr class="nocodegen"><td>2816<td>  A, B, C, D, E, F, G, H: UInt32;
<tr class="nocodegen"><td>2817<td>  T1, T2: UInt32;
<tr class="nocodegen"><td>2818<td>  W: array[0..63] of UInt32;
<tr class="covered"><td>2819<td>begin
<tr class="covered"><td>2820<td>  SwapUInt32Buffer(Buffer[0], W, 16);
<tr class="nocodegen"><td>2821<td>
<tr class="covered"><td>2822<td>  for I := 16 to 63 do
<tr class="nocodegen"><td>2823<td>  begin
<tr class="covered"><td>2824<td>    T1 := W[I - 15];
<tr class="covered"><td>2825<td>    T2 := W[I - 2];
<tr class="covered"><td>2826<td>    W[I] := W[I - 16] + W[I - 7] +
<tr class="nocodegen"><td>2827<td>            ((T1 shr  7 or T1 shl 25) xor (T1 shr 18 or T1 shl 14) xor (T1 shr  3)) +
<tr class="nocodegen"><td>2828<td>            ((T2 shr 17 or T2 shl 15) xor (T2 shr 19 or T2 shl 13) xor (T2 shr 10));
<tr class="covered"><td>2829<td>  end;
<tr class="nocodegen"><td>2830<td>
<tr class="nocodegen"><td>2831<td>  // calculate new hash values
<tr class="covered"><td>2832<td>  A := FDigest[0];
<tr class="covered"><td>2833<td>  B := FDigest[1];
<tr class="covered"><td>2834<td>  C := FDigest[2];
<tr class="covered"><td>2835<td>  D := FDigest[3];
<tr class="covered"><td>2836<td>  E := FDigest[4];
<tr class="covered"><td>2837<td>  F := FDigest[5];
<tr class="covered"><td>2838<td>  G := FDigest[6];
<tr class="covered"><td>2839<td>  H := FDigest[7];
<tr class="nocodegen"><td>2840<td>
<tr class="covered"><td>2841<td>  for I := 0 to 63 do
<tr class="nocodegen"><td>2842<td>  begin
<tr class="covered"><td>2843<td>    T1 := ((E shr 6 or E shl 26) xor (E shr 11 or E shl 21) xor
<tr class="nocodegen"><td>2844<td>           (E shr 25 or E shl 7)) + H + (((F xor G) and E) xor G) + SHA_256K[I] + W[I];
<tr class="covered"><td>2845<td>    T2 := ((A shr 2 or A shl 30) xor (A shr 13 or A shl 19) xor
<tr class="nocodegen"><td>2846<td>           (A shr 22 or A shl 10)) + (((B or C) and A) or (B and C));
<tr class="covered"><td>2847<td>    H := G; G := F; F := E; E := D + T1; D := C; C := B; B := A; A := T1 + T2;
<tr class="covered"><td>2848<td>  end;
<tr class="nocodegen"><td>2849<td>
<tr class="covered"><td>2850<td>  Inc(FDigest[0], A);
<tr class="covered"><td>2851<td>  Inc(FDigest[1], B);
<tr class="covered"><td>2852<td>  Inc(FDigest[2], C);
<tr class="covered"><td>2853<td>  Inc(FDigest[3], D);
<tr class="covered"><td>2854<td>  Inc(FDigest[4], E);
<tr class="covered"><td>2855<td>  Inc(FDigest[5], F);
<tr class="covered"><td>2856<td>  Inc(FDigest[6], G);
<tr class="covered"><td>2857<td>  Inc(FDigest[7], H);
<tr class="covered"><td>2858<td>end;
<tr class="nocodegen"><td>2859<td>{$ENDIF !THash_SHA256_asm}
<tr class="nocodegen"><td>2860<td>
<tr class="nocodegen"><td>2861<td>class function THash_SHA256.DigestSize: UInt32;
<tr class="covered"><td>2862<td>begin
<tr class="covered"><td>2863<td>  Result := 32;
<tr class="covered"><td>2864<td>end;
<tr class="nocodegen"><td>2865<td>
<tr class="nocodegen"><td>2866<td>{ THash_SHA224 }
<tr class="nocodegen"><td>2867<td>
<tr class="nocodegen"><td>2868<td>class function THash_SHA224.BlockSize: UInt32;
<tr class="covered"><td>2869<td>begin
<tr class="covered"><td>2870<td>  Result := 64;
<tr class="covered"><td>2871<td>end;
<tr class="nocodegen"><td>2872<td>
<tr class="nocodegen"><td>2873<td>class function THash_SHA224.DigestSize: UInt32;
<tr class="covered"><td>2874<td>begin
<tr class="covered"><td>2875<td>  Result := 28;
<tr class="covered"><td>2876<td>end;
<tr class="nocodegen"><td>2877<td>
<tr class="nocodegen"><td>2878<td>procedure THash_SHA224.DoInit;
<tr class="covered"><td>2879<td>begin
<tr class="covered"><td>2880<td>  FDigest[0]:= $C1059ED8;
<tr class="covered"><td>2881<td>  FDigest[1]:= $367CD507;
<tr class="covered"><td>2882<td>  FDigest[2]:= $3070DD17;
<tr class="covered"><td>2883<td>  FDigest[3]:= $F70E5939;
<tr class="covered"><td>2884<td>  FDigest[4]:= $FFC00B31;
<tr class="covered"><td>2885<td>  FDigest[5]:= $68581511;
<tr class="covered"><td>2886<td>  FDigest[6]:= $64F98FA7;
<tr class="covered"><td>2887<td>  FDigest[7]:= $BEFA4FA4;
<tr class="covered"><td>2888<td>end;
<tr class="nocodegen"><td>2889<td>
<tr class="nocodegen"><td>2890<td>{ THash_SHA384 }
<tr class="nocodegen"><td>2891<td>
<tr class="nocodegen"><td>2892<td>procedure THash_SHA384.DoInit;
<tr class="covered"><td>2893<td>begin
<tr class="covered"><td>2894<td>  FDigest[0] := Int64($CBBB9D5DC1059ED8);
<tr class="covered"><td>2895<td>  FDigest[1] := Int64($629A292A367CD507);
<tr class="covered"><td>2896<td>  FDigest[2] := Int64($9159015A3070DD17);
<tr class="covered"><td>2897<td>  FDigest[3] := Int64($152FECD8F70E5939);
<tr class="covered"><td>2898<td>  FDigest[4] := Int64($67332667FFC00B31);
<tr class="covered"><td>2899<td>  FDigest[5] := Int64($8EB44A8768581511);
<tr class="covered"><td>2900<td>  FDigest[6] := Int64($DB0C2E0D64F98FA7);
<tr class="covered"><td>2901<td>  FDigest[7] := Int64($47B5481DBEFA4FA4);
<tr class="covered"><td>2902<td>end;
<tr class="nocodegen"><td>2903<td>
<tr class="nocodegen"><td>2904<td>{$IFNDEF THash_SHA384_asm}
<tr class="nocodegen"><td>2905<td>procedure THash_SHA384.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>2906<td>var
<tr class="nocodegen"><td>2907<td>  A, B, C, D, E, F, G, H: UInt64;
<tr class="nocodegen"><td>2908<td>  T1, T2: UInt64;
<tr class="nocodegen"><td>2909<td>  I: Integer;
<tr class="nocodegen"><td>2910<td>  W: array [0..79] of UInt64;
<tr class="covered"><td>2911<td>begin
<tr class="nocodegen"><td>2912<td>{ TODO : The array passed is a UInt32 array, which doesn't fit with the name of this method!}
<tr class="covered"><td>2913<td>  SwapInt64Buffer(Buffer[0], W, 16);
<tr class="nocodegen"><td>2914<td>
<tr class="nocodegen"><td>2915<td>  // calculate other 64 uint64
<tr class="covered"><td>2916<td>  for I := 16 to 79 do
<tr class="nocodegen"><td>2917<td>  begin
<tr class="covered"><td>2918<td>    T1 := W[I - 15];
<tr class="covered"><td>2919<td>    T2 := W[I - 2];
<tr class="covered"><td>2920<td>    W[I] := W[I - 16] + W[I - 7] +
<tr class="nocodegen"><td>2921<td>            ((T1 shr  1 or T1 shl 63) xor (T1 shr  8 or T1 shl 56) xor (T1 shr  7)) +
<tr class="nocodegen"><td>2922<td>            ((T2 shr 19 or T2 shl 45) xor (T2 shr 61 or T2 shl  3) xor (T2 shr  6));
<tr class="covered"><td>2923<td>  end;
<tr class="nocodegen"><td>2924<td>
<tr class="nocodegen"><td>2925<td>  // calculate new hash values
<tr class="covered"><td>2926<td>  A := FDigest[0];
<tr class="covered"><td>2927<td>  B := FDigest[1];
<tr class="covered"><td>2928<td>  C := FDigest[2];
<tr class="covered"><td>2929<td>  D := FDigest[3];
<tr class="covered"><td>2930<td>  E := FDigest[4];
<tr class="covered"><td>2931<td>  F := FDigest[5];
<tr class="covered"><td>2932<td>  G := FDigest[6];
<tr class="covered"><td>2933<td>  H := FDigest[7];
<tr class="nocodegen"><td>2934<td>
<tr class="covered"><td>2935<td>  for I := 0 to 79 do
<tr class="nocodegen"><td>2936<td>  begin
<tr class="covered"><td>2937<td>    T1 := ((E shr 14 or E shl 50) xor (E shr 18 or E shl 46) xor
<tr class="nocodegen"><td>2938<td>           (E shr 41 or E shl 23)) + H + (((F xor G) and E) xor G) + SHA_512K[I] + W[I];
<tr class="covered"><td>2939<td>    T2 := ((A shr 28 or A shl 36) xor (A shr 34 or A shl 30) xor
<tr class="nocodegen"><td>2940<td>           (A shr 39 or A shl 25)) + (((B or C) and A) or (B and C));
<tr class="covered"><td>2941<td>    H := G;
<tr class="covered"><td>2942<td>    G := F;
<tr class="covered"><td>2943<td>    F := E;
<tr class="covered"><td>2944<td>    E := D + T1;
<tr class="covered"><td>2945<td>    D := C;
<tr class="covered"><td>2946<td>    C := B;
<tr class="covered"><td>2947<td>    B := A;
<tr class="covered"><td>2948<td>    A := T1 + T2;
<tr class="covered"><td>2949<td>  end;
<tr class="nocodegen"><td>2950<td>
<tr class="covered"><td>2951<td>  Inc(FDigest[0], A);
<tr class="covered"><td>2952<td>  Inc(FDigest[1], B);
<tr class="covered"><td>2953<td>  Inc(FDigest[2], C);
<tr class="covered"><td>2954<td>  Inc(FDigest[3], D);
<tr class="covered"><td>2955<td>  Inc(FDigest[4], E);
<tr class="covered"><td>2956<td>  Inc(FDigest[5], F);
<tr class="covered"><td>2957<td>  Inc(FDigest[6], G);
<tr class="covered"><td>2958<td>  Inc(FDigest[7], H);
<tr class="covered"><td>2959<td>end;
<tr class="nocodegen"><td>2960<td>{$ENDIF !THash_SHA384_asm}
<tr class="nocodegen"><td>2961<td>
<tr class="nocodegen"><td>2962<td>procedure THash_SHA384.DoDone;
<tr class="covered"><td>2963<td>begin
<tr class="covered"><td>2964<td>  if FPaddingByte = 0 then
<tr class="covered"><td>2965<td>    FPaddingByte := $80;
<tr class="covered"><td>2966<td>  FBuffer[FBufferIndex] := FPaddingByte;
<tr class="covered"><td>2967<td>  Inc(FBufferIndex);
<tr class="covered"><td>2968<td>  if FBufferIndex &gt; FBufferSize - 16 then
<tr class="nocodegen"><td>2969<td>  begin
<tr class="covered"><td>2970<td>    FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>2971<td>    DoTransform(Pointer(FBuffer));
<tr class="covered"><td>2972<td>    FBufferIndex := 0;
<tr class="nocodegen"><td>2973<td>  end;
<tr class="covered"><td>2974<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>2975<td>  SwapUInt32Buffer(FCount, FCount, 4);
<tr class="covered"><td>2976<td>  PUInt32(@FBuffer[FBufferSize - 16])^ := FCount[3];
<tr class="covered"><td>2977<td>  PUInt32(@FBuffer[FBufferSize - 12])^ := FCount[2];
<tr class="covered"><td>2978<td>  PUInt32(@FBuffer[FBufferSize -  8])^ := FCount[1];
<tr class="covered"><td>2979<td>  PUInt32(@FBuffer[FBufferSize -  4])^ := FCount[0];
<tr class="covered"><td>2980<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>2981<td>  SwapInt64Buffer(FDigest, FDigest, SizeOf(FDigest) div 8);
<tr class="covered"><td>2982<td>end;
<tr class="nocodegen"><td>2983<td>
<tr class="nocodegen"><td>2984<td>function THash_SHA384.Digest: PByteArray;
<tr class="covered"><td>2985<td>begin
<tr class="covered"><td>2986<td>  Result := @FDigest;
<tr class="covered"><td>2987<td>end;
<tr class="nocodegen"><td>2988<td>
<tr class="nocodegen"><td>2989<td>class function THash_SHA384.DigestSize: UInt32;
<tr class="covered"><td>2990<td>begin
<tr class="covered"><td>2991<td>  Result := 48;
<tr class="covered"><td>2992<td>end;
<tr class="nocodegen"><td>2993<td>
<tr class="nocodegen"><td>2994<td>class function THash_SHA384.BlockSize: UInt32;
<tr class="covered"><td>2995<td>begin
<tr class="covered"><td>2996<td>  Result := 128;
<tr class="covered"><td>2997<td>end;
<tr class="nocodegen"><td>2998<td>
<tr class="nocodegen"><td>2999<td>{ THash_SHA512 }
<tr class="nocodegen"><td>3000<td>
<tr class="nocodegen"><td>3001<td>procedure THash_SHA512.DoInit;
<tr class="covered"><td>3002<td>begin
<tr class="covered"><td>3003<td>  FDigest[0] := Int64($6A09E667F3BCC908);
<tr class="covered"><td>3004<td>  FDigest[1] := Int64($BB67AE8584CAA73B);
<tr class="covered"><td>3005<td>  FDigest[2] := Int64($3C6EF372FE94F82B);
<tr class="covered"><td>3006<td>  FDigest[3] := Int64($A54FF53A5F1D36F1);
<tr class="covered"><td>3007<td>  FDigest[4] := Int64($510E527FADE682D1);
<tr class="covered"><td>3008<td>  FDigest[5] := Int64($9B05688C2B3E6C1F);
<tr class="covered"><td>3009<td>  FDigest[6] := Int64($1F83D9ABFB41BD6B);
<tr class="covered"><td>3010<td>  FDigest[7] := Int64($5BE0CD19137E2179);
<tr class="covered"><td>3011<td>end;
<tr class="nocodegen"><td>3012<td>
<tr class="nocodegen"><td>3013<td>class function THash_SHA512.DigestSize: UInt32;
<tr class="covered"><td>3014<td>begin
<tr class="covered"><td>3015<td>  Result := 64;
<tr class="covered"><td>3016<td>end;
<tr class="nocodegen"><td>3017<td>
<tr class="nocodegen"><td>3018<td>{ THashBaseHaval }
<tr class="nocodegen"><td>3019<td>
<tr class="nocodegen"><td>3020<td>procedure THashBaseHaval.SetRounds(Value: UInt32);
<tr class="covered"><td>3021<td>begin
<tr class="covered"><td>3022<td>  if (Value &lt; GetMinRounds) or (Value &gt; 5) then
<tr class="nocodegen"><td>3023<td>  begin
<tr class="covered"><td>3024<td>    if DigestSize &lt;= 20 then
<tr class="covered"><td>3025<td>      Value := 3
<tr class="nocodegen"><td>3026<td>    else
<tr class="nocodegen"><td>3027<td>    begin
<tr class="covered"><td>3028<td>      if DigestSize &lt;= 28 then
<tr class="covered"><td>3029<td>        Value := 4
<tr class="nocodegen"><td>3030<td>      else
<tr class="covered"><td>3031<td>        Value := 5;
<tr class="nocodegen"><td>3032<td>    end;
<tr class="nocodegen"><td>3033<td>  end;
<tr class="covered"><td>3034<td>  FRounds := Value;
<tr class="covered"><td>3035<td>  case FRounds of
<tr class="covered"><td>3036<td>    3: FTransform := DoTransform3;
<tr class="covered"><td>3037<td>    4: FTransform := DoTransform4;
<tr class="covered"><td>3038<td>    5: FTransform := DoTransform5;
<tr class="nocodegen"><td>3039<td>  end;
<tr class="covered"><td>3040<td>end;
<tr class="nocodegen"><td>3041<td>
<tr class="nocodegen"><td>3042<td>procedure THashBaseHaval.DoInit;
<tr class="covered"><td>3043<td>begin
<tr class="covered"><td>3044<td>  SetRounds(FRounds);
<tr class="covered"><td>3045<td>  FDigest[0] := $243F6A88;
<tr class="covered"><td>3046<td>  FDigest[1] := $85A308D3;
<tr class="covered"><td>3047<td>  FDigest[2] := $13198A2E;
<tr class="covered"><td>3048<td>  FDigest[3] := $03707344;
<tr class="covered"><td>3049<td>  FDigest[4] := $A4093822;
<tr class="covered"><td>3050<td>  FDigest[5] := $299F31D0;
<tr class="covered"><td>3051<td>  FDigest[6] := $082EFA98;
<tr class="covered"><td>3052<td>  FDigest[7] := $EC4E6C89;
<tr class="covered"><td>3053<td>end;
<tr class="nocodegen"><td>3054<td>
<tr class="nocodegen"><td>3055<td>procedure THashBaseHaval.DoTransform(Buffer: PUInt32Array);
<tr class="covered"><td>3056<td>begin
<tr class="covered"><td>3057<td>  FTransform(Buffer);
<tr class="covered"><td>3058<td>end;
<tr class="nocodegen"><td>3059<td>
<tr class="nocodegen"><td>3060<td>function THashBaseHaval.GetMaxRounds: UInt32;
<tr class="covered"><td>3061<td>begin
<tr class="covered"><td>3062<td>  Result := 5;
<tr class="covered"><td>3063<td>end;
<tr class="nocodegen"><td>3064<td>
<tr class="nocodegen"><td>3065<td>function THashBaseHaval.GetMinRounds: UInt32;
<tr class="covered"><td>3066<td>begin
<tr class="covered"><td>3067<td>  if DigestSize &lt;= 20 then
<tr class="covered"><td>3068<td>    Result := 3
<tr class="nocodegen"><td>3069<td>  else
<tr class="nocodegen"><td>3070<td>  begin
<tr class="covered"><td>3071<td>    if DigestSize &lt;= 28 then
<tr class="covered"><td>3072<td>      Result := 4
<tr class="nocodegen"><td>3073<td>    else
<tr class="covered"><td>3074<td>      Result := 5;
<tr class="nocodegen"><td>3075<td>  end;
<tr class="covered"><td>3076<td>end;
<tr class="nocodegen"><td>3077<td>
<tr class="nocodegen"><td>3078<td>function THashBaseHaval.GetRounds: UInt32;
<tr class="covered"><td>3079<td>begin
<tr class="covered"><td>3080<td>  Result := FRounds;
<tr class="covered"><td>3081<td>end;
<tr class="nocodegen"><td>3082<td>
<tr class="nocodegen"><td>3083<td>{$IFNDEF THashBaseHaval_asm}
<tr class="nocodegen"><td>3084<td>procedure THashBaseHaval.DoTransform3(Buffer: PUInt32Array);
<tr class="nocodegen"><td>3085<td>var
<tr class="nocodegen"><td>3086<td>  A, B, C, D, E, F, G, H, I, T: UInt32;
<tr class="nocodegen"><td>3087<td>  Data: PUInt32;
<tr class="nocodegen"><td>3088<td>  Offset: PByte;
<tr class="covered"><td>3089<td>begin
<tr class="covered"><td>3090<td>  Offset := @Haval_Offset;
<tr class="covered"><td>3091<td>  Data   := @Haval_Data;
<tr class="nocodegen"><td>3092<td>
<tr class="covered"><td>3093<td>  A := FDigest[0];
<tr class="covered"><td>3094<td>  B := FDigest[1];
<tr class="covered"><td>3095<td>  C := FDigest[2];
<tr class="covered"><td>3096<td>  D := FDigest[3];
<tr class="covered"><td>3097<td>  E := FDigest[4];
<tr class="covered"><td>3098<td>  F := FDigest[5];
<tr class="covered"><td>3099<td>  G := FDigest[6];
<tr class="covered"><td>3100<td>  H := FDigest[7];
<tr class="nocodegen"><td>3101<td>
<tr class="covered"><td>3102<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3103<td>  begin
<tr class="covered"><td>3104<td>    T := C and (E xor D) xor G and A xor F and B xor E;
<tr class="covered"><td>3105<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[I];
<tr class="covered"><td>3106<td>	H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3107<td>  end;
<tr class="nocodegen"><td>3108<td>
<tr class="covered"><td>3109<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3110<td>  begin
<tr class="covered"><td>3111<td>    T := F and (D and not A xor B and C xor E xor G) xor B and (D xor C) xor A and C xor G;
<tr class="covered"><td>3112<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3113<td>    Inc(Offset);
<tr class="covered"><td>3114<td>    Inc(Data);
<tr class="covered"><td>3115<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3116<td>  end;
<tr class="nocodegen"><td>3117<td>
<tr class="covered"><td>3118<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3119<td>  begin
<tr class="covered"><td>3120<td>    T := D and (F and E xor G xor A) xor F and C xor E and B xor A;
<tr class="covered"><td>3121<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3122<td>    Inc(Offset);
<tr class="covered"><td>3123<td>    Inc(Data);
<tr class="covered"><td>3124<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3125<td>  end;
<tr class="nocodegen"><td>3126<td>
<tr class="covered"><td>3127<td>  Inc(FDigest[0], A);
<tr class="covered"><td>3128<td>  Inc(FDigest[1], B);
<tr class="covered"><td>3129<td>  Inc(FDigest[2], C);
<tr class="covered"><td>3130<td>  Inc(FDigest[3], D);
<tr class="covered"><td>3131<td>  Inc(FDigest[4], E);
<tr class="covered"><td>3132<td>  Inc(FDigest[5], F);
<tr class="covered"><td>3133<td>  Inc(FDigest[6], G);
<tr class="covered"><td>3134<td>  Inc(FDigest[7], H);
<tr class="covered"><td>3135<td>end;
<tr class="nocodegen"><td>3136<td>
<tr class="nocodegen"><td>3137<td>procedure THashBaseHaval.DoTransform4(Buffer: PUInt32Array);
<tr class="nocodegen"><td>3138<td>var
<tr class="nocodegen"><td>3139<td>  A, B, C, D, E, F, G, H, I, T: UInt32;
<tr class="nocodegen"><td>3140<td>  Data: PUInt32;
<tr class="nocodegen"><td>3141<td>  Offset: PByte;
<tr class="covered"><td>3142<td>begin
<tr class="covered"><td>3143<td>  Offset := @Haval_Offset;
<tr class="covered"><td>3144<td>  Data := @Haval_Data;
<tr class="nocodegen"><td>3145<td>
<tr class="covered"><td>3146<td>  A := FDigest[0];
<tr class="covered"><td>3147<td>  B := FDigest[1];
<tr class="covered"><td>3148<td>  C := FDigest[2];
<tr class="covered"><td>3149<td>  D := FDigest[3];
<tr class="covered"><td>3150<td>  E := FDigest[4];
<tr class="covered"><td>3151<td>  F := FDigest[5];
<tr class="covered"><td>3152<td>  G := FDigest[6];
<tr class="covered"><td>3153<td>  H := FDigest[7];
<tr class="nocodegen"><td>3154<td>
<tr class="covered"><td>3155<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3156<td>  begin
<tr class="covered"><td>3157<td>    T := D and (A xor B) xor F and G xor E and C xor A;
<tr class="covered"><td>3158<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[I];
<tr class="covered"><td>3159<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3160<td>  end;
<tr class="nocodegen"><td>3161<td>
<tr class="covered"><td>3162<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3163<td>  begin
<tr class="covered"><td>3164<td>    T := B and (G and not A xor C and F xor D xor E) xor C and (G xor F) xor A and F xor E;
<tr class="covered"><td>3165<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3166<td>    Inc(Offset);
<tr class="covered"><td>3167<td>    Inc(Data);
<tr class="covered"><td>3168<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3169<td>  end;
<tr class="nocodegen"><td>3170<td>
<tr class="covered"><td>3171<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3172<td>  begin
<tr class="covered"><td>3173<td>    T := G and (C and A xor B xor F) xor C and D xor A and E xor F;
<tr class="covered"><td>3174<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3175<td>    Inc(Offset);
<tr class="covered"><td>3176<td>    Inc(Data);
<tr class="covered"><td>3177<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3178<td>  end;
<tr class="nocodegen"><td>3179<td>
<tr class="covered"><td>3180<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3181<td>  begin
<tr class="covered"><td>3182<td>    T := A and (E and not C xor F and not G xor B xor G xor D) xor F and
<tr class="nocodegen"><td>3183<td>        (B and C xor E xor G) xor C and G xor D;
<tr class="covered"><td>3184<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3185<td>    Inc(Offset);
<tr class="covered"><td>3186<td>    Inc(Data);
<tr class="covered"><td>3187<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3188<td>  end;
<tr class="nocodegen"><td>3189<td>
<tr class="covered"><td>3190<td>  Inc(FDigest[0], A);
<tr class="covered"><td>3191<td>  Inc(FDigest[1], B);
<tr class="covered"><td>3192<td>  Inc(FDigest[2], C);
<tr class="covered"><td>3193<td>  Inc(FDigest[3], D);
<tr class="covered"><td>3194<td>  Inc(FDigest[4], E);
<tr class="covered"><td>3195<td>  Inc(FDigest[5], F);
<tr class="covered"><td>3196<td>  Inc(FDigest[6], G);
<tr class="covered"><td>3197<td>  Inc(FDigest[7], H);
<tr class="covered"><td>3198<td>end;
<tr class="nocodegen"><td>3199<td>
<tr class="nocodegen"><td>3200<td>procedure THashBaseHaval.DoTransform5(Buffer: PUInt32Array);
<tr class="nocodegen"><td>3201<td>var
<tr class="nocodegen"><td>3202<td>  A, B, C, D, E, F, G, H, I, T: UInt32;
<tr class="nocodegen"><td>3203<td>  Data: PUInt32;
<tr class="nocodegen"><td>3204<td>  Offset: PByte;
<tr class="covered"><td>3205<td>begin
<tr class="covered"><td>3206<td>  Offset := @Haval_Offset;
<tr class="covered"><td>3207<td>  Data := @Haval_Data;
<tr class="nocodegen"><td>3208<td>
<tr class="covered"><td>3209<td>  A := FDigest[0];
<tr class="covered"><td>3210<td>  B := FDigest[1];
<tr class="covered"><td>3211<td>  C := FDigest[2];
<tr class="covered"><td>3212<td>  D := FDigest[3];
<tr class="covered"><td>3213<td>  E := FDigest[4];
<tr class="covered"><td>3214<td>  F := FDigest[5];
<tr class="covered"><td>3215<td>  G := FDigest[6];
<tr class="covered"><td>3216<td>  H := FDigest[7];
<tr class="nocodegen"><td>3217<td>
<tr class="covered"><td>3218<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3219<td>  begin
<tr class="covered"><td>3220<td>    T := C and (G xor B) xor F and E xor A and D xor G;
<tr class="covered"><td>3221<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[I];
<tr class="covered"><td>3222<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3223<td>  end;
<tr class="nocodegen"><td>3224<td>
<tr class="covered"><td>3225<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3226<td>  begin
<tr class="covered"><td>3227<td>    T := D and (E and not A xor B and C xor G xor F) xor B and (E xor C) xor A and C xor F;
<tr class="covered"><td>3228<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3229<td>    Inc(Offset);
<tr class="covered"><td>3230<td>    Inc(Data);
<tr class="covered"><td>3231<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3232<td>  end;
<tr class="nocodegen"><td>3233<td>
<tr class="covered"><td>3234<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3235<td>  begin
<tr class="covered"><td>3236<td>    T := E and (B and D xor C xor F) xor B and A xor D and G xor F;
<tr class="covered"><td>3237<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3238<td>    Inc(Offset);
<tr class="covered"><td>3239<td>    Inc(Data);
<tr class="covered"><td>3240<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3241<td>  end;
<tr class="nocodegen"><td>3242<td>
<tr class="covered"><td>3243<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3244<td>  begin
<tr class="covered"><td>3245<td>    T := D and (F and not A xor C and not B xor E xor B xor G) xor C and
<tr class="nocodegen"><td>3246<td>        (E and A xor F xor B) xor A and B xor G;
<tr class="covered"><td>3247<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3248<td>    Inc(Offset);
<tr class="covered"><td>3249<td>    Inc(Data);
<tr class="covered"><td>3250<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3251<td>  end;
<tr class="nocodegen"><td>3252<td>
<tr class="covered"><td>3253<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3254<td>  begin
<tr class="covered"><td>3255<td>    T := B and (D and E and G xor not F) xor D and A xor E and F xor G and C;
<tr class="covered"><td>3256<td>    T := (T shr 7 or T shl 25) + (H shr 11 or H shl 21) + Buffer[Offset^] + Data^;
<tr class="covered"><td>3257<td>    Inc(Offset); Inc(Data);
<tr class="covered"><td>3258<td>    H := G; G := F; F := E; E := D; D := C; C := B; B := A; A := T;
<tr class="covered"><td>3259<td>  end;
<tr class="nocodegen"><td>3260<td>
<tr class="covered"><td>3261<td>  Inc(FDigest[0], A);
<tr class="covered"><td>3262<td>  Inc(FDigest[1], B);
<tr class="covered"><td>3263<td>  Inc(FDigest[2], C);
<tr class="covered"><td>3264<td>  Inc(FDigest[3], D);
<tr class="covered"><td>3265<td>  Inc(FDigest[4], E);
<tr class="covered"><td>3266<td>  Inc(FDigest[5], F);
<tr class="covered"><td>3267<td>  Inc(FDigest[6], G);
<tr class="covered"><td>3268<td>  Inc(FDigest[7], H);
<tr class="covered"><td>3269<td>end;
<tr class="nocodegen"><td>3270<td>
<tr class="nocodegen"><td>3271<td>{$ENDIF !THashBaseHaval_asm}
<tr class="nocodegen"><td>3272<td>
<tr class="nocodegen"><td>3273<td>procedure THashBaseHaval.DoDone;
<tr class="nocodegen"><td>3274<td>
<tr class="nocodegen"><td>3275<td>  function ROR(Value, Count: UInt32): UInt32;
<tr class="nocodegen"><td>3276<td>  {$IFDEF X86ASM}
<tr class="nocodegen"><td>3277<td>  asm
<tr class="nocodegen"><td>3278<td>        MOV     ECX,EDX
<tr class="nocodegen"><td>3279<td>        ROR     EAX,CL
<tr class="nocodegen"><td>3280<td>  end;
<tr class="nocodegen"><td>3281<td>  {$ELSE !X86ASM}
<tr class="covered"><td>3282<td>  begin
<tr class="covered"><td>3283<td>    Result := (Value shr Count) or (Value shl (32 - Count));
<tr class="covered"><td>3284<td>  end;
<tr class="nocodegen"><td>3285<td>  {$ENDIF !X86ASM}
<tr class="nocodegen"><td>3286<td>
<tr class="nocodegen"><td>3287<td>var
<tr class="nocodegen"><td>3288<td>  T: Word;
<tr class="covered"><td>3289<td>begin
<tr class="covered"><td>3290<td>  if FCount[2] or FCount[3] &lt;&gt; 0 then
<tr class="notcovered"><td>3291<td>    RaiseHashOverflowError;
<tr class="covered"><td>3292<td>  if FPaddingByte = 0 then
<tr class="notcovered"><td>3293<td>    FPaddingByte := $01;
<tr class="covered"><td>3294<td>  FBuffer[FBufferIndex] := FPaddingByte;
<tr class="covered"><td>3295<td>  Inc(FBufferIndex);
<tr class="covered"><td>3296<td>  if FBufferIndex &gt; FBufferSize - 10 then
<tr class="nocodegen"><td>3297<td>  begin
<tr class="covered"><td>3298<td>    FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex - 10, 0);
<tr class="covered"><td>3299<td>    DoTransform(Pointer(FBuffer));
<tr class="covered"><td>3300<td>    FBufferIndex := 0;
<tr class="nocodegen"><td>3301<td>  end;
<tr class="covered"><td>3302<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex - 10, 0);
<tr class="covered"><td>3303<td>  T := (DigestSize shl 9) or (UInt32(FRounds) shl 3) or 1;
<tr class="covered"><td>3304<td>  Move(T, FBuffer[FBufferSize - 10], SizeOf(T));
<tr class="covered"><td>3305<td>  Move(FCount, FBuffer[FBufferSize - 8], 8);
<tr class="covered"><td>3306<td>  DoTransform(Pointer(FBuffer));
<tr class="nocodegen"><td>3307<td>
<tr class="covered"><td>3308<td>  case DigestSize of
<tr class="nocodegen"><td>3309<td>    16: begin
<tr class="nocodegen"><td>3310<td>          Inc(FDigest[0], ROR(FDigest[7] and $000000FF or
<tr class="nocodegen"><td>3311<td>                              FDigest[6] and $FF000000 or
<tr class="nocodegen"><td>3312<td>                              FDigest[5] and $00FF0000 or
<tr class="covered"><td>3313<td>                              FDigest[4] and $0000FF00, 8));
<tr class="covered"><td>3314<td>          Inc(FDigest[1], ROR(FDigest[7] and $0000FF00 or
<tr class="nocodegen"><td>3315<td>                              FDigest[6] and $000000FF or
<tr class="nocodegen"><td>3316<td>                              FDigest[5] and $FF000000 or
<tr class="nocodegen"><td>3317<td>                              FDigest[4] and $00FF0000, 16));
<tr class="covered"><td>3318<td>          Inc(FDigest[2], ROR(FDigest[7] and $00FF0000 or
<tr class="nocodegen"><td>3319<td>                              FDigest[6] and $0000FF00 or
<tr class="nocodegen"><td>3320<td>                              FDigest[5] and $000000FF or
<tr class="nocodegen"><td>3321<td>                              FDigest[4] and $FF000000, 24));
<tr class="covered"><td>3322<td>          Inc(FDigest[3],     FDigest[7] and $FF000000 or
<tr class="nocodegen"><td>3323<td>                              FDigest[6] and $00FF0000 or
<tr class="nocodegen"><td>3324<td>                              FDigest[5] and $0000FF00 or
<tr class="nocodegen"><td>3325<td>                              FDigest[4] and $000000FF);
<tr class="nocodegen"><td>3326<td>        end;
<tr class="nocodegen"><td>3327<td>    20: begin
<tr class="nocodegen"><td>3328<td>          Inc(FDigest[0], ROR(FDigest[7] and ($3F) or
<tr class="nocodegen"><td>3329<td>                              FDigest[6] and ($7F shl 25) or
<tr class="covered"><td>3330<td>                              FDigest[5] and ($3F shl 19), 19));
<tr class="covered"><td>3331<td>          Inc(FDigest[1], ROR(FDigest[7] and ($3F shl 6) or
<tr class="nocodegen"><td>3332<td>                              FDigest[6] and ($3F) or
<tr class="nocodegen"><td>3333<td>                              FDigest[5] and ($7F shl 25), 25));
<tr class="covered"><td>3334<td>          Inc(FDigest[2],     FDigest[7] and ($7F shl 12) or
<tr class="nocodegen"><td>3335<td>                              FDigest[6] and ($3F shl  6) or
<tr class="nocodegen"><td>3336<td>                              FDigest[5] and ($3F));
<tr class="covered"><td>3337<td>          Inc(FDigest[3],    (FDigest[7] and ($3F shl 19) or
<tr class="nocodegen"><td>3338<td>                              FDigest[6] and ($7F shl 12) or
<tr class="nocodegen"><td>3339<td>                              FDigest[5] and ($3F shl  6)) shr 6);
<tr class="covered"><td>3340<td>          Inc(FDigest[4],    (FDigest[7] and ($7F shl 25) or
<tr class="nocodegen"><td>3341<td>                              FDigest[6] and ($3F shl 19) or
<tr class="nocodegen"><td>3342<td>                              FDigest[5] and ($7F shl 12)) shr 12);
<tr class="nocodegen"><td>3343<td>        end;
<tr class="nocodegen"><td>3344<td>    24: begin
<tr class="nocodegen"><td>3345<td>          Inc(FDigest[0], ROR(FDigest[7] and ($1F) or
<tr class="covered"><td>3346<td>                              FDigest[6] and ($3F shl 26), 26));
<tr class="covered"><td>3347<td>          Inc(FDigest[1],     FDigest[7] and ($1F shl 5) or
<tr class="nocodegen"><td>3348<td>                              FDigest[6] and ($1F));
<tr class="covered"><td>3349<td>          Inc(FDigest[2],    (FDigest[7] and ($3F shl 10) or
<tr class="nocodegen"><td>3350<td>                              FDigest[6] and ($1F shl  5)) shr 5);
<tr class="covered"><td>3351<td>          Inc(FDigest[3],    (FDigest[7] and ($1F shl 16) or
<tr class="nocodegen"><td>3352<td>                              FDigest[6] and ($3F shl 10)) shr 10);
<tr class="covered"><td>3353<td>          Inc(FDigest[4],    (FDigest[7] and ($1F shl 21) or
<tr class="nocodegen"><td>3354<td>                              FDigest[6] and ($1F shl 16)) shr 16);
<tr class="covered"><td>3355<td>          Inc(FDigest[5],    (FDigest[7] and ($3F shl 26) or
<tr class="nocodegen"><td>3356<td>                              FDigest[6] and ($1F shl 21)) shr 21);
<tr class="nocodegen"><td>3357<td>        end;
<tr class="nocodegen"><td>3358<td>    28: begin
<tr class="covered"><td>3359<td>          Inc(FDigest[0], FDigest[7] shr 27 and $1F);
<tr class="covered"><td>3360<td>          Inc(FDigest[1], FDigest[7] shr 22 and $1F);
<tr class="covered"><td>3361<td>          Inc(FDigest[2], FDigest[7] shr 18 and $0F);
<tr class="covered"><td>3362<td>          Inc(FDigest[3], FDigest[7] shr 13 and $1F);
<tr class="covered"><td>3363<td>          Inc(FDigest[4], FDigest[7] shr  9 and $0F);
<tr class="covered"><td>3364<td>          Inc(FDigest[5], FDigest[7] shr  4 and $1F);
<tr class="covered"><td>3365<td>          Inc(FDigest[6], FDigest[7]        and $0F);
<tr class="nocodegen"><td>3366<td>        end;
<tr class="nocodegen"><td>3367<td>  end;
<tr class="covered"><td>3368<td>end;
<tr class="nocodegen"><td>3369<td>
<tr class="nocodegen"><td>3370<td>function THashBaseHaval.Digest: PByteArray;
<tr class="covered"><td>3371<td>begin
<tr class="covered"><td>3372<td>  Result := @FDigest;
<tr class="covered"><td>3373<td>end;
<tr class="nocodegen"><td>3374<td>
<tr class="nocodegen"><td>3375<td>class function THashBaseHaval.BlockSize: UInt32;
<tr class="covered"><td>3376<td>begin
<tr class="covered"><td>3377<td>  Result := 128;
<tr class="covered"><td>3378<td>end;
<tr class="nocodegen"><td>3379<td>
<tr class="nocodegen"><td>3380<td>{ THash_Haval128 }
<tr class="nocodegen"><td>3381<td>
<tr class="nocodegen"><td>3382<td>class function THash_Haval128.DigestSize: UInt32;
<tr class="covered"><td>3383<td>begin
<tr class="covered"><td>3384<td>  Result := 16;
<tr class="covered"><td>3385<td>end;
<tr class="nocodegen"><td>3386<td>
<tr class="nocodegen"><td>3387<td>{ THash_Haval160 }
<tr class="nocodegen"><td>3388<td>
<tr class="nocodegen"><td>3389<td>class function THash_Haval160.DigestSize: UInt32;
<tr class="covered"><td>3390<td>begin
<tr class="covered"><td>3391<td>  Result := 20;
<tr class="covered"><td>3392<td>end;
<tr class="nocodegen"><td>3393<td>
<tr class="nocodegen"><td>3394<td>{ THash_Haval192 }
<tr class="nocodegen"><td>3395<td>
<tr class="nocodegen"><td>3396<td>class function THash_Haval192.DigestSize: UInt32;
<tr class="covered"><td>3397<td>begin
<tr class="covered"><td>3398<td>  Result := 24;
<tr class="covered"><td>3399<td>end;
<tr class="nocodegen"><td>3400<td>
<tr class="nocodegen"><td>3401<td>{ THash_Haval224 }
<tr class="nocodegen"><td>3402<td>
<tr class="nocodegen"><td>3403<td>class function THash_Haval224.DigestSize: UInt32;
<tr class="covered"><td>3404<td>begin
<tr class="covered"><td>3405<td>  Result := 28;
<tr class="covered"><td>3406<td>end;
<tr class="nocodegen"><td>3407<td>
<tr class="nocodegen"><td>3408<td>{ THash_Haval256 }
<tr class="nocodegen"><td>3409<td>
<tr class="nocodegen"><td>3410<td>class function THash_Haval256.DigestSize: UInt32;
<tr class="covered"><td>3411<td>begin
<tr class="covered"><td>3412<td>  Result := 32;
<tr class="covered"><td>3413<td>end;
<tr class="nocodegen"><td>3414<td>
<tr class="nocodegen"><td>3415<td>{ THash_Tiger }
<tr class="nocodegen"><td>3416<td>
<tr class="nocodegen"><td>3417<td>procedure THash_Tiger.SetRounds(Value: UInt32);
<tr class="covered"><td>3418<td>begin
<tr class="covered"><td>3419<td>  if (Value &lt; cTigerMinRounds) then
<tr class="covered"><td>3420<td>    Value := cTigerMinRounds;
<tr class="nocodegen"><td>3421<td>
<tr class="covered"><td>3422<td>  if (Value &gt; cTigerMaxRounds) then
<tr class="covered"><td>3423<td>    Value := cTigerMaxRounds;
<tr class="nocodegen"><td>3424<td>
<tr class="covered"><td>3425<td>  FRounds := Value;
<tr class="covered"><td>3426<td>end;
<tr class="nocodegen"><td>3427<td>
<tr class="nocodegen"><td>3428<td>procedure THash_Tiger.DoInit;
<tr class="covered"><td>3429<td>begin
<tr class="covered"><td>3430<td>  SetRounds(FRounds);
<tr class="covered"><td>3431<td>  if FPaddingByte = 0 then
<tr class="covered"><td>3432<td>    FPaddingByte := $01;
<tr class="covered"><td>3433<td>  FDigest[0] := $89ABCDEF;
<tr class="covered"><td>3434<td>  FDigest[1] := $01234567;
<tr class="covered"><td>3435<td>  FDigest[2] := $76543210;
<tr class="covered"><td>3436<td>  FDigest[3] := $FEDCBA98;
<tr class="covered"><td>3437<td>  FDigest[4] := $C3B2E187;
<tr class="covered"><td>3438<td>  FDigest[5] := $F096A5B4;
<tr class="covered"><td>3439<td>end;
<tr class="nocodegen"><td>3440<td>
<tr class="nocodegen"><td>3441<td>{$IFNDEF THash_Tiger_asm}
<tr class="nocodegen"><td>3442<td>procedure THash_Tiger.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>3443<td>type
<tr class="nocodegen"><td>3444<td>  PTiger_Data = ^TTiger_Data;
<tr class="nocodegen"><td>3445<td>  TTiger_Data = array[0..3, 0..255] of Int64;
<tr class="nocodegen"><td>3446<td>
<tr class="nocodegen"><td>3447<td>  PInt64Array = ^TInt64Array;
<tr class="nocodegen"><td>3448<td>  TInt64Array = array[0..7] of Int64;
<tr class="nocodegen"><td>3449<td>
<tr class="nocodegen"><td>3450<td>var
<tr class="nocodegen"><td>3451<td>  A, B, C, T: Int64;
<tr class="nocodegen"><td>3452<td>  x0, x1, x2, x3, x4, x5, x6, x7: UInt64;
<tr class="nocodegen"><td>3453<td>  I: Integer;
<tr class="covered"><td>3454<td>begin
<tr class="covered"><td>3455<td>  A  := PInt64Array(@FDigest)[0];
<tr class="covered"><td>3456<td>  B  := PInt64Array(@FDigest)[1];
<tr class="covered"><td>3457<td>  C  := PInt64Array(@FDigest)[2];
<tr class="covered"><td>3458<td>  x0 := PInt64Array(Buffer)[0];
<tr class="covered"><td>3459<td>  x1 := PInt64Array(Buffer)[1];
<tr class="covered"><td>3460<td>  x2 := PInt64Array(Buffer)[2];
<tr class="covered"><td>3461<td>  x3 := PInt64Array(Buffer)[3];
<tr class="covered"><td>3462<td>  x4 := PInt64Array(Buffer)[4];
<tr class="covered"><td>3463<td>  x5 := PInt64Array(Buffer)[5];
<tr class="covered"><td>3464<td>  x6 := PInt64Array(Buffer)[6];
<tr class="covered"><td>3465<td>  x7 := PInt64Array(Buffer)[7];
<tr class="nocodegen"><td>3466<td>
<tr class="covered"><td>3467<td>  for I := 1 to FRounds do // a Loop is faster for PC with small Cache
<tr class="nocodegen"><td>3468<td>  begin
<tr class="covered"><td>3469<td>    if I &gt; 1 then // Key Schedule
<tr class="nocodegen"><td>3470<td>    begin
<tr class="covered"><td>3471<td>      Dec(x0, x7 xor $A5A5A5A5A5A5A5A5);
<tr class="covered"><td>3472<td>      x1 := x1 xor x0;
<tr class="covered"><td>3473<td>      Inc(x2, x1);
<tr class="covered"><td>3474<td>      Dec(x3, x2 xor (not x1 shl 19));
<tr class="covered"><td>3475<td>      x4 := x4 xor x3;
<tr class="covered"><td>3476<td>      Inc(x5, x4);
<tr class="covered"><td>3477<td>      Dec(x6, x5 xor (not x4 shr 23));
<tr class="covered"><td>3478<td>      x7 := x7 xor x6;
<tr class="covered"><td>3479<td>      Inc(x0, x7);
<tr class="covered"><td>3480<td>      Dec(x1, x0 xor (not x7 shl 19));
<tr class="covered"><td>3481<td>      x2 := x2 xor x1;
<tr class="covered"><td>3482<td>      Inc(x3, x2);
<tr class="covered"><td>3483<td>      Dec(x4, x3 xor (not x2 shr 23));
<tr class="covered"><td>3484<td>      x5 := x5 xor x4;
<tr class="covered"><td>3485<td>      Inc(x6, x5);
<tr class="covered"><td>3486<td>      Dec(x7, x6 xor $0123456789ABCDEF);
<tr class="nocodegen"><td>3487<td>    end;
<tr class="nocodegen"><td>3488<td>
<tr class="covered"><td>3489<td>    C := C xor x0;
<tr class="covered"><td>3490<td>    Dec(A, TTiger_Data(Tiger_Data)[0, UInt32(C)        and $FF] xor
<tr class="nocodegen"><td>3491<td>           TTiger_Data(Tiger_Data)[1, UInt32(C) shr 16 and $FF] xor
<tr class="nocodegen"><td>3492<td>           TTiger_Data(Tiger_Data)[2,          C  shr 32 and $FF] xor
<tr class="nocodegen"><td>3493<td>           TTiger_Data(Tiger_Data)[3, UInt32(C shr 32) shr 16 and $FF]);
<tr class="covered"><td>3494<td>    Inc(B, TTiger_Data(Tiger_Data)[3, UInt32(C) shr  8 and $FF] xor
<tr class="nocodegen"><td>3495<td>           TTiger_Data(Tiger_Data)[2, UInt32(C) shr 24] xor
<tr class="nocodegen"><td>3496<td>           TTiger_Data(Tiger_Data)[1, UInt32(C shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3497<td>           TTiger_Data(Tiger_Data)[0, UInt32(C shr 32) shr 24]);
<tr class="nocodegen"><td>3498<td>
<tr class="covered"><td>3499<td>    if I = 1 then
<tr class="covered"><td>3500<td>      B := B shl 2 + B
<tr class="nocodegen"><td>3501<td>    else
<tr class="nocodegen"><td>3502<td>    begin
<tr class="covered"><td>3503<td>      if I = 2 then
<tr class="covered"><td>3504<td>        B := B shl 3 - B
<tr class="nocodegen"><td>3505<td>      else
<tr class="covered"><td>3506<td>        B := B shl 3 + B;
<tr class="nocodegen"><td>3507<td>    end;
<tr class="nocodegen"><td>3508<td>
<tr class="covered"><td>3509<td>    A := A xor x1;
<tr class="covered"><td>3510<td>    Dec(B, TTiger_Data(Tiger_Data)[0, UInt32(A)        and $FF] xor
<tr class="nocodegen"><td>3511<td>           TTiger_Data(Tiger_Data)[1, UInt32(A) shr 16 and $FF] xor
<tr class="nocodegen"><td>3512<td>           TTiger_Data(Tiger_Data)[2,          A  shr 32 and $FF] xor
<tr class="nocodegen"><td>3513<td>           TTiger_Data(Tiger_Data)[3, UInt32(A shr 32) shr 16 and $FF]);
<tr class="covered"><td>3514<td>    Inc(C, TTiger_Data(Tiger_Data)[3, UInt32(A) shr  8 and $FF] xor
<tr class="nocodegen"><td>3515<td>           TTiger_Data(Tiger_Data)[2, UInt32(A) shr 24] xor
<tr class="nocodegen"><td>3516<td>           TTiger_Data(Tiger_Data)[1, UInt32(A shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3517<td>           TTiger_Data(Tiger_Data)[0, UInt32(A shr 32) shr 24]);
<tr class="nocodegen"><td>3518<td>
<tr class="covered"><td>3519<td>    if I = 1 then
<tr class="covered"><td>3520<td>      C := C shl 2 + C
<tr class="nocodegen"><td>3521<td>    else
<tr class="nocodegen"><td>3522<td>    begin
<tr class="covered"><td>3523<td>      if I = 2 then
<tr class="covered"><td>3524<td>        C := C shl 3 - C
<tr class="nocodegen"><td>3525<td>      else
<tr class="covered"><td>3526<td>        C := C shl 3 + C;
<tr class="nocodegen"><td>3527<td>    end;
<tr class="nocodegen"><td>3528<td>
<tr class="covered"><td>3529<td>    B := B xor x2;
<tr class="covered"><td>3530<td>    Dec(C, TTiger_Data(Tiger_Data)[0, UInt32(B)        and $FF] xor
<tr class="nocodegen"><td>3531<td>           TTiger_Data(Tiger_Data)[1, UInt32(B) shr 16 and $FF] xor
<tr class="nocodegen"><td>3532<td>           TTiger_Data(Tiger_Data)[2,          B  shr 32 and $FF] xor
<tr class="nocodegen"><td>3533<td>           TTiger_Data(Tiger_Data)[3, UInt32(B shr 32) shr 16 and $FF]);
<tr class="covered"><td>3534<td>    Inc(A, TTiger_Data(Tiger_Data)[3, UInt32(B) shr  8 and $FF] xor
<tr class="nocodegen"><td>3535<td>           TTiger_Data(Tiger_Data)[2, UInt32(B) shr 24] xor
<tr class="nocodegen"><td>3536<td>           TTiger_Data(Tiger_Data)[1, UInt32(B shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3537<td>           TTiger_Data(Tiger_Data)[0, UInt32(B shr 32) shr 24]);
<tr class="nocodegen"><td>3538<td>
<tr class="covered"><td>3539<td>    if I = 1 then
<tr class="covered"><td>3540<td>      A := A shl 2 + A
<tr class="nocodegen"><td>3541<td>    else
<tr class="nocodegen"><td>3542<td>    begin
<tr class="covered"><td>3543<td>      if I = 2 then
<tr class="covered"><td>3544<td>        A := A shl 3 - A
<tr class="nocodegen"><td>3545<td>      else
<tr class="covered"><td>3546<td>        A := A shl 3 + A;
<tr class="nocodegen"><td>3547<td>    end;
<tr class="nocodegen"><td>3548<td>
<tr class="covered"><td>3549<td>    C := C xor x3;
<tr class="covered"><td>3550<td>    Dec(A, TTiger_Data(Tiger_Data)[0, UInt32(C)        and $FF] xor
<tr class="nocodegen"><td>3551<td>           TTiger_Data(Tiger_Data)[1, UInt32(C) shr 16 and $FF] xor
<tr class="nocodegen"><td>3552<td>           TTiger_Data(Tiger_Data)[2,          C  shr 32 and $FF] xor
<tr class="nocodegen"><td>3553<td>           TTiger_Data(Tiger_Data)[3, UInt32(C shr 32) shr 16 and $FF]);
<tr class="covered"><td>3554<td>    Inc(B, TTiger_Data(Tiger_Data)[3, UInt32(C) shr  8 and $FF] xor
<tr class="nocodegen"><td>3555<td>           TTiger_Data(Tiger_Data)[2, UInt32(C) shr 24] xor
<tr class="nocodegen"><td>3556<td>           TTiger_Data(Tiger_Data)[1, UInt32(C shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3557<td>           TTiger_Data(Tiger_Data)[0, UInt32(C shr 32) shr 24]);
<tr class="nocodegen"><td>3558<td>
<tr class="covered"><td>3559<td>    if I = 1 then
<tr class="covered"><td>3560<td>      B := B shl 2 + B
<tr class="nocodegen"><td>3561<td>    else
<tr class="nocodegen"><td>3562<td>    begin
<tr class="covered"><td>3563<td>      if I = 2 then
<tr class="covered"><td>3564<td>        B := B shl 3 - B
<tr class="nocodegen"><td>3565<td>      else
<tr class="covered"><td>3566<td>        B := B shl 3 + B;
<tr class="nocodegen"><td>3567<td>    end;
<tr class="nocodegen"><td>3568<td>
<tr class="covered"><td>3569<td>    A := A xor x4;
<tr class="covered"><td>3570<td>    Dec(B, TTiger_Data(Tiger_Data)[0, UInt32(A)        and $FF] xor
<tr class="nocodegen"><td>3571<td>           TTiger_Data(Tiger_Data)[1, UInt32(A) shr 16 and $FF] xor
<tr class="nocodegen"><td>3572<td>           TTiger_Data(Tiger_Data)[2,          A  shr 32 and $FF] xor
<tr class="nocodegen"><td>3573<td>           TTiger_Data(Tiger_Data)[3, UInt32(A shr 32) shr 16 and $FF]);
<tr class="covered"><td>3574<td>    Inc(C, TTiger_Data(Tiger_Data)[3, UInt32(A) shr  8 and $FF] xor
<tr class="nocodegen"><td>3575<td>           TTiger_Data(Tiger_Data)[2, UInt32(A) shr 24] xor
<tr class="nocodegen"><td>3576<td>           TTiger_Data(Tiger_Data)[1, UInt32(A shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3577<td>           TTiger_Data(Tiger_Data)[0, UInt32(A shr 32) shr 24]);
<tr class="nocodegen"><td>3578<td>
<tr class="covered"><td>3579<td>    if I = 1 then
<tr class="covered"><td>3580<td>      C := C shl 2 + C
<tr class="nocodegen"><td>3581<td>    else
<tr class="nocodegen"><td>3582<td>    begin
<tr class="covered"><td>3583<td>      if I = 2 then
<tr class="covered"><td>3584<td>        C := C shl 3 - C
<tr class="nocodegen"><td>3585<td>      else
<tr class="covered"><td>3586<td>        C := C shl 3 + C;
<tr class="nocodegen"><td>3587<td>    end;
<tr class="nocodegen"><td>3588<td>
<tr class="covered"><td>3589<td>    B := B xor x5;
<tr class="covered"><td>3590<td>    Dec(C, TTiger_Data(Tiger_Data)[0, UInt32(B)        and $FF] xor
<tr class="nocodegen"><td>3591<td>           TTiger_Data(Tiger_Data)[1, UInt32(B) shr 16 and $FF] xor
<tr class="nocodegen"><td>3592<td>           TTiger_Data(Tiger_Data)[2,          B  shr 32 and $FF] xor
<tr class="nocodegen"><td>3593<td>           TTiger_Data(Tiger_Data)[3, UInt32(B shr 32) shr 16 and $FF]);
<tr class="covered"><td>3594<td>    Inc(A, TTiger_Data(Tiger_Data)[3, UInt32(B) shr  8 and $FF] xor
<tr class="nocodegen"><td>3595<td>           TTiger_Data(Tiger_Data)[2, UInt32(B) shr 24] xor
<tr class="nocodegen"><td>3596<td>           TTiger_Data(Tiger_Data)[1, UInt32(B shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3597<td>           TTiger_Data(Tiger_Data)[0, UInt32(B shr 32) shr 24]);
<tr class="nocodegen"><td>3598<td>
<tr class="covered"><td>3599<td>    if I = 1 then
<tr class="covered"><td>3600<td>      A := A shl 2 + A
<tr class="nocodegen"><td>3601<td>    else
<tr class="nocodegen"><td>3602<td>    begin
<tr class="covered"><td>3603<td>      if I = 2 then
<tr class="covered"><td>3604<td>        A := A shl 3 - A
<tr class="nocodegen"><td>3605<td>      else
<tr class="covered"><td>3606<td>        A := A shl 3 + A;
<tr class="nocodegen"><td>3607<td>    end;
<tr class="nocodegen"><td>3608<td>
<tr class="covered"><td>3609<td>    C := C xor x6;
<tr class="covered"><td>3610<td>    Dec(A, TTiger_Data(Tiger_Data)[0, UInt32(C)        and $FF] xor
<tr class="nocodegen"><td>3611<td>           TTiger_Data(Tiger_Data)[1, UInt32(C) shr 16 and $FF] xor
<tr class="nocodegen"><td>3612<td>           TTiger_Data(Tiger_Data)[2,          C  shr 32 and $FF] xor
<tr class="nocodegen"><td>3613<td>           TTiger_Data(Tiger_Data)[3, UInt32(C shr 32) shr 16 and $FF]);
<tr class="covered"><td>3614<td>    Inc(B, TTiger_Data(Tiger_Data)[3, UInt32(C) shr  8 and $FF] xor
<tr class="nocodegen"><td>3615<td>           TTiger_Data(Tiger_Data)[2, UInt32(C) shr 24] xor
<tr class="nocodegen"><td>3616<td>           TTiger_Data(Tiger_Data)[1, UInt32(C shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3617<td>           TTiger_Data(Tiger_Data)[0, UInt32(C shr 32) shr 24]);
<tr class="nocodegen"><td>3618<td>
<tr class="covered"><td>3619<td>    if I = 1 then
<tr class="covered"><td>3620<td>      B := B shl 2 + B
<tr class="nocodegen"><td>3621<td>    else
<tr class="nocodegen"><td>3622<td>    begin
<tr class="covered"><td>3623<td>      if I = 2 then
<tr class="covered"><td>3624<td>        B := B shl 3 - B
<tr class="nocodegen"><td>3625<td>      else
<tr class="covered"><td>3626<td>        B := B shl 3 + B;
<tr class="nocodegen"><td>3627<td>    end;
<tr class="nocodegen"><td>3628<td>
<tr class="covered"><td>3629<td>    A := A xor x7;
<tr class="covered"><td>3630<td>    Dec(B, TTiger_Data(Tiger_Data)[0, UInt32(A)        and $FF] xor
<tr class="nocodegen"><td>3631<td>           TTiger_Data(Tiger_Data)[1, UInt32(A) shr 16 and $FF] xor
<tr class="nocodegen"><td>3632<td>           TTiger_Data(Tiger_Data)[2,          A  shr 32 and $FF] xor
<tr class="nocodegen"><td>3633<td>           TTiger_Data(Tiger_Data)[3, UInt32(A shr 32) shr 16 and $FF]);
<tr class="covered"><td>3634<td>    Inc(C, TTiger_Data(Tiger_Data)[3, UInt32(A) shr  8 and $FF] xor
<tr class="nocodegen"><td>3635<td>           TTiger_Data(Tiger_Data)[2, UInt32(A) shr 24] xor
<tr class="nocodegen"><td>3636<td>           TTiger_Data(Tiger_Data)[1, UInt32(A shr 32) shr 8 and $FF] xor
<tr class="nocodegen"><td>3637<td>           TTiger_Data(Tiger_Data)[0, UInt32(A shr 32) shr 24]);
<tr class="nocodegen"><td>3638<td>
<tr class="covered"><td>3639<td>    if I = 1 then
<tr class="covered"><td>3640<td>      C := C shl 2 + C
<tr class="nocodegen"><td>3641<td>    else
<tr class="nocodegen"><td>3642<td>    begin
<tr class="covered"><td>3643<td>      if I = 2 then
<tr class="covered"><td>3644<td>        C := C shl 3 - C
<tr class="nocodegen"><td>3645<td>      else
<tr class="covered"><td>3646<td>        C := C shl 3 + C;
<tr class="nocodegen"><td>3647<td>    end;
<tr class="nocodegen"><td>3648<td>
<tr class="covered"><td>3649<td>    T := A; A := C; C := B; B := T;
<tr class="covered"><td>3650<td>  end;
<tr class="nocodegen"><td>3651<td>
<tr class="covered"><td>3652<td>  PInt64Array(@FDigest)[0] := A xor PInt64Array(@FDigest)[0];
<tr class="covered"><td>3653<td>  PInt64Array(@FDigest)[1] := B  -  PInt64Array(@FDigest)[1];
<tr class="covered"><td>3654<td>  PInt64Array(@FDigest)[2] := C  +  PInt64Array(@FDigest)[2];
<tr class="covered"><td>3655<td>end;
<tr class="nocodegen"><td>3656<td>{$ENDIF}
<tr class="nocodegen"><td>3657<td>
<tr class="nocodegen"><td>3658<td>function THash_Tiger.GetMaxRounds: UInt32;
<tr class="covered"><td>3659<td>begin
<tr class="covered"><td>3660<td>  Result := cTigerMaxRounds;
<tr class="covered"><td>3661<td>end;
<tr class="nocodegen"><td>3662<td>
<tr class="nocodegen"><td>3663<td>function THash_Tiger.GetMinRounds: UInt32;
<tr class="covered"><td>3664<td>begin
<tr class="covered"><td>3665<td>  Result := cTigerMinRounds;
<tr class="covered"><td>3666<td>end;
<tr class="nocodegen"><td>3667<td>
<tr class="nocodegen"><td>3668<td>function THash_Tiger.GetRounds: UInt32;
<tr class="covered"><td>3669<td>begin
<tr class="covered"><td>3670<td>  Result := FRounds;
<tr class="covered"><td>3671<td>end;
<tr class="nocodegen"><td>3672<td>
<tr class="nocodegen"><td>3673<td>class function THash_Tiger.DigestSize: UInt32;
<tr class="covered"><td>3674<td>begin
<tr class="covered"><td>3675<td>  Result := 24;
<tr class="covered"><td>3676<td>end;
<tr class="nocodegen"><td>3677<td>
<tr class="nocodegen"><td>3678<td>{ THash_Panama }
<tr class="nocodegen"><td>3679<td>
<tr class="nocodegen"><td>3680<td>procedure THash_Panama.DoInit;
<tr class="covered"><td>3681<td>begin
<tr class="covered"><td>3682<td>  FillChar(FLFSRBuffer, SizeOf(FLFSRBuffer), 0);
<tr class="covered"><td>3683<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>3684<td>  FTap := 0;
<tr class="covered"><td>3685<td>end;
<tr class="nocodegen"><td>3686<td>
<tr class="nocodegen"><td>3687<td>{$IFNDEF THash_Panama_asm}
<tr class="nocodegen"><td>3688<td>procedure THash_Panama.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>3689<td>var
<tr class="nocodegen"><td>3690<td>  T0, T1, T2, T3: UInt32;
<tr class="nocodegen"><td>3691<td>  PBufB, PTap0, PTap25: PUInt32Array;
<tr class="covered"><td>3692<td>begin
<tr class="nocodegen"><td>3693<td>  // perform non-linearity stage (GAMMA)
<tr class="covered"><td>3694<td>  T0 := FDigest[ 0];
<tr class="covered"><td>3695<td>  T1 := FDigest[ 1];
<tr class="covered"><td>3696<td>  FDigest[ 0] := FDigest[ 0] xor (FDigest[ 1] or not FDigest[ 2]);
<tr class="covered"><td>3697<td>  FDigest[ 1] := FDigest[ 1] xor (FDigest[ 2] or not FDigest[ 3]);
<tr class="covered"><td>3698<td>  FDigest[ 2] := FDigest[ 2] xor (FDigest[ 3] or not FDigest[ 4]);
<tr class="covered"><td>3699<td>  FDigest[ 3] := FDigest[ 3] xor (FDigest[ 4] or not FDigest[ 5]);
<tr class="covered"><td>3700<td>  FDigest[ 4] := FDigest[ 4] xor (FDigest[ 5] or not FDigest[ 6]);
<tr class="covered"><td>3701<td>  FDigest[ 5] := FDigest[ 5] xor (FDigest[ 6] or not FDigest[ 7]);
<tr class="covered"><td>3702<td>  FDigest[ 6] := FDigest[ 6] xor (FDigest[ 7] or not FDigest[ 8]);
<tr class="covered"><td>3703<td>  FDigest[ 7] := FDigest[ 7] xor (FDigest[ 8] or not FDigest[ 9]);
<tr class="covered"><td>3704<td>  FDigest[ 8] := FDigest[ 8] xor (FDigest[ 9] or not FDigest[10]);
<tr class="covered"><td>3705<td>  FDigest[ 9] := FDigest[ 9] xor (FDigest[10] or not FDigest[11]);
<tr class="covered"><td>3706<td>  FDigest[10] := FDigest[10] xor (FDigest[11] or not FDigest[12]);
<tr class="covered"><td>3707<td>  FDigest[11] := FDigest[11] xor (FDigest[12] or not FDigest[13]);
<tr class="covered"><td>3708<td>  FDigest[12] := FDigest[12] xor (FDigest[13] or not FDigest[14]);
<tr class="covered"><td>3709<td>  FDigest[13] := FDigest[13] xor (FDigest[14] or not FDigest[15]);
<tr class="covered"><td>3710<td>  FDigest[14] := FDigest[14] xor (FDigest[15] or not FDigest[16]);
<tr class="covered"><td>3711<td>  FDigest[15] := FDigest[15] xor (FDigest[16] or not T0);
<tr class="covered"><td>3712<td>  FDigest[16] := FDigest[16] xor (T0 or not T1);
<tr class="nocodegen"><td>3713<td>
<tr class="nocodegen"><td>3714<td>  // perform bit-dispersion stage (PI)
<tr class="covered"><td>3715<td>  T0 := FDigest[ 1];
<tr class="covered"><td>3716<td>  T1 := FDigest[ 7]; FDigest[ 1] := (T1 shl  1) or (T1 shr 31);
<tr class="covered"><td>3717<td>  T1 := FDigest[ 5]; FDigest[ 5] := (T0 shl 15) or (T0 shr 17);
<tr class="covered"><td>3718<td>  T0 := FDigest[ 8]; FDigest[ 8] := (T1 shl  4) or (T1 shr 28);
<tr class="covered"><td>3719<td>  T1 := FDigest[ 6]; FDigest[ 6] := (T0 shl 21) or (T0 shr 11);
<tr class="covered"><td>3720<td>  T0 := FDigest[13]; FDigest[13] := (T1 shl 27) or (T1 shr  5);
<tr class="covered"><td>3721<td>  T1 := FDigest[14]; FDigest[14] := (T0 shl  9) or (T0 shr 23);
<tr class="covered"><td>3722<td>  T0 := FDigest[ 2]; FDigest[ 2] := (T1 shl  3) or (T1 shr 29);
<tr class="covered"><td>3723<td>  T1 := FDigest[10]; FDigest[10] := (T0 shl 23) or (T0 shr  9);
<tr class="covered"><td>3724<td>  T0 := FDigest[16]; FDigest[16] := (T1 shl  8) or (T1 shr 24);
<tr class="covered"><td>3725<td>  T1 := FDigest[12]; FDigest[12] := (T0 shl 14) or (T0 shr 18);
<tr class="covered"><td>3726<td>  T0 := FDigest[ 9]; FDigest[ 9] := (T1 shl 13) or (T1 shr 19);
<tr class="covered"><td>3727<td>  T1 := FDigest[11]; FDigest[11] := (T0 shl  2) or (T0 shr 30);
<tr class="covered"><td>3728<td>  T0 := FDigest[ 4]; FDigest[ 4] := (T1 shl 10) or (T1 shr 22);
<tr class="covered"><td>3729<td>  T1 := FDigest[ 3]; FDigest[ 3] := (T0 shl  6) or (T0 shr 26);
<tr class="covered"><td>3730<td>  T0 := FDigest[15]; FDigest[15] := (T1 shl 24) or (T1 shr  8);
<tr class="covered"><td>3731<td>  FDigest[ 7] := (T0 shl 28) or (T0 shr  4);
<tr class="nocodegen"><td>3732<td>
<tr class="nocodegen"><td>3733<td>  // LFSR emulation
<tr class="covered"><td>3734<td>  PBufB  := @FLFSRBuffer[(FTap + 16) and 31];
<tr class="covered"><td>3735<td>  FTap   := (FTap - 1) and 31;
<tr class="covered"><td>3736<td>  PTap0  := @FLFSRBuffer[FTap];
<tr class="covered"><td>3737<td>  PTap25 := @FLFSRBuffer[(FTap + 25) and 31];
<tr class="nocodegen"><td>3738<td>
<tr class="nocodegen"><td>3739<td>  // update the LFSR buffer (LAMBDA_PUSH)
<tr class="covered"><td>3740<td>  PTap25[ 0] := PTap25[ 0] xor PTap0[ 2];
<tr class="covered"><td>3741<td>  PTap25[ 1] := PTap25[ 1] xor PTap0[ 3];
<tr class="covered"><td>3742<td>  PTap25[ 2] := PTap25[ 2] xor PTap0[ 4];
<tr class="covered"><td>3743<td>  PTap25[ 3] := PTap25[ 3] xor PTap0[ 5];
<tr class="covered"><td>3744<td>  PTap25[ 4] := PTap25[ 4] xor PTap0[ 6];
<tr class="covered"><td>3745<td>  PTap25[ 5] := PTap25[ 5] xor PTap0[ 7];
<tr class="covered"><td>3746<td>  PTap25[ 6] := PTap25[ 6] xor PTap0[ 0];
<tr class="covered"><td>3747<td>  PTap25[ 7] := PTap25[ 7] xor PTap0[ 1];
<tr class="covered"><td>3748<td>  PTap0[ 0] := PTap0[ 0] xor Buffer[ 0];
<tr class="covered"><td>3749<td>  PTap0[ 1] := PTap0[ 1] xor Buffer[ 1];
<tr class="covered"><td>3750<td>  PTap0[ 2] := PTap0[ 2] xor Buffer[ 2];
<tr class="covered"><td>3751<td>  PTap0[ 3] := PTap0[ 3] xor Buffer[ 3];
<tr class="covered"><td>3752<td>  PTap0[ 4] := PTap0[ 4] xor Buffer[ 4];
<tr class="covered"><td>3753<td>  PTap0[ 5] := PTap0[ 5] xor Buffer[ 5];
<tr class="covered"><td>3754<td>  PTap0[ 6] := PTap0[ 6] xor Buffer[ 6];
<tr class="covered"><td>3755<td>  PTap0[ 7] := PTap0[ 7] xor Buffer[ 7];
<tr class="nocodegen"><td>3756<td>
<tr class="nocodegen"><td>3757<td>  // perform diffusion stage (THETA) + buffer injection stage (SIGMA)
<tr class="covered"><td>3758<td>  T0 := FDigest[ 0];
<tr class="covered"><td>3759<td>  T1 := FDigest[ 1];
<tr class="covered"><td>3760<td>  T2 := FDigest[ 2];
<tr class="covered"><td>3761<td>  T3 := FDigest[ 3];
<tr class="nocodegen"><td>3762<td>
<tr class="covered"><td>3763<td>  FDigest[ 0] := FDigest[ 0] xor FDigest[ 1] xor FDigest[ 4] xor 1;
<tr class="covered"><td>3764<td>  FDigest[ 1] := FDigest[ 1] xor FDigest[ 2] xor FDigest[ 5] xor Buffer[ 0];
<tr class="covered"><td>3765<td>  FDigest[ 2] := FDigest[ 2] xor FDigest[ 3] xor FDigest[ 6] xor Buffer[ 1];
<tr class="covered"><td>3766<td>  FDigest[ 3] := FDigest[ 3] xor FDigest[ 4] xor FDigest[ 7] xor Buffer[ 2];
<tr class="covered"><td>3767<td>  FDigest[ 4] := FDigest[ 4] xor FDigest[ 5] xor FDigest[ 8] xor Buffer[ 3];
<tr class="covered"><td>3768<td>  FDigest[ 5] := FDigest[ 5] xor FDigest[ 6] xor FDigest[ 9] xor Buffer[ 4];
<tr class="covered"><td>3769<td>  FDigest[ 6] := FDigest[ 6] xor FDigest[ 7] xor FDigest[10] xor Buffer[ 5];
<tr class="covered"><td>3770<td>  FDigest[ 7] := FDigest[ 7] xor FDigest[ 8] xor FDigest[11] xor Buffer[ 6];
<tr class="covered"><td>3771<td>  FDigest[ 8] := FDigest[ 8] xor FDigest[ 9] xor FDigest[12] xor Buffer[ 7];
<tr class="nocodegen"><td>3772<td>
<tr class="covered"><td>3773<td>  FDigest[ 9] := FDigest[ 9] xor FDigest[10] xor FDigest[13] xor PBufB[ 0];
<tr class="covered"><td>3774<td>  FDigest[10] := FDigest[10] xor FDigest[11] xor FDigest[14] xor PBufB[ 1];
<tr class="covered"><td>3775<td>  FDigest[11] := FDigest[11] xor FDigest[12] xor FDigest[15] xor PBufB[ 2];
<tr class="covered"><td>3776<td>  FDigest[12] := FDigest[12] xor FDigest[13] xor FDigest[16] xor PBufB[ 3];
<tr class="covered"><td>3777<td>  FDigest[13] := FDigest[13] xor FDigest[14] xor T0          xor PBufB[ 4];
<tr class="covered"><td>3778<td>  FDigest[14] := FDigest[14] xor FDigest[15] xor T1          xor PBufB[ 5];
<tr class="covered"><td>3779<td>  FDigest[15] := FDigest[15] xor FDigest[16] xor T2          xor PBufB[ 6];
<tr class="covered"><td>3780<td>  FDigest[16] := FDigest[16] xor T0          xor T3          xor PBufB[ 7];
<tr class="covered"><td>3781<td>end;
<tr class="nocodegen"><td>3782<td>{$ENDIF !THash_Panama_asm}
<tr class="nocodegen"><td>3783<td>
<tr class="nocodegen"><td>3784<td>procedure THash_Panama.DoDone;
<tr class="covered"><td>3785<td>begin
<tr class="covered"><td>3786<td>  if FPaddingByte = 0 then
<tr class="covered"><td>3787<td>    FPaddingByte := $01;
<tr class="covered"><td>3788<td>  FBuffer[FBufferIndex] := FPaddingByte;
<tr class="covered"><td>3789<td>  Inc(FBufferIndex);
<tr class="covered"><td>3790<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>3791<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>3792<td>  DoPull;
<tr class="covered"><td>3793<td>  FillChar(FLFSRBuffer, SizeOf(FLFSRBuffer), 0);
<tr class="covered"><td>3794<td>  FTap := 0;
<tr class="covered"><td>3795<td>end;
<tr class="nocodegen"><td>3796<td>
<tr class="nocodegen"><td>3797<td>{$IFNDEF THash_Panama_asm}
<tr class="nocodegen"><td>3798<td>procedure THash_Panama.DoPull;
<tr class="nocodegen"><td>3799<td>var
<tr class="nocodegen"><td>3800<td>  PBufL, PBufB, PTap0, PTap25: PUInt32Array;
<tr class="nocodegen"><td>3801<td>  T0, T1, T2, T3: UInt32;
<tr class="nocodegen"><td>3802<td>  I: Integer;
<tr class="covered"><td>3803<td>begin
<tr class="covered"><td>3804<td>  for I := 0 to 31 do
<tr class="nocodegen"><td>3805<td>  begin
<tr class="nocodegen"><td>3806<td>    // LFSR emulation
<tr class="covered"><td>3807<td>    PBufL := @FLFSRBuffer[(FTap +  4) and 31];
<tr class="covered"><td>3808<td>    PBufB := @FLFSRBuffer[(FTap + 16) and 31];
<tr class="covered"><td>3809<td>    FTap := (FTap - 1) and 31;
<tr class="covered"><td>3810<td>    PTap0  := @FLFSRBuffer[FTap];
<tr class="covered"><td>3811<td>    PTap25 := @FLFSRBuffer[(FTap + 25) and 31];
<tr class="nocodegen"><td>3812<td>
<tr class="nocodegen"><td>3813<td>    // update the LFSR buffer (LAMBDA_PULL)
<tr class="covered"><td>3814<td>    PTap25[ 0] := PTap25[ 0] xor PTap0[ 2];
<tr class="covered"><td>3815<td>    PTap25[ 1] := PTap25[ 1] xor PTap0[ 3];
<tr class="covered"><td>3816<td>    PTap25[ 2] := PTap25[ 2] xor PTap0[ 4];
<tr class="covered"><td>3817<td>    PTap25[ 3] := PTap25[ 3] xor PTap0[ 5];
<tr class="covered"><td>3818<td>    PTap25[ 4] := PTap25[ 4] xor PTap0[ 6];
<tr class="covered"><td>3819<td>    PTap25[ 5] := PTap25[ 5] xor PTap0[ 7];
<tr class="covered"><td>3820<td>    PTap25[ 6] := PTap25[ 6] xor PTap0[ 0];
<tr class="covered"><td>3821<td>    PTap25[ 7] := PTap25[ 7] xor PTap0[ 1];
<tr class="covered"><td>3822<td>    PTap0[ 0] := PTap0[ 0] xor FDigest[ 1];
<tr class="covered"><td>3823<td>    PTap0[ 1] := PTap0[ 1] xor FDigest[ 2];
<tr class="covered"><td>3824<td>    PTap0[ 2] := PTap0[ 2] xor FDigest[ 3];
<tr class="covered"><td>3825<td>    PTap0[ 3] := PTap0[ 3] xor FDigest[ 4];
<tr class="covered"><td>3826<td>    PTap0[ 4] := PTap0[ 4] xor FDigest[ 5];
<tr class="covered"><td>3827<td>    PTap0[ 5] := PTap0[ 5] xor FDigest[ 6];
<tr class="covered"><td>3828<td>    PTap0[ 6] := PTap0[ 6] xor FDigest[ 7];
<tr class="covered"><td>3829<td>    PTap0[ 7] := PTap0[ 7] xor FDigest[ 8];
<tr class="nocodegen"><td>3830<td>
<tr class="nocodegen"><td>3831<td>    // perform non-linearity stage (GAMMA)
<tr class="covered"><td>3832<td>    T0 := FDigest[ 0];
<tr class="covered"><td>3833<td>    T1 := FDigest[ 1];
<tr class="covered"><td>3834<td>    FDigest[ 0] := FDigest[ 0] xor (FDigest[ 1] or not FDigest[ 2]);
<tr class="covered"><td>3835<td>    FDigest[ 1] := FDigest[ 1] xor (FDigest[ 2] or not FDigest[ 3]);
<tr class="covered"><td>3836<td>    FDigest[ 2] := FDigest[ 2] xor (FDigest[ 3] or not FDigest[ 4]);
<tr class="covered"><td>3837<td>    FDigest[ 3] := FDigest[ 3] xor (FDigest[ 4] or not FDigest[ 5]);
<tr class="covered"><td>3838<td>    FDigest[ 4] := FDigest[ 4] xor (FDigest[ 5] or not FDigest[ 6]);
<tr class="covered"><td>3839<td>    FDigest[ 5] := FDigest[ 5] xor (FDigest[ 6] or not FDigest[ 7]);
<tr class="covered"><td>3840<td>    FDigest[ 6] := FDigest[ 6] xor (FDigest[ 7] or not FDigest[ 8]);
<tr class="covered"><td>3841<td>    FDigest[ 7] := FDigest[ 7] xor (FDigest[ 8] or not FDigest[ 9]);
<tr class="covered"><td>3842<td>    FDigest[ 8] := FDigest[ 8] xor (FDigest[ 9] or not FDigest[10]);
<tr class="covered"><td>3843<td>    FDigest[ 9] := FDigest[ 9] xor (FDigest[10] or not FDigest[11]);
<tr class="covered"><td>3844<td>    FDigest[10] := FDigest[10] xor (FDigest[11] or not FDigest[12]);
<tr class="covered"><td>3845<td>    FDigest[11] := FDigest[11] xor (FDigest[12] or not FDigest[13]);
<tr class="covered"><td>3846<td>    FDigest[12] := FDigest[12] xor (FDigest[13] or not FDigest[14]);
<tr class="covered"><td>3847<td>    FDigest[13] := FDigest[13] xor (FDigest[14] or not FDigest[15]);
<tr class="covered"><td>3848<td>    FDigest[14] := FDigest[14] xor (FDigest[15] or not FDigest[16]);
<tr class="covered"><td>3849<td>    FDigest[15] := FDigest[15] xor (FDigest[16] or not T0);
<tr class="covered"><td>3850<td>    FDigest[16] := FDigest[16] xor (T0 or not T1);
<tr class="nocodegen"><td>3851<td>
<tr class="nocodegen"><td>3852<td>    // perform bit-dispersion stage (PI)
<tr class="covered"><td>3853<td>    T0 := FDigest[ 1];
<tr class="covered"><td>3854<td>    T1 := FDigest[ 7]; FDigest[ 1] := (T1 shl  1) or (T1 shr 31);
<tr class="covered"><td>3855<td>    T1 := FDigest[ 5]; FDigest[ 5] := (T0 shl 15) or (T0 shr 17);
<tr class="covered"><td>3856<td>    T0 := FDigest[ 8]; FDigest[ 8] := (T1 shl  4) or (T1 shr 28);
<tr class="covered"><td>3857<td>    T1 := FDigest[ 6]; FDigest[ 6] := (T0 shl 21) or (T0 shr 11);
<tr class="covered"><td>3858<td>    T0 := FDigest[13]; FDigest[13] := (T1 shl 27) or (T1 shr  5);
<tr class="covered"><td>3859<td>    T1 := FDigest[14]; FDigest[14] := (T0 shl  9) or (T0 shr 23);
<tr class="covered"><td>3860<td>    T0 := FDigest[ 2]; FDigest[ 2] := (T1 shl  3) or (T1 shr 29);
<tr class="covered"><td>3861<td>    T1 := FDigest[10]; FDigest[10] := (T0 shl 23) or (T0 shr  9);
<tr class="covered"><td>3862<td>    T0 := FDigest[16]; FDigest[16] := (T1 shl  8) or (T1 shr 24);
<tr class="covered"><td>3863<td>    T1 := FDigest[12]; FDigest[12] := (T0 shl 14) or (T0 shr 18);
<tr class="covered"><td>3864<td>    T0 := FDigest[ 9]; FDigest[ 9] := (T1 shl 13) or (T1 shr 19);
<tr class="covered"><td>3865<td>    T1 := FDigest[11]; FDigest[11] := (T0 shl  2) or (T0 shr 30);
<tr class="covered"><td>3866<td>    T0 := FDigest[ 4]; FDigest[ 4] := (T1 shl 10) or (T1 shr 22);
<tr class="covered"><td>3867<td>    T1 := FDigest[ 3]; FDigest[ 3] := (T0 shl  6) or (T0 shr 26);
<tr class="covered"><td>3868<td>    T0 := FDigest[15]; FDigest[15] := (T1 shl 24) or (T1 shr  8);
<tr class="covered"><td>3869<td>    FDigest[ 7] := (T0 shl 28) or (T0 shr  4);
<tr class="nocodegen"><td>3870<td>
<tr class="nocodegen"><td>3871<td>    // perform diffusion stage (THETA) + buffer injection stage (SIGMA)
<tr class="covered"><td>3872<td>    T0 := FDigest[ 0];
<tr class="covered"><td>3873<td>    T1 := FDigest[ 1];
<tr class="covered"><td>3874<td>    T2 := FDigest[ 2];
<tr class="covered"><td>3875<td>    T3 := FDigest[ 3];
<tr class="covered"><td>3876<td>    FDigest[ 0] := FDigest[ 0] xor FDigest[ 1] xor FDigest[ 4] xor 1;
<tr class="covered"><td>3877<td>    FDigest[ 1] := FDigest[ 1] xor FDigest[ 2] xor FDigest[ 5] xor PBufL[ 0];
<tr class="covered"><td>3878<td>    FDigest[ 2] := FDigest[ 2] xor FDigest[ 3] xor FDigest[ 6] xor PBufL[ 1];
<tr class="covered"><td>3879<td>    FDigest[ 3] := FDigest[ 3] xor FDigest[ 4] xor FDigest[ 7] xor PBufL[ 2];
<tr class="covered"><td>3880<td>    FDigest[ 4] := FDigest[ 4] xor FDigest[ 5] xor FDigest[ 8] xor PBufL[ 3];
<tr class="covered"><td>3881<td>    FDigest[ 5] := FDigest[ 5] xor FDigest[ 6] xor FDigest[ 9] xor PBufL[ 4];
<tr class="covered"><td>3882<td>    FDigest[ 6] := FDigest[ 6] xor FDigest[ 7] xor FDigest[10] xor PBufL[ 5];
<tr class="covered"><td>3883<td>    FDigest[ 7] := FDigest[ 7] xor FDigest[ 8] xor FDigest[11] xor PBufL[ 6];
<tr class="covered"><td>3884<td>    FDigest[ 8] := FDigest[ 8] xor FDigest[ 9] xor FDigest[12] xor PBufL[ 7];
<tr class="covered"><td>3885<td>    FDigest[ 9] := FDigest[ 9] xor FDigest[10] xor FDigest[13] xor PBufB[ 0];
<tr class="covered"><td>3886<td>    FDigest[10] := FDigest[10] xor FDigest[11] xor FDigest[14] xor PBufB[ 1];
<tr class="covered"><td>3887<td>    FDigest[11] := FDigest[11] xor FDigest[12] xor FDigest[15] xor PBufB[ 2];
<tr class="covered"><td>3888<td>    FDigest[12] := FDigest[12] xor FDigest[13] xor FDigest[16] xor PBufB[ 3];
<tr class="covered"><td>3889<td>    FDigest[13] := FDigest[13] xor FDigest[14] xor T0          xor PBufB[ 4];
<tr class="covered"><td>3890<td>    FDigest[14] := FDigest[14] xor FDigest[15] xor T1          xor PBufB[ 5];
<tr class="covered"><td>3891<td>    FDigest[15] := FDigest[15] xor FDigest[16] xor T2          xor PBufB[ 6];
<tr class="covered"><td>3892<td>    FDigest[16] := FDigest[16] xor T0 xor T3                   xor PBufB[ 7];
<tr class="covered"><td>3893<td>  end;
<tr class="nocodegen"><td>3894<td>
<tr class="nocodegen"><td>3895<td>  // move state to Digest buffer
<tr class="covered"><td>3896<td>  FDigest[0] := FDigest[ 9];
<tr class="covered"><td>3897<td>  FDigest[1] := FDigest[10];
<tr class="covered"><td>3898<td>  FDigest[2] := FDigest[11];
<tr class="covered"><td>3899<td>  FDigest[3] := FDigest[12];
<tr class="covered"><td>3900<td>  FDigest[4] := FDigest[13];
<tr class="covered"><td>3901<td>  FDigest[5] := FDigest[14];
<tr class="covered"><td>3902<td>  FDigest[6] := FDigest[15];
<tr class="covered"><td>3903<td>  FDigest[7] := FDigest[16];
<tr class="covered"><td>3904<td>end;
<tr class="nocodegen"><td>3905<td>{$ENDIF !THash_Panama_asm}
<tr class="nocodegen"><td>3906<td>
<tr class="nocodegen"><td>3907<td>function THash_Panama.Digest: PByteArray;
<tr class="covered"><td>3908<td>begin
<tr class="covered"><td>3909<td>  Result := @FDigest;
<tr class="covered"><td>3910<td>end;
<tr class="nocodegen"><td>3911<td>
<tr class="nocodegen"><td>3912<td>class function THash_Panama.DigestSize: UInt32;
<tr class="covered"><td>3913<td>begin
<tr class="covered"><td>3914<td>  Result := 32;
<tr class="covered"><td>3915<td>end;
<tr class="nocodegen"><td>3916<td>
<tr class="nocodegen"><td>3917<td>class function THash_Panama.BlockSize: UInt32;
<tr class="covered"><td>3918<td>begin
<tr class="covered"><td>3919<td>  Result := 32
<tr class="covered"><td>3920<td>end;
<tr class="nocodegen"><td>3921<td>
<tr class="nocodegen"><td>3922<td>{ THashBaseWhirlpool }
<tr class="nocodegen"><td>3923<td>
<tr class="nocodegen"><td>3924<td>{$IFNDEF THashBaseWhirlpool_asm}
<tr class="nocodegen"><td>3925<td>procedure THashBaseWhirlpool.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>3926<td>type
<tr class="nocodegen"><td>3927<td>  PWhirlData = ^TWhirlData;
<tr class="nocodegen"><td>3928<td>  TWhirlData = array[0..15] of UInt32;
<tr class="nocodegen"><td>3929<td>  PWhirlTable = ^TWhirlTable;
<tr class="nocodegen"><td>3930<td>  TWhirlTable = array[0..7, 0..511] of UInt32;
<tr class="nocodegen"><td>3931<td>
<tr class="nocodegen"><td>3932<td>  procedure Whirl(var L: TWhirlData; const K: TWhirlData; const T: PWhirlTable);
<tr class="covered"><td>3933<td>  begin
<tr class="covered"><td>3934<td>    L[0*2+0] := T[0, ((K[ 0] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3935<td>                T[1, ((K[14] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3936<td>                T[2, ((K[12] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3937<td>                T[3, ((K[10] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>3938<td>                T[4, ((K[ 9] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3939<td>                T[5, ((K[ 7] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3940<td>                T[6, ((K[ 5] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3941<td>                T[7, ((K[ 3] shr 23) and $1fe)];
<tr class="covered"><td>3942<td>    L[0*2+1] := T[0, ((K[ 0] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3943<td>                T[1, ((K[14] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3944<td>                T[2, ((K[12] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3945<td>                T[3, ((K[10] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>3946<td>                T[4, ((K[ 9] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3947<td>                T[5, ((K[ 7] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3948<td>                T[6, ((K[ 5] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3949<td>                T[7, ((K[ 3] shr 23) and $1fe)+1];
<tr class="covered"><td>3950<td>    L[1*2+0] := T[0, ((K[ 2] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3951<td>                T[1, ((K[ 0] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3952<td>                T[2, ((K[14] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3953<td>                T[3, ((K[12] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>3954<td>                T[4, ((K[11] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3955<td>                T[5, ((K[ 9] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3956<td>                T[6, ((K[ 7] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3957<td>                T[7, ((K[ 5] shr 23) and $1fe)];
<tr class="covered"><td>3958<td>    L[1*2+1] := T[0, ((K[ 2] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3959<td>                T[1, ((K[ 0] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3960<td>                T[2, ((K[14] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3961<td>                T[3, ((K[12] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>3962<td>                T[4, ((K[11] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3963<td>                T[5, ((K[ 9] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3964<td>                T[6, ((K[ 7] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3965<td>                T[7, ((K[ 5] shr 23) and $1fe)+1];
<tr class="covered"><td>3966<td>    L[2*2+0] := T[0, ((K[ 4] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3967<td>                T[1, ((K[ 2] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3968<td>                T[2, ((K[ 0] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3969<td>                T[3, ((K[14] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>3970<td>                T[4, ((K[13] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3971<td>                T[5, ((K[11] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3972<td>                T[6, ((K[ 9] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3973<td>                T[7, ((K[ 7] shr 23) and $1fe)];
<tr class="covered"><td>3974<td>    L[2*2+1] := T[0, ((K[ 4] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3975<td>                T[1, ((K[ 2] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3976<td>                T[2, ((K[ 0] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3977<td>                T[3, ((K[14] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>3978<td>                T[4, ((K[13] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3979<td>                T[5, ((K[11] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3980<td>                T[6, ((K[ 9] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3981<td>                T[7, ((K[ 7] shr 23) and $1fe)+1];
<tr class="covered"><td>3982<td>    L[3*2+0] := T[0, ((K[ 6] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3983<td>                T[1, ((K[ 4] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3984<td>                T[2, ((K[ 2] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3985<td>                T[3, ((K[ 0] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>3986<td>                T[4, ((K[15] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3987<td>                T[5, ((K[13] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>3988<td>                T[6, ((K[11] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>3989<td>                T[7, ((K[ 9] shr 23) and $1fe)];
<tr class="covered"><td>3990<td>    L[3*2+1] := T[0, ((K[ 6] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3991<td>                T[1, ((K[ 4] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3992<td>                T[2, ((K[ 2] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3993<td>                T[3, ((K[ 0] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>3994<td>                T[4, ((K[15] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>3995<td>                T[5, ((K[13] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>3996<td>                T[6, ((K[11] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>3997<td>                T[7, ((K[ 9] shr 23) and $1fe)+1];
<tr class="covered"><td>3998<td>    L[4*2+0] := T[0, ((K[ 8] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>3999<td>                T[1, ((K[ 6] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4000<td>                T[2, ((K[ 4] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4001<td>                T[3, ((K[ 2] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>4002<td>                T[4, ((K[ 1] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>4003<td>                T[5, ((K[15] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4004<td>                T[6, ((K[13] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4005<td>                T[7, ((K[11] shr 23) and $1fe)];
<tr class="covered"><td>4006<td>    L[4*2+1] := T[0, ((K[ 8] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4007<td>                T[1, ((K[ 6] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4008<td>                T[2, ((K[ 4] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4009<td>                T[3, ((K[ 2] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>4010<td>                T[4, ((K[ 1] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4011<td>                T[5, ((K[15] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4012<td>                T[6, ((K[13] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4013<td>                T[7, ((K[11] shr 23) and $1fe)+1];
<tr class="covered"><td>4014<td>    L[5*2+0] := T[0, ((K[10] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>4015<td>                T[1, ((K[ 8] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4016<td>                T[2, ((K[ 6] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4017<td>                T[3, ((K[ 4] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>4018<td>                T[4, ((K[ 3] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>4019<td>                T[5, ((K[ 1] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4020<td>                T[6, ((K[15] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4021<td>                T[7, ((K[13] shr 23) and $1fe)];
<tr class="covered"><td>4022<td>    L[5*2+1] := T[0, ((K[10] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4023<td>                T[1, ((K[ 8] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4024<td>                T[2, ((K[ 6] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4025<td>                T[3, ((K[ 4] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>4026<td>                T[4, ((K[ 3] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4027<td>                T[5, ((K[ 1] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4028<td>                T[6, ((K[15] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4029<td>                T[7, ((K[13] shr 23) and $1fe)+1];
<tr class="covered"><td>4030<td>    L[6*2+0] := T[0, ((K[12] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>4031<td>                T[1, ((K[10] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4032<td>                T[2, ((K[ 8] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4033<td>                T[3, ((K[ 6] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>4034<td>                T[4, ((K[ 5] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>4035<td>                T[5, ((K[ 3] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4036<td>                T[6, ((K[ 1] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4037<td>                T[7, ((K[15] shr 23) and $1fe)];
<tr class="covered"><td>4038<td>    L[6*2+1] := T[0, ((K[12] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4039<td>                T[1, ((K[10] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4040<td>                T[2, ((K[ 8] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4041<td>                T[3, ((K[ 6] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>4042<td>                T[4, ((K[ 5] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4043<td>                T[5, ((K[ 3] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4044<td>                T[6, ((K[ 1] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4045<td>                T[7, ((K[15] shr 23) and $1fe)+1];
<tr class="covered"><td>4046<td>    L[7*2+0] := T[0, ((K[14] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>4047<td>                T[1, ((K[12] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4048<td>                T[2, ((K[10] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4049<td>                T[3, ((K[ 8] shr 23) and $1fe)] xor
<tr class="nocodegen"><td>4050<td>                T[4, ((K[ 7] shl  1) and $1fe)] xor
<tr class="nocodegen"><td>4051<td>                T[5, ((K[ 5] shr  7) and $1fe)] xor
<tr class="nocodegen"><td>4052<td>                T[6, ((K[ 3] shr 15) and $1fe)] xor
<tr class="nocodegen"><td>4053<td>                T[7, ((K[ 1] shr 23) and $1fe)];
<tr class="covered"><td>4054<td>    L[7*2+1] := T[0, ((K[14] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4055<td>                T[1, ((K[12] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4056<td>                T[2, ((K[10] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4057<td>                T[3, ((K[ 8] shr 23) and $1fe)+1] xor
<tr class="nocodegen"><td>4058<td>                T[4, ((K[ 7] shl  1) and $1fe)+1] xor
<tr class="nocodegen"><td>4059<td>                T[5, ((K[ 5] shr  7) and $1fe)+1] xor
<tr class="nocodegen"><td>4060<td>                T[6, ((K[ 3] shr 15) and $1fe)+1] xor
<tr class="nocodegen"><td>4061<td>                T[7, ((K[ 1] shr 23) and $1fe)+1];
<tr class="covered"><td>4062<td>  end;
<tr class="nocodegen"><td>4063<td>
<tr class="nocodegen"><td>4064<td>var
<tr class="nocodegen"><td>4065<td>  S, L, K: TWhirlData;
<tr class="nocodegen"><td>4066<td>  I: Integer;
<tr class="covered"><td>4067<td>begin
<tr class="covered"><td>4068<td>  Assert(not Odd(Whirlpool_Rounds));
<tr class="nocodegen"><td>4069<td>
<tr class="covered"><td>4070<td>  Move(FDigest, K, SizeOf(FDigest));
<tr class="covered"><td>4071<td>  XORBuffers(FDigest, Buffer[0], SizeOf(FDigest), S);
<tr class="nocodegen"><td>4072<td>
<tr class="nocodegen"><td>4073<td>  // iterate over all rounds
<tr class="covered"><td>4074<td>  for I := 0 to Whirlpool_Rounds div 2 - 1 do
<tr class="nocodegen"><td>4075<td>  begin
<tr class="covered"><td>4076<td>    Whirl(L, K, FTableC);
<tr class="covered"><td>4077<td>    L[0] := L[0] xor PUInt32Array(FTableR)[I*4+0];
<tr class="covered"><td>4078<td>    L[1] := L[1] xor PUInt32Array(FTableR)[I*4+1];
<tr class="covered"><td>4079<td>    Whirl(K, S, FTableC);
<tr class="covered"><td>4080<td>    XORBuffers(L, K, SizeOf(S), S);
<tr class="nocodegen"><td>4081<td>
<tr class="covered"><td>4082<td>    Whirl(K, L, FTableC);
<tr class="covered"><td>4083<td>    K[0] := K[0] xor PUInt32Array(FTableR)[I*4+2];
<tr class="covered"><td>4084<td>    K[1] := K[1] xor PUInt32Array(FTableR)[I*4+3];
<tr class="covered"><td>4085<td>    Whirl(L, S, FTableC);
<tr class="covered"><td>4086<td>    XORBuffers(K, L, SizeOf(S), S);
<tr class="covered"><td>4087<td>  end;
<tr class="nocodegen"><td>4088<td>
<tr class="covered"><td>4089<td>  XORBuffers(S, Buffer[0], SizeOf(FDigest), S);
<tr class="covered"><td>4090<td>  XORBuffers(S, FDigest, SizeOf(FDigest), FDigest);
<tr class="covered"><td>4091<td>end;
<tr class="nocodegen"><td>4092<td>{$ENDIF !THashBaseWhirlpool_asm}
<tr class="nocodegen"><td>4093<td>
<tr class="nocodegen"><td>4094<td>procedure THashBaseWhirlpool.DoDone;
<tr class="nocodegen"><td>4095<td>var
<tr class="nocodegen"><td>4096<td>  I: Integer;
<tr class="covered"><td>4097<td>begin
<tr class="covered"><td>4098<td>  if FPaddingByte = 0 then
<tr class="covered"><td>4099<td>    FPaddingByte := $80;
<tr class="covered"><td>4100<td>  FBuffer[FBufferIndex] := FPaddingByte;
<tr class="covered"><td>4101<td>  Inc(FBufferIndex);
<tr class="covered"><td>4102<td>  if FBufferIndex &gt; FBufferSize - 32 then
<tr class="nocodegen"><td>4103<td>  begin
<tr class="covered"><td>4104<td>    FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>4105<td>    DoTransform(Pointer(FBuffer));
<tr class="covered"><td>4106<td>    FBufferIndex := 0;
<tr class="nocodegen"><td>4107<td>  end;
<tr class="covered"><td>4108<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>4109<td>  for I := 31 downto 0 do
<tr class="covered"><td>4110<td>    FBuffer[63 - I] := PByteArray(@FCount)[I];
<tr class="covered"><td>4111<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>4112<td>end;
<tr class="nocodegen"><td>4113<td>
<tr class="nocodegen"><td>4114<td>function THashBaseWhirlpool.Digest: PByteArray;
<tr class="covered"><td>4115<td>begin
<tr class="covered"><td>4116<td>  Result := @FDigest;
<tr class="covered"><td>4117<td>end;
<tr class="nocodegen"><td>4118<td>
<tr class="nocodegen"><td>4119<td>class function THashBaseWhirlpool.DigestSize: UInt32;
<tr class="covered"><td>4120<td>begin
<tr class="covered"><td>4121<td>  Result := 64;
<tr class="covered"><td>4122<td>end;
<tr class="nocodegen"><td>4123<td>
<tr class="nocodegen"><td>4124<td>class function THashBaseWhirlpool.BlockSize: UInt32;
<tr class="covered"><td>4125<td>begin
<tr class="covered"><td>4126<td>  Result := 64;
<tr class="covered"><td>4127<td>end;
<tr class="nocodegen"><td>4128<td>
<tr class="nocodegen"><td>4129<td>{ THash_Whirlpool0 }
<tr class="nocodegen"><td>4130<td>
<tr class="nocodegen"><td>4131<td>procedure THash_Whirlpool0.DoInit;
<tr class="covered"><td>4132<td>begin
<tr class="covered"><td>4133<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>4134<td>  FTableC := @Whirlpool_C_U;
<tr class="covered"><td>4135<td>  FTableR := @Whirlpool_RC_U
<tr class="covered"><td>4136<td>end;
<tr class="nocodegen"><td>4137<td>
<tr class="nocodegen"><td>4138<td>{ THash_WhirlpoolT }
<tr class="nocodegen"><td>4139<td>
<tr class="nocodegen"><td>4140<td>procedure THash_WhirlpoolT.DoInit;
<tr class="covered"><td>4141<td>begin
<tr class="covered"><td>4142<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>4143<td>  FTableC := @Whirlpool_C_T;
<tr class="covered"><td>4144<td>  FTableR := @Whirlpool_RC_T;
<tr class="covered"><td>4145<td>end;
<tr class="nocodegen"><td>4146<td>
<tr class="nocodegen"><td>4147<td>{ THash_Whirlpool1_ }
<tr class="nocodegen"><td>4148<td>
<tr class="nocodegen"><td>4149<td>procedure THash_Whirlpool1_.DoInit;
<tr class="covered"><td>4150<td>begin
<tr class="covered"><td>4151<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>4152<td>  FTableC := @Whirlpool_C_1;
<tr class="covered"><td>4153<td>  FTableR := @Whirlpool_RC_1;
<tr class="covered"><td>4154<td>end;
<tr class="nocodegen"><td>4155<td>
<tr class="nocodegen"><td>4156<td>{ THash_Square }
<tr class="nocodegen"><td>4157<td>
<tr class="nocodegen"><td>4158<td>procedure THash_Square.DoInit;
<tr class="covered"><td>4159<td>begin
<tr class="covered"><td>4160<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>4161<td>end;
<tr class="nocodegen"><td>4162<td>
<tr class="nocodegen"><td>4163<td>{$IFNDEF THash_Square_asm}
<tr class="nocodegen"><td>4164<td>procedure THash_Square.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>4165<td>var
<tr class="nocodegen"><td>4166<td>  Key: array[0..8, 0..3] of UInt32;
<tr class="nocodegen"><td>4167<td>  A, B, C, D: UInt32;
<tr class="nocodegen"><td>4168<td>  AA, BB, CC, DD: UInt32;
<tr class="nocodegen"><td>4169<td>  I: Integer;
<tr class="covered"><td>4170<td>begin
<tr class="nocodegen"><td>4171<td>  // Build and expand the Key, Digest include the Key
<tr class="covered"><td>4172<td>  Key[0, 0] := FDigest[0];
<tr class="covered"><td>4173<td>  Key[0, 1] := FDigest[1];
<tr class="covered"><td>4174<td>  Key[0, 2] := FDigest[2];
<tr class="covered"><td>4175<td>  Key[0, 3] := FDigest[3];
<tr class="nocodegen"><td>4176<td>
<tr class="covered"><td>4177<td>  for I := 1 to 8 do
<tr class="nocodegen"><td>4178<td>  begin
<tr class="covered"><td>4179<td>    Key[I, 0] := Key[I - 1, 0] xor Key[I - 1, 3] shr 8 xor Key[I - 1, 3] shl 24 xor 1 shl (I - 1);
<tr class="covered"><td>4180<td>    Key[I, 1] := Key[I - 1, 1] xor Key[I, 0];
<tr class="covered"><td>4181<td>    Key[I, 2] := Key[I - 1, 2] xor Key[I, 1];
<tr class="covered"><td>4182<td>    Key[I, 3] := Key[I - 1, 3] xor Key[I, 2];
<tr class="nocodegen"><td>4183<td>
<tr class="covered"><td>4184<td>    Key[I - 1, 0] := Square_PHIr[0, Key[I - 1, 0]        and $FF] xor
<tr class="nocodegen"><td>4185<td>                     Square_PHIr[1, Key[I - 1, 0] shr  8 and $FF] xor
<tr class="nocodegen"><td>4186<td>                     Square_PHIr[2, Key[I - 1, 0] shr 16 and $FF] xor
<tr class="nocodegen"><td>4187<td>                     Square_PHIr[3, Key[I - 1, 0] shr 24        ];
<tr class="covered"><td>4188<td>    Key[I - 1, 1] := Square_PHIr[0, Key[I - 1, 1]        and $FF] xor
<tr class="nocodegen"><td>4189<td>                     Square_PHIr[1, Key[I - 1, 1] shr  8 and $FF] xor
<tr class="nocodegen"><td>4190<td>                     Square_PHIr[2, Key[I - 1, 1] shr 16 and $FF] xor
<tr class="nocodegen"><td>4191<td>                     Square_PHIr[3, Key[I - 1, 1] shr 24        ];
<tr class="covered"><td>4192<td>    Key[I - 1, 2] := Square_PHIr[0, Key[I - 1, 2]        and $FF] xor
<tr class="nocodegen"><td>4193<td>                     Square_PHIr[1, Key[I - 1, 2] shr  8 and $FF] xor
<tr class="nocodegen"><td>4194<td>                     Square_PHIr[2, Key[I - 1, 2] shr 16 and $FF] xor
<tr class="nocodegen"><td>4195<td>                     Square_PHIr[3, Key[I - 1, 2] shr 24        ];
<tr class="covered"><td>4196<td>    Key[I - 1, 3] := Square_PHIr[0, Key[I - 1, 3]        and $FF] xor
<tr class="nocodegen"><td>4197<td>                     Square_PHIr[1, Key[I - 1, 3] shr  8 and $FF] xor
<tr class="nocodegen"><td>4198<td>                     Square_PHIr[2, Key[I - 1, 3] shr 16 and $FF] xor
<tr class="nocodegen"><td>4199<td>                     Square_PHIr[3, Key[I - 1, 3] shr 24        ];
<tr class="covered"><td>4200<td>  end;
<tr class="nocodegen"><td>4201<td>
<tr class="nocodegen"><td>4202<td>  // Encrypt begin here, same TCipher_Square.Encode
<tr class="covered"><td>4203<td>  A := Buffer[0] xor Key[0, 0];
<tr class="covered"><td>4204<td>  B := Buffer[1] xor Key[0, 1];
<tr class="covered"><td>4205<td>  C := Buffer[2] xor Key[0, 2];
<tr class="covered"><td>4206<td>  D := Buffer[3] xor Key[0, 3];
<tr class="nocodegen"><td>4207<td>
<tr class="covered"><td>4208<td>  for I := 0 to 6 do
<tr class="nocodegen"><td>4209<td>  begin
<tr class="covered"><td>4210<td>    AA := Square_TE[0, A        and $FF] xor
<tr class="nocodegen"><td>4211<td>          Square_TE[1, B        and $FF] xor
<tr class="nocodegen"><td>4212<td>          Square_TE[2, C        and $FF] xor
<tr class="nocodegen"><td>4213<td>          Square_TE[3, D        and $FF] xor Key[I + 1, 0];
<tr class="covered"><td>4214<td>    BB := Square_TE[0, A shr  8 and $FF] xor
<tr class="nocodegen"><td>4215<td>          Square_TE[1, B shr  8 and $FF] xor
<tr class="nocodegen"><td>4216<td>          Square_TE[2, C shr  8 and $FF] xor
<tr class="nocodegen"><td>4217<td>          Square_TE[3, D shr  8 and $FF] xor Key[I + 1, 1];
<tr class="covered"><td>4218<td>    CC := Square_TE[0, A shr 16 and $FF] xor
<tr class="nocodegen"><td>4219<td>          Square_TE[1, B shr 16 and $FF] xor
<tr class="nocodegen"><td>4220<td>          Square_TE[2, C shr 16 and $FF] xor
<tr class="nocodegen"><td>4221<td>          Square_TE[3, D shr 16 and $FF] xor Key[I + 1, 2];
<tr class="covered"><td>4222<td>    DD := Square_TE[0, A shr 24        ] xor
<tr class="nocodegen"><td>4223<td>          Square_TE[1, B shr 24        ] xor
<tr class="nocodegen"><td>4224<td>          Square_TE[2, C shr 24        ] xor
<tr class="nocodegen"><td>4225<td>          Square_TE[3, D shr 24        ] xor Key[I + 1, 3];
<tr class="nocodegen"><td>4226<td>
<tr class="covered"><td>4227<td>    A := AA; B := BB; C := CC; D := DD;
<tr class="covered"><td>4228<td>  end;
<tr class="nocodegen"><td>4229<td>
<tr class="covered"><td>4230<td>  FDigest[0] := Buffer[0] xor
<tr class="nocodegen"><td>4231<td>                Square_SEint[A        and $FF]        xor
<tr class="nocodegen"><td>4232<td>                Square_SEint[B        and $FF] shl  8 xor
<tr class="nocodegen"><td>4233<td>                Square_SEint[C        and $FF] shl 16 xor
<tr class="nocodegen"><td>4234<td>                Square_SEint[D        and $FF] shl 24 xor Key[8, 0];
<tr class="covered"><td>4235<td>  FDigest[1] := Buffer[1] xor
<tr class="nocodegen"><td>4236<td>                Square_SEint[A shr  8 and $FF]        xor
<tr class="nocodegen"><td>4237<td>                Square_SEint[B shr  8 and $FF] shl  8 xor
<tr class="nocodegen"><td>4238<td>                Square_SEint[C shr  8 and $FF] shl 16 xor
<tr class="nocodegen"><td>4239<td>                Square_SEint[D shr  8 and $FF] shl 24 xor Key[8, 1];
<tr class="covered"><td>4240<td>  FDigest[2] := Buffer[2] xor
<tr class="nocodegen"><td>4241<td>                Square_SEint[A shr 16 and $FF]        xor
<tr class="nocodegen"><td>4242<td>                Square_SEint[B shr 16 and $FF] shl  8 xor
<tr class="nocodegen"><td>4243<td>                Square_SEint[C shr 16 and $FF] shl 16 xor
<tr class="nocodegen"><td>4244<td>                Square_SEint[D shr 16 and $FF] shl 24 xor Key[8, 2];
<tr class="covered"><td>4245<td>  FDigest[3] := Buffer[3] xor
<tr class="nocodegen"><td>4246<td>                Square_SEint[A shr 24        ]        xor
<tr class="nocodegen"><td>4247<td>                Square_SEint[B shr 24        ] shl  8 xor
<tr class="nocodegen"><td>4248<td>                Square_SEint[C shr 24        ] shl 16 xor
<tr class="nocodegen"><td>4249<td>                Square_SEint[D shr 24        ] shl 24 xor Key[8, 3];
<tr class="covered"><td>4250<td>end;
<tr class="nocodegen"><td>4251<td>{$ENDIF !THash_Square_asm}
<tr class="nocodegen"><td>4252<td>
<tr class="nocodegen"><td>4253<td>procedure THash_Square.DoDone;
<tr class="nocodegen"><td>4254<td>var
<tr class="nocodegen"><td>4255<td>  I: Integer;
<tr class="covered"><td>4256<td>begin
<tr class="covered"><td>4257<td>  if FPaddingByte = 0 then
<tr class="covered"><td>4258<td>    FPaddingByte := $80;
<tr class="covered"><td>4259<td>  FBuffer[FBufferIndex] := FPaddingByte;
<tr class="covered"><td>4260<td>  Inc(FBufferIndex);
<tr class="covered"><td>4261<td>  if FBufferIndex &gt; FBufferSize - 8 then
<tr class="nocodegen"><td>4262<td>  begin
<tr class="covered"><td>4263<td>    FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>4264<td>    DoTransform(Pointer(FBuffer));
<tr class="covered"><td>4265<td>    FBufferIndex := 0;
<tr class="nocodegen"><td>4266<td>  end;
<tr class="covered"><td>4267<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>4268<td>  for I := 7 downto 0 do
<tr class="covered"><td>4269<td>    FBuffer[15 - I] := PByteArray(@FCount[0])[I];
<tr class="covered"><td>4270<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>4271<td>end;
<tr class="nocodegen"><td>4272<td>
<tr class="nocodegen"><td>4273<td>function THash_Square.Digest: PByteArray;
<tr class="covered"><td>4274<td>begin
<tr class="covered"><td>4275<td>  Result := @FDigest;
<tr class="covered"><td>4276<td>end;
<tr class="nocodegen"><td>4277<td>
<tr class="nocodegen"><td>4278<td>class function THash_Square.DigestSize: UInt32;
<tr class="covered"><td>4279<td>begin
<tr class="covered"><td>4280<td>  Result := 16;
<tr class="covered"><td>4281<td>end;
<tr class="nocodegen"><td>4282<td>
<tr class="nocodegen"><td>4283<td>class function THash_Square.BlockSize: UInt32;
<tr class="covered"><td>4284<td>begin
<tr class="covered"><td>4285<td>  Result := 16;
<tr class="covered"><td>4286<td>end;
<tr class="nocodegen"><td>4287<td>
<tr class="nocodegen"><td>4288<td>{ THashBaseSnefru }
<tr class="nocodegen"><td>4289<td>
<tr class="nocodegen"><td>4290<td>procedure THashBaseSnefru.SetRounds(Value: UInt32);
<tr class="covered"><td>4291<td>begin
<tr class="covered"><td>4292<td>  if (Value &lt; 2) or (Value &gt; 8) then
<tr class="covered"><td>4293<td>    Value := 8;
<tr class="covered"><td>4294<td>  FRounds := Value;
<tr class="covered"><td>4295<td>end;
<tr class="nocodegen"><td>4296<td>
<tr class="nocodegen"><td>4297<td>procedure THashBaseSnefru.DoInit;
<tr class="covered"><td>4298<td>begin
<tr class="covered"><td>4299<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>4300<td>  SetRounds(FRounds);
<tr class="covered"><td>4301<td>end;
<tr class="nocodegen"><td>4302<td>
<tr class="nocodegen"><td>4303<td>function THashBaseSnefru.GetMaxRounds: UInt32;
<tr class="covered"><td>4304<td>begin
<tr class="covered"><td>4305<td>  Result := 8;
<tr class="covered"><td>4306<td>end;
<tr class="nocodegen"><td>4307<td>
<tr class="nocodegen"><td>4308<td>function THashBaseSnefru.GetMinRounds: UInt32;
<tr class="covered"><td>4309<td>begin
<tr class="covered"><td>4310<td>  Result := 2;
<tr class="covered"><td>4311<td>end;
<tr class="nocodegen"><td>4312<td>
<tr class="nocodegen"><td>4313<td>function THashBaseSnefru.GetRounds: UInt32;
<tr class="covered"><td>4314<td>begin
<tr class="covered"><td>4315<td>  Result := FRounds;
<tr class="covered"><td>4316<td>end;
<tr class="nocodegen"><td>4317<td>
<tr class="nocodegen"><td>4318<td>procedure THashBaseSnefru.DoDone;
<tr class="covered"><td>4319<td>begin
<tr class="covered"><td>4320<td>  if FBufferIndex &gt; 0 then
<tr class="nocodegen"><td>4321<td>  begin
<tr class="covered"><td>4322<td>    FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>4323<td>    DoTransform(Pointer(FBuffer));
<tr class="covered"><td>4324<td>    FBufferIndex := 0;
<tr class="nocodegen"><td>4325<td>  end;
<tr class="covered"><td>4326<td>  FillChar(FBuffer[FBufferIndex], FBufferSize - FBufferIndex, 0);
<tr class="covered"><td>4327<td>  PUInt32(@FBuffer[FBufferSize - 8])^ := SwapUInt32(FCount[1]);
<tr class="covered"><td>4328<td>  PUInt32(@FBuffer[FBufferSize - 4])^ := SwapUInt32(FCount[0]);
<tr class="covered"><td>4329<td>  DoTransform(Pointer(FBuffer));
<tr class="covered"><td>4330<td>  SwapUInt32Buffer(FDigest, FDigest, 8);
<tr class="covered"><td>4331<td>end;
<tr class="nocodegen"><td>4332<td>
<tr class="nocodegen"><td>4333<td>function THashBaseSnefru.Digest: PByteArray;
<tr class="covered"><td>4334<td>begin
<tr class="covered"><td>4335<td>  Result := @FDigest;
<tr class="covered"><td>4336<td>end;
<tr class="nocodegen"><td>4337<td>
<tr class="nocodegen"><td>4338<td>{ THash_Snefru128 }
<tr class="nocodegen"><td>4339<td>
<tr class="nocodegen"><td>4340<td>{$IFNDEF THash_Snefru128_asm}
<tr class="nocodegen"><td>4341<td>procedure THash_Snefru128.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>4342<td>const
<tr class="nocodegen"><td>4343<td>  ShiftTable: array[0..3] of Integer = (16, 8, 16, 24);
<tr class="nocodegen"><td>4344<td>var
<tr class="nocodegen"><td>4345<td>  I, Index, ByteInWord, T, N, S, S0, S1: UInt32;
<tr class="nocodegen"><td>4346<td>  D, Box0, Box1: PUInt32Array;
<tr class="covered"><td>4347<td>begin
<tr class="covered"><td>4348<td>  D := @FDigest;
<tr class="covered"><td>4349<td>  SwapUInt32Buffer(Buffer[0], D[4], 12);
<tr class="covered"><td>4350<td>  Move(D[0], D[16], 16);
<tr class="covered"><td>4351<td>  Box0 := @Snefru_Data[0];
<tr class="covered"><td>4352<td>  Box1 := @Snefru_Data[1];
<tr class="covered"><td>4353<td>  for Index := 0 to FRounds - 1 do
<tr class="nocodegen"><td>4354<td>  begin
<tr class="covered"><td>4355<td>    for ByteInWord := 0 to 3 do
<tr class="nocodegen"><td>4356<td>    begin
<tr class="covered"><td>4357<td>      I := 0;
<tr class="covered"><td>4358<td>      N := D[0];
<tr class="covered"><td>4359<td>      while I &lt; 16 do
<tr class="nocodegen"><td>4360<td>      begin
<tr class="covered"><td>4361<td>        S0 := Box0[N and $FF];
<tr class="covered"><td>4362<td>        T := (I +  1) and 15;    N := D[T] xor S0; D[T] := N;
<tr class="covered"><td>4363<td>        T := (I + 15) and 15; D[T] := D[T] xor S0;
<tr class="covered"><td>4364<td>        S1 := Box0[N and $FF];
<tr class="covered"><td>4365<td>        T := (I +  2) and 15;    N := D[T] xor S1; D[T] := N;
<tr class="covered"><td>4366<td>        T := (I + 16) and 15; D[T] := D[T] xor S1;
<tr class="covered"><td>4367<td>        S0 := Box1[N and $FF];
<tr class="covered"><td>4368<td>        T := (I +  3) and 15;    N := D[T] xor S0; D[T] := N;
<tr class="covered"><td>4369<td>        T := (I + 17) and 15; D[T] := D[T] xor S0;
<tr class="covered"><td>4370<td>        S1 := Box1[N and $FF];
<tr class="covered"><td>4371<td>        T := (I +  4) and 15;    N := D[T] xor S1; D[T] := N;
<tr class="covered"><td>4372<td>        T := (I + 18) and 15; D[T] := D[T] xor S1;
<tr class="covered"><td>4373<td>        Inc(I, 4);
<tr class="nocodegen"><td>4374<td>      end;
<tr class="covered"><td>4375<td>      T := ShiftTable[ByteInWord];
<tr class="covered"><td>4376<td>      S := 32 - T;
<tr class="covered"><td>4377<td>      for I := 0 to 15 do
<tr class="covered"><td>4378<td>        D[I] := D[I] shr T or D[I] shl S;
<tr class="covered"><td>4379<td>    end;
<tr class="covered"><td>4380<td>    Box0 := @Box0[512];
<tr class="covered"><td>4381<td>    Box1 := @Box1[512];
<tr class="covered"><td>4382<td>  end;
<tr class="covered"><td>4383<td>  for I := 0 to 3 do
<tr class="covered"><td>4384<td>    D[I] := D[I + 16] xor D[15 - I];
<tr class="covered"><td>4385<td>end;
<tr class="nocodegen"><td>4386<td>{$ENDIF !THash_Snefru128_asm}
<tr class="nocodegen"><td>4387<td>
<tr class="nocodegen"><td>4388<td>class function THash_Snefru128.DigestSize: UInt32;
<tr class="covered"><td>4389<td>begin
<tr class="covered"><td>4390<td>  Result := 16;
<tr class="covered"><td>4391<td>end;
<tr class="nocodegen"><td>4392<td>
<tr class="nocodegen"><td>4393<td>class function THash_Snefru128.BlockSize: UInt32;
<tr class="covered"><td>4394<td>begin
<tr class="covered"><td>4395<td>  Result := 48
<tr class="covered"><td>4396<td>end;
<tr class="nocodegen"><td>4397<td>
<tr class="nocodegen"><td>4398<td>{ THash_Snefru256 }
<tr class="nocodegen"><td>4399<td>
<tr class="nocodegen"><td>4400<td>{$IFNDEF THash_Snefru256_asm}
<tr class="nocodegen"><td>4401<td>procedure THash_Snefru256.DoTransform(Buffer: PUInt32Array);
<tr class="nocodegen"><td>4402<td>const
<tr class="nocodegen"><td>4403<td>  ShiftTable: array[0..3] of Integer = (16, 8, 16, 24);
<tr class="nocodegen"><td>4404<td>var
<tr class="nocodegen"><td>4405<td>  I, Index, ByteInWord, T, N, S, S0, S1: UInt32;
<tr class="nocodegen"><td>4406<td>  D, Box0, Box1: PUInt32Array;
<tr class="covered"><td>4407<td>begin
<tr class="covered"><td>4408<td>  D := @FDigest;
<tr class="covered"><td>4409<td>  SwapUInt32Buffer(Buffer[0], D[8], 8);
<tr class="covered"><td>4410<td>  Move(D[0], D[16], 32);
<tr class="covered"><td>4411<td>  Box0 := @Snefru_Data[0];
<tr class="covered"><td>4412<td>  Box1 := @Snefru_Data[1];
<tr class="covered"><td>4413<td>  for Index := 0 to FRounds - 1 do
<tr class="nocodegen"><td>4414<td>  begin
<tr class="covered"><td>4415<td>    for ByteInWord := 0 to 3 do
<tr class="nocodegen"><td>4416<td>    begin
<tr class="covered"><td>4417<td>      I := 0;
<tr class="covered"><td>4418<td>      N := D[0];
<tr class="covered"><td>4419<td>      while I &lt; 16 do
<tr class="nocodegen"><td>4420<td>      begin
<tr class="covered"><td>4421<td>        S0 := Box0[N and $FF];
<tr class="covered"><td>4422<td>        T := (I +  1) and 15;    N := D[T] xor S0; D[T] := N;
<tr class="covered"><td>4423<td>        T := (I + 15) and 15; D[T] := D[T] xor S0;
<tr class="covered"><td>4424<td>        S1 := Box0[N and $FF];
<tr class="covered"><td>4425<td>        T := (I +  2) and 15;    N := D[T] xor S1; D[T] := N;
<tr class="covered"><td>4426<td>        T := (I + 16) and 15; D[T] := D[T] xor S1;
<tr class="covered"><td>4427<td>        S0 := Box1[N and $FF];
<tr class="covered"><td>4428<td>        T := (I +  3) and 15;    N := D[T] xor S0; D[T] := N;
<tr class="covered"><td>4429<td>        T := (I + 17) and 15; D[T] := D[T] xor S0;
<tr class="covered"><td>4430<td>        S1 := Box1[N and $FF];
<tr class="covered"><td>4431<td>        T := (I +  4) and 15;    N := D[T] xor S1; D[T] := N;
<tr class="covered"><td>4432<td>        T := (I + 18) and 15; D[T] := D[T] xor S1;
<tr class="covered"><td>4433<td>        Inc(I, 4);
<tr class="nocodegen"><td>4434<td>      end;
<tr class="covered"><td>4435<td>      T := ShiftTable[ByteInWord];
<tr class="covered"><td>4436<td>      S := 32 - T;
<tr class="covered"><td>4437<td>      for I := 0 to 15 do
<tr class="covered"><td>4438<td>        D[I] := D[I] shr T or D[I] shl S;
<tr class="covered"><td>4439<td>    end;
<tr class="covered"><td>4440<td>    Box0 := @Box0[512];
<tr class="covered"><td>4441<td>    Box1 := @Box1[512];
<tr class="covered"><td>4442<td>  end;
<tr class="covered"><td>4443<td>  for I := 0 to 7 do
<tr class="covered"><td>4444<td>    D[I] := D[I + 16] xor D[15 - I];
<tr class="covered"><td>4445<td>end;
<tr class="nocodegen"><td>4446<td>{$ENDIF !THash_Snefru256_asm}
<tr class="nocodegen"><td>4447<td>
<tr class="nocodegen"><td>4448<td>class function THash_Snefru256.DigestSize: UInt32;
<tr class="covered"><td>4449<td>begin
<tr class="covered"><td>4450<td>  Result := 32;
<tr class="covered"><td>4451<td>end;
<tr class="nocodegen"><td>4452<td>
<tr class="nocodegen"><td>4453<td>class function THash_Snefru256.BlockSize: UInt32;
<tr class="covered"><td>4454<td>begin
<tr class="covered"><td>4455<td>  Result := 32
<tr class="covered"><td>4456<td>end;
<tr class="nocodegen"><td>4457<td>
<tr class="nocodegen"><td>4458<td>{ THash_Sapphire }
<tr class="nocodegen"><td>4459<td>
<tr class="nocodegen"><td>4460<td>procedure THash_Sapphire.DoInit;
<tr class="nocodegen"><td>4461<td>var
<tr class="nocodegen"><td>4462<td>  I: Integer;
<tr class="covered"><td>4463<td>begin
<tr class="covered"><td>4464<td>  FillChar(FDigest, SizeOf(FDigest), 0);
<tr class="covered"><td>4465<td>  FRotor := 1;
<tr class="covered"><td>4466<td>  FRatchet := 3;
<tr class="covered"><td>4467<td>  FAvalanche := 5;
<tr class="covered"><td>4468<td>  FPlain := 7;
<tr class="covered"><td>4469<td>  FCipher := 11;
<tr class="covered"><td>4470<td>  for I := 0 to 255 do
<tr class="covered"><td>4471<td>    FCards[I] := 255 - I;
<tr class="covered"><td>4472<td>end;
<tr class="nocodegen"><td>4473<td>
<tr class="nocodegen"><td>4474<td>procedure THash_Sapphire.DoTransform(Buffer: PUInt32Array);
<tr class="notcovered"><td>4475<td>begin
<tr class="nocodegen"><td>4476<td>  // Empty on purpose: the base class for the hashes declares an abstract
<tr class="nocodegen"><td>4477<td>  // DoTransform method and not providing an override for it would cause a
<tr class="nocodegen"><td>4478<td>  // compiler warning
<tr class="notcovered"><td>4479<td>end;
<tr class="nocodegen"><td>4480<td>
<tr class="nocodegen"><td>4481<td>procedure THash_Sapphire.SetDigestSize(Value: UInt8);
<tr class="covered"><td>4482<td>begin
<tr class="covered"><td>4483<td>  if (Value &gt;= 1) and (Value &lt;= 64) then
<tr class="covered"><td>4484<td>    FDigestSize := Value
<tr class="nocodegen"><td>4485<td>  else
<tr class="notcovered"><td>4486<td>    FDigestSize := DigestSize;
<tr class="covered"><td>4487<td>end;
<tr class="nocodegen"><td>4488<td>
<tr class="nocodegen"><td>4489<td>procedure THash_Sapphire.DoDone;
<tr class="nocodegen"><td>4490<td>var
<tr class="nocodegen"><td>4491<td>  I: Integer;
<tr class="covered"><td>4492<td>begin
<tr class="covered"><td>4493<td>  for I := 255 downto 0 do
<tr class="covered"><td>4494<td>    Calc(I, 1);
<tr class="covered"><td>4495<td>  for I := 0 to DigestSize - 1 do
<tr class="nocodegen"><td>4496<td>  begin
<tr class="covered"><td>4497<td>    Calc(#0#0, 1);
<tr class="covered"><td>4498<td>    PByteArray(@FDigest)[I] := FCipher;
<tr class="covered"><td>4499<td>  end;
<tr class="covered"><td>4500<td>end;
<tr class="nocodegen"><td>4501<td>
<tr class="nocodegen"><td>4502<td>{$IFNDEF THash_Sapphire_asm}
<tr class="nocodegen"><td>4503<td>procedure THash_Sapphire.Calc(const Data; DataSize: Integer);
<tr class="nocodegen"><td>4504<td>var
<tr class="nocodegen"><td>4505<td>  Cipher, Ratchet, Rotor, Plain, Avalanche, T: UInt32;
<tr class="nocodegen"><td>4506<td>  D: PByte;
<tr class="covered"><td>4507<td>begin
<tr class="covered"><td>4508<td>  D         := @Data;
<tr class="covered"><td>4509<td>  Cipher    := FCipher;
<tr class="covered"><td>4510<td>  Ratchet   := FRatchet;
<tr class="covered"><td>4511<td>  Rotor     := FRotor;
<tr class="covered"><td>4512<td>  Plain     := FPlain;
<tr class="covered"><td>4513<td>  Avalanche := FAvalanche;
<tr class="nocodegen"><td>4514<td>
<tr class="covered"><td>4515<td>  while DataSize &gt; 0 do
<tr class="nocodegen"><td>4516<td>  begin
<tr class="covered"><td>4517<td>    Dec(DataSize);
<tr class="covered"><td>4518<td>    Ratchet := (Ratchet + FCards[Rotor]) and $FF;
<tr class="covered"><td>4519<td>    Rotor := (Rotor + 1) and $FF;
<tr class="covered"><td>4520<td>    T := FCards[Cipher];
<tr class="covered"><td>4521<td>    FCards[Cipher] := FCards[Ratchet];
<tr class="covered"><td>4522<td>    FCards[Ratchet] := FCards[Plain];
<tr class="covered"><td>4523<td>    FCards[Plain] := FCards[Rotor];
<tr class="covered"><td>4524<td>    FCards[Rotor] := T;
<tr class="covered"><td>4525<td>    Avalanche := (Avalanche + FCards[T]) and $FF;
<tr class="covered"><td>4526<td>    T := (FCards[Plain] + FCards[Cipher] + FCards[Avalanche]) and $FF;
<tr class="covered"><td>4527<td>    Plain := D^; Inc(D);
<tr class="covered"><td>4528<td>    Cipher := Plain xor FCards[FCards[T]] xor FCards[(FCards[Ratchet] + FCards[Rotor]) and $FF];
<tr class="nocodegen"><td>4529<td>  end;
<tr class="nocodegen"><td>4530<td>
<tr class="covered"><td>4531<td>  FCipher    := Cipher;
<tr class="covered"><td>4532<td>  FRatchet   := Ratchet;
<tr class="covered"><td>4533<td>  FRotor     := Rotor;
<tr class="covered"><td>4534<td>  FPlain     := Plain;
<tr class="covered"><td>4535<td>  FAvalanche := Avalanche;
<tr class="covered"><td>4536<td>end;
<tr class="nocodegen"><td>4537<td>{$ENDIF !THash_Sapphire_asm}
<tr class="nocodegen"><td>4538<td>
<tr class="nocodegen"><td>4539<td>function THash_Sapphire.Digest: PByteArray;
<tr class="covered"><td>4540<td>begin
<tr class="covered"><td>4541<td>  Result := @FDigest;
<tr class="covered"><td>4542<td>end;
<tr class="nocodegen"><td>4543<td>
<tr class="nocodegen"><td>4544<td>function THash_Sapphire.DigestAsBytes: TBytes;
<tr class="nocodegen"><td>4545<td>var
<tr class="nocodegen"><td>4546<td>  Size: Integer;
<tr class="covered"><td>4547<td>begin
<tr class="covered"><td>4548<td>  if FDigestSize &gt; 0 then
<tr class="covered"><td>4549<td>    Size := FDigestSize
<tr class="nocodegen"><td>4550<td>  else
<tr class="notcovered"><td>4551<td>    Size := DigestSize;
<tr class="nocodegen"><td>4552<td>
<tr class="covered"><td>4553<td>  SetLength(Result, Size);
<tr class="covered"><td>4554<td>  if Size &lt;&gt; 0 then
<tr class="covered"><td>4555<td>    Move(FDigest, Result[0], Size);
<tr class="covered"><td>4556<td>end;
<tr class="nocodegen"><td>4557<td>
<tr class="nocodegen"><td>4558<td>class function THash_Sapphire.DigestSize: UInt32;
<tr class="covered"><td>4559<td>begin
<tr class="covered"><td>4560<td>  Result := 64;
<tr class="covered"><td>4561<td>end;
<tr class="nocodegen"><td>4562<td>
<tr class="nocodegen"><td>4563<td>class function THash_Sapphire.BlockSize: UInt32;
<tr class="covered"><td>4564<td>begin
<tr class="covered"><td>4565<td>  Result := 1;
<tr class="covered"><td>4566<td>end;
<tr class="nocodegen"><td>4567<td>
<tr class="nocodegen"><td>4568<td>{$IFDEF RESTORE_RANGECHECKS}{$R+}{$ENDIF}
<tr class="nocodegen"><td>4569<td>{$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}
<tr class="nocodegen"><td>4570<td>
<tr class="nocodegen"><td>4571<td>{ THash_Keccak_224 }
<tr class="nocodegen"><td>4572<td>
<tr class="nocodegen"><td>4573<td>class function THash_Keccak_224.BlockSize: UInt32;
<tr class="covered"><td>4574<td>begin
<tr class="covered"><td>4575<td>  Result := 144;
<tr class="covered"><td>4576<td>end;
<tr class="nocodegen"><td>4577<td>
<tr class="nocodegen"><td>4578<td>class function THash_Keccak_224.DigestSize: UInt32;
<tr class="covered"><td>4579<td>begin
<tr class="covered"><td>4580<td>  Result := 28;
<tr class="covered"><td>4581<td>end;
<tr class="nocodegen"><td>4582<td>
<tr class="nocodegen"><td>4583<td>procedure THash_Keccak_224.DoInit;
<tr class="covered"><td>4584<td>begin
<tr class="covered"><td>4585<td>  inherited;
<tr class="nocodegen"><td>4586<td>
<tr class="covered"><td>4587<td>  FIsKeccack := true;
<tr class="covered"><td>4588<td>end;
<tr class="nocodegen"><td>4589<td>
<tr class="nocodegen"><td>4590<td>{ THash_Keccak_256 }
<tr class="nocodegen"><td>4591<td>
<tr class="nocodegen"><td>4592<td>class function THash_Keccak_256.BlockSize: UInt32;
<tr class="covered"><td>4593<td>begin
<tr class="covered"><td>4594<td>  Result := 136;
<tr class="covered"><td>4595<td>end;
<tr class="nocodegen"><td>4596<td>
<tr class="nocodegen"><td>4597<td>class function THash_Keccak_256.DigestSize: UInt32;
<tr class="covered"><td>4598<td>begin
<tr class="covered"><td>4599<td>  Result := 32;
<tr class="covered"><td>4600<td>end;
<tr class="nocodegen"><td>4601<td>
<tr class="nocodegen"><td>4602<td>procedure THash_Keccak_256.DoInit;
<tr class="covered"><td>4603<td>begin
<tr class="covered"><td>4604<td>  inherited;
<tr class="nocodegen"><td>4605<td>
<tr class="covered"><td>4606<td>  FIsKeccack := true;
<tr class="covered"><td>4607<td>end;
<tr class="nocodegen"><td>4608<td>
<tr class="nocodegen"><td>4609<td>{ THash_Keccak_384 }
<tr class="nocodegen"><td>4610<td>
<tr class="nocodegen"><td>4611<td>class function THash_Keccak_384.BlockSize: UInt32;
<tr class="covered"><td>4612<td>begin
<tr class="covered"><td>4613<td>  Result := 104;
<tr class="covered"><td>4614<td>end;
<tr class="nocodegen"><td>4615<td>
<tr class="nocodegen"><td>4616<td>class function THash_Keccak_384.DigestSize: UInt32;
<tr class="covered"><td>4617<td>begin
<tr class="covered"><td>4618<td>  Result := 48;
<tr class="covered"><td>4619<td>end;
<tr class="nocodegen"><td>4620<td>
<tr class="nocodegen"><td>4621<td>procedure THash_Keccak_384.DoInit;
<tr class="covered"><td>4622<td>begin
<tr class="covered"><td>4623<td>  inherited;
<tr class="nocodegen"><td>4624<td>
<tr class="covered"><td>4625<td>  FIsKeccack := true;
<tr class="covered"><td>4626<td>end;
<tr class="nocodegen"><td>4627<td>
<tr class="nocodegen"><td>4628<td>{ THash_Keccak_512 }
<tr class="nocodegen"><td>4629<td>
<tr class="nocodegen"><td>4630<td>class function THash_Keccak_512.BlockSize: UInt32;
<tr class="covered"><td>4631<td>begin
<tr class="covered"><td>4632<td>  Result := 72;
<tr class="covered"><td>4633<td>end;
<tr class="nocodegen"><td>4634<td>
<tr class="nocodegen"><td>4635<td>class function THash_Keccak_512.DigestSize: UInt32;
<tr class="covered"><td>4636<td>begin
<tr class="covered"><td>4637<td>  Result := 64;
<tr class="covered"><td>4638<td>end;
<tr class="nocodegen"><td>4639<td>
<tr class="nocodegen"><td>4640<td>procedure THash_Keccak_512.DoInit;
<tr class="covered"><td>4641<td>begin
<tr class="covered"><td>4642<td>  inherited;
<tr class="nocodegen"><td>4643<td>
<tr class="covered"><td>4644<td>  FIsKeccack := true;
<tr class="covered"><td>4645<td>end;
<tr class="nocodegen"><td>4646<td>
<tr class="nocodegen"><td>4647<td>{ THash_SHA3_224 }
<tr class="nocodegen"><td>4648<td>
<tr class="nocodegen"><td>4649<td>class function THash_SHA3_224.BlockSize: UInt32;
<tr class="covered"><td>4650<td>begin
<tr class="covered"><td>4651<td>  Result := 144;
<tr class="covered"><td>4652<td>end;
<tr class="nocodegen"><td>4653<td>
<tr class="nocodegen"><td>4654<td>class function THash_SHA3_224.DigestSize: UInt32;
<tr class="covered"><td>4655<td>begin
<tr class="covered"><td>4656<td>  Result := 28;
<tr class="covered"><td>4657<td>end;
<tr class="nocodegen"><td>4658<td>
<tr class="nocodegen"><td>4659<td>procedure THash_SHA3_224.DoInit;
<tr class="covered"><td>4660<td>begin
<tr class="covered"><td>4661<td>  inherited;
<tr class="nocodegen"><td>4662<td>
<tr class="covered"><td>4663<td>  InitSponge(1152,  448);
<tr class="covered"><td>4664<td>  FSpongeState.FixedOutputLength := 224;
<tr class="covered"><td>4665<td>end;
<tr class="nocodegen"><td>4666<td>
<tr class="nocodegen"><td>4667<td>{ THash_SHA3_256 }
<tr class="nocodegen"><td>4668<td>
<tr class="nocodegen"><td>4669<td>class function THash_SHA3_256.BlockSize: UInt32;
<tr class="covered"><td>4670<td>begin
<tr class="covered"><td>4671<td>  Result := 136;
<tr class="covered"><td>4672<td>end;
<tr class="nocodegen"><td>4673<td>
<tr class="nocodegen"><td>4674<td>class function THash_SHA3_256.DigestSize: UInt32;
<tr class="covered"><td>4675<td>begin
<tr class="covered"><td>4676<td>  Result := 32;
<tr class="covered"><td>4677<td>end;
<tr class="nocodegen"><td>4678<td>
<tr class="nocodegen"><td>4679<td>procedure THash_SHA3_256.DoInit;
<tr class="covered"><td>4680<td>begin
<tr class="covered"><td>4681<td>  inherited;
<tr class="nocodegen"><td>4682<td>
<tr class="covered"><td>4683<td>  InitSponge(1088,  512);
<tr class="covered"><td>4684<td>  FSpongeState.fixedOutputLength := 256;
<tr class="covered"><td>4685<td>end;
<tr class="nocodegen"><td>4686<td>
<tr class="nocodegen"><td>4687<td>{ THash_SHA3_384 }
<tr class="nocodegen"><td>4688<td>
<tr class="nocodegen"><td>4689<td>class function THash_SHA3_384.BlockSize: UInt32;
<tr class="covered"><td>4690<td>begin
<tr class="covered"><td>4691<td>  Result := 104;
<tr class="covered"><td>4692<td>end;
<tr class="nocodegen"><td>4693<td>
<tr class="nocodegen"><td>4694<td>class function THash_SHA3_384.DigestSize: UInt32;
<tr class="covered"><td>4695<td>begin
<tr class="covered"><td>4696<td>  Result := 48;
<tr class="covered"><td>4697<td>end;
<tr class="nocodegen"><td>4698<td>
<tr class="nocodegen"><td>4699<td>procedure THash_SHA3_384.DoInit;
<tr class="covered"><td>4700<td>begin
<tr class="covered"><td>4701<td>  inherited;
<tr class="nocodegen"><td>4702<td>
<tr class="covered"><td>4703<td>  InitSponge(832,  768);
<tr class="covered"><td>4704<td>  FSpongeState.fixedOutputLength := 384;
<tr class="covered"><td>4705<td>end;
<tr class="nocodegen"><td>4706<td>
<tr class="nocodegen"><td>4707<td>{ THash_SHA3_512 }
<tr class="nocodegen"><td>4708<td>
<tr class="nocodegen"><td>4709<td>class function THash_SHA3_512.BlockSize: UInt32;
<tr class="covered"><td>4710<td>begin
<tr class="covered"><td>4711<td>  Result := 72;
<tr class="covered"><td>4712<td>end;
<tr class="nocodegen"><td>4713<td>
<tr class="nocodegen"><td>4714<td>class function THash_SHA3_512.DigestSize: UInt32;
<tr class="covered"><td>4715<td>begin
<tr class="covered"><td>4716<td>  Result := 64;
<tr class="covered"><td>4717<td>end;
<tr class="nocodegen"><td>4718<td>
<tr class="nocodegen"><td>4719<td>procedure THash_SHA3_512.DoInit;
<tr class="covered"><td>4720<td>begin
<tr class="covered"><td>4721<td>  inherited;
<tr class="nocodegen"><td>4722<td>
<tr class="covered"><td>4723<td>  InitSponge(576, 1024);
<tr class="covered"><td>4724<td>  FSpongeState.fixedOutputLength := 512;
<tr class="covered"><td>4725<td>end;
<tr class="nocodegen"><td>4726<td>
<tr class="nocodegen"><td>4727<td>{ THash_Shake128 }
<tr class="nocodegen"><td>4728<td>
<tr class="nocodegen"><td>4729<td>class function THash_Shake128.BlockSize: UInt32;
<tr class="covered"><td>4730<td>begin
<tr class="covered"><td>4731<td>  Result := 168;
<tr class="covered"><td>4732<td>end;
<tr class="nocodegen"><td>4733<td>
<tr class="nocodegen"><td>4734<td>class function THash_Shake128.DigestSize: UInt32;
<tr class="covered"><td>4735<td>begin
<tr class="nocodegen"><td>4736<td>  // 0 because the hash output length is defined via HashSize property at runtime
<tr class="covered"><td>4737<td>  Result := 0;
<tr class="covered"><td>4738<td>end;
<tr class="nocodegen"><td>4739<td>
<tr class="nocodegen"><td>4740<td>procedure THash_Shake128.DoInit;
<tr class="covered"><td>4741<td>begin
<tr class="covered"><td>4742<td>  inherited;
<tr class="nocodegen"><td>4743<td>
<tr class="covered"><td>4744<td>  InitSponge(1344, 256);
<tr class="covered"><td>4745<td>end;
<tr class="nocodegen"><td>4746<td>
<tr class="nocodegen"><td>4747<td>{ THash_Shake256 }
<tr class="nocodegen"><td>4748<td>
<tr class="nocodegen"><td>4749<td>class function THash_Shake256.BlockSize: UInt32;
<tr class="covered"><td>4750<td>begin
<tr class="covered"><td>4751<td>  Result := 136;
<tr class="covered"><td>4752<td>end;
<tr class="nocodegen"><td>4753<td>
<tr class="nocodegen"><td>4754<td>class function THash_Shake256.DigestSize: UInt32;
<tr class="covered"><td>4755<td>begin
<tr class="nocodegen"><td>4756<td>  // 0 because the hash output length is defined via HashSize property at runtime
<tr class="covered"><td>4757<td>  Result := 0;
<tr class="covered"><td>4758<td>end;
<tr class="nocodegen"><td>4759<td>
<tr class="nocodegen"><td>4760<td>procedure THash_Shake256.DoInit;
<tr class="covered"><td>4761<td>begin
<tr class="covered"><td>4762<td>  inherited;
<tr class="nocodegen"><td>4763<td>
<tr class="covered"><td>4764<td>  InitSponge(1088, 512);
<tr class="covered"><td>4765<td>end;
<tr class="nocodegen"><td>4766<td>
<tr class="nocodegen"><td>4767<td>{ THash_SHA3Base }
<tr class="nocodegen"><td>4768<td>
<tr class="nocodegen"><td>4769<td>procedure THash_SHA3Base.InitSponge(Rate, Capacity: UInt16);
<tr class="nocodegen"><td>4770<td>var
<tr class="nocodegen"><td>4771<td>  OutputLengthBackup : UInt16;
<tr class="covered"><td>4772<td>begin
<tr class="covered"><td>4773<td>  if FOutpLengSet then
<tr class="covered"><td>4774<td>    OutputLengthBackup := FSpongeState.FixedOutputLength
<tr class="nocodegen"><td>4775<td>  else
<tr class="nocodegen"><td>4776<td>    // Suppress compiler warning about potentially uninitialized variable
<tr class="covered"><td>4777<td>    OutputLengthBackup := 0;
<tr class="nocodegen"><td>4778<td>
<tr class="covered"><td>4779<td>  FillChar(FSpongeState, SizeOf(FSpongeState), 0);
<tr class="nocodegen"><td>4780<td>
<tr class="covered"><td>4781<td>  if (Rate + Capacity &lt;&gt; 1600) or (Rate = 0) or (Rate &gt;= 1600) or
<tr class="nocodegen"><td>4782<td>     ((Rate and 63) &lt;&gt; 0) then
<tr class="notcovered"><td>4783<td>    raise EDECHashException.CreateFmt(sHashInitFailure, ['SHA3',
<tr class="nocodegen"><td>4784<td>                                                         'rate: ' + IntToStr(Rate) +
<tr class="nocodegen"><td>4785<td>                                                         ' capacity: ' + IntToStr(Capacity)]);
<tr class="nocodegen"><td>4786<td>
<tr class="covered"><td>4787<td>  FSpongeState.Rate     := Rate;
<tr class="covered"><td>4788<td>  FSpongeState.Capacity := Capacity;
<tr class="nocodegen"><td>4789<td>
<tr class="covered"><td>4790<td>  if FOutpLengSet then
<tr class="covered"><td>4791<td>    FSpongeState.FixedOutputLength := OutputLengthBackup;
<tr class="covered"><td>4792<td>end;
<tr class="nocodegen"><td>4793<td>
<tr class="nocodegen"><td>4794<td>procedure THash_SHA3Base.KeccakAbsorb(var state: TState_B; data: PUInt64; laneCount: Integer);
<tr class="covered"><td>4795<td>begin
<tr class="covered"><td>4796<td>   XORIntoState(TState_L(state), data, laneCount);
<tr class="covered"><td>4797<td>   KeccakPermutation(TState_L(state));
<tr class="covered"><td>4798<td>end;
<tr class="nocodegen"><td>4799<td>
<tr class="nocodegen"><td>4800<td>{$IFDEF PUREPASCAL}
<tr class="nocodegen"><td>4801<td>function THash_SHA3Base.RotL(const x: UInt64; c: Integer): UInt64;
<tr class="nocodegen"><td>4802<td>begin
<tr class="nocodegen"><td>4803<td>  Result := (x shl c) or (x shr (64-c));
<tr class="nocodegen"><td>4804<td>end;
<tr class="nocodegen"><td>4805<td>
<tr class="nocodegen"><td>4806<td>function THash_SHA3Base.RotL1(var x: UInt64): UInt64;
<tr class="nocodegen"><td>4807<td>begin
<tr class="nocodegen"><td>4808<td>  Result := (x shl 1) or (x shr (64-1));
<tr class="nocodegen"><td>4809<td>end;
<tr class="nocodegen"><td>4810<td>
<tr class="nocodegen"><td>4811<td>procedure THash_SHA3Base.KeccakPermutation(var state: TState_L);
<tr class="nocodegen"><td>4812<td>var
<tr class="nocodegen"><td>4813<td>   A : PUInt64Array;
<tr class="nocodegen"><td>4814<td>   B : array[0..24] of UInt64;
<tr class="nocodegen"><td>4815<td>   C0, C1, C2, C3, C4, D0, D1, D2, D3, D4: UInt64;
<tr class="nocodegen"><td>4816<td>   i : Integer;
<tr class="nocodegen"><td>4817<td>
<tr class="covered"><td>4818<td>begin
<tr class="covered"><td>4819<td>   A := PUInt64Array(@state);
<tr class="covered"><td>4820<td>   for i := 0 to 23 do
<tr class="nocodegen"><td>4821<td>   begin
<tr class="covered"><td>4822<td>      C0 := A[00] xor A[05] xor A[10] xor A[15] xor A[20];
<tr class="covered"><td>4823<td>      C1 := A[01] xor A[06] xor A[11] xor A[16] xor A[21];
<tr class="covered"><td>4824<td>      C2 := A[02] xor A[07] xor A[12] xor A[17] xor A[22];
<tr class="covered"><td>4825<td>      C3 := A[03] xor A[08] xor A[13] xor A[18] xor A[23];
<tr class="covered"><td>4826<td>      C4 := A[04] xor A[09] xor A[14] xor A[19] xor A[24];
<tr class="nocodegen"><td>4827<td>
<tr class="covered"><td>4828<td>      D0 := RotL1(C0) xor C3;
<tr class="covered"><td>4829<td>      D1 := RotL1(C1) xor C4;
<tr class="covered"><td>4830<td>      D2 := RotL1(C2) xor C0;
<tr class="covered"><td>4831<td>      D3 := RotL1(C3) xor C1;
<tr class="covered"><td>4832<td>      D4 := RotL1(C4) xor C2;
<tr class="nocodegen"><td>4833<td>
<tr class="covered"><td>4834<td>      B[00] := A[00] xor D1;
<tr class="covered"><td>4835<td>      B[01] := RotL(A[06] xor D2, 44);
<tr class="covered"><td>4836<td>      B[02] := RotL(A[12] xor D3, 43);
<tr class="covered"><td>4837<td>      B[03] := RotL(A[18] xor D4, 21);
<tr class="covered"><td>4838<td>      B[04] := RotL(A[24] xor D0, 14);
<tr class="covered"><td>4839<td>      B[05] := RotL(A[03] xor D4, 28);
<tr class="covered"><td>4840<td>      B[06] := RotL(A[09] xor D0, 20);
<tr class="covered"><td>4841<td>      B[07] := RotL(A[10] xor D1, 3);
<tr class="covered"><td>4842<td>      B[08] := RotL(A[16] xor D2, 45);
<tr class="covered"><td>4843<td>      B[09] := RotL(A[22] xor D3, 61);
<tr class="covered"><td>4844<td>      B[10] := RotL(A[01] xor D2, 1);
<tr class="covered"><td>4845<td>      B[11] := RotL(A[07] xor D3, 6);
<tr class="covered"><td>4846<td>      B[12] := RotL(A[13] xor D4, 25);
<tr class="covered"><td>4847<td>      B[13] := RotL(A[19] xor D0, 8);
<tr class="covered"><td>4848<td>      B[14] := RotL(A[20] xor D1, 18);
<tr class="covered"><td>4849<td>      B[15] := RotL(A[04] xor D0, 27);
<tr class="covered"><td>4850<td>      B[16] := RotL(A[05] xor D1, 36);
<tr class="covered"><td>4851<td>      B[17] := RotL(A[11] xor D2, 10);
<tr class="covered"><td>4852<td>      B[18] := RotL(A[17] xor D3, 15);
<tr class="covered"><td>4853<td>      B[19] := RotL(A[23] xor D4, 56);
<tr class="covered"><td>4854<td>      B[20] := RotL(A[02] xor D3, 62);
<tr class="covered"><td>4855<td>      B[21] := RotL(A[08] xor D4, 55);
<tr class="covered"><td>4856<td>      B[22] := RotL(A[14] xor D0, 39);
<tr class="covered"><td>4857<td>      B[23] := RotL(A[15] xor D1, 41);
<tr class="covered"><td>4858<td>      B[24] := RotL(A[21] xor D2, 2);
<tr class="nocodegen"><td>4859<td>
<tr class="covered"><td>4860<td>      A[00] := B[00] xor ((not B[01]) and B[02]);
<tr class="covered"><td>4861<td>      A[01] := B[01] xor ((not B[02]) and B[03]);
<tr class="covered"><td>4862<td>      A[02] := B[02] xor ((not B[03]) and B[04]);
<tr class="covered"><td>4863<td>      A[03] := B[03] xor ((not B[04]) and B[00]);
<tr class="covered"><td>4864<td>      A[04] := B[04] xor ((not B[00]) and B[01]);
<tr class="covered"><td>4865<td>      A[05] := B[05] xor ((not B[06]) and B[07]);
<tr class="covered"><td>4866<td>      A[06] := B[06] xor ((not B[07]) and B[08]);
<tr class="covered"><td>4867<td>      A[07] := B[07] xor ((not B[08]) and B[09]);
<tr class="covered"><td>4868<td>      A[08] := B[08] xor ((not B[09]) and B[05]);
<tr class="covered"><td>4869<td>      A[09] := B[09] xor ((not B[05]) and B[06]);
<tr class="covered"><td>4870<td>      A[10] := B[10] xor ((not B[11]) and B[12]);
<tr class="covered"><td>4871<td>      A[11] := B[11] xor ((not B[12]) and B[13]);
<tr class="covered"><td>4872<td>      A[12] := B[12] xor ((not B[13]) and B[14]);
<tr class="covered"><td>4873<td>      A[13] := B[13] xor ((not B[14]) and B[10]);
<tr class="covered"><td>4874<td>      A[14] := B[14] xor ((not B[10]) and B[11]);
<tr class="covered"><td>4875<td>      A[15] := B[15] xor ((not B[16]) and B[17]);
<tr class="covered"><td>4876<td>      A[16] := B[16] xor ((not B[17]) and B[18]);
<tr class="covered"><td>4877<td>      A[17] := B[17] xor ((not B[18]) and B[19]);
<tr class="covered"><td>4878<td>      A[18] := B[18] xor ((not B[19]) and B[15]);
<tr class="covered"><td>4879<td>      A[19] := B[19] xor ((not B[15]) and B[16]);
<tr class="covered"><td>4880<td>      A[20] := B[20] xor ((not B[21]) and B[22]);
<tr class="covered"><td>4881<td>      A[21] := B[21] xor ((not B[22]) and B[23]);
<tr class="covered"><td>4882<td>      A[22] := B[22] xor ((not B[23]) and B[24]);
<tr class="covered"><td>4883<td>      A[23] := B[23] xor ((not B[24]) and B[20]);
<tr class="covered"><td>4884<td>      A[24] := B[24] xor ((not B[20]) and B[21]);
<tr class="nocodegen"><td>4885<td>
<tr class="covered"><td>4886<td>      A[00] := A[00] xor cRoundConstants[i];
<tr class="covered"><td>4887<td>   end;
<tr class="covered"><td>4888<td>end;
<tr class="nocodegen"><td>4889<td>{$ELSE}
<tr class="nocodegen"><td>4890<td>// Must be procedural as otherwise the parameters get passed in different
<tr class="nocodegen"><td>4891<td>// CPU registers and the complete ASM code would have needed to be rewritten.
<tr class="nocodegen"><td>4892<td>procedure KeccakPermutationKernel(B, A, C : Pointer);
<tr class="nocodegen"><td>4893<td>asm
<tr class="nocodegen"><td>4894<td>  {$IFDEF X86ASM}
<tr class="nocodegen"><td>4895<td>    {$INCLUDE DECHash.sha3_mmx.inc}
<tr class="nocodegen"><td>4896<td>  {$ELSE}
<tr class="nocodegen"><td>4897<td>    {$INCLUDE DECHash.sha3_x64.inc}
<tr class="nocodegen"><td>4898<td>  {$ENDIF}
<tr class="nocodegen"><td>4899<td>end;
<tr class="nocodegen"><td>4900<td>
<tr class="nocodegen"><td>4901<td>procedure THash_SHA3Base.KeccakPermutation(var state: TState_L);
<tr class="nocodegen"><td>4902<td>var
<tr class="nocodegen"><td>4903<td>   A : PUInt64Array;
<tr class="nocodegen"><td>4904<td>   B : array [0..24] of UInt64;
<tr class="nocodegen"><td>4905<td>   C : array [0..4] of UInt64;
<tr class="nocodegen"><td>4906<td>   i : Integer;
<tr class="nocodegen"><td>4907<td>
<tr class="nocodegen"><td>4908<td>  {$IFDEF X86ASM}
<tr class="nocodegen"><td>4909<td>  procedure EMMS;
<tr class="nocodegen"><td>4910<td>  asm
<tr class="nocodegen"><td>4911<td>    // This operation marks the x87 FPU data registers (which are aliased to the
<tr class="nocodegen"><td>4912<td>    // MMX technology registers) as available for use by x87 FPU floating-point
<tr class="nocodegen"><td>4913<td>    // instructions.
<tr class="nocodegen"><td>4914<td>    emms
<tr class="nocodegen"><td>4915<td>  end;
<tr class="nocodegen"><td>4916<td>  {$ENDIF}
<tr class="nocodegen"><td>4917<td>
<tr class="nocodegen"><td>4918<td>begin
<tr class="nocodegen"><td>4919<td>   A := PUInt64Array(@state);
<tr class="nocodegen"><td>4920<td>   for i:=0 to 23 do
<tr class="nocodegen"><td>4921<td>   begin
<tr class="nocodegen"><td>4922<td>     KeccakPermutationKernel(@B, A, @C);
<tr class="nocodegen"><td>4923<td>     A[00] := A[00] xor cRoundConstants[i];
<tr class="nocodegen"><td>4924<td>   end;
<tr class="nocodegen"><td>4925<td>
<tr class="nocodegen"><td>4926<td>   {$IFDEF X86ASM}
<tr class="nocodegen"><td>4927<td>   EMMS;
<tr class="nocodegen"><td>4928<td>   {$ENDIF}
<tr class="nocodegen"><td>4929<td>end;
<tr class="nocodegen"><td>4930<td>{$ENDIF}
<tr class="nocodegen"><td>4931<td>
<tr class="nocodegen"><td>4932<td>procedure THash_SHA3Base.PadAndSwitchToSqueezingPhase;
<tr class="nocodegen"><td>4933<td>var
<tr class="nocodegen"><td>4934<td>  i: integer;
<tr class="covered"><td>4935<td>begin
<tr class="nocodegen"><td>4936<td>  // Note: the bits are numbered from 0 = LSB to 7 = MSB
<tr class="covered"><td>4937<td>  if (FSpongeState.BitsInQueue + 1 = FSpongeState.Rate) then
<tr class="nocodegen"><td>4938<td>  begin
<tr class="covered"><td>4939<td>    i := FSpongeState.BitsInQueue div 8;
<tr class="covered"><td>4940<td>    FSpongeState.DataQueue[i] := FSpongeState.DataQueue[i] or
<tr class="nocodegen"><td>4941<td>                                 (1 shl (FSpongeState.BitsInQueue and 7));
<tr class="covered"><td>4942<td>    AbsorbQueue;
<tr class="covered"><td>4943<td>    FillChar(FSpongeState.DataQueue, FSpongeState.Rate div 8, 0);
<tr class="nocodegen"><td>4944<td>  end
<tr class="nocodegen"><td>4945<td>  else
<tr class="nocodegen"><td>4946<td>  begin
<tr class="covered"><td>4947<td>    i := FSpongeState.BitsInQueue div 8;
<tr class="covered"><td>4948<td>    FillChar(FSpongeState.DataQueue[(FSpongeState.BitsInQueue+7) div 8],
<tr class="nocodegen"><td>4949<td>             FSpongeState.Rate div 8 - (FSpongeState.BitsInQueue+7) div 8, 0);
<tr class="covered"><td>4950<td>    FSpongeState.DataQueue[i] := FSpongeState.DataQueue[i] or
<tr class="nocodegen"><td>4951<td>                                 (1 shl (FSpongeState.BitsInQueue and 7));
<tr class="nocodegen"><td>4952<td>  end;
<tr class="nocodegen"><td>4953<td>
<tr class="covered"><td>4954<td>  i := (FSpongeState.Rate-1) div 8;
<tr class="covered"><td>4955<td>  FSpongeState.DataQueue[i] := FSpongeState.DataQueue[i] or
<tr class="nocodegen"><td>4956<td>                               (1 shl ((FSpongeState.Rate-1) and 7));
<tr class="covered"><td>4957<td>  AbsorbQueue;
<tr class="covered"><td>4958<td>  ExtractFromState(@FSpongeState.DataQueue,
<tr class="nocodegen"><td>4959<td>                   TState_L(FSpongeState.State),
<tr class="nocodegen"><td>4960<td>                   FSpongeState.Rate div 64);
<tr class="covered"><td>4961<td>  FSpongeState.bitsAvailableForSqueezing := FSpongeState.Rate;
<tr class="covered"><td>4962<td>  FSpongeState.SqueezeActive := true;
<tr class="covered"><td>4963<td>end;
<tr class="nocodegen"><td>4964<td>
<tr class="nocodegen"><td>4965<td>procedure THash_SHA3Base.Squeeze(var Output: TSHA3Digest; OutputLength: Int32);
<tr class="nocodegen"><td>4966<td>var
<tr class="nocodegen"><td>4967<td>  i            : Int32;
<tr class="nocodegen"><td>4968<td>  PartialBlock : Int16;
<tr class="covered"><td>4969<td>begin
<tr class="covered"><td>4970<td>  if not FSpongeState.SqueezeActive then
<tr class="covered"><td>4971<td>    PadAndSwitchToSqueezingPhase;
<tr class="nocodegen"><td>4972<td>
<tr class="nocodegen"><td>4973<td>  // Only multiple of 8 bits are allowed, truncation must be done at user level
<tr class="covered"><td>4974<td>  if OutputLength and 7 &lt;&gt; 0 then
<tr class="notcovered"><td>4975<td>    raise EDECHashException.CreateFmt(sSHA3AbsorbFailure,
<tr class="nocodegen"><td>4976<td>                                 [OutputLength, 'true']);
<tr class="nocodegen"><td>4977<td>
<tr class="covered"><td>4978<td>  i := 0;
<tr class="covered"><td>4979<td>  while i &lt; OutputLength do
<tr class="nocodegen"><td>4980<td>  begin
<tr class="covered"><td>4981<td>    if FSpongeState.bitsAvailableForSqueezing = 0 then
<tr class="nocodegen"><td>4982<td>    begin
<tr class="covered"><td>4983<td>      KeccakPermutation(TState_L(FSpongeState.State));
<tr class="covered"><td>4984<td>      ExtractFromState(@FSpongeState.DataQueue, TState_L(FSpongeState.State),
<tr class="nocodegen"><td>4985<td>                       FSpongeState.Rate div 64);
<tr class="covered"><td>4986<td>      FSpongeState.bitsAvailableForSqueezing := FSpongeState.Rate;
<tr class="nocodegen"><td>4987<td>    end;
<tr class="nocodegen"><td>4988<td>
<tr class="covered"><td>4989<td>    PartialBlock := FSpongeState.bitsAvailableForSqueezing;
<tr class="covered"><td>4990<td>    if PartialBlock &gt; OutputLength - i then
<tr class="covered"><td>4991<td>      PartialBlock := OutputLength - i;
<tr class="nocodegen"><td>4992<td>
<tr class="covered"><td>4993<td>    move(FSpongeState.DataQueue[(FSpongeState.Rate - FSpongeState.bitsAvailableForSqueezing) div 8],
<tr class="nocodegen"><td>4994<td>         output[i div 8], PartialBlock div 8);
<tr class="covered"><td>4995<td>    dec(FSpongeState.bitsAvailableForSqueezing, PartialBlock);
<tr class="covered"><td>4996<td>    inc(i, PartialBlock);
<tr class="nocodegen"><td>4997<td>  end;
<tr class="covered"><td>4998<td>end;
<tr class="nocodegen"><td>4999<td>
<tr class="nocodegen"><td>5000<td>procedure THash_SHA3Base.XORIntoState(var state: TState_L; pI: PUInt64; laneCount: Integer);
<tr class="nocodegen"><td>5001<td>var
<tr class="nocodegen"><td>5002<td>   pS: PUInt64;
<tr class="nocodegen"><td>5003<td>   i: Integer;
<tr class="covered"><td>5004<td>begin
<tr class="covered"><td>5005<td>   pS := @state[0];
<tr class="covered"><td>5006<td>   for i:=laneCount-1 downto 0 do begin
<tr class="covered"><td>5007<td>      pS^ := pS^ xor pI^;
<tr class="covered"><td>5008<td>      Inc(pI);
<tr class="covered"><td>5009<td>      Inc(pS);
<tr class="covered"><td>5010<td>   end;
<tr class="covered"><td>5011<td>end;
<tr class="nocodegen"><td>5012<td>
<tr class="nocodegen"><td>5013<td>
<tr class="nocodegen"><td>5014<td>procedure THash_SHA3Base.Absorb(Data: PBABytes; DatabitLen: Int32);
<tr class="nocodegen"><td>5015<td>var
<tr class="nocodegen"><td>5016<td>  i, j, wholeBlocks, partialBlock: Integer;
<tr class="nocodegen"><td>5017<td>  partialByte: Integer;
<tr class="nocodegen"><td>5018<td>  curData: PUInt64;
<tr class="covered"><td>5019<td>begin
<tr class="nocodegen"><td>5020<td>  // if a number of bits which cannot be divided by 8 without reminder is in the
<tr class="nocodegen"><td>5021<td>  // queue or algorithm is already in squeezing state
<tr class="covered"><td>5022<td>  if (FSpongeState.BitsInQueue and 7 &lt;&gt; 0) or FSpongeState.SqueezeActive then
<tr class="nocodegen"><td>5023<td>  begin
<tr class="notcovered"><td>5024<td>    raise EDECHashException.CreateFmt(sSHA3AbsorbFailure,
<tr class="nocodegen"><td>5025<td>                                     [FSpongeState.BitsInQueue,
<tr class="nocodegen"><td>5026<td>                                      BoolToStr(FSpongeState.SqueezeActive, true)]);
<tr class="nocodegen"><td>5027<td>  end;
<tr class="nocodegen"><td>5028<td>
<tr class="covered"><td>5029<td>  i := 0;
<tr class="nocodegen"><td>5030<td>
<tr class="covered"><td>5031<td>  while i &lt; databitlen do
<tr class="nocodegen"><td>5032<td>  begin
<tr class="covered"><td>5033<td>     if ((FSpongeState.BitsInQueue = 0) and (databitlen &gt;= FSpongeState.Rate) and
<tr class="nocodegen"><td>5034<td>        (i &lt;= (databitlen - FSpongeState.Rate))) then
<tr class="nocodegen"><td>5035<td>     begin
<tr class="covered"><td>5036<td>       wholeBlocks := (databitlen-i) div FSpongeState.Rate;
<tr class="covered"><td>5037<td>       curData := @data^[i div 8];
<tr class="covered"><td>5038<td>       j := 0;
<tr class="covered"><td>5039<td>       while j &lt; wholeBlocks do
<tr class="nocodegen"><td>5040<td>       begin
<tr class="covered"><td>5041<td>         KeccakAbsorb(FSpongeState.State, curData, FSpongeState.Rate div 64);
<tr class="covered"><td>5042<td>         Inc(j);
<tr class="covered"><td>5043<td>         Inc(PByte(curData), FSpongeState.Rate div 8);
<tr class="nocodegen"><td>5044<td>       end;
<tr class="covered"><td>5045<td>       Inc(i, wholeBlocks * FSpongeState.Rate);
<tr class="nocodegen"><td>5046<td>     end
<tr class="nocodegen"><td>5047<td>     else
<tr class="nocodegen"><td>5048<td>     begin
<tr class="covered"><td>5049<td>       partialBlock := databitlen - i;
<tr class="covered"><td>5050<td>       if partialBlock + FSpongeState.BitsInQueue &gt; FSpongeState.Rate then
<tr class="covered"><td>5051<td>         partialBlock := FSpongeState.Rate - FSpongeState.BitsInQueue;
<tr class="nocodegen"><td>5052<td>
<tr class="covered"><td>5053<td>       partialByte := partialBlock and 7;
<tr class="covered"><td>5054<td>       Dec(partialBlock, partialByte);
<tr class="covered"><td>5055<td>       Move(data^[i div 8], FSpongeState.DataQueue[FSpongeState.BitsInQueue div 8], partialBlock div 8);
<tr class="covered"><td>5056<td>       Inc(FSpongeState.BitsInQueue, partialBlock);
<tr class="covered"><td>5057<td>       Inc(i, partialBlock);
<tr class="covered"><td>5058<td>       if FSpongeState.BitsInQueue=FSpongeState.Rate then
<tr class="covered"><td>5059<td>          AbsorbQueue;
<tr class="nocodegen"><td>5060<td>
<tr class="covered"><td>5061<td>       if partialByte &gt; 0 then
<tr class="nocodegen"><td>5062<td>       begin
<tr class="nocodegen"><td>5063<td>         FSpongeState.DataQueue[FSpongeState.BitsInQueue div 8] :=
<tr class="covered"><td>5064<td>           data^[i div 8] and ((1 shl partialByte)-1);
<tr class="nocodegen"><td>5065<td>
<tr class="covered"><td>5066<td>         Inc(FSpongeState.BitsInQueue, partialByte);
<tr class="covered"><td>5067<td>         Inc(i, partialByte);
<tr class="nocodegen"><td>5068<td>       end;
<tr class="nocodegen"><td>5069<td>     end;
<tr class="nocodegen"><td>5070<td>  end;
<tr class="covered"><td>5071<td>end;
<tr class="nocodegen"><td>5072<td>
<tr class="nocodegen"><td>5073<td>procedure THash_SHA3Base.AbsorbQueue;
<tr class="covered"><td>5074<td>begin
<tr class="nocodegen"><td>5075<td>  // state.bitsInQueue is assumed to be equal to state.rat
<tr class="covered"><td>5076<td>  KeccakAbsorb(FSpongeState.State, @FSpongeState.DataQueue, FSpongeState.Rate div 64);
<tr class="covered"><td>5077<td>  FSpongeState.BitsInQueue := 0;
<tr class="covered"><td>5078<td>end;
<tr class="nocodegen"><td>5079<td>
<tr class="nocodegen"><td>5080<td>procedure THash_SHA3Base.Calc(const Data; DataSize: Integer);
<tr class="nocodegen"><td>5081<td>var
<tr class="nocodegen"><td>5082<td>  DataPtr   : PBABytes;
<tr class="nocodegen"><td>5083<td>  RoundSize : UInt32;
<tr class="nocodegen"><td>5084<td>const
<tr class="nocodegen"><td>5085<td>  // Maximum number of bytes one can process in one round
<tr class="nocodegen"><td>5086<td>  MaxRoundSize = MaxInt div 8;
<tr class="covered"><td>5087<td>begin
<tr class="nocodegen"><td>5088<td>  // due to the way the inherited calc is constructed it must not be called here!
<tr class="covered"><td>5089<td>  if (DataSize &gt; 0) then
<tr class="nocodegen"><td>5090<td>  begin
<tr class="covered"><td>5091<td>    DataPtr := PBABytes(@Data);
<tr class="nocodegen"><td>5092<td>
<tr class="covered"><td>5093<td>    while (UInt32(DataSize) &gt; 0) do
<tr class="nocodegen"><td>5094<td>    begin
<tr class="covered"><td>5095<td>      RoundSize := DataSize;
<tr class="covered"><td>5096<td>      if (RoundSize &gt; MaxRoundSize) then
<tr class="notcovered"><td>5097<td>        RoundSize := MaxRoundSize;
<tr class="nocodegen"><td>5098<td>
<tr class="covered"><td>5099<td>      Absorb(DataPtr, RoundSize * 8);
<tr class="covered"><td>5100<td>      Dec(DataSize, RoundSize);
<tr class="covered"><td>5101<td>      Inc(DataPtr, RoundSize);
<tr class="nocodegen"><td>5102<td>    end;
<tr class="nocodegen"><td>5103<td>
<tr class="nocodegen"><td>5104<td>  end;
<tr class="covered"><td>5105<td>end;
<tr class="nocodegen"><td>5106<td>
<tr class="nocodegen"><td>5107<td>constructor THash_SHA3Base.Create;
<tr class="covered"><td>5108<td>begin
<tr class="covered"><td>5109<td>  inherited;
<tr class="nocodegen"><td>5110<td>
<tr class="covered"><td>5111<td>  FOutpLengSet := false;
<tr class="covered"><td>5112<td>  SetLength(FDigest, 64);
<tr class="covered"><td>5113<td>end;
<tr class="nocodegen"><td>5114<td>
<tr class="nocodegen"><td>5115<td>function THash_SHA3Base.Digest: PByteArray;
<tr class="covered"><td>5116<td>begin
<tr class="covered"><td>5117<td>  Result := @FDigest[0];
<tr class="covered"><td>5118<td>end;
<tr class="nocodegen"><td>5119<td>
<tr class="nocodegen"><td>5120<td>procedure THash_SHA3Base.DoDone;
<tr class="covered"><td>5121<td>begin
<tr class="covered"><td>5122<td>  if not FSpongeState.SqueezeActive then
<tr class="covered"><td>5123<td>    FinalBit_LSB(FPaddingByte, FFinalByteLength, FDigest);
<tr class="covered"><td>5124<td>end;
<tr class="nocodegen"><td>5125<td>
<tr class="nocodegen"><td>5126<td>procedure THash_SHA3Base.DoInit;
<tr class="covered"><td>5127<td>begin
<tr class="nocodegen"><td>5128<td>  inherited;
<tr class="nocodegen"><td>5129<td>
<tr class="covered"><td>5130<td>  FIsKeccack := false;
<tr class="covered"><td>5131<td>  FillChar(FDIgest[0], Length(FDigest), 0);
<tr class="covered"><td>5132<td>end;
<tr class="nocodegen"><td>5133<td>
<tr class="nocodegen"><td>5134<td>procedure THash_SHA3Base.DoUpdate(Data: Pointer; DataBitLen: Int32);
<tr class="nocodegen"><td>5135<td>var
<tr class="nocodegen"><td>5136<td>  LastByte: Byte;
<tr class="covered"><td>5137<td>begin
<tr class="nocodegen"><td>5138<td>  // No partial byte
<tr class="covered"><td>5139<td>  if DataBitLen and 7 = 0 then
<tr class="covered"><td>5140<td>    Absorb(Data, DataBitLen)
<tr class="nocodegen"><td>5141<td>  else
<tr class="nocodegen"><td>5142<td>  begin
<tr class="nocodegen"><td>5143<td>    // Data contains a partial byte. Calculate the whole bytes first then the
<tr class="nocodegen"><td>5144<td>    // partial one.
<tr class="covered"><td>5145<td>    Absorb(Data, DataBitLen - (DataBitLen and 7));
<tr class="nocodegen"><td>5146<td>
<tr class="nocodegen"><td>5147<td>    // Align the last partial byte to the least significant bits
<tr class="covered"><td>5148<td>    LastByte := PBABytes(Data)^[DatabitLen div 8] shr (8 - (DataBitLen and 7));
<tr class="covered"><td>5149<td>    Absorb(@LastByte, DataBitLen and 7);
<tr class="nocodegen"><td>5150<td>  end;
<tr class="covered"><td>5151<td>end;
<tr class="nocodegen"><td>5152<td>
<tr class="nocodegen"><td>5153<td>procedure THash_SHA3Base.ExtractFromState(outp: Pointer; const state: TState_L; laneCount: Integer);
<tr class="nocodegen"><td>5154<td>var
<tr class="nocodegen"><td>5155<td>   pI, pS: PUInt64;
<tr class="nocodegen"><td>5156<td>   i: Integer;
<tr class="covered"><td>5157<td>begin
<tr class="covered"><td>5158<td>   pI := outp;
<tr class="covered"><td>5159<td>   pS := @state[0];
<tr class="covered"><td>5160<td>   for i := laneCount - 1 downto 0 do
<tr class="nocodegen"><td>5161<td>   begin
<tr class="covered"><td>5162<td>     pI^ := pS^;
<tr class="covered"><td>5163<td>     Inc(pI);
<tr class="covered"><td>5164<td>     Inc(pS);
<tr class="covered"><td>5165<td>   end;
<tr class="covered"><td>5166<td>end;
<tr class="nocodegen"><td>5167<td>
<tr class="nocodegen"><td>5168<td>procedure THash_SHA3Base.FinalBit_LSB(Bits: Byte; Bitlen: UInt16;
<tr class="nocodegen"><td>5169<td>                                     var Hashvalue: TSHA3Digest);
<tr class="nocodegen"><td>5170<td>var
<tr class="nocodegen"><td>5171<td>  WorkingBitLen : Int16;
<tr class="nocodegen"><td>5172<td>  lw : UInt16;
<tr class="covered"><td>5173<td>begin
<tr class="nocodegen"><td>5174<td>  // normalize Bitlen and Bits (zero high bits)
<tr class="covered"><td>5175<td>  Bitlen := Bitlen and 7;
<tr class="covered"><td>5176<td>  if Bitlen = 0 then
<tr class="covered"><td>5177<td>    lw := 0
<tr class="nocodegen"><td>5178<td>  else
<tr class="covered"><td>5179<td>    lw := Bits and pred(word(1) shl Bitlen);
<tr class="nocodegen"><td>5180<td>
<tr class="nocodegen"><td>5181<td>  // 'append' (in LSB language) the domain separation bits
<tr class="nocodegen"><td>5182<td>  //if (FSpongeState.FixedOutputLength = 0) then
<tr class="covered"><td>5183<td>  if self.ClassParent = THash_ShakeBase then
<tr class="nocodegen"><td>5184<td>  begin
<tr class="covered"><td>5185<td>    lw := lw or (word($F) shl Bitlen);
<tr class="covered"><td>5186<td>    WorkingBitLen := Bitlen + 4;
<tr class="nocodegen"><td>5187<td>  end
<tr class="nocodegen"><td>5188<td>  else
<tr class="nocodegen"><td>5189<td>  begin
<tr class="covered"><td>5190<td>    if not FIsKeccack then
<tr class="nocodegen"><td>5191<td>    begin
<tr class="nocodegen"><td>5192<td>      // SHA3: append two bits 01
<tr class="covered"><td>5193<td>      lw := lw or (word($2) shl Bitlen);
<tr class="nocodegen"><td>5194<td>
<tr class="covered"><td>5195<td>      WorkingBitLen := Bitlen + 2;
<tr class="nocodegen"><td>5196<td>    end
<tr class="nocodegen"><td>5197<td>    else
<tr class="covered"><td>5198<td>      WorkingBitLen := Bitlen;
<tr class="nocodegen"><td>5199<td>  end;
<tr class="nocodegen"><td>5200<td>
<tr class="nocodegen"><td>5201<td>  // update state with final bits
<tr class="covered"><td>5202<td>  if WorkingBitLen &lt; 9 then
<tr class="nocodegen"><td>5203<td>  begin
<tr class="nocodegen"><td>5204<td>    // 0..8 bits, one call to update
<tr class="covered"><td>5205<td>    lw := lw shl (8-WorkingBitLen);
<tr class="covered"><td>5206<td>    DoUpdate(@lw, WorkingBitLen);
<tr class="nocodegen"><td>5207<td>    // squeeze the digits from the sponge
<tr class="covered"><td>5208<td>    Squeeze(Hashvalue, FSpongeState.FixedOutputLength);
<tr class="nocodegen"><td>5209<td>  end
<tr class="nocodegen"><td>5210<td>  else
<tr class="nocodegen"><td>5211<td>  begin
<tr class="nocodegen"><td>5212<td>    // More than 8 bits, first a regular update with low byte
<tr class="covered"><td>5213<td>    DoUpdate(@lw, 8);
<tr class="nocodegen"><td>5214<td>
<tr class="nocodegen"><td>5215<td>    // Finally update remaining last bits
<tr class="covered"><td>5216<td>    dec(WorkingBitLen,8);
<tr class="covered"><td>5217<td>    lw := lw shr WorkingBitLen;
<tr class="covered"><td>5218<td>    DoUpdate(@lw, WorkingBitLen);
<tr class="nocodegen"><td>5219<td>
<tr class="covered"><td>5220<td>    Squeeze(Hashvalue, FSpongeState.FixedOutputLength);
<tr class="nocodegen"><td>5221<td>  end;
<tr class="covered"><td>5222<td>end;
<tr class="nocodegen"><td>5223<td>
<tr class="nocodegen"><td>5224<td>procedure THash_SHA3Base.DoTransform(Buffer: PUInt32Array);
<tr class="notcovered"><td>5225<td>begin
<tr class="nocodegen"><td>5226<td>// Empty on purpose as calculation is implemented differently for SHA3. Needed
<tr class="nocodegen"><td>5227<td>// to suppress the compiler warning that a class with an abstract method is created
<tr class="notcovered"><td>5228<td>end;
<tr class="nocodegen"><td>5229<td>
<tr class="nocodegen"><td>5230<td>{ THash_ShakeBase }
<tr class="nocodegen"><td>5231<td>
<tr class="nocodegen"><td>5232<td>function THash_ShakeBase.GetHashSize: UInt16;
<tr class="notcovered"><td>5233<td>begin
<tr class="nocodegen"><td>5234<td>  // divided by 8 since this field is in bits
<tr class="notcovered"><td>5235<td>  Result := FSpongeState.FixedOutputLength shr 3;
<tr class="notcovered"><td>5236<td>end;
<tr class="nocodegen"><td>5237<td>
<tr class="nocodegen"><td>5238<td>procedure THash_ShakeBase.SetHashSize(const Value: UInt16);
<tr class="covered"><td>5239<td>begin
<tr class="covered"><td>5240<td>  if (Value = 0) then
<tr class="covered"><td>5241<td>    raise EDECHashException.CreateResFmt(@sHashInitFailure,
<tr class="nocodegen"><td>5242<td>                                         [GetShortClassName, sHashOutputLength0]);
<tr class="nocodegen"><td>5243<td>
<tr class="nocodegen"><td>5244<td>  // multiplied with 8 since this field is in bits
<tr class="covered"><td>5245<td>  FSpongeState.FixedOutputLength := Value * 8;
<tr class="nocodegen"><td>5246<td>  // This flag tells the initialization of the algorithm that
<tr class="nocodegen"><td>5247<td>  // FixedOutputLength needs to be preserved
<tr class="covered"><td>5248<td>  FOutpLengSet := true;
<tr class="nocodegen"><td>5249<td>
<tr class="covered"><td>5250<td>  SetLength(FDigest, Value);
<tr class="covered"><td>5251<td>  FillChar(FDigest[0], Length(FDigest), #0);
<tr class="covered"><td>5252<td>end;
<tr class="nocodegen"><td>5253<td>
<tr class="nocodegen"><td>5254<td>function THash_ShakeBase.DigestAsBytes: TBytes;
<tr class="covered"><td>5255<td>begin
<tr class="covered"><td>5256<td>  SetLength(Result, FSpongeState.FixedOutputLength shr 3);
<tr class="covered"><td>5257<td>  if FSpongeState.FixedOutputLength &gt; 0 then
<tr class="covered"><td>5258<td>    Move(Digest^, Result[0], Length(Result));
<tr class="covered"><td>5259<td>end;
<tr class="nocodegen"><td>5260<td>
<tr class="nocodegen"><td>5261<td>{ THash_BCrypt }
<tr class="nocodegen"><td>5262<td>
<tr class="nocodegen"><td>5263<td>class function THash_BCrypt.BlockSize: UInt32;
<tr class="covered"><td>5264<td>begin
<tr class="covered"><td>5265<td>  Result := 8;
<tr class="covered"><td>5266<td>end;
<tr class="nocodegen"><td>5267<td>
<tr class="nocodegen"><td>5268<td>procedure THash_BCrypt.Calc(const Data; DataSize: Integer);
<tr class="nocodegen"><td>5269<td>const
<tr class="nocodegen"><td>5270<td>  ctext: TBCDigest = ($4F,$72,$70,$68,$65,$61,$6E,$42, {'OrpheanBeholderScryDoubt'}
<tr class="nocodegen"><td>5271<td>                      $65,$68,$6F,$6C,$64,$65,$72,$53,
<tr class="nocodegen"><td>5272<td>                      $63,$72,$79,$44,$6F,$75,$62,$74);
<tr class="nocodegen"><td>5273<td>var
<tr class="nocodegen"><td>5274<td>  PwdData : TBytes;
<tr class="nocodegen"><td>5275<td>  i       : Integer;
<tr class="covered"><td>5276<td>begin
<tr class="covered"><td>5277<td>  if (DataSize &gt; MaxPasswordLength) then
<tr class="covered"><td>5278<td>    raise EDECHashException.CreateFmt(sPasswordTooLong, [MaxPasswordLength]);
<tr class="nocodegen"><td>5279<td>
<tr class="nocodegen"><td>5280<td>  // While this should normally be caught on setting salt already it is there
<tr class="nocodegen"><td>5281<td>  // especially to catch cases where no salt has been specified yet.
<tr class="covered"><td>5282<td>  if (Length(FSalt) &lt; MinSaltLength) or (Length(FSalt) &gt; MaxSaltLength) then
<tr class="covered"><td>5283<td>    raise EDECHashException.CreateFmt(sWrongSaltLength,
<tr class="nocodegen"><td>5284<td>                                      [MinSaltLength, MaxSaltLength]);
<tr class="nocodegen"><td>5285<td>
<tr class="nocodegen"><td>5286<td>  // This automatically &quot;adds&quot; the required #0 terminator at the end of the password
<tr class="covered"><td>5287<td>  SetLength(PwdData, DataSize + 1);
<tr class="covered"><td>5288<td>  Move(Data, PwdData[0], DataSize);
<tr class="nocodegen"><td>5289<td>
<tr class="covered"><td>5290<td>  EksBlowfishSetup(PwdData, DataSize + 1);
<tr class="nocodegen"><td>5291<td>
<tr class="covered"><td>5292<td>  Move(ctext, FDigest[0], Length(ctext));
<tr class="nocodegen"><td>5293<td>
<tr class="nocodegen"><td>5294<td>  // Encrypt the magic initialisation text 64 times using ECB mode
<tr class="covered"><td>5295<td>  for i := 1 to 64 do
<tr class="nocodegen"><td>5296<td>  begin
<tr class="covered"><td>5297<td>    BF_Encrypt(PBFBlock(@FDigest[ 0])^, PBFBlock(@FDigest[ 0])^);
<tr class="covered"><td>5298<td>    BF_Encrypt(PBFBlock(@FDigest[ 8])^, PBFBlock(@FDigest[ 8])^);
<tr class="covered"><td>5299<td>    BF_Encrypt(PBFBlock(@FDigest[16])^, PBFBlock(@FDigest[16])^);
<tr class="covered"><td>5300<td>  end;
<tr class="nocodegen"><td>5301<td>
<tr class="covered"><td>5302<td>end;
<tr class="nocodegen"><td>5303<td>
<tr class="nocodegen"><td>5304<td>procedure THash_BCrypt.EksBlowfishSetup(var Password : TBytes;
<tr class="nocodegen"><td>5305<td>                                        PasswordSize : Integer);
<tr class="nocodegen"><td>5306<td>var
<tr class="nocodegen"><td>5307<td>  i, rounds: UInt32;
<tr class="nocodegen"><td>5308<td>const
<tr class="nocodegen"><td>5309<td>  zero: TBytes = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
<tr class="covered"><td>5310<td>begin
<tr class="nocodegen"><td>5311<td>  // number of rounds = 2^cost, loop includes 0
<tr class="covered"><td>5312<td>  if (FCost = 31) then
<tr class="notcovered"><td>5313<td>    rounds := MaxLongint
<tr class="nocodegen"><td>5314<td>  else
<tr class="covered"><td>5315<td>    rounds := (Int32(1) shl FCost) - 1;
<tr class="nocodegen"><td>5316<td>
<tr class="nocodegen"><td>5317<td>  // Just copy the boxes into the context
<tr class="covered"><td>5318<td>  ExpandKey(FSalt, Password, PasswordSize);
<tr class="nocodegen"><td>5319<td>
<tr class="nocodegen"><td>5320<td>  // This is the time consuming part
<tr class="covered"><td>5321<td>  for i := rounds downto 0 do
<tr class="nocodegen"><td>5322<td>  begin
<tr class="covered"><td>5323<td>    ExpandKey(zero, Password,  PasswordSize);
<tr class="covered"><td>5324<td>    ExpandKey(zero, FSalt, 16);
<tr class="covered"><td>5325<td>  end;
<tr class="covered"><td>5326<td>end;
<tr class="nocodegen"><td>5327<td>
<tr class="nocodegen"><td>5328<td>procedure THash_BCrypt.Expandkey(Salt             : TBytes;
<tr class="nocodegen"><td>5329<td>                                 var Password     : TBytes;
<tr class="nocodegen"><td>5330<td>                                     PasswordSize : Integer);
<tr class="nocodegen"><td>5331<td>type
<tr class="nocodegen"><td>5332<td>  TByteArray72 = packed array[0..71] of UInt8;
<tr class="nocodegen"><td>5333<td>
<tr class="nocodegen"><td>5334<td>var
<tr class="nocodegen"><td>5335<td>  i,j,k,h : Integer;
<tr class="nocodegen"><td>5336<td>  KL      : UInt32;
<tr class="nocodegen"><td>5337<td>  tmp     : TBFBlock;
<tr class="nocodegen"><td>5338<td>  KBP     : ^TByteArray72;
<tr class="covered"><td>5339<td>begin
<tr class="covered"><td>5340<td>  KBP := @Password[0];
<tr class="nocodegen"><td>5341<td>
<tr class="nocodegen"><td>5342<td>  // Text explanations and comments are from the N.Provos &amp; D.Mazieres paper.
<tr class="nocodegen"><td>5343<td>
<tr class="nocodegen"><td>5344<td>  // ExpandKey(state,salt,key) modifies the P-Array and S-boxes based on the
<tr class="nocodegen"><td>5345<td>  // value of the 128-bit salt and the variable length key. First XOR all the
<tr class="nocodegen"><td>5346<td>  // subkeys in the P-array with the encryption key. The first 32 bits of the
<tr class="nocodegen"><td>5347<td>  // key are XORed with P1, the next 32 bits with P2, and so on. The key is
<tr class="nocodegen"><td>5348<td>  // viewed as being cyclic; when the process reaches the end of the key, it
<tr class="nocodegen"><td>5349<td>  // starts reusing bits from the beginning to XOR with subkeys.
<tr class="nocodegen"><td>5350<td>
<tr class="nocodegen"><td>5351<td>  // WE: Same as standard key part except that PArray[i] is used for _bf_p[i]
<tr class="covered"><td>5352<td>  k := 0;
<tr class="covered"><td>5353<td>  for i := 0 to 17 do
<tr class="nocodegen"><td>5354<td>  begin
<tr class="covered"><td>5355<td>    KL := 0;
<tr class="covered"><td>5356<td>    for j:=0 to 3 do
<tr class="nocodegen"><td>5357<td>    begin
<tr class="covered"><td>5358<td>      KL := (KL shl 8) or KBP^[k];
<tr class="covered"><td>5359<td>      inc(k);
<tr class="nocodegen"><td>5360<td>
<tr class="covered"><td>5361<td>      if (k = PasswordSize) then
<tr class="covered"><td>5362<td>        k := 0;
<tr class="covered"><td>5363<td>    end;
<tr class="nocodegen"><td>5364<td>
<tr class="covered"><td>5365<td>    FContext.PArray[i] := FContext.PArray[i] xor KL;
<tr class="covered"><td>5366<td>  end;
<tr class="nocodegen"><td>5367<td>
<tr class="nocodegen"><td>5368<td>  // Subsequently, ExpandKey blowfish-encrypts the first 64 bits of
<tr class="nocodegen"><td>5369<td>  // its salt argument using the current state of the key schedule.
<tr class="covered"><td>5370<td>  BF_Encrypt(PBFBlock(@salt[0])^, tmp);
<tr class="nocodegen"><td>5371<td>
<tr class="nocodegen"><td>5372<td>  // The resulting ciphertext replaces subkeys P_1 and P_2.
<tr class="covered"><td>5373<td>  FContext.PArray[0] := SwapUInt32(TBF2Long(tmp).L);
<tr class="covered"><td>5374<td>  FContext.PArray[1] := SwapUInt32(TBF2Long(tmp).R);
<tr class="nocodegen"><td>5375<td>
<tr class="nocodegen"><td>5376<td>  // That same ciphertext is also XORed with the second 64-bits of
<tr class="nocodegen"><td>5377<td>  // salt, and the result encrypted with the new state of the key
<tr class="nocodegen"><td>5378<td>  // schedule. The output of the second encryption replaces subkeys
<tr class="nocodegen"><td>5379<td>  // P_3 and P_4. It is also XORed with the first 64-bits of salt
<tr class="nocodegen"><td>5380<td>  // and encrypted to replace P_5 and P_6. The process continues,
<tr class="nocodegen"><td>5381<td>  // alternating between the first and second 64 bits salt.
<tr class="covered"><td>5382<td>  h := 8;
<tr class="covered"><td>5383<td>  for i := 1 to 8 do
<tr class="nocodegen"><td>5384<td>  begin
<tr class="covered"><td>5385<td>    BF_XorBlock(tmp, PBFBlock(@Salt[h])^, tmp);
<tr class="covered"><td>5386<td>    h := h xor 8;
<tr class="covered"><td>5387<td>    BF_Encrypt(tmp, tmp);
<tr class="covered"><td>5388<td>    FContext.PArray[2*i]   := SwapUInt32(TBF2Long(tmp).L);
<tr class="covered"><td>5389<td>    FContext.PArray[2*i+1] := SwapUInt32(TBF2Long(tmp).R);
<tr class="covered"><td>5390<td>  end;
<tr class="nocodegen"><td>5391<td>
<tr class="nocodegen"><td>5392<td>  // When ExpandKey finishes replacing entries in the P-Array, it continues
<tr class="nocodegen"><td>5393<td>  // on replacing S-box entries two at a time. After replacing the last two
<tr class="nocodegen"><td>5394<td>  // entries of the last S-box, ExpandKey returns the new key schedule.
<tr class="covered"><td>5395<td>  for j := 0 to 3 do
<tr class="nocodegen"><td>5396<td>  begin
<tr class="covered"><td>5397<td>    for i := 0 to 127 do
<tr class="nocodegen"><td>5398<td>    begin
<tr class="covered"><td>5399<td>      BF_XorBlock(tmp, PBFBlock(@Salt[h])^, tmp);
<tr class="covered"><td>5400<td>      h := h xor 8;
<tr class="covered"><td>5401<td>      BF_Encrypt(tmp, tmp);
<tr class="covered"><td>5402<td>      FContext.SBox[j, 2*i]   := SwapUInt32(TBF2Long(tmp).L);
<tr class="covered"><td>5403<td>      FContext.SBox[j, 2*i+1] := SwapUInt32(TBF2Long(tmp).R);
<tr class="covered"><td>5404<td>    end;
<tr class="covered"><td>5405<td>  end;
<tr class="covered"><td>5406<td>end;
<tr class="nocodegen"><td>5407<td>
<tr class="nocodegen"><td>5408<td>function THash_BCrypt.GetCryptHash(Password     : TBytes;
<tr class="nocodegen"><td>5409<td>                                   const Params : string;
<tr class="nocodegen"><td>5410<td>                                   const Salt   : TBytes;
<tr class="nocodegen"><td>5411<td>                                   Format       : TDECFormatClass): string;
<tr class="nocodegen"><td>5412<td>var
<tr class="nocodegen"><td>5413<td>  Hash : THash_BCrypt;
<tr class="covered"><td>5414<td>begin
<tr class="covered"><td>5415<td>  Hash := THash_BCrypt.Create;
<tr class="covered"><td>5416<td>  try
<tr class="covered"><td>5417<td>    Hash.Cost := StrToInt(string(Params));
<tr class="covered"><td>5418<td>    Hash.Salt := Salt;
<tr class="nocodegen"><td>5419<td>
<tr class="nocodegen"><td>5420<td>    // BCrypt leaves off the $ in front of the actual password hash value
<tr class="covered"><td>5421<td>    Result := TEncoding.ASCII.GetString(Format.Encode(Hash.CalcBytes(Password)));
<tr class="nocodegen"><td>5422<td>  finally
<tr class="covered"><td>5423<td>    Hash.Free;
<tr class="nocodegen"><td>5424<td>  end;
<tr class="covered"><td>5425<td>end;
<tr class="nocodegen"><td>5426<td>
<tr class="nocodegen"><td>5427<td>class function THash_BCrypt.GetCryptID: string;
<tr class="covered"><td>5428<td>begin
<tr class="covered"><td>5429<td>  Result := '$2a';
<tr class="covered"><td>5430<td>end;
<tr class="nocodegen"><td>5431<td>
<tr class="nocodegen"><td>5432<td>function THash_BCrypt.GetCryptParams(const Params : string;
<tr class="nocodegen"><td>5433<td>                                     Format       : TDECFormatClass): string;
<tr class="covered"><td>5434<td>begin
<tr class="covered"><td>5435<td>  Result := Params;
<tr class="covered"><td>5436<td>  if (Length(Result) &lt; 2) then
<tr class="covered"><td>5437<td>    Result := '0' + Result;
<tr class="nocodegen"><td>5438<td>
<tr class="covered"><td>5439<td>  Result := '$' + Result;
<tr class="covered"><td>5440<td>end;
<tr class="nocodegen"><td>5441<td>
<tr class="nocodegen"><td>5442<td>function THash_BCrypt.IsValidPassword(Password        : TBytes;
<tr class="nocodegen"><td>5443<td>                                      const CryptData : string;
<tr class="nocodegen"><td>5444<td>                                      Format: TDECFormatClass): Boolean;
<tr class="nocodegen"><td>5445<td>var
<tr class="nocodegen"><td>5446<td>  SplittedCryptData : TBCryptBSDData;
<tr class="nocodegen"><td>5447<td>  Hash              : string;
<tr class="covered"><td>5448<td>begin
<tr class="covered"><td>5449<td>  Result := false;
<tr class="nocodegen"><td>5450<td>
<tr class="covered"><td>5451<td>  if (Length(CryptData) = 60) then
<tr class="nocodegen"><td>5452<td>  begin
<tr class="covered"><td>5453<td>    if SplitTestVector(CryptData, SplittedCryptData) then
<tr class="nocodegen"><td>5454<td>    begin
<tr class="nocodegen"><td>5455<td>      // Is the CryptData for this algorithm?
<tr class="covered"><td>5456<td>      if '$' + SplittedCryptData.ID &lt;&gt; GetCryptID then
<tr class="nocodegen"><td>5457<td>        exit;
<tr class="nocodegen"><td>5458<td>
<tr class="covered"><td>5459<td>      Hash := GetDigestInCryptFormat(Password,
<tr class="nocodegen"><td>5460<td>                                     SplittedCryptData.Cost,
<tr class="nocodegen"><td>5461<td>                                     SplittedCryptData.Salt,
<tr class="nocodegen"><td>5462<td>                                     False,
<tr class="nocodegen"><td>5463<td>                                     Format);
<tr class="nocodegen"><td>5464<td>
<tr class="covered"><td>5465<td>      Result := Hash = CryptData;
<tr class="nocodegen"><td>5466<td>    end;
<tr class="nocodegen"><td>5467<td>  end;
<tr class="covered"><td>5468<td>end;
<tr class="nocodegen"><td>5469<td>
<tr class="nocodegen"><td>5470<td>//function THash_BCrypt.IsValidPassword(const Password  : string;
<tr class="nocodegen"><td>5471<td>//                                      const CryptData : string;
<tr class="nocodegen"><td>5472<td>//                                      Format          : TDECFormatClass): Boolean;
<tr class="nocodegen"><td>5473<td>//var
<tr class="nocodegen"><td>5474<td>//  SplittedCryptData : TBCryptBSDData;
<tr class="nocodegen"><td>5475<td>//  Hash              : string;
<tr class="nocodegen"><td>5476<td>//begin
<tr class="nocodegen"><td>5477<td>//  Result := false;
<tr class="nocodegen"><td>5478<td>//
<tr class="nocodegen"><td>5479<td>//  if (Length(CryptData) = 60) then
<tr class="nocodegen"><td>5480<td>//  begin
<tr class="nocodegen"><td>5481<td>//    if SplitTestVector(CryptData, SplittedCryptData) then
<tr class="nocodegen"><td>5482<td>//    begin
<tr class="nocodegen"><td>5483<td>//      // Is the CryptData for this algorithm?
<tr class="nocodegen"><td>5484<td>//      if '$' + SplittedCryptData.ID &lt;&gt; GetCryptID then
<tr class="nocodegen"><td>5485<td>//        exit;
<tr class="nocodegen"><td>5486<td>//
<tr class="nocodegen"><td>5487<td>//      Hash := GetDigestInCryptFormat(Password,
<tr class="nocodegen"><td>5488<td>//                                     SplittedCryptData.Cost,
<tr class="nocodegen"><td>5489<td>//                                     SplittedCryptData.Salt,
<tr class="nocodegen"><td>5490<td>//                                     False,
<tr class="nocodegen"><td>5491<td>//                                     Format);
<tr class="nocodegen"><td>5492<td>//
<tr class="nocodegen"><td>5493<td>//      Result := Hash = CryptData;
<tr class="nocodegen"><td>5494<td>//    end;
<tr class="nocodegen"><td>5495<td>//  end;
<tr class="nocodegen"><td>5496<td>//end;
<tr class="nocodegen"><td>5497<td>
<tr class="nocodegen"><td>5498<td>procedure THash_BCrypt.BF_Encrypt(const BI: TBFBlock; var BO: TBFBlock);
<tr class="nocodegen"><td>5499<td>var
<tr class="nocodegen"><td>5500<td>  xl, xr : UInt32;
<tr class="nocodegen"><td>5501<td>  pp     : ^UInt32;
<tr class="nocodegen"><td>5502<td>  i      : integer;
<tr class="covered"><td>5503<td>begin
<tr class="covered"><td>5504<td>  xl := SwapUInt32(TBF2Long(BI).L) xor FContext.PArray[0];
<tr class="covered"><td>5505<td>  xr := SwapUInt32(TBF2Long(BI).R);
<tr class="covered"><td>5506<td>  pp := @FContext.PArray[1];
<tr class="nocodegen"><td>5507<td>
<tr class="nocodegen"><td>5508<td>  {$Q-}
<tr class="nocodegen"><td>5509<td>  // 16 rounds = 8 double rounds without swapping
<tr class="covered"><td>5510<td>  for i := 1 to 8 do
<tr class="nocodegen"><td>5511<td>  begin
<tr class="nocodegen"><td>5512<td>    {$IFOPT Q+}The following code requires overflow checks being off!
<tr class="nocodegen"><td>5513<td>               If the compiler complains do a clean on the main source project
<tr class="nocodegen"><td>5514<td>               and recompile it!{$ENDIF}
<tr class="nocodegen"><td>5515<td>
<tr class="covered"><td>5516<td>    xr := xr xor pp^ xor (FContext.SBox[0][xl shr 24        ] +
<tr class="nocodegen"><td>5517<td>                          FContext.SBox[1][xl shr 16 and $ff] xor
<tr class="nocodegen"><td>5518<td>                          FContext.SBox[2][xl shr 8  and $ff] +
<tr class="nocodegen"><td>5519<td>                          FContext.SBox[3][xl        and $ff]);
<tr class="covered"><td>5520<td>    inc(pp);
<tr class="covered"><td>5521<td>    xl := xl xor pp^ xor (FContext.SBox[0][xr shr 24        ] +
<tr class="nocodegen"><td>5522<td>                          FContext.SBox[1][xr shr 16 and $ff] xor
<tr class="nocodegen"><td>5523<td>                          FContext.SBox[2][xr shr 8  and $ff] +
<tr class="nocodegen"><td>5524<td>                          FContext.SBox[3][xr        and $ff]);
<tr class="covered"><td>5525<td>    inc(pp);
<tr class="covered"><td>5526<td>  end;
<tr class="nocodegen"><td>5527<td>
<tr class="nocodegen"><td>5528<td>  {$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}
<tr class="covered"><td>5529<td>  TBF2Long(BO).R := SwapUInt32(xl);
<tr class="covered"><td>5530<td>  TBF2Long(BO).L := SwapUInt32(xr xor pp^);
<tr class="covered"><td>5531<td>end;
<tr class="nocodegen"><td>5532<td>
<tr class="nocodegen"><td>5533<td>procedure THash_BCrypt.BF_XorBlock(const B1, B2: TBFBlock; var B3: TBFBlock);
<tr class="covered"><td>5534<td>begin
<tr class="covered"><td>5535<td>  TBF2Long(B3).L := TBF2Long(B1).L xor TBF2Long(B2).L;
<tr class="covered"><td>5536<td>  TBF2Long(B3).R := TBF2Long(B1).R xor TBF2Long(B2).R;
<tr class="covered"><td>5537<td>end;
<tr class="nocodegen"><td>5538<td>
<tr class="nocodegen"><td>5539<td>constructor THash_BCrypt.Create;
<tr class="covered"><td>5540<td>begin
<tr class="covered"><td>5541<td>  inherited;
<tr class="nocodegen"><td>5542<td>
<tr class="covered"><td>5543<td>  FCost := 10; // must be specified by the user, but better init with a
<tr class="nocodegen"><td>5544<td>               // fixed value instead of no initialization at all.
<tr class="covered"><td>5545<td>end;
<tr class="nocodegen"><td>5546<td>
<tr class="nocodegen"><td>5547<td>function THash_BCrypt.Digest: PByteArray;
<tr class="covered"><td>5548<td>begin
<tr class="covered"><td>5549<td>  Result := @FDigest;
<tr class="covered"><td>5550<td>end;
<tr class="nocodegen"><td>5551<td>
<tr class="nocodegen"><td>5552<td>class function THash_BCrypt.DigestSize: UInt32;
<tr class="covered"><td>5553<td>begin
<tr class="nocodegen"><td>5554<td>  // Should have been 192 bit = 24 byte, but original imnplementation had a flaw
<tr class="nocodegen"><td>5555<td>  // not returning the last byte which has been kept instead of fixing it.
<tr class="covered"><td>5556<td>  Result := 23;
<tr class="covered"><td>5557<td>end;
<tr class="nocodegen"><td>5558<td>
<tr class="nocodegen"><td>5559<td>procedure THash_BCrypt.DoDone;
<tr class="covered"><td>5560<td>begin
<tr class="covered"><td>5561<td>  ProtectBuffer(FContext.PArray, SizeOf(FContext.PArray));
<tr class="covered"><td>5562<td>  ProtectBuffer(FContext.IV, SizeOf(FContext.IV));
<tr class="covered"><td>5563<td>  ProtectBuffer(FContext.buf, SizeOf(FContext.buf));
<tr class="nocodegen"><td>5564<td>
<tr class="covered"><td>5565<td>  inherited;
<tr class="covered"><td>5566<td>end;
<tr class="nocodegen"><td>5567<td>
<tr class="nocodegen"><td>5568<td>procedure THash_BCrypt.DoInit;
<tr class="covered"><td>5569<td>begin
<tr class="covered"><td>5570<td>  FillChar(FDigest,  SizeOf(FDigest), 0);
<tr class="covered"><td>5571<td>  FillChar(FContext, SizeOf(FContext), 0);
<tr class="nocodegen"><td>5572<td>
<tr class="covered"><td>5573<td>  FContext.SBox   := Blowfish_Data;
<tr class="covered"><td>5574<td>  FContext.PArray := Blowfish_Key;
<tr class="covered"><td>5575<td>end;
<tr class="nocodegen"><td>5576<td>
<tr class="nocodegen"><td>5577<td>procedure THash_BCrypt.DoTransform(Buffer: PUInt32Array);
<tr class="notcovered"><td>5578<td>begin
<tr class="nocodegen"><td>5579<td>  // Empty on purpose, as bcrypt needs to know the input length. Thus calculation
<tr class="nocodegen"><td>5580<td>  // is done directly in method Calc.
<tr class="notcovered"><td>5581<td>end;
<tr class="nocodegen"><td>5582<td>
<tr class="nocodegen"><td>5583<td>function THash_BCrypt.MaxCost: UInt8;
<tr class="covered"><td>5584<td>begin
<tr class="covered"><td>5585<td>  Result := 31;
<tr class="covered"><td>5586<td>end;
<tr class="nocodegen"><td>5587<td>
<tr class="nocodegen"><td>5588<td>class function THash_BCrypt.MaxPasswordLength: UInt8;
<tr class="covered"><td>5589<td>begin
<tr class="covered"><td>5590<td>  Result := 72;
<tr class="covered"><td>5591<td>end;
<tr class="nocodegen"><td>5592<td>
<tr class="nocodegen"><td>5593<td>function THash_BCrypt.MaxSaltLength: UInt8;
<tr class="covered"><td>5594<td>begin
<tr class="covered"><td>5595<td>  Result := 16;
<tr class="covered"><td>5596<td>end;
<tr class="nocodegen"><td>5597<td>
<tr class="nocodegen"><td>5598<td>function THash_BCrypt.MinCost: UInt8;
<tr class="covered"><td>5599<td>begin
<tr class="covered"><td>5600<td>  Result := 4;
<tr class="covered"><td>5601<td>end;
<tr class="nocodegen"><td>5602<td>
<tr class="nocodegen"><td>5603<td>function THash_BCrypt.MinSaltLength: UInt8;
<tr class="covered"><td>5604<td>begin
<tr class="covered"><td>5605<td>  Result := 16;
<tr class="covered"><td>5606<td>end;
<tr class="nocodegen"><td>5607<td>
<tr class="nocodegen"><td>5608<td>procedure THash_BCrypt.SetCost(const Value: UInt8);
<tr class="covered"><td>5609<td>begin
<tr class="covered"><td>5610<td>  if (Value in [MinCost..MaxCost]) then
<tr class="covered"><td>5611<td>    FCost := Value
<tr class="nocodegen"><td>5612<td>  else
<tr class="covered"><td>5613<td>    raise EDECHashException.CreateFmt(sCostFactorInvalid, [MinCost, MaxCost]);
<tr class="covered"><td>5614<td>end;
<tr class="nocodegen"><td>5615<td>
<tr class="nocodegen"><td>5616<td>function THash_BCrypt.SplitTestVector(const Vector     : string;
<tr class="nocodegen"><td>5617<td>                                      var SplittedData : TBCryptBSDData): Boolean;
<tr class="nocodegen"><td>5618<td>var
<tr class="nocodegen"><td>5619<td>  Parts : TArray&lt;string&gt;;
<tr class="covered"><td>5620<td>begin
<tr class="covered"><td>5621<td>  Result := false;
<tr class="nocodegen"><td>5622<td>
<tr class="covered"><td>5623<td>  Parts             := Vector.Split(['$'], TStringSplitOptions.ExcludeEmpty);
<tr class="nocodegen"><td>5624<td>
<tr class="covered"><td>5625<td>  if (Length(Parts) = 3) then
<tr class="nocodegen"><td>5626<td>  begin
<tr class="covered"><td>5627<td>    SplittedData.ID   := Parts[0];
<tr class="covered"><td>5628<td>    SplittedData.Cost := Copy(Parts[1], Low(Parts[1]), Length(Parts[1]));
<tr class="covered"><td>5629<td>    SplittedData.Salt := Copy(Parts[2], Low(Parts[2]), 22);
<tr class="covered"><td>5630<td>    Result := true;
<tr class="nocodegen"><td>5631<td>  end;
<tr class="covered"><td>5632<td>end;
<tr class="nocodegen"><td>5633<td>
<tr class="nocodegen"><td>5634<td>{$IFDEF RESTORE_RANGECHECKS}{$R+}{$ENDIF}
<tr class="nocodegen"><td>5635<td>{$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}
<tr class="nocodegen"><td>5636<td>
<tr class="covered"><td>5637<td>initialization
<tr class="nocodegen"><td>5638<td>  // Define the has returned by ValidHash if passing nil as parameter
<tr class="covered"><td>5639<td>  SetDefaultHashClass(THash_SHA256);
<tr class="nocodegen"><td>5640<td>
<tr class="nocodegen"><td>5641<td>  {$IFNDEF ManualRegisterHashClasses}
<tr class="covered"><td>5642<td>  THash_MD2.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5643<td>  THash_MD4.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5644<td>  THash_MD5.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5645<td>  THash_RipeMD128.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5646<td>  THash_RipeMD160.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5647<td>  THash_RipeMD256.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5648<td>  THash_RipeMD320.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5649<td>  THash_SHA0.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5650<td>  THash_SHA1.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5651<td>  THash_SHA224.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5652<td>  THash_SHA256.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5653<td>  THash_SHA384.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5654<td>  THash_SHA512.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5655<td>  THash_SHA3_224.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5656<td>  THash_SHA3_256.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5657<td>  THash_SHA3_384.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5658<td>  THash_SHA3_512.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5659<td>  THash_Keccak_224.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5660<td>  THash_Keccak_256.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5661<td>  THash_Keccak_384.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5662<td>  THash_Keccak_512.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5663<td>  THash_Shake128.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5664<td>  THash_Shake256.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5665<td>  THash_Haval128.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5666<td>  THash_Haval160.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5667<td>  THash_Haval192.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5668<td>  THash_Haval224.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5669<td>  THash_Haval256.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5670<td>  THash_Tiger.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5671<td>  THash_Panama.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5672<td>
<tr class="nocodegen"><td>5673<td>    {$IFDEF OLD_WHIRLPOOL_NAMES}
<tr class="nocodegen"><td>5674<td>    THash_Whirlpool.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5675<td>    THash_Whirlpool1.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5676<td>    THash_Whirlpool1New.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5677<td>    {$ELSE}
<tr class="covered"><td>5678<td>    THash_Whirlpool1.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5679<td>    {$ENDIF}
<tr class="nocodegen"><td>5680<td>
<tr class="covered"><td>5681<td>  THash_Whirlpool0.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5682<td>  THash_WhirlpoolT.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5683<td>
<tr class="covered"><td>5684<td>  THash_Square.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5685<td>  THash_Snefru128.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5686<td>  THash_Snefru256.RegisterClass(TDECHash.ClassList);
<tr class="covered"><td>5687<td>  THash_Sapphire.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5688<td>
<tr class="covered"><td>5689<td>  THash_BCrypt.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5690<td>
<tr class="nocodegen"><td>5691<td>    {$IFDEF OLD_SHA_NAME}
<tr class="nocodegen"><td>5692<td>    THash_SHA.RegisterClass(TDECHash.ClassList);
<tr class="nocodegen"><td>5693<td>    {$ENDIF}
<tr class="nocodegen"><td>5694<td>
<tr class="nocodegen"><td>5695<td>  {$ENDIF}
<tr class="nocodegen"><td>5696<td>
<tr class="covered"><td>5697<td>finalization
<tr class="nocodegen"><td>5698<td>  // No need to unregister the hash classes, as the list is being freed
<tr class="nocodegen"><td>5699<td>  // in finalization of DECHashBase unit
<tr class="nocodegen"><td>5700<td>
<tr class="covered"><td>5701<td>end.
</table>
<script>(function () {
var starts = [],prev = document.getElementById("nav-prev"),next = document.getElementById("nav-next");
(function () {
var p;
document.querySelectorAll("table.s tr").forEach(r => {
if (r.classList.contains("notcovered")) {
if (!p) starts.push(r);
p = r;
} else { p = null }
})
})();
function findPrev() {
var y = prev.getBoundingClientRect().top - 4;
for (var i=starts.length-1; i>=0; i--) {
if (starts[i].getBoundingClientRect().top < y) return starts[i]
}
}
function findNext() {
var y = next.getBoundingClientRect().top + 4;
for (var i=0; i<starts.length; i++) {
if (starts[i].getBoundingClientRect().top > y) return starts[i];
}
}
function onScroll() {
prev.setAttribute("class", findPrev() ? "active" : "");
next.setAttribute("class", findNext() ? "active" : "");
onScroll.pending = 0;
}
document.addEventListener("scroll", function() {
if (!onScroll.pending) { onScroll.pending = requestAnimationFrame(onScroll) }
});
onScroll();
function scrollTo(row) {
if (row) window.scrollTo({ behavior: "smooth", top: window.scrollY+row.getBoundingClientRect().top-prev.getBoundingClientRect().top });
}
next.addEventListener("click", () => scrollTo(findNext()) );
prev.addEventListener("click", () => scrollTo(findPrev()) );
})();</script>
<script>
const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
const comparer = (idx, asc) => (a, b) => ((v1, v2) =>!isNaN(parseFloat(v1 || "-")) && !isNaN(parseFloat(v2 || "-")) ? parseFloat(v1)-parseFloat(v2) : v1.toString().localeCompare(v2))(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));
document.querySelectorAll("thead th[idx]").forEach(th => th.addEventListener("click", (() => {
	const table = th.closest("table").querySelector("tbody");
	Array.from(table.querySelectorAll("tr"))
		.sort(comparer(+th.getAttribute("idx"), this.asc = !this.asc))
		.forEach(tr => table.appendChild(tr) );
	})));
</script>
</body>
</html>
