<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
body {max-width: max-content;margin: auto;}
table {border-spacing:0;}
table, td, th {border: 0;}
td, th {background: white; margin: 0; padding: .5em 1em}
table small { color: #777; }
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: consolas,courier,monospace; font-size: 10pt;}
thead, th {background: #808C98; color: white; }
table th small { color: #ddd; }
th[idx] {cursor: pointer; user-select: none;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: calc(min(80em, 95vw));}
table.s tr td {padding: .1em .5em; white-space: pre-wrap;}
table.s tr td:first-child {text-align: right; font-weight: bold; vertical-align: top}
table.s tr.notcovered td {background: #ddf;}
table.s tr.nocodegen td {background: #ffe;}
table.s tr.covered td {background: #cfc;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum td { background-position: 50%; background-repeat: no-repeat; background-size: 90% 70%; }
table.sum tr:nth-child(odd) td { background-color: #f4f4f4}
table.sum tr:hover td, tr:hover td a { filter: invert(10%) }
table.sum tr th {text-align:left; border: .5px solid #5d4e4c; height: 1em}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
table.sum thead th { position: sticky; top:0; }
table.sum thead tr + tr th { position: sticky; top: calc(2.5em - 2px); }
table.sum tfoot th { position: sticky; bottom:0; }
table.sum tfoot th+th {text-align: right;}
table.sum a, table.sum a:visited {color: #5d4e4c; text-decoration: none;}
#nav {position: fixed;overflow: visible;left: min(calc(50% + 41em), calc(100% - 6em));padding: .1em .5em .1em .2em;background: white;box-shadow: 1px 1px 3px #888;}
#nav div {opacity: .3; user-select: none; pointer-events: none;}
#nav div.active {opacity: 1;	cursor: pointer;	pointer-events: initial;}
#nav div.active:hover {color: #00A;}
</style>
</head>
<body>
<p>Coverage report for <bold>DECCRC (..\..\Source\DECCRC.pas)</bold>.</p>
<p>Generated at 30.11.2022 22:06:19 by <a href="https://github.com/DelphiCodeCoverage/DelphiCodeCoverage" target="_blank" title="DelphiCodeCoverage on GitHub">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p>Statistics for ..\..\Source\DECCRC.pas</p>
<table class="o"><tr><td>Number of lines covered<td>150<td rowspan=3 style="background: conic-gradient(#9fe098 96%, #eee 96%);width: 4.5em; border-radius: 50%"><tr><td>Number of lines with code gen<td>155<tr><td>Line coverage<td>96<small>.8</small>&nbsp;%</table>
<br><br>
<div id="nav"><div id="nav-prev">&#x25b2; Prev</div><div id="nav-next">&#x25bc; Next</div></div>
<table class="s">
<tr class="nocodegen"><td>1<td>{*****************************************************************************
<tr class="nocodegen"><td>2<td>  The DEC team (see file NOTICE.txt) licenses this file
<tr class="nocodegen"><td>3<td>  to you under the Apache License, Version 2.0 (the
<tr class="nocodegen"><td>4<td>  &quot;License&quot;); you may not use this file except in compliance
<tr class="nocodegen"><td>5<td>  with the License. A copy of this licence is found in the root directory
<tr class="nocodegen"><td>6<td>  of this project in the file LICENCE.txt or alternatively at
<tr class="nocodegen"><td>7<td>
<tr class="nocodegen"><td>8<td>    http://www.apache.org/licenses/LICENSE-2.0
<tr class="nocodegen"><td>9<td>
<tr class="nocodegen"><td>10<td>  Unless required by applicable law or agreed to in writing,
<tr class="nocodegen"><td>11<td>  software distributed under the License is distributed on an
<tr class="nocodegen"><td>12<td>  &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<tr class="nocodegen"><td>13<td>  KIND, either express or implied.  See the License for the
<tr class="nocodegen"><td>14<td>  specific language governing permissions and limitations
<tr class="nocodegen"><td>15<td>  under the License.
<tr class="nocodegen"><td>16<td>*****************************************************************************}
<tr class="nocodegen"><td>17<td>
<tr class="nocodegen"><td>18<td>{
<tr class="nocodegen"><td>19<td>  Implementation of threadsafe CRC checksum functions.
<tr class="nocodegen"><td>20<td>
<tr class="nocodegen"><td>21<td>  The following standard CRCs are supported:
<tr class="nocodegen"><td>22<td>    CRC-8, CRC-10, CRC-12 (Mobil Telephone),
<tr class="nocodegen"><td>23<td>    CRC-16, CRC-16-CCITT, CRC-16-ZModem,
<tr class="nocodegen"><td>24<td>    CRC-24 (PGP's MIME64 Armor CRC),
<tr class="nocodegen"><td>25<td>    CRC-32, CRC-32-CCITT and CRC-32-ZModem.
<tr class="nocodegen"><td>26<td>
<tr class="nocodegen"><td>27<td>  How to use:
<tr class="nocodegen"><td>28<td>
<tr class="nocodegen"><td>29<td>  var
<tr class="nocodegen"><td>30<td>    CRC16: UInt16;
<tr class="nocodegen"><td>31<td>  begin
<tr class="nocodegen"><td>32<td>    CRC16 := CRCCalc(CRC_16, Data, SizeOf(Data)); // all in one
<tr class="nocodegen"><td>33<td>  end;
<tr class="nocodegen"><td>34<td>
<tr class="nocodegen"><td>35<td>  or
<tr class="nocodegen"><td>36<td>
<tr class="nocodegen"><td>37<td>  var
<tr class="nocodegen"><td>38<td>    CRC: TCRCDef;
<tr class="nocodegen"><td>39<td>    CRC32: UInt32;
<tr class="nocodegen"><td>40<td>  begin
<tr class="nocodegen"><td>41<td>    CRCInit(CRC, CRC_32);                         // setup CRC data structure
<tr class="nocodegen"><td>42<td>    CRCCode(CRC, Data, SizeOf(Data));             // calcs CRC for &quot;Data&quot;
<tr class="nocodegen"><td>43<td>    CRCCode(CRC, PChar(string)^, Length(string) * SizeOf(string[1])); // calcs CRC for String
<tr class="nocodegen"><td>44<td>    CRC32 := CRCDone(CRC);                        // returns correct combined CRC for Data and String
<tr class="nocodegen"><td>45<td>    // after CRCDone we can start a new calculation
<tr class="nocodegen"><td>46<td>  end;
<tr class="nocodegen"><td>47<td>}
<tr class="nocodegen"><td>48<td>
<tr class="nocodegen"><td>49<td>unit DECCRC;
<tr class="nocodegen"><td>50<td>
<tr class="nocodegen"><td>51<td>interface
<tr class="nocodegen"><td>52<td>
<tr class="nocodegen"><td>53<td>{$INCLUDE DECOptions.inc}
<tr class="nocodegen"><td>54<td>
<tr class="nocodegen"><td>55<td>type
<tr class="nocodegen"><td>56<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>57<td>  ///   CRC Definition Structure
<tr class="nocodegen"><td>58<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>59<td>  PCRCDef = ^TCRCDef;
<tr class="nocodegen"><td>60<td>
<tr class="nocodegen"><td>61<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>62<td>  ///   Record with meta data about a single CRC algorithm/polynom
<tr class="nocodegen"><td>63<td>  ///   Do *not* reorder or change this structure
<tr class="nocodegen"><td>64<td>  /// &lt;para&gt;
<tr class="nocodegen"><td>65<td>  ///   SizeOf(TCRCDef) = 1056 = 0420h
<tr class="nocodegen"><td>66<td>  /// &lt;/para&gt;
<tr class="nocodegen"><td>67<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>68<td>  TCRCDef = packed record
<tr class="nocodegen"><td>69<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>70<td>    ///   Lookup Table, precomputed in CRCSetup
<tr class="nocodegen"><td>71<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>72<td>    Table       : array[0..255] of UInt32;
<tr class="nocodegen"><td>73<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>74<td>    ///   Intermediate CRC
<tr class="nocodegen"><td>75<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>76<td>    CRC         : UInt32;
<tr class="nocodegen"><td>77<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>78<td>    ///   Is this Polynomial an inverse function?
<tr class="nocodegen"><td>79<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>80<td>    Inverse     : LongBool;
<tr class="nocodegen"><td>81<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>82<td>    ///   Shift Value for CRCCode (for more speed)
<tr class="nocodegen"><td>83<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>84<td>    Shift       : UInt32;
<tr class="nocodegen"><td>85<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>86<td>    ///   Start Value of CRC cComputation
<tr class="nocodegen"><td>87<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>88<td>    InitVector  : UInt32;
<tr class="nocodegen"><td>89<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>90<td>    ///   Final XOR Vector of computed CRC
<tr class="nocodegen"><td>91<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>92<td>    FinalVector : UInt32;
<tr class="nocodegen"><td>93<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>94<td>    ///   Precomputed AND Mask of computed CRC
<tr class="nocodegen"><td>95<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>96<td>    Mask        : UInt32;
<tr class="nocodegen"><td>97<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>98<td>    ///   Bitsize of CRC
<tr class="nocodegen"><td>99<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>100<td>    Bits        : UInt32;
<tr class="nocodegen"><td>101<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>102<td>    ///   Used Polynomial
<tr class="nocodegen"><td>103<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>104<td>    Polynomial  : UInt32;
<tr class="nocodegen"><td>105<td>  end;
<tr class="nocodegen"><td>106<td>
<tr class="nocodegen"><td>107<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>108<td>  ///   predefined standard CRC Types
<tr class="nocodegen"><td>109<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>110<td>  TCRCType = (
<tr class="nocodegen"><td>111<td>    CRC_8,
<tr class="nocodegen"><td>112<td>    CRC_10,
<tr class="nocodegen"><td>113<td>    CRC_12,
<tr class="nocodegen"><td>114<td>    CRC_16,
<tr class="nocodegen"><td>115<td>    CRC_16CCITT,
<tr class="nocodegen"><td>116<td>    CRC_16XModem,
<tr class="nocodegen"><td>117<td>    CRC_24,
<tr class="nocodegen"><td>118<td>    CRC_32,
<tr class="nocodegen"><td>119<td>    CRC_32CCITT,
<tr class="nocodegen"><td>120<td>    CRC_32ZModem,
<tr class="nocodegen"><td>121<td>    CRC_8ATMHEC,
<tr class="nocodegen"><td>122<td>    CRC_8SMBus,
<tr class="nocodegen"><td>123<td>    CRC_15CAN,
<tr class="nocodegen"><td>124<td>    CRC_16ZMODEM
<tr class="nocodegen"><td>125<td>  );
<tr class="nocodegen"><td>126<td>
<tr class="nocodegen"><td>127<td>type
<tr class="nocodegen"><td>128<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>129<td>  ///   Callback method used by some CRC calculation routines to fetch the data
<tr class="nocodegen"><td>130<td>  ///   to be processed
<tr class="nocodegen"><td>131<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>132<td>  /// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>133<td>  ///   Buffer containing the data to be processed
<tr class="nocodegen"><td>134<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>135<td>  /// &lt;param name=&quot;Count&quot;&gt;
<tr class="nocodegen"><td>136<td>  ///   Number of bytes of the buffer to be processed
<tr class="nocodegen"><td>137<td>  /// &lt;/param&gt;
<tr class="nocodegen"><td>138<td>  /// &lt;returns&gt;
<tr class="nocodegen"><td>139<td>  ///
<tr class="nocodegen"><td>140<td>  /// &lt;/returns&gt;
<tr class="nocodegen"><td>141<td>  TReadMethod = function(var Buffer; Count: Int64): Int64 of object;
<tr class="nocodegen"><td>142<td>
<tr class="nocodegen"><td>143<td>// initialize CRC Definition with a custom Algorithm
<tr class="nocodegen"><td>144<td>
<tr class="nocodegen"><td>145<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>146<td>///   Fills the individual fields of a CRC meta data structure
<tr class="nocodegen"><td>147<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>148<td>/// &lt;param name=&quot;CRCDef&quot;&gt;
<tr class="nocodegen"><td>149<td>///   Structure whose fields shall be filled
<tr class="nocodegen"><td>150<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>151<td>/// &lt;param name=&quot;Polynomial&quot;&gt;
<tr class="nocodegen"><td>152<td>///   CRC polynome, defining the algorithm
<tr class="nocodegen"><td>153<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>154<td>/// &lt;param name=&quot;Bits&quot;&gt;
<tr class="nocodegen"><td>155<td>///   Size of the CRC value to be computed in bits. Needs to be at least 8
<tr class="nocodegen"><td>156<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>157<td>/// &lt;param name=&quot;InitVector&quot;&gt;
<tr class="nocodegen"><td>158<td>///   Initial value for the vector going into each calculation cycle
<tr class="nocodegen"><td>159<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>160<td>/// &lt;param name=&quot;FinalVector&quot;&gt;
<tr class="nocodegen"><td>161<td>///   Final XOR Vector of computed CRC
<tr class="nocodegen"><td>162<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>163<td>/// &lt;param name=&quot;Inverse&quot;&gt;
<tr class="nocodegen"><td>164<td>///   true if this Polynomial is an inverse function
<tr class="nocodegen"><td>165<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>166<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>167<td>///   true on success, false when a number smaller 8 is being passed as Bits parameter
<tr class="nocodegen"><td>168<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>169<td>function CRCSetup(var CRCDef: TCRCDef;
<tr class="nocodegen"><td>170<td>                  Polynomial, Bits, InitVector, FinalVector: UInt32;
<tr class="nocodegen"><td>171<td>                  Inverse: LongBool): Boolean;
<tr class="nocodegen"><td>172<td>
<tr class="nocodegen"><td>173<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>174<td>///   Retrieves the necessary meta data and precomputed tables for a given CRC
<tr class="nocodegen"><td>175<td>///   algorithm.
<tr class="nocodegen"><td>176<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>177<td>/// &lt;param name=&quot;CRCDef&quot;&gt;
<tr class="nocodegen"><td>178<td>///   Record in which the to be retrieved meta data will be returned
<tr class="nocodegen"><td>179<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>180<td>/// &lt;param name=&quot;CRCType&quot;&gt;
<tr class="nocodegen"><td>181<td>///   Specifies the exact CRC type which shall be initialized
<tr class="nocodegen"><td>182<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>183<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>184<td>///   true on success
<tr class="nocodegen"><td>185<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>186<td>function CRCInit(var CRCDef: TCRCDef; CRCType: TCRCType): Boolean;
<tr class="nocodegen"><td>187<td>
<tr class="nocodegen"><td>188<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>189<td>///   Calculate the CRC of the contents of the passed in buffer.
<tr class="nocodegen"><td>190<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>191<td>/// &lt;param name=&quot;CRCDef&quot;&gt;
<tr class="nocodegen"><td>192<td>///   Structure with the necessary metadata for the CRC algorithm to be used.
<tr class="nocodegen"><td>193<td>///   CRC processing state is being updated during calculation to enable this
<tr class="nocodegen"><td>194<td>///   structure to be fed in another call to CRCCode if a CRC over multiple
<tr class="nocodegen"><td>195<td>///   buffers has to be calculated.
<tr class="nocodegen"><td>196<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>197<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>198<td>///   Buffer with the data the CRC shall be calculated from
<tr class="nocodegen"><td>199<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>200<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>201<td>///   Number of bytes to calculate the CRC from, starting at the beginning of
<tr class="nocodegen"><td>202<td>///   the buffer
<tr class="nocodegen"><td>203<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>204<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>205<td>///   Calculated CRC value, including any necessary correction (like CRCDone).
<tr class="nocodegen"><td>206<td>///   CRCDef.CRC holds the actual computed CRC, additional calls of CRCCode
<tr class="nocodegen"><td>207<td>///   compute the total CRC of split buffers
<tr class="nocodegen"><td>208<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>209<td>function CRCCode(var CRCDef: TCRCDef; const Buffer; Size: UInt32): UInt32; overload;
<tr class="nocodegen"><td>210<td>
<tr class="nocodegen"><td>211<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>212<td>///   Calculate the CRC of the contents provided by a given callback
<tr class="nocodegen"><td>213<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>214<td>/// &lt;param name=&quot;CRCDef&quot;&gt;
<tr class="nocodegen"><td>215<td>///   Structure with the necessary metadata for the CRC algorithm to be used.
<tr class="nocodegen"><td>216<td>///   CRC processing state is being updated during calculation to enable this
<tr class="nocodegen"><td>217<td>///   structure to be fed in another call to CRCCode if a CRC over multiple
<tr class="nocodegen"><td>218<td>///   buffers has to be calculated.
<tr class="nocodegen"><td>219<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>220<td>/// &lt;param name=&quot;ReadMethod&quot;&gt;
<tr class="nocodegen"><td>221<td>///   Callback which is being called to get the data the CRC is processed over,
<tr class="nocodegen"><td>222<td>///   e.g. TStream.Read
<tr class="nocodegen"><td>223<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>224<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>225<td>///   Number of bytes over which the CRC will be calculated. The callback will
<tr class="nocodegen"><td>226<td>///   be called until that number of bytes have been processed.
<tr class="nocodegen"><td>227<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>228<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>229<td>///   Calculated CRC value, including any necessary correction (like CRCDone).
<tr class="nocodegen"><td>230<td>///   CRCDef.CRC holds the actual computed CRC, additional calls of CRCCode
<tr class="nocodegen"><td>231<td>///   compute the total CRC of split buffers
<tr class="nocodegen"><td>232<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>233<td>function CRCCode(var CRCDef: TCRCDef;
<tr class="nocodegen"><td>234<td>                 ReadMethod: TReadMethod;
<tr class="nocodegen"><td>235<td>                 Size: UInt32 = $FFFFFFFF): UInt32; overload;
<tr class="nocodegen"><td>236<td>
<tr class="nocodegen"><td>237<td>{ TODO :
<tr class="nocodegen"><td>238<td>DUnitTests für die Callback-Methoden Varianten von CRCCode und CRCCalc
<tr class="nocodegen"><td>239<td>schreiben }
<tr class="nocodegen"><td>240<td>//
<tr class="nocodegen"><td>241<td>//    CRCInit(CRC, CRC_32);                         // setup CRC data structure
<tr class="nocodegen"><td>242<td>//    CRCCode(CRC, Data, SizeOf(Data));             // calcs CRC for &quot;Data&quot;
<tr class="nocodegen"><td>243<td>//    CRCCode(CRC, PChar(string)^, Length(string) * SizeOf(string[1])); // calcs CRC for String
<tr class="nocodegen"><td>244<td>//    CRC32 := CRCDone(CRC);
<tr class="nocodegen"><td>245<td>
<tr class="nocodegen"><td>246<td>// returns corrected CRC as definied in CRCDef and resets CRCDef.CRC to InitVector
<tr class="nocodegen"><td>247<td>
<tr class="nocodegen"><td>248<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>249<td>///   Corrects the CRC via the final vector and resets the internal intermediate
<tr class="nocodegen"><td>250<td>///   CRC value to the init vector so the next CRC calculation can start.
<tr class="nocodegen"><td>251<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>252<td>/// &lt;param name=&quot;CRCDef&quot;&gt;
<tr class="nocodegen"><td>253<td>///   Structure with the current CRC state
<tr class="nocodegen"><td>254<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>255<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>256<td>///   Final CRC value
<tr class="nocodegen"><td>257<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>258<td>function CRCDone(var CRCDef: TCRCDef): UInt32;
<tr class="nocodegen"><td>259<td>
<tr class="nocodegen"><td>260<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>261<td>///   Calculates a CRC over some Buffer with Size Bytes length. Processing is
<tr class="nocodegen"><td>262<td>///   being done in one single step
<tr class="nocodegen"><td>263<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>264<td>/// &lt;param name=&quot;CRCType&quot;&gt;
<tr class="nocodegen"><td>265<td>///   Specifies the CRC algorithm to be used
<tr class="nocodegen"><td>266<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>267<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>268<td>///   Buffer with the data to calculate the CRC from
<tr class="nocodegen"><td>269<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>270<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>271<td>///   Number of bytes over which the CRC will be calculated from the beginning
<tr class="nocodegen"><td>272<td>///   of the buffer
<tr class="nocodegen"><td>273<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>274<td>function CRCCalc(CRCType: TCRCType; const Buffer; Size: UInt32): UInt32; overload;
<tr class="nocodegen"><td>275<td>
<tr class="nocodegen"><td>276<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>277<td>///   Calculates a CRC. Data is passed via callback, which is called repeatedly
<tr class="nocodegen"><td>278<td>///   if necessary
<tr class="nocodegen"><td>279<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>280<td>/// &lt;param name=&quot;CRCType&quot;&gt;
<tr class="nocodegen"><td>281<td>///   Specifies the CRC algorithm to be used
<tr class="nocodegen"><td>282<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>283<td>/// &lt;param name=&quot;ReadMethod&quot;&gt;
<tr class="nocodegen"><td>284<td>///   Callback which is being called to get the data the CRC is processed over
<tr class="nocodegen"><td>285<td>///   e.g. TStream.Read
<tr class="nocodegen"><td>286<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>287<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>288<td>///   Number of bytes over which the CRC will be calculated. The callback will
<tr class="nocodegen"><td>289<td>///   be called until that number of bytes have been processed.
<tr class="nocodegen"><td>290<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>291<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>292<td>///   Calculated CRC value.
<tr class="nocodegen"><td>293<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>294<td>function CRCCalc(CRCType    : TCRCType;
<tr class="nocodegen"><td>295<td>                 ReadMethod : TReadMethod;
<tr class="nocodegen"><td>296<td>                 Size       : UInt32 = $FFFFFFFF): UInt32; overload;
<tr class="nocodegen"><td>297<td>
<tr class="nocodegen"><td>298<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>299<td>///   Calculates a CRC according a predefined CRC16-Standard over some Buffer
<tr class="nocodegen"><td>300<td>///   with Size Bytes length. Processing is being done in one single step
<tr class="nocodegen"><td>301<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>302<td>/// &lt;remarks&gt;
<tr class="nocodegen"><td>303<td>///   call CRC := CRC16(0, Data, SizeOf(Data));
<tr class="nocodegen"><td>304<td>/// &lt;/remarks&gt;
<tr class="nocodegen"><td>305<td>/// &lt;param name=&quot;CRC&quot;&gt;
<tr class="nocodegen"><td>306<td>///   Specifies the CRC algorithm to be used
<tr class="nocodegen"><td>307<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>308<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>309<td>///   Buffer with the data to calculate the CRC from
<tr class="nocodegen"><td>310<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>311<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>312<td>///   Number of bytes over which the CRC will be calculated from the beginning
<tr class="nocodegen"><td>313<td>///   of the buffer
<tr class="nocodegen"><td>314<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>315<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>316<td>///   Calculated CRC16 value
<tr class="nocodegen"><td>317<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>318<td>function CRC16(CRC: UInt16; const Buffer; Size: UInt32): UInt16;
<tr class="nocodegen"><td>319<td>
<tr class="nocodegen"><td>320<td>/// &lt;summary&gt;
<tr class="nocodegen"><td>321<td>///   Calculates a CRC according the CRC32-CCITT standard over some Buffer
<tr class="nocodegen"><td>322<td>///   with Size Bytes length. Processing is being done in one single step
<tr class="nocodegen"><td>323<td>/// &lt;/summary&gt;
<tr class="nocodegen"><td>324<td>/// &lt;remarks&gt;
<tr class="nocodegen"><td>325<td>///   call CRC := CRC32(0, Data, SizeOf(Data));
<tr class="nocodegen"><td>326<td>/// &lt;/remarks&gt;
<tr class="nocodegen"><td>327<td>/// &lt;param name=&quot;CRC&quot;&gt;
<tr class="nocodegen"><td>328<td>///   Specifies the CRC algorithm to be used
<tr class="nocodegen"><td>329<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>330<td>/// &lt;param name=&quot;Buffer&quot;&gt;
<tr class="nocodegen"><td>331<td>///   Buffer with the data to calculate the CRC from
<tr class="nocodegen"><td>332<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>333<td>/// &lt;param name=&quot;Size&quot;&gt;
<tr class="nocodegen"><td>334<td>///   Number of bytes over which the CRC will be calculated from the beginning
<tr class="nocodegen"><td>335<td>///   of the buffer
<tr class="nocodegen"><td>336<td>/// &lt;/param&gt;
<tr class="nocodegen"><td>337<td>/// &lt;returns&gt;
<tr class="nocodegen"><td>338<td>///   Calculated CRC32 value
<tr class="nocodegen"><td>339<td>/// &lt;/returns&gt;
<tr class="nocodegen"><td>340<td>function CRC32(CRC: UInt32; const Buffer; Size: UInt32): UInt32;
<tr class="nocodegen"><td>341<td>
<tr class="nocodegen"><td>342<td>implementation
<tr class="nocodegen"><td>343<td>
<tr class="nocodegen"><td>344<td>{$IFOPT Q+}{$DEFINE RESTORE_OVERFLOWCHECKS}{$Q-}{$ENDIF}
<tr class="nocodegen"><td>345<td>{$IFOPT R+}{$DEFINE RESTORE_RANGECHECKS}{$R-}{$ENDIF}
<tr class="nocodegen"><td>346<td>
<tr class="nocodegen"><td>347<td>type
<tr class="nocodegen"><td>348<td>  PCRCTab = ^TCRCTab;
<tr class="nocodegen"><td>349<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>350<td>  ///   Array type for the meta data definitions of the individual CRC algorithms
<tr class="nocodegen"><td>351<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>352<td>  TCRCTab = array[TCRCType] of packed record
<tr class="nocodegen"><td>353<td>    Poly, Bits, Init, FInit: UInt32;
<tr class="nocodegen"><td>354<td>    Inverse: LongBool;
<tr class="nocodegen"><td>355<td>  end;
<tr class="nocodegen"><td>356<td>
<tr class="nocodegen"><td>357<td>const
<tr class="nocodegen"><td>358<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>359<td>  ///   Table containing meta data of various well known CRC algorithms/polynoms
<tr class="nocodegen"><td>360<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>361<td>  CRCTab : TCRCTab = (
<tr class="nocodegen"><td>362<td>    (Poly: $000000D1; Bits: 08; Init: $00000000; FInit: $00000000; Inverse: True),  // CRC_8  GSM/ERR
<tr class="nocodegen"><td>363<td>    (Poly: $00000233; Bits: 10; Init: $00000000; FInit: $00000000; Inverse: True),  // CRC_10 ATM/OAM Cell
<tr class="nocodegen"><td>364<td>    (Poly: $0000080F; Bits: 12; Init: $00000000; FInit: $00000000; Inverse: True),  // CRC_12
<tr class="nocodegen"><td>365<td>    (Poly: $00008005; Bits: 16; Init: $00000000; FInit: $00000000; Inverse: True),  // CRC_16 ARC;IBM;MODBUS RTU
<tr class="nocodegen"><td>366<td>     // Init value of 1D0F instead of FFFF because the code doesn't fill with zeros,
<tr class="nocodegen"><td>367<td>     // which would otherwise be required for the CCITT variant
<tr class="nocodegen"><td>368<td>    (Poly: $00001021; Bits: 16; Init: $00001D0F; FInit: $00000000; Inverse: False), // CRC_16 CCITT ITU
<tr class="nocodegen"><td>369<td>    (Poly: $00008408; Bits: 16; Init: $00000000; FInit: $00000000; Inverse: True),  // CRC_16 XModem
<tr class="nocodegen"><td>370<td>    (Poly: $00864CFB; Bits: 24; Init: $00B704CE; FInit: $00000000; Inverse: False), // CRC_24
<tr class="nocodegen"><td>371<td>    (Poly: $9DB11213; Bits: 32; Init: $FFFFFFFF; FInit: $FFFFFFFF; Inverse: True),  // CRC_32
<tr class="nocodegen"><td>372<td>
<tr class="nocodegen"><td>373<td>    (Poly: $04C11DB7; Bits: 32; Init: $FFFFFFFF; FInit: $FFFFFFFF; Inverse: True),  // CRC_32CCITT
<tr class="nocodegen"><td>374<td>    (Poly: $04C11DB7; Bits: 32; Init: $FFFFFFFF; FInit: $00000000; Inverse: True),  // CRC_32ZModem
<tr class="nocodegen"><td>375<td>    (Poly: $00000007; Bits: 08; Init: $00000000; FInit: $00000000; Inverse: True),  // CRC_8ATMHEC
<tr class="nocodegen"><td>376<td>    (Poly: $00000007; Bits: 08; Init: $00000000; FInit: $00000000; Inverse: False), // CRC_8SMBus
<tr class="nocodegen"><td>377<td>    (Poly: $00004599; Bits: 15; Init: $00000000; FInit: $00000000; Inverse: True),  // CRC_15CAN
<tr class="nocodegen"><td>378<td>    (Poly: $00001021; Bits: 16; Init: $00000000; FInit: $00000000; Inverse: False)  // CRC_16ZMODEM
<tr class="nocodegen"><td>379<td>  );
<tr class="nocodegen"><td>380<td>
<tr class="nocodegen"><td>381<td>  // some other CRC's, not all yet verfied
<tr class="nocodegen"><td>382<td>  // DD    $00001021, 16, $0000FFFF, $00000000,  0   // CRC_16 CCITT British Aerospace
<tr class="nocodegen"><td>383<td>  // DD    $00004003, 16, $00000000, $00000000, -1   // CRC_16 reversed
<tr class="nocodegen"><td>384<td>  // DD    $00001005, 16, $00000000, $00000000, -1   // CRC_16 X25
<tr class="nocodegen"><td>385<td>
<tr class="nocodegen"><td>386<td>  // https://fenix.tecnico.ulisboa.pt/downloadFile/3779571246541/BasicCrd.pdf enthält
<tr class="nocodegen"><td>387<td>  // eine beschreibung dieser BasicCard Smartcard incl. C-CRC Quellcode, aber die
<tr class="nocodegen"><td>388<td>  // Polynome konnte ich so noch nicht überprüfen
<tr class="nocodegen"><td>389<td>  // DD    $00000053, 16, $00000000, $00000000, -1   // BasicCard 16Bit CRC (sparse poly for Crypto MCU)
<tr class="nocodegen"><td>390<td>  // DD    $000000C5, 32, $00000000, $00000000, -1   // BasicCard 32Bit CRC
<tr class="nocodegen"><td>391<td>
<tr class="nocodegen"><td>392<td>function CRCSetup(var CRCDef: TCRCDef; Polynomial, Bits, InitVector,
<tr class="nocodegen"><td>393<td>  FinalVector: UInt32; Inverse: LongBool): Boolean;
<tr class="nocodegen"><td>394<td>// initialize CRCDef according to the parameters, calculate the lookup table
<tr class="nocodegen"><td>395<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>396<td>asm
<tr class="nocodegen"><td>397<td>       CMP   ECX,8
<tr class="nocodegen"><td>398<td>       JB    @@8
<tr class="nocodegen"><td>399<td>       PUSH  EBX
<tr class="nocodegen"><td>400<td>       PUSH  EDI
<tr class="nocodegen"><td>401<td>       PUSH  ESI
<tr class="nocodegen"><td>402<td>       MOV   [EAX].TCRCDef.Polynomial,EDX
<tr class="nocodegen"><td>403<td>       MOV   [EAX].TCRCDef.Bits,ECX
<tr class="nocodegen"><td>404<td>       MOV   EBX,InitVector
<tr class="nocodegen"><td>405<td>       MOV   EDI,FinalVector
<tr class="nocodegen"><td>406<td>       MOV   ESI,Inverse
<tr class="nocodegen"><td>407<td>       MOV   [EAX].TCRCDef.CRC,EBX
<tr class="nocodegen"><td>408<td>       MOV   [EAX].TCRCDef.InitVector,EBX
<tr class="nocodegen"><td>409<td>       MOV   [EAX].TCRCDef.FinalVector,EDI
<tr class="nocodegen"><td>410<td>       MOV   [EAX].TCRCDef.Inverse,ESI
<tr class="nocodegen"><td>411<td>       XOR   EDI,EDI
<tr class="nocodegen"><td>412<td>       LEA   EBX,[ECX - 8]
<tr class="nocodegen"><td>413<td>       SUB   ECX,32
<tr class="nocodegen"><td>414<td>       DEC   EDI
<tr class="nocodegen"><td>415<td>       NEG   ECX
<tr class="nocodegen"><td>416<td>       SHR   EDI,CL
<tr class="nocodegen"><td>417<td>       MOV   [EAX].TCRCDef.Shift,EBX
<tr class="nocodegen"><td>418<td>       MOV   [EAX].TCRCDef.Mask,EDI
<tr class="nocodegen"><td>419<td>       TEST  ESI,ESI
<tr class="nocodegen"><td>420<td>       JZ    @@5
<tr class="nocodegen"><td>421<td>       XOR   EBX,EBX
<tr class="nocodegen"><td>422<td>       MOV   ECX,[EAX].TCRCDef.Bits
<tr class="nocodegen"><td>423<td>@@1:   SHR   EDX,1
<tr class="nocodegen"><td>424<td>       ADC   EBX,EBX
<tr class="nocodegen"><td>425<td>       DEC   ECX
<tr class="nocodegen"><td>426<td>       JNZ   @@1
<tr class="nocodegen"><td>427<td>       NOP
<tr class="nocodegen"><td>428<td>       MOV   ECX,255
<tr class="nocodegen"><td>429<td>       NOP
<tr class="nocodegen"><td>430<td>@@20:  MOV   EDX,ECX
<tr class="nocodegen"><td>431<td>       SHR   EDX,1
<tr class="nocodegen"><td>432<td>       JNC   @@21
<tr class="nocodegen"><td>433<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>434<td>@@21:  SHR   EDX,1
<tr class="nocodegen"><td>435<td>       JNC   @@22
<tr class="nocodegen"><td>436<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>437<td>@@22:  SHR   EDX,1
<tr class="nocodegen"><td>438<td>       JNC   @@23
<tr class="nocodegen"><td>439<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>440<td>@@23:  SHR   EDX,1
<tr class="nocodegen"><td>441<td>       JNC   @@24
<tr class="nocodegen"><td>442<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>443<td>@@24:  SHR   EDX,1
<tr class="nocodegen"><td>444<td>       JNC   @@25
<tr class="nocodegen"><td>445<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>446<td>@@25:  SHR   EDX,1
<tr class="nocodegen"><td>447<td>       JNC   @@26
<tr class="nocodegen"><td>448<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>449<td>@@26:  SHR   EDX,1
<tr class="nocodegen"><td>450<td>       JNC   @@27
<tr class="nocodegen"><td>451<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>452<td>@@27:  SHR   EDX,1
<tr class="nocodegen"><td>453<td>       JNC   @@28
<tr class="nocodegen"><td>454<td>       XOR   EDX,EBX
<tr class="nocodegen"><td>455<td>@@28:  MOV   [EAX + ECX * 4],EDX
<tr class="nocodegen"><td>456<td>       DEC   ECX
<tr class="nocodegen"><td>457<td>       JNL   @@20
<tr class="nocodegen"><td>458<td>       JMP   @@7
<tr class="nocodegen"><td>459<td>@@5:   AND   EDX,EDI
<tr class="nocodegen"><td>460<td>       ROL   EDX,CL
<tr class="nocodegen"><td>461<td>       MOV   EBX,255
<tr class="nocodegen"><td>462<td>// can be coded branchfree
<tr class="nocodegen"><td>463<td>@@60:  MOV   ESI,EBX
<tr class="nocodegen"><td>464<td>       SHL   ESI,25
<tr class="nocodegen"><td>465<td>       JNC   @@61
<tr class="nocodegen"><td>466<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>467<td>@@61:  ADD   ESI,ESI
<tr class="nocodegen"><td>468<td>       JNC   @@62
<tr class="nocodegen"><td>469<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>470<td>@@62:  ADD   ESI,ESI
<tr class="nocodegen"><td>471<td>       JNC   @@63
<tr class="nocodegen"><td>472<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>473<td>@@63:  ADD   ESI,ESI
<tr class="nocodegen"><td>474<td>       JNC   @@64
<tr class="nocodegen"><td>475<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>476<td>@@64:  ADD   ESI,ESI
<tr class="nocodegen"><td>477<td>       JNC   @@65
<tr class="nocodegen"><td>478<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>479<td>@@65:  ADD   ESI,ESI
<tr class="nocodegen"><td>480<td>       JNC   @@66
<tr class="nocodegen"><td>481<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>482<td>@@66:  ADD   ESI,ESI
<tr class="nocodegen"><td>483<td>       JNC   @@67
<tr class="nocodegen"><td>484<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>485<td>@@67:  ADD   ESI,ESI
<tr class="nocodegen"><td>486<td>       JNC   @@68
<tr class="nocodegen"><td>487<td>       XOR   ESI,EDX
<tr class="nocodegen"><td>488<td>@@68:  ROR   ESI,CL
<tr class="nocodegen"><td>489<td>       MOV   [EAX + EBX * 4],ESI
<tr class="nocodegen"><td>490<td>       DEC   EBX
<tr class="nocodegen"><td>491<td>       JNL   @@60
<tr class="nocodegen"><td>492<td>@@7:   POP   ESI
<tr class="nocodegen"><td>493<td>       POP   EDI
<tr class="nocodegen"><td>494<td>       POP   EBX
<tr class="nocodegen"><td>495<td>@@8:   CMC
<tr class="nocodegen"><td>496<td>       SBB   EAX,EAX
<tr class="nocodegen"><td>497<td>       NEG   EAX
<tr class="nocodegen"><td>498<td>end;
<tr class="nocodegen"><td>499<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>500<td>var
<tr class="nocodegen"><td>501<td>  Value, XorValue, OldValue: UInt32;
<tr class="nocodegen"><td>502<td>  Index: Integer;
<tr class="nocodegen"><td>503<td>  B: Boolean;
<tr class="nocodegen"><td>504<td>  One: Byte;
<tr class="covered"><td>505<td>begin
<tr class="covered"><td>506<td>  if Bits &gt;= 8 then
<tr class="nocodegen"><td>507<td>  begin
<tr class="covered"><td>508<td>    CRCDef.Polynomial := Polynomial;
<tr class="covered"><td>509<td>    CRCDef.Bits := Bits;
<tr class="covered"><td>510<td>    CRCDef.CRC := InitVector;
<tr class="covered"><td>511<td>    CRCDef.InitVector := InitVector;
<tr class="covered"><td>512<td>    CRCDef.FinalVector := FinalVector;
<tr class="covered"><td>513<td>    CRCDef.Inverse := Inverse;
<tr class="covered"><td>514<td>    CRCDef.Shift := Bits - 8;
<tr class="covered"><td>515<td>    Bits := -(Bits - 32);
<tr class="covered"><td>516<td>    CRCDef.Mask := -1 shr Byte(Bits);
<tr class="nocodegen"><td>517<td>
<tr class="covered"><td>518<td>    if Inverse then
<tr class="nocodegen"><td>519<td>    begin
<tr class="covered"><td>520<td>      Bits := CRCDef.Bits;
<tr class="covered"><td>521<td>      XorValue := 0;
<tr class="nocodegen"><td>522<td>      repeat
<tr class="covered"><td>523<td>        Inc(XorValue, XorValue + Ord(Polynomial and $1));
<tr class="covered"><td>524<td>        Polynomial := Polynomial shr 1;
<tr class="covered"><td>525<td>        Dec(Bits);
<tr class="covered"><td>526<td>      until Bits = 0;
<tr class="nocodegen"><td>527<td>
<tr class="covered"><td>528<td>      One := $1;
<tr class="covered"><td>529<td>      for Index := 255 downto 0 do
<tr class="nocodegen"><td>530<td>      begin
<tr class="covered"><td>531<td>        Value := Index;
<tr class="nocodegen"><td>532<td>
<tr class="covered"><td>533<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>534<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>535<td>
<tr class="covered"><td>536<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>537<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>538<td>
<tr class="covered"><td>539<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>540<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>541<td>
<tr class="covered"><td>542<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>543<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>544<td>
<tr class="covered"><td>545<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>546<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>547<td>
<tr class="covered"><td>548<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>549<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>550<td>
<tr class="covered"><td>551<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>552<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>553<td>
<tr class="covered"><td>554<td>        B := Boolean(Value and One); Value := Value shr 1;
<tr class="covered"><td>555<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>556<td>
<tr class="covered"><td>557<td>        CRCDef.Table[Index] := Value;
<tr class="covered"><td>558<td>      end;
<tr class="nocodegen"><td>559<td>    end
<tr class="nocodegen"><td>560<td>    else
<tr class="nocodegen"><td>561<td>    begin
<tr class="covered"><td>562<td>      XorValue := Polynomial and CRCDef.Mask;
<tr class="covered"><td>563<td>      XorValue := (XorValue shl Byte(Bits)) or (XorValue shr (32 - Byte(Bits)));
<tr class="covered"><td>564<td>      for Index := 255 downto 0 do
<tr class="nocodegen"><td>565<td>      begin
<tr class="covered"><td>566<td>        B := Boolean(Index and $000000080); Value := Index shl 25;
<tr class="covered"><td>567<td>        if B then Value := Value xor XorValue;
<tr class="nocodegen"><td>568<td>
<tr class="covered"><td>569<td>        OldValue := Value; Inc(Value, Value);
<tr class="covered"><td>570<td>        if Value &lt; OldValue then Value := Value xor XorValue;
<tr class="nocodegen"><td>571<td>
<tr class="covered"><td>572<td>        OldValue := Value; Inc(Value, Value);
<tr class="covered"><td>573<td>        if Value &lt; OldValue then Value := Value xor XorValue;
<tr class="nocodegen"><td>574<td>
<tr class="covered"><td>575<td>        OldValue := Value; Inc(Value, Value);
<tr class="covered"><td>576<td>        if Value &lt; OldValue then Value := Value xor XorValue;
<tr class="nocodegen"><td>577<td>
<tr class="covered"><td>578<td>        OldValue := Value; Inc(Value, Value);
<tr class="covered"><td>579<td>        if Value &lt; OldValue then Value := Value xor XorValue;
<tr class="nocodegen"><td>580<td>
<tr class="covered"><td>581<td>        OldValue := Value; Inc(Value, Value);
<tr class="covered"><td>582<td>        if Value &lt; OldValue then Value := Value xor XorValue;
<tr class="nocodegen"><td>583<td>
<tr class="covered"><td>584<td>        OldValue := Value; Inc(Value, Value);
<tr class="covered"><td>585<td>        if Value &lt; OldValue then Value := Value xor XorValue;
<tr class="nocodegen"><td>586<td>
<tr class="covered"><td>587<td>        OldValue := Value; Inc(Value, Value);
<tr class="covered"><td>588<td>        if Value &lt; OldValue then Value := Value xor XorValue;
<tr class="nocodegen"><td>589<td>
<tr class="covered"><td>590<td>        Value := (Value shr Byte(Bits)) or (Value shl (32 - Byte(Bits)));
<tr class="covered"><td>591<td>        CRCDef.Table[Index] := Value;
<tr class="covered"><td>592<td>      end;
<tr class="nocodegen"><td>593<td>    end;
<tr class="covered"><td>594<td>    Result := True;
<tr class="nocodegen"><td>595<td>  end
<tr class="nocodegen"><td>596<td>  else
<tr class="covered"><td>597<td>    Result := False;
<tr class="covered"><td>598<td>end;
<tr class="nocodegen"><td>599<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>600<td>
<tr class="nocodegen"><td>601<td>function CRCInit(var CRCDef: TCRCDef; CRCType: TCRCType): Boolean;
<tr class="covered"><td>602<td>begin
<tr class="covered"><td>603<td>  Result := CRCSetup(CRCDef,
<tr class="nocodegen"><td>604<td>                     PCRCTab(@CRCTab)[CRCType].Poly,
<tr class="nocodegen"><td>605<td>                     PCRCTab(@CRCTab)[CRCType].Bits,
<tr class="nocodegen"><td>606<td>                     PCRCTab(@CRCTab)[CRCType].Init,
<tr class="nocodegen"><td>607<td>                     PCRCTab(@CRCTab)[CRCType].FInit,
<tr class="nocodegen"><td>608<td>                     PCRCTab(@CRCTab)[CRCType].Inverse);
<tr class="covered"><td>609<td>end;
<tr class="nocodegen"><td>610<td>
<tr class="nocodegen"><td>611<td>function CRCCode(var CRCDef: TCRCDef; const Buffer; Size: UInt32): UInt32;
<tr class="nocodegen"><td>612<td>// do the CRC computation
<tr class="nocodegen"><td>613<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>614<td>asm
<tr class="nocodegen"><td>615<td>       JECXZ @@5
<tr class="nocodegen"><td>616<td>       TEST  EDX,EDX
<tr class="nocodegen"><td>617<td>       JZ    @@5
<tr class="nocodegen"><td>618<td>       PUSH  ESI
<tr class="nocodegen"><td>619<td>       PUSH  EBX
<tr class="nocodegen"><td>620<td>       MOV   ESI,EAX
<tr class="nocodegen"><td>621<td>       CMP   [EAX].TCRCDef.Inverse,0
<tr class="nocodegen"><td>622<td>       MOV   EAX,[ESI].TCRCDef.CRC
<tr class="nocodegen"><td>623<td>       JZ    @@2
<tr class="nocodegen"><td>624<td>       XOR   EBX,EBX
<tr class="nocodegen"><td>625<td>@@1:   MOV   BL,[EDX]
<tr class="nocodegen"><td>626<td>       XOR   BL,AL
<tr class="nocodegen"><td>627<td>       SHR   EAX,8
<tr class="nocodegen"><td>628<td>       INC   EDX
<tr class="nocodegen"><td>629<td>       XOR   EAX,[ESI + EBX * 4]
<tr class="nocodegen"><td>630<td>       DEC   ECX
<tr class="nocodegen"><td>631<td>       JNZ   @@1
<tr class="nocodegen"><td>632<td>       JMP   @@4
<tr class="nocodegen"><td>633<td>@@2:   PUSH  EDI
<tr class="nocodegen"><td>634<td>       MOV   EBX,EAX
<tr class="nocodegen"><td>635<td>       MOV   EDI,ECX
<tr class="nocodegen"><td>636<td>       MOV   ECX,[ESI].TCRCDef.Shift
<tr class="nocodegen"><td>637<td>       MOV   EBX,EAX
<tr class="nocodegen"><td>638<td>@@3:   SHR   EBX,CL
<tr class="nocodegen"><td>639<td>       SHL   EAX,8
<tr class="nocodegen"><td>640<td>       XOR   BL,[EDX]
<tr class="nocodegen"><td>641<td>       INC   EDX
<tr class="nocodegen"><td>642<td>       MOVZX EBX,BL
<tr class="nocodegen"><td>643<td>       XOR   EAX,[ESI + EBX * 4]
<tr class="nocodegen"><td>644<td>       DEC   EDI
<tr class="nocodegen"><td>645<td>       MOV   EBX,EAX
<tr class="nocodegen"><td>646<td>       JNZ   @@3
<tr class="nocodegen"><td>647<td>       POP   EDI
<tr class="nocodegen"><td>648<td>@@4:   MOV   [ESI].TCRCDef.CRC,EAX
<tr class="nocodegen"><td>649<td>       XOR   EAX,[ESI].TCRCDef.FinalVector
<tr class="nocodegen"><td>650<td>       AND   EAX,[ESI].TCRCDef.Mask
<tr class="nocodegen"><td>651<td>       POP   EBX
<tr class="nocodegen"><td>652<td>       POP   ESI
<tr class="nocodegen"><td>653<td>       RET
<tr class="nocodegen"><td>654<td>@@5:   MOV   EAX,[EAX].TCRCDef.CRC
<tr class="nocodegen"><td>655<td>end;
<tr class="nocodegen"><td>656<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>657<td>var
<tr class="nocodegen"><td>658<td>  P: PByte;
<tr class="nocodegen"><td>659<td>  Value: Byte;
<tr class="covered"><td>660<td>begin
<tr class="covered"><td>661<td>  Result := CRCDef.CRC;
<tr class="covered"><td>662<td>  P := @Buffer;
<tr class="covered"><td>663<td>  if (Size &lt;&gt; 0) and (P &lt;&gt; nil) then
<tr class="nocodegen"><td>664<td>  begin
<tr class="covered"><td>665<td>    if CRCDef.Inverse then
<tr class="nocodegen"><td>666<td>    begin
<tr class="nocodegen"><td>667<td>      repeat
<tr class="covered"><td>668<td>        Value := P^ xor Byte(Result);
<tr class="covered"><td>669<td>        Result := (Result shr 8) xor CRCDef.Table[Value];
<tr class="covered"><td>670<td>        Inc(P);
<tr class="covered"><td>671<td>        Dec(Size);
<tr class="covered"><td>672<td>      until Size = 0;
<tr class="nocodegen"><td>673<td>    end
<tr class="nocodegen"><td>674<td>    else
<tr class="nocodegen"><td>675<td>    begin
<tr class="covered"><td>676<td>      Value := Byte(CRCDef.Shift); // move to local variable =&gt; cpu register
<tr class="nocodegen"><td>677<td>      repeat
<tr class="covered"><td>678<td>        Result := (Result shl 8) xor CRCDef.Table[Byte(Result shr Value) xor P^];
<tr class="covered"><td>679<td>        Inc(P);
<tr class="covered"><td>680<td>        Dec(Size);
<tr class="covered"><td>681<td>      until Size = 0;
<tr class="nocodegen"><td>682<td>    end;
<tr class="covered"><td>683<td>    CRCDef.CRC := Result;
<tr class="covered"><td>684<td>    Result := (Result xor CRCDef.FinalVector) and CRCDef.Mask;
<tr class="nocodegen"><td>685<td>  end;
<tr class="covered"><td>686<td>end;
<tr class="nocodegen"><td>687<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>688<td>
<tr class="nocodegen"><td>689<td>function CRCCode(var CRCDef: TCRCDef; ReadMethod: TReadMethod; Size: UInt32 = $FFFFFFFF): UInt32;
<tr class="nocodegen"><td>690<td>var
<tr class="nocodegen"><td>691<td>  Buffer: array[0..1023] of Char;
<tr class="nocodegen"><td>692<td>  Count: Int64;
<tr class="covered"><td>693<td>begin
<tr class="nocodegen"><td>694<td>  repeat
<tr class="covered"><td>695<td>    if Size &gt; SizeOf(Buffer) then
<tr class="notcovered"><td>696<td>      Count := SizeOf(Buffer)
<tr class="nocodegen"><td>697<td>    else
<tr class="covered"><td>698<td>      Count := Size;
<tr class="covered"><td>699<td>    Count := ReadMethod(Buffer, Count);
<tr class="covered"><td>700<td>    Result := CRCCode(CRCDef, Buffer, Count);
<tr class="covered"><td>701<td>    Dec(Size, Count);
<tr class="covered"><td>702<td>  until (Size = 0) or (Count = 0);
<tr class="covered"><td>703<td>end;
<tr class="nocodegen"><td>704<td>
<tr class="nocodegen"><td>705<td>function CRCDone(var CRCDef: TCRCDef): UInt32;
<tr class="nocodegen"><td>706<td>// finalize CRCDef after a computation
<tr class="nocodegen"><td>707<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>708<td>asm
<tr class="nocodegen"><td>709<td>       MOV   EDX,[EAX].TCRCDef.CRC
<tr class="nocodegen"><td>710<td>       MOV   ECX,[EAX].TCRCDef.InitVector
<tr class="nocodegen"><td>711<td>       XOR   EDX,[EAX].TCRCDef.FinalVector
<tr class="nocodegen"><td>712<td>       MOV   [EAX].TCRCDef.CRC,ECX
<tr class="nocodegen"><td>713<td>       AND   EDX,[EAX].TCRCDef.Mask
<tr class="nocodegen"><td>714<td>       MOV   EAX,EDX
<tr class="nocodegen"><td>715<td>end;
<tr class="nocodegen"><td>716<td>{$ELSE !X86ASM}
<tr class="covered"><td>717<td>begin
<tr class="covered"><td>718<td>  Result := CRCDef.CRC;
<tr class="covered"><td>719<td>  CRCDef.CRC := CRCDef.InitVector;
<tr class="covered"><td>720<td>  Result := (Result xor CRCDef.FinalVector) and CRCDef.Mask;
<tr class="covered"><td>721<td>end;
<tr class="nocodegen"><td>722<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>723<td>
<tr class="nocodegen"><td>724<td>function CRCCalc(CRCType: TCRCType; const Buffer; Size: UInt32): UInt32;
<tr class="nocodegen"><td>725<td>// inplace calculation
<tr class="nocodegen"><td>726<td>var
<tr class="nocodegen"><td>727<td>  CRC: TCRCDef;
<tr class="covered"><td>728<td>begin
<tr class="covered"><td>729<td>  CRCInit(CRC, CRCType);
<tr class="covered"><td>730<td>  Result := CRCCode(CRC, Buffer, Size);
<tr class="covered"><td>731<td>end;
<tr class="nocodegen"><td>732<td>
<tr class="nocodegen"><td>733<td>function CRCCalc(CRCType: TCRCType; ReadMethod: TReadMethod; Size: UInt32): UInt32;
<tr class="nocodegen"><td>734<td>var
<tr class="nocodegen"><td>735<td>  CRC: TCRCDef;
<tr class="nocodegen"><td>736<td>begin
<tr class="nocodegen"><td>737<td>  CRCInit(CRC, CRCType);
<tr class="nocodegen"><td>738<td>  Result := CRCCode(CRC, ReadMethod, Size);
<tr class="nocodegen"><td>739<td>end;
<tr class="nocodegen"><td>740<td>
<tr class="nocodegen"><td>741<td>// predefined CRC16/CRC32CCITT, avoid slower lookuptable computation by use of precomputation
<tr class="nocodegen"><td>742<td>var
<tr class="nocodegen"><td>743<td>  FCRC16: PCRCDef = nil;
<tr class="nocodegen"><td>744<td>  FCRC32: PCRCDef = nil;
<tr class="nocodegen"><td>745<td>
<tr class="nocodegen"><td>746<td>function CRC16Init: Pointer;
<tr class="covered"><td>747<td>begin
<tr class="nocodegen"><td>748<td>  // Replace GetMem by GetMemory due to C++ Builder compatibility
<tr class="nocodegen"><td>749<td>  // GetMem(FCRC16, SizeOf(TCRCDef));
<tr class="covered"><td>750<td>  FCRC16 := GetMemory(SizeOf(TCRCDef));
<tr class="covered"><td>751<td>  CRCInit(FCRC16^, CRC_16);
<tr class="covered"><td>752<td>  Result := FCRC16;
<tr class="covered"><td>753<td>end;
<tr class="nocodegen"><td>754<td>
<tr class="nocodegen"><td>755<td>function CRC16(CRC: UInt16; const Buffer; Size: UInt32): UInt16;
<tr class="nocodegen"><td>756<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>757<td>asm
<tr class="nocodegen"><td>758<td>       JECXZ @@2
<tr class="nocodegen"><td>759<td>       PUSH  EDI
<tr class="nocodegen"><td>760<td>       PUSH  ESI
<tr class="nocodegen"><td>761<td>       MOV   EDI,ECX
<tr class="nocodegen"><td>762<td>{$IFDEF PIC}
<tr class="nocodegen"><td>763<td>       MOV   ESI,[EBX].FCRC16
<tr class="nocodegen"><td>764<td>{$ELSE !PIC}
<tr class="nocodegen"><td>765<td>       MOV   ESI,FCRC16
<tr class="nocodegen"><td>766<td>{$ENDIF !PIC}
<tr class="nocodegen"><td>767<td>       XOR   ECX,ECX
<tr class="nocodegen"><td>768<td>       TEST  ESI,ESI
<tr class="nocodegen"><td>769<td>       JZ    @@3
<tr class="nocodegen"><td>770<td>@@1:   MOV    CL,[EDX]
<tr class="nocodegen"><td>771<td>       XOR    CL,AL
<tr class="nocodegen"><td>772<td>       SHR   EAX,8
<tr class="nocodegen"><td>773<td>       INC   EDX
<tr class="nocodegen"><td>774<td>       XOR   EAX,[ESI + ECX * 4]
<tr class="nocodegen"><td>775<td>       DEC   EDI
<tr class="nocodegen"><td>776<td>       JNZ   @@1
<tr class="nocodegen"><td>777<td>       POP   ESI
<tr class="nocodegen"><td>778<td>       POP   EDI
<tr class="nocodegen"><td>779<td>@@2:   RET
<tr class="nocodegen"><td>780<td>@@3:   PUSH  EAX
<tr class="nocodegen"><td>781<td>       PUSH  EDX
<tr class="nocodegen"><td>782<td>       CALL  CRC16Init
<tr class="nocodegen"><td>783<td>       MOV   ESI,EAX
<tr class="nocodegen"><td>784<td>       XOR   ECX,ECX
<tr class="nocodegen"><td>785<td>       POP   EDX
<tr class="nocodegen"><td>786<td>       POP   EAX
<tr class="nocodegen"><td>787<td>       JMP   @@1
<tr class="nocodegen"><td>788<td>end;
<tr class="nocodegen"><td>789<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>790<td>var
<tr class="nocodegen"><td>791<td>  LCRC16: PCRCDef;
<tr class="nocodegen"><td>792<td>  P: PByte;
<tr class="nocodegen"><td>793<td>  CRC32: UInt32;
<tr class="nocodegen"><td>794<td>  Value: Byte;
<tr class="covered"><td>795<td>begin
<tr class="covered"><td>796<td>  if Size &lt;&gt; 0 then
<tr class="nocodegen"><td>797<td>  begin
<tr class="covered"><td>798<td>    LCRC16 := FCRC16;
<tr class="covered"><td>799<td>    if LCRC16 = nil then
<tr class="notcovered"><td>800<td>      LCRC16 := CRC16Init;
<tr class="nocodegen"><td>801<td>
<tr class="covered"><td>802<td>    CRC32 := CRC;
<tr class="covered"><td>803<td>    P := @Buffer;
<tr class="nocodegen"><td>804<td>    repeat
<tr class="covered"><td>805<td>      Value := P^ xor Byte(CRC32);
<tr class="covered"><td>806<td>      CRC32 := (CRC32 shr 8) xor LCRC16.Table[Value];
<tr class="covered"><td>807<td>      Inc(P);
<tr class="covered"><td>808<td>      Dec(Size);
<tr class="covered"><td>809<td>    until Size = 0;
<tr class="covered"><td>810<td>    Result := UInt16(CRC32);
<tr class="nocodegen"><td>811<td>  end
<tr class="nocodegen"><td>812<td>  else
<tr class="notcovered"><td>813<td>    Result := CRC;
<tr class="covered"><td>814<td>end;
<tr class="nocodegen"><td>815<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>816<td>
<tr class="nocodegen"><td>817<td>function CRC32Init: Pointer;
<tr class="covered"><td>818<td>begin
<tr class="nocodegen"><td>819<td>  // Replaced for C++ Builder compatibility
<tr class="nocodegen"><td>820<td>  // GetMem(FCRC32, SizeOf(TCRCDef));
<tr class="covered"><td>821<td>  FCRC32 := GetMemory(SizeOf(TCRCDef));
<tr class="covered"><td>822<td>  CRCInit(FCRC32^, CRC_32CCITT);
<tr class="covered"><td>823<td>  Result := FCRC32;
<tr class="covered"><td>824<td>end;
<tr class="nocodegen"><td>825<td>
<tr class="nocodegen"><td>826<td>function CRC32(CRC: UInt32; const Buffer; Size: UInt32): UInt32;
<tr class="nocodegen"><td>827<td>{$IFDEF X86ASM}
<tr class="nocodegen"><td>828<td>asm
<tr class="nocodegen"><td>829<td>       JECXZ @@2
<tr class="nocodegen"><td>830<td>       PUSH  EDI
<tr class="nocodegen"><td>831<td>       PUSH  ESI
<tr class="nocodegen"><td>832<td>       NOT   EAX                    // inverse Input CRC
<tr class="nocodegen"><td>833<td>       MOV   EDI,ECX
<tr class="nocodegen"><td>834<td>{$IFDEF PIC}
<tr class="nocodegen"><td>835<td>       MOV   ESI,[EBX].FCRC32
<tr class="nocodegen"><td>836<td>{$ELSE !PIC}
<tr class="nocodegen"><td>837<td>       MOV   ESI,FCRC32
<tr class="nocodegen"><td>838<td>{$ENDIF !PIC}
<tr class="nocodegen"><td>839<td>       XOR   ECX,ECX
<tr class="nocodegen"><td>840<td>       TEST  ESI,ESI
<tr class="nocodegen"><td>841<td>       JZ    @@3
<tr class="nocodegen"><td>842<td>@@1:   MOV    CL,[EDX]
<tr class="nocodegen"><td>843<td>       XOR    CL,AL
<tr class="nocodegen"><td>844<td>       SHR   EAX,8
<tr class="nocodegen"><td>845<td>       INC   EDX
<tr class="nocodegen"><td>846<td>       XOR   EAX,[ESI + ECX * 4]
<tr class="nocodegen"><td>847<td>       DEC   EDI
<tr class="nocodegen"><td>848<td>       JNZ   @@1
<tr class="nocodegen"><td>849<td>       NOT   EAX                    // inverse Output CRC
<tr class="nocodegen"><td>850<td>       POP   ESI
<tr class="nocodegen"><td>851<td>       POP   EDI
<tr class="nocodegen"><td>852<td>@@2:   RET
<tr class="nocodegen"><td>853<td>@@3:   PUSH  EAX
<tr class="nocodegen"><td>854<td>       PUSH  EDX
<tr class="nocodegen"><td>855<td>       CALL  CRC32Init
<tr class="nocodegen"><td>856<td>       MOV   ESI,EAX
<tr class="nocodegen"><td>857<td>       XOR   ECX,ECX
<tr class="nocodegen"><td>858<td>       POP   EDX
<tr class="nocodegen"><td>859<td>       POP   EAX
<tr class="nocodegen"><td>860<td>       JMP   @@1
<tr class="nocodegen"><td>861<td>end;
<tr class="nocodegen"><td>862<td>{$ELSE !X86ASM}
<tr class="nocodegen"><td>863<td>var
<tr class="nocodegen"><td>864<td>  LCRC32: PCRCDef;
<tr class="nocodegen"><td>865<td>  P: PByte;
<tr class="nocodegen"><td>866<td>  CRC32: UInt32;
<tr class="nocodegen"><td>867<td>  Value: Byte;
<tr class="covered"><td>868<td>begin
<tr class="covered"><td>869<td>  if Size &lt;&gt; 0 then
<tr class="nocodegen"><td>870<td>  begin
<tr class="covered"><td>871<td>    LCRC32 := FCRC32;
<tr class="covered"><td>872<td>    if LCRC32 = nil then
<tr class="notcovered"><td>873<td>      LCRC32 := CRC32Init;
<tr class="nocodegen"><td>874<td>
<tr class="covered"><td>875<td>    CRC32 := not CRC; // inverse Input CRC
<tr class="covered"><td>876<td>    P := @Buffer;
<tr class="nocodegen"><td>877<td>    repeat
<tr class="covered"><td>878<td>      Value := P^ xor Byte(CRC32);
<tr class="covered"><td>879<td>      CRC32 := (CRC32 shr 8) xor LCRC32.Table[Value];
<tr class="covered"><td>880<td>      Inc(P);
<tr class="covered"><td>881<td>      Dec(Size);
<tr class="covered"><td>882<td>    until Size = 0;
<tr class="covered"><td>883<td>    Result := not CRC32; // inverse Output CRC
<tr class="nocodegen"><td>884<td>  end
<tr class="nocodegen"><td>885<td>  else
<tr class="notcovered"><td>886<td>    Result := CRC;
<tr class="covered"><td>887<td>end;
<tr class="nocodegen"><td>888<td>{$ENDIF !X86ASM}
<tr class="nocodegen"><td>889<td>
<tr class="nocodegen"><td>890<td>procedure CRCInitThreadSafe;
<tr class="covered"><td>891<td>begin
<tr class="covered"><td>892<td>  CRC16Init;
<tr class="covered"><td>893<td>  CRC32Init;
<tr class="covered"><td>894<td>end;
<tr class="nocodegen"><td>895<td>
<tr class="nocodegen"><td>896<td>{$IFDEF RESTORE_RANGECHECKS}{$R+}{$ENDIF}
<tr class="nocodegen"><td>897<td>{$IFDEF RESTORE_OVERFLOWCHECKS}{$Q+}{$ENDIF}
<tr class="nocodegen"><td>898<td>
<tr class="covered"><td>899<td>initialization
<tr class="covered"><td>900<td>  CRCInitThreadSafe;
<tr class="nocodegen"><td>901<td>
<tr class="covered"><td>902<td>finalization
<tr class="covered"><td>903<td>  if FCRC16 &lt;&gt; nil then
<tr class="covered"><td>904<td>    FreeMem(FCRC16);
<tr class="nocodegen"><td>905<td>
<tr class="covered"><td>906<td>  if FCRC32 &lt;&gt; nil then
<tr class="covered"><td>907<td>    FreeMem(FCRC32);
<tr class="covered"><td>908<td>end.
</table>
<script>(function () {
var starts = [],prev = document.getElementById("nav-prev"),next = document.getElementById("nav-next");
(function () {
var p;
document.querySelectorAll("table.s tr").forEach(r => {
if (r.classList.contains("notcovered")) {
if (!p) starts.push(r);
p = r;
} else { p = null }
})
})();
function findPrev() {
var y = prev.getBoundingClientRect().top - 4;
for (var i=starts.length-1; i>=0; i--) {
if (starts[i].getBoundingClientRect().top < y) return starts[i]
}
}
function findNext() {
var y = next.getBoundingClientRect().top + 4;
for (var i=0; i<starts.length; i++) {
if (starts[i].getBoundingClientRect().top > y) return starts[i];
}
}
function onScroll() {
prev.setAttribute("class", findPrev() ? "active" : "");
next.setAttribute("class", findNext() ? "active" : "");
onScroll.pending = 0;
}
document.addEventListener("scroll", function() {
if (!onScroll.pending) { onScroll.pending = requestAnimationFrame(onScroll) }
});
onScroll();
function scrollTo(row) {
if (row) window.scrollTo({ behavior: "smooth", top: window.scrollY+row.getBoundingClientRect().top-prev.getBoundingClientRect().top });
}
next.addEventListener("click", () => scrollTo(findNext()) );
prev.addEventListener("click", () => scrollTo(findPrev()) );
})();</script>
<script>
const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
const comparer = (idx, asc) => (a, b) => ((v1, v2) =>!isNaN(parseFloat(v1 || "-")) && !isNaN(parseFloat(v2 || "-")) ? parseFloat(v1)-parseFloat(v2) : v1.toString().localeCompare(v2))(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));
document.querySelectorAll("thead th[idx]").forEach(th => th.addEventListener("click", (() => {
	const table = th.closest("table").querySelector("tbody");
	Array.from(table.querySelectorAll("tr"))
		.sort(comparer(+th.getAttribute("idx"), this.asc = !this.asc))
		.forEach(tr => table.appendChild(tr) );
	})));
</script>
</body>
</html>
